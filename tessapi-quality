# 1 "tessapi-quality.cpp"
# 1 "<built-in>" 1
# 1 "<built-in>" 3
# 326 "<built-in>" 3
# 1 "<command line>" 1
# 1 "<built-in>" 2
# 1 "tessapi-quality.cpp" 2
# 1 "/usr/include/stdlib.h" 1 3 4
/*
 * Copyright (c) 2000, 2002 - 2008 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
/*-
 * Copyright (c) 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)stdlib.h	8.5 (Berkeley) 5/19/95
 */





# 1 "/usr/include/Availability.h" 1 3 4
/*
 * Copyright (c) 2007-2014 by Apple Inc.. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */



 /*     
    These macros are for use in OS header files. They enable function prototypes
    and Objective-C methods to be tagged with the OS version in which they
    were first available; and, if applicable, the OS version in which they 
    became deprecated.  
     
    The desktop Mac OS X and iOS each have different version numbers.
    The __OSX_AVAILABLE_STARTING() macro allows you to specify both the desktop
    and iOS version numbers.  For instance:
        __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_2_0)
    means the function/method was first available on Mac OS X 10.2 on the desktop
    and first available in iOS 2.0 on the iPhone.
    
    If a function is available on one platform, but not the other a _NA (not
    applicable) parameter is used.  For instance:
            __OSX_AVAILABLE_STARTING(__MAC_10_3,__IPHONE_NA)
    means that the function/method was first available on Mac OS X 10.3, and it
    currently not implemented on the iPhone.

    At some point, a function/method may be deprecated.  That means Apple
    recommends applications stop using the function, either because there is a 
    better replacement or the functionality is being phased out.  Deprecated
    functions/methods can be tagged with a __OSX_AVAILABLE_BUT_DEPRECATED()
    macro which specifies the OS version where the function became available
    as well as the OS version in which it became deprecated.  For instance:
        __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_0,__MAC_10_5,__IPHONE_NA,__IPHONE_NA)
    means that the function/method was introduced in Mac OS X 10.0, then
    became deprecated beginning in Mac OS X 10.5.  On iOS the function 
    has never been available.  
    
    For these macros to function properly, a program must specify the OS version range 
    it is targeting.  The min OS version is specified as an option to the compiler:
    -mmacosx-version-min=10.x when building for Mac OS X, and -miphoneos-version-min=y.z
    when building for the iPhone.  The upper bound for the OS version is rarely needed,
    but it can be set on the command line via: -D__MAC_OS_X_VERSION_MAX_ALLOWED=10x0 for
    Mac OS X and __IPHONE_OS_VERSION_MAX_ALLOWED = y0z00 for iOS.  
    
    Examples:

        A function available in Mac OS X 10.5 and later, but not on the phone:
        
            extern void mymacfunc() __OSX_AVAILABLE_STARTING(__MAC_10_5,__IPHONE_NA);


        An Objective-C method in Mac OS X 10.5 and later, but not on the phone:
        
            @interface MyClass : NSObject
            -(void) mymacmethod __OSX_AVAILABLE_STARTING(__MAC_10_5,__IPHONE_NA);
            @end

        
        An enum available on the phone, but not available on Mac OS X:
        
            #if __IPHONE_OS_VERSION_MIN_REQUIRED
                enum { myEnum = 1 };
            #endif
           Note: this works when targeting the Mac OS X platform because 
           __IPHONE_OS_VERSION_MIN_REQUIRED is undefined which evaluates to zero. 
        

        An enum with values added in different iPhoneOS versions:
		
			enum {
			    myX  = 1,	// Usable on iPhoneOS 2.1 and later
			    myY  = 2,	// Usable on iPhoneOS 3.0 and later
			    myZ  = 3,	// Usable on iPhoneOS 3.0 and later
				...
		      Note: you do not want to use #if with enumeration values
			  when a client needs to see all values at compile time
			  and use runtime logic to only use the viable values.
			  

    It is also possible to use the *_VERSION_MIN_REQUIRED in source code to make one
    source base that can be compiled to target a range of OS versions.  It is best
    to not use the _MAC_* and __IPHONE_* macros for comparisons, but rather their values.
    That is because you might get compiled on an old OS that does not define a later
    OS version macro, and in the C preprocessor undefined values evaluate to zero
    in expresssions, which could cause the #if expression to evaluate in an unexpected
    way.
    
        #ifdef __MAC_OS_X_VERSION_MIN_REQUIRED
            // code only compiled when targeting Mac OS X and not iPhone
            // note use of 1050 instead of __MAC_10_5
            #if __MAC_OS_X_VERSION_MIN_REQUIRED < 1050
                // code in here might run on pre-Leopard OS
            #else
                // code here can assume Leopard or later
            #endif
        #endif


*/
# 132 "/usr/include/Availability.h" 3 4
/* __MAC_NA is not defined to a value but is uses as a token by macros to indicate that the API is unavailable */
# 151 "/usr/include/Availability.h" 3 4
/* __IPHONE_NA is not defined to a value but is uses as a token by macros to indicate that the API is unavailable */


# 1 "/usr/include/AvailabilityInternal.h" 1 3 4
/*
 * Copyright (c) 2007-2012 by Apple Inc.. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

/*
    File:       AvailabilityInternal.h
 
    Contains:   implementation details of __OSX_AVAILABLE_* macros from <Availability.h>

*/
# 4963 "/usr/include/AvailabilityInternal.h" 3 4
    /* compiler for Mac OS X sets __ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__ */

    /* make sure a default max version is set */






            /* use better attributes if possible */
# 154 "/usr/include/Availability.h" 2 3 4
# 190 "/usr/include/Availability.h" 3 4
/* for use to document app extension usage */
# 62 "/usr/include/stdlib.h" 2 3 4

# 1 "/usr/include/_types.h" 1 3 4
/*
 * Copyright (c) 2004, 2008, 2009 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */





# 1 "/usr/include/sys/_types.h" 1 3 4
/*
 * Copyright (c) 2003-2007 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */





# 1 "/usr/include/sys/cdefs.h" 1 3 4
/*
 * Copyright (c) 2000-2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
/* Copyright 1995 NeXT Computer, Inc. All rights reserved. */
/*
 * Copyright (c) 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Berkeley Software Design, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)cdefs.h	8.8 (Berkeley) 1/9/95
 */
# 78 "/usr/include/sys/cdefs.h" 3 4
/* This SDK is designed to work with clang and specific versions of
 * gcc >= 4.0 with Apple's patch sets */




/*
 * The __CONCAT macro is used to concatenate parts of symbol names, e.g.
 * with "#define OLD(foo) __CONCAT(old,foo)", OLD(foo) produces oldfoo.
 * The __CONCAT macro is a bit tricky -- make sure you don't put spaces
 * in between its arguments.  __CONCAT can also concatenate double-quoted
 * strings produced by the __STRING macro, but this only works with ANSI C.
 */
# 138 "/usr/include/sys/cdefs.h" 3 4
/* __unused denotes variables and functions that may not be used, preventing
 * the compiler from warning about it if not used.
 */


/* __used forces variables and functions to be included even if it appears
 * to the compiler that they are not used (and would thust be discarded).
 */


/* __deprecated causes the compiler to produce a warning when encountering
 * code using the deprecated functionality.
 * __deprecated_msg() does the same, and compilers that support it will print
 * a message along with the deprecation warning.
 * This may require turning on such warning with the -Wdeprecated flag.
 * __deprecated_enum_msg() should be used on enums, and compilers that support
 * it will print the deprecation warning.
 */
# 180 "/usr/include/sys/cdefs.h" 3 4
/* __unavailable causes the compiler to error out when encountering
 * code using the tagged function of variable.
 */


/* Delete pseudo-keywords wherever they are not available or needed. */





/*
 * We use `__restrict' as a way to define the `restrict' type qualifier
 * without disturbing older software that is unaware of C99 keywords.
 */






/* Declaring inline functions within headers is error-prone due to differences
 * across various versions of the C language and extensions.  __header_inline
 * can be used to declare inline functions within system headers.  In cases
 * where you want to force inlining instead of letting the compiler make
 * the decision, you can use __header_always_inline.
 *
 * Be aware that using inline for functions which compilers may also provide
 * builtins can behave differently under various compilers.  If you intend to
 * provide an inline version of such a function, you may want to use a macro
 * instead.
 *
 * The check for !__GNUC__ || __clang__ is because gcc doesn't correctly
 * support c99 inline in some cases:
 * http://gcc.gnu.org/bugzilla/show_bug.cgi?id=55965
 */
# 242 "/usr/include/sys/cdefs.h" 3 4
/*
 * Compiler-dependent macros that bracket portions of code where the
 * "-Wunreachable-code" warning should be ignored. Please use sparingly.
 */
# 263 "/usr/include/sys/cdefs.h" 3 4
/*
 * Compiler-dependent macros to declare that functions take printf-like
 * or scanf-like arguments.  They are null except for versions of gcc
 * that are known to support the features properly.  Functions declared
 * with these attributes will cause compilation warnings if there is a
 * mismatch between the format string and subsequent function parameter
 * types.
 */
# 294 "/usr/include/sys/cdefs.h" 3 4
/* Source compatibility only, ID string not emitted in object file */
# 311 "/usr/include/sys/cdefs.h" 3 4
/*
 * COMPILATION ENVIRONMENTS -- see compat(5) for additional detail
 *
 * DEFAULT	By default newly complied code will get POSIX APIs plus
 *		Apple API extensions in scope.
 *
 *		Most users will use this compilation environment to avoid
 *		behavioral differences between 32 and 64 bit code.
 *
 * LEGACY	Defining _NONSTD_SOURCE will get pre-POSIX APIs plus Apple
 *		API extensions in scope.
 *
 *		This is generally equivalent to the Tiger release compilation
 *		environment, except that it cannot be applied to 64 bit code;
 *		its use is discouraged.
 *
 *		We expect this environment to be deprecated in the future.
 *
 * STRICT	Defining _POSIX_C_SOURCE or _XOPEN_SOURCE restricts the
 *		available APIs to exactly the set of APIs defined by the
 *		corresponding standard, based on the value defined.
 *
 *		A correct, portable definition for _POSIX_C_SOURCE is 200112L.
 *		A correct, portable definition for _XOPEN_SOURCE is 600L.
 *
 *		Apple API extensions are not visible in this environment,
 *		which can cause Apple specific code to fail to compile,
 *		or behave incorrectly if prototypes are not in scope or
 *		warnings about missing prototypes are not enabled or ignored.
 *
 * In any compilation environment, for correct symbol resolution to occur,
 * function prototypes must be in scope.  It is recommended that all Apple
 * tools users add either the "-Wall" or "-Wimplicit-function-declaration"
 * compiler flags to their projects to be warned when a function is being
 * used without a prototype in scope.
 */

/* These settings are particular to each product. */
/* Platform: MacOSX */

/* #undef __DARWIN_ONLY_UNIX_CONFORMANCE (automatically set for 64-bit) */


/*
 * The __DARWIN_ALIAS macros are used to do symbol renaming; they allow
 * legacy code to use the old symbol, thus maintaining binary compatibility
 * while new code can use a standards compliant version of the same function.
 *
 * __DARWIN_ALIAS is used by itself if the function signature has not
 * changed, it is used along with a #ifdef check for __DARWIN_UNIX03
 * if the signature has changed.  Because the __LP64__ environment
 * only supports UNIX03 semantics it causes __DARWIN_UNIX03 to be
 * defined, but causes __DARWIN_ALIAS to do no symbol mangling.
 *
 * As a special case, when XCode is used to target a specific version of the
 * OS, the manifest constant __ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__
 * will be defined by the compiler, with the digits representing major version
 * time 100 + minor version times 10 (e.g. 10.5 := 1050).  If we are targeting
 * pre-10.5, and it is the default compilation environment, revert the
 * compilation environment to pre-__DARWIN_UNIX03.
 */
# 440 "/usr/include/sys/cdefs.h" 3 4
/*
 * symbol suffixes used for symbol versioning
 */
# 485 "/usr/include/sys/cdefs.h" 3 4
/*
 * symbol versioning macros
 */
# 503 "/usr/include/sys/cdefs.h" 3 4
/*
 * symbol release macros
 */

# 1 "/usr/include/sys/_symbol_aliasing.h" 1 3 4
/* Copyright (c) 2010 Apple Inc. All rights reserved.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
# 507 "/usr/include/sys/cdefs.h" 2 3 4
# 517 "/usr/include/sys/cdefs.h" 3 4
/*
 * POSIX.1 requires that the macros we test be defined before any standard
 * header file is included.  This permits us to convert values for feature
 * testing, as necessary, using only _POSIX_C_SOURCE.
 *
 * Here's a quick run-down of the versions:
 *  defined(_POSIX_SOURCE)		1003.1-1988
 *  _POSIX_C_SOURCE == 1L		1003.1-1990
 *  _POSIX_C_SOURCE == 2L		1003.2-1992 C Language Binding Option
 *  _POSIX_C_SOURCE == 199309L		1003.1b-1993
 *  _POSIX_C_SOURCE == 199506L		1003.1c-1995, 1003.1i-1995,
 *					and the omnibus ISO/IEC 9945-1: 1996
 *  _POSIX_C_SOURCE == 200112L		1003.1-2001
 *  _POSIX_C_SOURCE == 200809L		1003.1-2008
 *
 * In addition, the X/Open Portability Guide, which is now the Single UNIX
 * Specification, defines a feature-test macro which indicates the version of
 * that specification, and which subsumes _POSIX_C_SOURCE.
 */

/* Deal with IEEE Std. 1003.1-1990, in which _POSIX_C_SOURCE == 1L. */





/* Deal with IEEE Std. 1003.2-1992, in which _POSIX_C_SOURCE == 2L. */





/* Deal with various X/Open Portability Guides and Single UNIX Spec. */
# 563 "/usr/include/sys/cdefs.h" 3 4
/*
 * Deal with all versions of POSIX.  The ordering relative to the tests above is
 * important.
 */




/* POSIX C deprecation macros */

# 1 "/usr/include/sys/_posix_availability.h" 1 3 4
/* Copyright (c) 2010 Apple Inc. All rights reserved.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
# 573 "/usr/include/sys/cdefs.h" 2 3 4



/*
 * Set a single macro which will always be defined and can be used to determine
 * the appropriate namespace.  For POSIX, these values will correspond to
 * _POSIX_C_SOURCE value.  Currently there are two additional levels corresponding
 * to ANSI (_ANSI_SOURCE) and Darwin extensions (_DARWIN_C_SOURCE)
 */
# 593 "/usr/include/sys/cdefs.h" 3 4
/* If the developer has neither requested a strict language mode nor a version
 * of POSIX, turn on functionality provided by __STDC_WANT_LIB_EXT1__ as part
 * of __DARWIN_C_FULL.
 */




/*
 * long long is not supported in c89 (__STRICT_ANSI__), but g++ -ansi and
 * c99 still want long longs.  While not perfect, we allow long longs for
 * g++.
 */




/*****************************************
 *  Public darwin-specific feature macros
 *****************************************/

/*
 * _DARWIN_FEATURE_64_BIT_INODE indicates that the ino_t type is 64-bit, and
 * structures modified for 64-bit inodes (like struct stat) will be used.
 */




/*
 * _DARWIN_FEATURE_64_ONLY_BIT_INODE indicates that the ino_t type may only
 * be 64-bit; there is no support for 32-bit ino_t when this macro is defined
 * (and non-zero).  There is no struct stat64 either, as the regular
 * struct stat will already be the 64-bit version.
 */




/*
 * _DARWIN_FEATURE_ONLY_VERS_1050 indicates that only those APIs updated
 * in 10.5 exists; no pre-10.5 variants are available.
 */




/*
 * _DARWIN_FEATURE_ONLY_UNIX_CONFORMANCE indicates only UNIX conforming API
 * are available (the legacy BSD APIs are not available)
 */




/*
 * _DARWIN_FEATURE_UNIX_CONFORMANCE indicates whether UNIX conformance is on,
 * and specifies the conformance level (3 is SUSv3)
 */




/* 
 * This macro casts away the qualifier from the variable
 *
 * Note: use at your own risk, removing qualifiers can result in
 * catastrophic run-time failures.
 */




/*
 * __XNU_PRIVATE_EXTERN is a linkage decoration indicating that a symbol can be
 * used from other compilation units, but not other libraries or executables.
 */




/*
 * Architecture validation for current SDK
 */
# 33 "/usr/include/sys/_types.h" 2 3 4
# 1 "/usr/include/machine/_types.h" 1 3 4
/*
 * Copyright (c) 2003-2007 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */





# 1 "/usr/include/i386/_types.h" 1 3 4
/*
 * Copyright (c) 2000-2003 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */



/*
 * This header file contains integer types.  It's intended to also contain
 * flotaing point and other arithmetic types, as needed, later.
 */


typedef signed char __int8_t;



typedef unsigned char __uint8_t;
typedef short __int16_t;
typedef unsigned short __uint16_t;
typedef int __int32_t;
typedef unsigned int __uint32_t;
typedef long long __int64_t;
typedef unsigned long long __uint64_t;

typedef long __darwin_intptr_t;
typedef unsigned int __darwin_natural_t;

/*
 * The rune type below is declared to be an ``int'' instead of the more natural
 * ``unsigned long'' or ``long''.  Two things are happening here.  It is not
 * unsigned so that EOF (-1) can be naturally assigned to it and used.  Also,
 * it looks like 10646 will be a 31 bit standard.  This means that if your
 * ints cannot hold 32 bits, you will be in trouble.  The reason an int was
 * chosen over a long is that the is*() and to*() routines take ints (says
 * ANSI C), but they use __darwin_ct_rune_t instead of int.  By changing it
 * here, you lose a bit of ANSI conformance, but your programs will still
 * work.
 *
 * NOTE: rune_t is not covered by ANSI nor other standards, and should not
 * be instantiated outside of lib/libc/locale.  Use wchar_t.  wchar_t and
 * rune_t must be the same type.  Also wint_t must be no narrower than
 * wchar_t, and should also be able to hold all members of the largest
 * character set plus one extra value (WEOF). wint_t must be at least 16 bits.
 */

typedef int __darwin_ct_rune_t; /* ct_rune_t */

/*
 * mbstate_t is an opaque object to keep conversion state, during multibyte
 * stream conversions.  The content must not be referenced by user programs.
 */
typedef union {
 char __mbstate8[128];
 long long _mbstateL; /* for alignment */
} __mbstate_t;

typedef __mbstate_t __darwin_mbstate_t; /* mbstate_t */


typedef long int __darwin_ptrdiff_t; /* ptr1 - ptr2 */







typedef long unsigned int __darwin_size_t; /* sizeof() */





typedef __builtin_va_list __darwin_va_list; /* va_list */





typedef int __darwin_wchar_t; /* wchar_t */




typedef __darwin_wchar_t __darwin_rune_t; /* rune_t */


typedef int __darwin_wint_t; /* wint_t */




typedef unsigned long __darwin_clock_t; /* clock() */
typedef __uint32_t __darwin_socklen_t; /* socklen_t (duh) */
typedef long __darwin_ssize_t; /* byte count or error */
typedef long __darwin_time_t; /* time() */
# 33 "/usr/include/machine/_types.h" 2 3 4
# 34 "/usr/include/sys/_types.h" 2 3 4

/*
 * Type definitions; takes common type definitions that must be used
 * in multiple header files due to [XSI], removes them from the system
 * space, and puts them in the implementation space.
 */
# 55 "/usr/include/sys/_types.h" 3 4
typedef __int64_t __darwin_blkcnt_t; /* total blocks */
typedef __int32_t __darwin_blksize_t; /* preferred block size */
typedef __int32_t __darwin_dev_t; /* dev_t */
typedef unsigned int __darwin_fsblkcnt_t; /* Used by statvfs and fstatvfs */
typedef unsigned int __darwin_fsfilcnt_t; /* Used by statvfs and fstatvfs */
typedef __uint32_t __darwin_gid_t; /* [???] process and group IDs */
typedef __uint32_t __darwin_id_t; /* [XSI] pid_t, uid_t, or gid_t*/
typedef __uint64_t __darwin_ino64_t; /* [???] Used for 64 bit inodes */

typedef __darwin_ino64_t __darwin_ino_t; /* [???] Used for inodes */



typedef __darwin_natural_t __darwin_mach_port_name_t; /* Used by mach */
typedef __darwin_mach_port_name_t __darwin_mach_port_t; /* Used by mach */
typedef __uint16_t __darwin_mode_t; /* [???] Some file attributes */
typedef __int64_t __darwin_off_t; /* [???] Used for file sizes */
typedef __int32_t __darwin_pid_t; /* [???] process and group IDs */
typedef __uint32_t __darwin_sigset_t; /* [???] signal set */
typedef __int32_t __darwin_suseconds_t; /* [???] microseconds */
typedef __uint32_t __darwin_uid_t; /* [???] user IDs */
typedef __uint32_t __darwin_useconds_t; /* [???] microseconds */
typedef unsigned char __darwin_uuid_t[16];
typedef char __darwin_uuid_string_t[37];


# 1 "/usr/include/sys/_pthread/_pthread_types.h" 1 3 4
/*
 * Copyright (c) 2003-2013 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */






// pthread opaque structures
# 57 "/usr/include/sys/_pthread/_pthread_types.h" 3 4
struct __darwin_pthread_handler_rec {
 void (*__routine)(void *); // Routine to call
 void *__arg; // Argument to pass
 struct __darwin_pthread_handler_rec *__next;
};

struct _opaque_pthread_attr_t {
 long __sig;
 char __opaque[56];
};

struct _opaque_pthread_cond_t {
 long __sig;
 char __opaque[40];
};

struct _opaque_pthread_condattr_t {
 long __sig;
 char __opaque[8];
};

struct _opaque_pthread_mutex_t {
 long __sig;
 char __opaque[56];
};

struct _opaque_pthread_mutexattr_t {
 long __sig;
 char __opaque[8];
};

struct _opaque_pthread_once_t {
 long __sig;
 char __opaque[8];
};

struct _opaque_pthread_rwlock_t {
 long __sig;
 char __opaque[192];
};

struct _opaque_pthread_rwlockattr_t {
 long __sig;
 char __opaque[16];
};

struct _opaque_pthread_t {
 long __sig;
 struct __darwin_pthread_handler_rec *__cleanup_stack;
 char __opaque[8176];
};

typedef struct _opaque_pthread_attr_t __darwin_pthread_attr_t;
typedef struct _opaque_pthread_cond_t __darwin_pthread_cond_t;
typedef struct _opaque_pthread_condattr_t __darwin_pthread_condattr_t;
typedef unsigned long __darwin_pthread_key_t;
typedef struct _opaque_pthread_mutex_t __darwin_pthread_mutex_t;
typedef struct _opaque_pthread_mutexattr_t __darwin_pthread_mutexattr_t;
typedef struct _opaque_pthread_once_t __darwin_pthread_once_t;
typedef struct _opaque_pthread_rwlock_t __darwin_pthread_rwlock_t;
typedef struct _opaque_pthread_rwlockattr_t __darwin_pthread_rwlockattr_t;
typedef struct _opaque_pthread_t *__darwin_pthread_t;
# 81 "/usr/include/sys/_types.h" 2 3 4
# 28 "/usr/include/_types.h" 2 3 4
# 39 "/usr/include/_types.h" 3 4
typedef int __darwin_nl_item;
typedef int __darwin_wctrans_t;

typedef __uint32_t __darwin_wctype_t;
# 64 "/usr/include/stdlib.h" 2 3 4

# 1 "/usr/include/sys/wait.h" 1 3 4
/*
 * Copyright (c) 2000 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
/* Copyright (c) 1995 NeXT Computer, Inc. All Rights Reserved */
/*
 * Copyright (c) 1982, 1986, 1989, 1993, 1994
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)wait.h	8.2 (Berkeley) 7/10/94
 */







/*
 * This file holds definitions relevent to the wait4 system call
 * and the alternate interfaces that use it (wait, wait3, waitpid).
 */

/*
 * [XSI] The type idtype_t shall be defined as an enumeration type whose
 * possible values shall include at least P_ALL, P_PID, and P_PGID.
 */
typedef enum {
 P_ALL,
 P_PID,
 P_PGID
} idtype_t;

/*
 * [XSI] The id_t and pid_t types shall be defined as described
 * in <sys/types.h>
 */

# 1 "/usr/include/sys/_types/_pid_t.h" 1 3 4
/*
 * Copyright (c) 2003-2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */


typedef __darwin_pid_t pid_t;
# 90 "/usr/include/sys/wait.h" 2 3 4
# 1 "/usr/include/sys/_types/_id_t.h" 1 3 4
/*
 * Copyright (c) 2003-2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */


typedef __darwin_id_t id_t; /* can hold pid_t, gid_t, or uid_t */
# 91 "/usr/include/sys/wait.h" 2 3 4

/*
 * [XSI] The siginfo_t type shall be defined as described in <signal.h>
 * [XSI] The rusage structure shall be defined as described in <sys/resource.h>
 * [XSI] Inclusion of the <sys/wait.h> header may also make visible all
 * symbols from <signal.h> and <sys/resource.h>
 *
 * NOTE:	This requirement is currently being satisfied by the direct
 *		inclusion of <sys/signal.h> and <sys/resource.h>, below.
 *
 *		Software should not depend on the exposure of anything other
 *		than the types siginfo_t and struct rusage as a result of
 *		this inclusion.  If you depend on any types or manifest
 *		values othe than siginfo_t and struct rusage from either of
 *		those files, you should explicitly include them yourself, as
 *		well, or in future releases your stware may not compile
 *		without modification.
 */

# 1 "/usr/include/sys/signal.h" 1 3 4
/*
 * Copyright (c) 2000-2006 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
/* Copyright (c) 1995 NeXT Computer, Inc. All Rights Reserved */
/*
 * Copyright (c) 1982, 1986, 1989, 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
 * (c) UNIX System Laboratories, Inc.
 * All or some portions of this file are derived from material licensed
 * to the University of California by American Telephone and Telegraph
 * Co. or Unix System Laboratories, Inc. and are reproduced herein with
 * the permission of UNIX System Laboratories, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)signal.h	8.2 (Berkeley) 1/21/94
 */






# 1 "/usr/include/sys/appleapiopts.h" 1 3 4
/*
 * Copyright (c) 2002 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
# 74 "/usr/include/sys/signal.h" 2 3 4







# 1 "/usr/include/machine/signal.h" 1 3 4
/*
 * Copyright (c) 2000-2007 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */





# 1 "/usr/include/i386/signal.h" 1 3 4
/*
 * Copyright (c) 2000-2002 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
/*
 * Copyright (c) 1992 NeXT Computer, Inc.
 *
 */







typedef int sig_atomic_t;
# 33 "/usr/include/machine/signal.h" 2 3 4
# 82 "/usr/include/sys/signal.h" 2 3 4
# 125 "/usr/include/sys/signal.h" 3 4
/*
 * Language spec sez we must list exactly one parameter, even though we
 * actually supply three.  Ugh!
 * SIG_HOLD is chosen to avoid KERN_SIG_* values in <sys/signalvar.h>
 */
# 145 "/usr/include/sys/signal.h" 3 4
# 1 "/usr/include/machine/_mcontext.h" 1 3 4
/*
 * Copyright (c) 2003-2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */


# 1 "/usr/include/i386/_mcontext.h" 1 3 4
/*
 * Copyright (c) 2003-2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */






# 1 "/usr/include/mach/i386/_structs.h" 1 3 4
/*
 * Copyright (c) 2004-2006 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
/*
 * @OSF_COPYRIGHT@
 */




/*
 * i386 is the structure that is exported to user threads for 
 * use in status/mutate calls.  This structure should never change.
 *
 */



struct __darwin_i386_thread_state
{
    unsigned int __eax;
    unsigned int __ebx;
    unsigned int __ecx;
    unsigned int __edx;
    unsigned int __edi;
    unsigned int __esi;
    unsigned int __ebp;
    unsigned int __esp;
    unsigned int __ss;
    unsigned int __eflags;
    unsigned int __eip;
    unsigned int __cs;
    unsigned int __ds;
    unsigned int __es;
    unsigned int __fs;
    unsigned int __gs;
};
# 85 "/usr/include/mach/i386/_structs.h" 3 4
/* This structure should be double-word aligned for performance */



struct __darwin_fp_control
{
    unsigned short __invalid :1,
        __denorm :1,
    __zdiv :1,
    __ovrfl :1,
    __undfl :1,
    __precis :1,
      :2,
    __pc :2,





    __rc :2,






     /*inf*/ :1,
      :3;
};
typedef struct __darwin_fp_control __darwin_fp_control_t;
# 141 "/usr/include/mach/i386/_structs.h" 3 4
/*
 * Status word.
 */



struct __darwin_fp_status
{
    unsigned short __invalid :1,
        __denorm :1,
    __zdiv :1,
    __ovrfl :1,
    __undfl :1,
    __precis :1,
    __stkflt :1,
    __errsumm :1,
    __c0 :1,
    __c1 :1,
    __c2 :1,
    __tos :3,
    __c3 :1,
    __busy :1;
};
typedef struct __darwin_fp_status __darwin_fp_status_t;
# 187 "/usr/include/mach/i386/_structs.h" 3 4
/* defn of 80bit x87 FPU or MMX register  */



struct __darwin_mmst_reg
{
 char __mmst_reg[10];
 char __mmst_rsrv[6];
};
# 206 "/usr/include/mach/i386/_structs.h" 3 4
/* defn of 128 bit XMM regs */



struct __darwin_xmm_reg
{
 char __xmm_reg[16];
};
# 222 "/usr/include/mach/i386/_structs.h" 3 4
/* 
 * Floating point state.
 */







struct __darwin_i386_float_state
{
 int __fpu_reserved[2];
 struct __darwin_fp_control __fpu_fcw; /* x87 FPU control word */
 struct __darwin_fp_status __fpu_fsw; /* x87 FPU status word */
 __uint8_t __fpu_ftw; /* x87 FPU tag word */
 __uint8_t __fpu_rsrv1; /* reserved */
 __uint16_t __fpu_fop; /* x87 FPU Opcode */
 __uint32_t __fpu_ip; /* x87 FPU Instruction Pointer offset */
 __uint16_t __fpu_cs; /* x87 FPU Instruction Pointer Selector */
 __uint16_t __fpu_rsrv2; /* reserved */
 __uint32_t __fpu_dp; /* x87 FPU Instruction Operand(Data) Pointer offset */
 __uint16_t __fpu_ds; /* x87 FPU Instruction Operand(Data) Pointer Selector */
 __uint16_t __fpu_rsrv3; /* reserved */
 __uint32_t __fpu_mxcsr; /* MXCSR Register state */
 __uint32_t __fpu_mxcsrmask; /* MXCSR mask */
 struct __darwin_mmst_reg __fpu_stmm0; /* ST0/MM0   */
 struct __darwin_mmst_reg __fpu_stmm1; /* ST1/MM1  */
 struct __darwin_mmst_reg __fpu_stmm2; /* ST2/MM2  */
 struct __darwin_mmst_reg __fpu_stmm3; /* ST3/MM3  */
 struct __darwin_mmst_reg __fpu_stmm4; /* ST4/MM4  */
 struct __darwin_mmst_reg __fpu_stmm5; /* ST5/MM5  */
 struct __darwin_mmst_reg __fpu_stmm6; /* ST6/MM6  */
 struct __darwin_mmst_reg __fpu_stmm7; /* ST7/MM7  */
 struct __darwin_xmm_reg __fpu_xmm0; /* XMM 0  */
 struct __darwin_xmm_reg __fpu_xmm1; /* XMM 1  */
 struct __darwin_xmm_reg __fpu_xmm2; /* XMM 2  */
 struct __darwin_xmm_reg __fpu_xmm3; /* XMM 3  */
 struct __darwin_xmm_reg __fpu_xmm4; /* XMM 4  */
 struct __darwin_xmm_reg __fpu_xmm5; /* XMM 5  */
 struct __darwin_xmm_reg __fpu_xmm6; /* XMM 6  */
 struct __darwin_xmm_reg __fpu_xmm7; /* XMM 7  */
 char __fpu_rsrv4[14*16]; /* reserved */
 int __fpu_reserved1;
};


struct __darwin_i386_avx_state
{
 int __fpu_reserved[2];
 struct __darwin_fp_control __fpu_fcw; /* x87 FPU control word */
 struct __darwin_fp_status __fpu_fsw; /* x87 FPU status word */
 __uint8_t __fpu_ftw; /* x87 FPU tag word */
 __uint8_t __fpu_rsrv1; /* reserved */
 __uint16_t __fpu_fop; /* x87 FPU Opcode */
 __uint32_t __fpu_ip; /* x87 FPU Instruction Pointer offset */
 __uint16_t __fpu_cs; /* x87 FPU Instruction Pointer Selector */
 __uint16_t __fpu_rsrv2; /* reserved */
 __uint32_t __fpu_dp; /* x87 FPU Instruction Operand(Data) Pointer offset */
 __uint16_t __fpu_ds; /* x87 FPU Instruction Operand(Data) Pointer Selector */
 __uint16_t __fpu_rsrv3; /* reserved */
 __uint32_t __fpu_mxcsr; /* MXCSR Register state */
 __uint32_t __fpu_mxcsrmask; /* MXCSR mask */
 struct __darwin_mmst_reg __fpu_stmm0; /* ST0/MM0   */
 struct __darwin_mmst_reg __fpu_stmm1; /* ST1/MM1  */
 struct __darwin_mmst_reg __fpu_stmm2; /* ST2/MM2  */
 struct __darwin_mmst_reg __fpu_stmm3; /* ST3/MM3  */
 struct __darwin_mmst_reg __fpu_stmm4; /* ST4/MM4  */
 struct __darwin_mmst_reg __fpu_stmm5; /* ST5/MM5  */
 struct __darwin_mmst_reg __fpu_stmm6; /* ST6/MM6  */
 struct __darwin_mmst_reg __fpu_stmm7; /* ST7/MM7  */
 struct __darwin_xmm_reg __fpu_xmm0; /* XMM 0  */
 struct __darwin_xmm_reg __fpu_xmm1; /* XMM 1  */
 struct __darwin_xmm_reg __fpu_xmm2; /* XMM 2  */
 struct __darwin_xmm_reg __fpu_xmm3; /* XMM 3  */
 struct __darwin_xmm_reg __fpu_xmm4; /* XMM 4  */
 struct __darwin_xmm_reg __fpu_xmm5; /* XMM 5  */
 struct __darwin_xmm_reg __fpu_xmm6; /* XMM 6  */
 struct __darwin_xmm_reg __fpu_xmm7; /* XMM 7  */
 char __fpu_rsrv4[14*16]; /* reserved */
 int __fpu_reserved1;
 char __avx_reserved1[64];
 struct __darwin_xmm_reg __fpu_ymmh0; /* YMMH 0  */
 struct __darwin_xmm_reg __fpu_ymmh1; /* YMMH 1  */
 struct __darwin_xmm_reg __fpu_ymmh2; /* YMMH 2  */
 struct __darwin_xmm_reg __fpu_ymmh3; /* YMMH 3  */
 struct __darwin_xmm_reg __fpu_ymmh4; /* YMMH 4  */
 struct __darwin_xmm_reg __fpu_ymmh5; /* YMMH 5  */
 struct __darwin_xmm_reg __fpu_ymmh6; /* YMMH 6  */
 struct __darwin_xmm_reg __fpu_ymmh7; /* YMMH 7  */
};
# 402 "/usr/include/mach/i386/_structs.h" 3 4
struct __darwin_i386_exception_state
{
 __uint16_t __trapno;
 __uint16_t __cpu;
 __uint32_t __err;
 __uint32_t __faultvaddr;
};
# 422 "/usr/include/mach/i386/_structs.h" 3 4
struct __darwin_x86_debug_state32
{
 unsigned int __dr0;
 unsigned int __dr1;
 unsigned int __dr2;
 unsigned int __dr3;
 unsigned int __dr4;
 unsigned int __dr5;
 unsigned int __dr6;
 unsigned int __dr7;
};
# 448 "/usr/include/mach/i386/_structs.h" 3 4
/*
 * 64 bit versions of the above
 */



struct __darwin_x86_thread_state64
{
 __uint64_t __rax;
 __uint64_t __rbx;
 __uint64_t __rcx;
 __uint64_t __rdx;
 __uint64_t __rdi;
 __uint64_t __rsi;
 __uint64_t __rbp;
 __uint64_t __rsp;
 __uint64_t __r8;
 __uint64_t __r9;
 __uint64_t __r10;
 __uint64_t __r11;
 __uint64_t __r12;
 __uint64_t __r13;
 __uint64_t __r14;
 __uint64_t __r15;
 __uint64_t __rip;
 __uint64_t __rflags;
 __uint64_t __cs;
 __uint64_t __fs;
 __uint64_t __gs;
};
# 509 "/usr/include/mach/i386/_structs.h" 3 4
struct __darwin_x86_float_state64
{
 int __fpu_reserved[2];
 struct __darwin_fp_control __fpu_fcw; /* x87 FPU control word */
 struct __darwin_fp_status __fpu_fsw; /* x87 FPU status word */
 __uint8_t __fpu_ftw; /* x87 FPU tag word */
 __uint8_t __fpu_rsrv1; /* reserved */
 __uint16_t __fpu_fop; /* x87 FPU Opcode */

 /* x87 FPU Instruction Pointer */
 __uint32_t __fpu_ip; /* offset */
 __uint16_t __fpu_cs; /* Selector */

 __uint16_t __fpu_rsrv2; /* reserved */

 /* x87 FPU Instruction Operand(Data) Pointer */
 __uint32_t __fpu_dp; /* offset */
 __uint16_t __fpu_ds; /* Selector */

 __uint16_t __fpu_rsrv3; /* reserved */
 __uint32_t __fpu_mxcsr; /* MXCSR Register state */
 __uint32_t __fpu_mxcsrmask; /* MXCSR mask */
 struct __darwin_mmst_reg __fpu_stmm0; /* ST0/MM0   */
 struct __darwin_mmst_reg __fpu_stmm1; /* ST1/MM1  */
 struct __darwin_mmst_reg __fpu_stmm2; /* ST2/MM2  */
 struct __darwin_mmst_reg __fpu_stmm3; /* ST3/MM3  */
 struct __darwin_mmst_reg __fpu_stmm4; /* ST4/MM4  */
 struct __darwin_mmst_reg __fpu_stmm5; /* ST5/MM5  */
 struct __darwin_mmst_reg __fpu_stmm6; /* ST6/MM6  */
 struct __darwin_mmst_reg __fpu_stmm7; /* ST7/MM7  */
 struct __darwin_xmm_reg __fpu_xmm0; /* XMM 0  */
 struct __darwin_xmm_reg __fpu_xmm1; /* XMM 1  */
 struct __darwin_xmm_reg __fpu_xmm2; /* XMM 2  */
 struct __darwin_xmm_reg __fpu_xmm3; /* XMM 3  */
 struct __darwin_xmm_reg __fpu_xmm4; /* XMM 4  */
 struct __darwin_xmm_reg __fpu_xmm5; /* XMM 5  */
 struct __darwin_xmm_reg __fpu_xmm6; /* XMM 6  */
 struct __darwin_xmm_reg __fpu_xmm7; /* XMM 7  */
 struct __darwin_xmm_reg __fpu_xmm8; /* XMM 8  */
 struct __darwin_xmm_reg __fpu_xmm9; /* XMM 9  */
 struct __darwin_xmm_reg __fpu_xmm10; /* XMM 10  */
 struct __darwin_xmm_reg __fpu_xmm11; /* XMM 11 */
 struct __darwin_xmm_reg __fpu_xmm12; /* XMM 12  */
 struct __darwin_xmm_reg __fpu_xmm13; /* XMM 13  */
 struct __darwin_xmm_reg __fpu_xmm14; /* XMM 14  */
 struct __darwin_xmm_reg __fpu_xmm15; /* XMM 15  */
 char __fpu_rsrv4[6*16]; /* reserved */
 int __fpu_reserved1;
};


struct __darwin_x86_avx_state64
{
 int __fpu_reserved[2];
 struct __darwin_fp_control __fpu_fcw; /* x87 FPU control word */
 struct __darwin_fp_status __fpu_fsw; /* x87 FPU status word */
 __uint8_t __fpu_ftw; /* x87 FPU tag word */
 __uint8_t __fpu_rsrv1; /* reserved */
 __uint16_t __fpu_fop; /* x87 FPU Opcode */

 /* x87 FPU Instruction Pointer */
 __uint32_t __fpu_ip; /* offset */
 __uint16_t __fpu_cs; /* Selector */

 __uint16_t __fpu_rsrv2; /* reserved */

 /* x87 FPU Instruction Operand(Data) Pointer */
 __uint32_t __fpu_dp; /* offset */
 __uint16_t __fpu_ds; /* Selector */

 __uint16_t __fpu_rsrv3; /* reserved */
 __uint32_t __fpu_mxcsr; /* MXCSR Register state */
 __uint32_t __fpu_mxcsrmask; /* MXCSR mask */
 struct __darwin_mmst_reg __fpu_stmm0; /* ST0/MM0   */
 struct __darwin_mmst_reg __fpu_stmm1; /* ST1/MM1  */
 struct __darwin_mmst_reg __fpu_stmm2; /* ST2/MM2  */
 struct __darwin_mmst_reg __fpu_stmm3; /* ST3/MM3  */
 struct __darwin_mmst_reg __fpu_stmm4; /* ST4/MM4  */
 struct __darwin_mmst_reg __fpu_stmm5; /* ST5/MM5  */
 struct __darwin_mmst_reg __fpu_stmm6; /* ST6/MM6  */
 struct __darwin_mmst_reg __fpu_stmm7; /* ST7/MM7  */
 struct __darwin_xmm_reg __fpu_xmm0; /* XMM 0  */
 struct __darwin_xmm_reg __fpu_xmm1; /* XMM 1  */
 struct __darwin_xmm_reg __fpu_xmm2; /* XMM 2  */
 struct __darwin_xmm_reg __fpu_xmm3; /* XMM 3  */
 struct __darwin_xmm_reg __fpu_xmm4; /* XMM 4  */
 struct __darwin_xmm_reg __fpu_xmm5; /* XMM 5  */
 struct __darwin_xmm_reg __fpu_xmm6; /* XMM 6  */
 struct __darwin_xmm_reg __fpu_xmm7; /* XMM 7  */
 struct __darwin_xmm_reg __fpu_xmm8; /* XMM 8  */
 struct __darwin_xmm_reg __fpu_xmm9; /* XMM 9  */
 struct __darwin_xmm_reg __fpu_xmm10; /* XMM 10  */
 struct __darwin_xmm_reg __fpu_xmm11; /* XMM 11 */
 struct __darwin_xmm_reg __fpu_xmm12; /* XMM 12  */
 struct __darwin_xmm_reg __fpu_xmm13; /* XMM 13  */
 struct __darwin_xmm_reg __fpu_xmm14; /* XMM 14  */
 struct __darwin_xmm_reg __fpu_xmm15; /* XMM 15  */
 char __fpu_rsrv4[6*16]; /* reserved */
 int __fpu_reserved1;
 char __avx_reserved1[64];
 struct __darwin_xmm_reg __fpu_ymmh0; /* YMMH 0  */
 struct __darwin_xmm_reg __fpu_ymmh1; /* YMMH 1  */
 struct __darwin_xmm_reg __fpu_ymmh2; /* YMMH 2  */
 struct __darwin_xmm_reg __fpu_ymmh3; /* YMMH 3  */
 struct __darwin_xmm_reg __fpu_ymmh4; /* YMMH 4  */
 struct __darwin_xmm_reg __fpu_ymmh5; /* YMMH 5  */
 struct __darwin_xmm_reg __fpu_ymmh6; /* YMMH 6  */
 struct __darwin_xmm_reg __fpu_ymmh7; /* YMMH 7  */
 struct __darwin_xmm_reg __fpu_ymmh8; /* YMMH 8  */
 struct __darwin_xmm_reg __fpu_ymmh9; /* YMMH 9  */
 struct __darwin_xmm_reg __fpu_ymmh10; /* YMMH 10  */
 struct __darwin_xmm_reg __fpu_ymmh11; /* YMMH 11  */
 struct __darwin_xmm_reg __fpu_ymmh12; /* YMMH 12  */
 struct __darwin_xmm_reg __fpu_ymmh13; /* YMMH 13  */
 struct __darwin_xmm_reg __fpu_ymmh14; /* YMMH 14  */
 struct __darwin_xmm_reg __fpu_ymmh15; /* YMMH 15  */
};
# 751 "/usr/include/mach/i386/_structs.h" 3 4
struct __darwin_x86_exception_state64
{
    __uint16_t __trapno;
    __uint16_t __cpu;
    __uint32_t __err;
    __uint64_t __faultvaddr;
};
# 771 "/usr/include/mach/i386/_structs.h" 3 4
struct __darwin_x86_debug_state64
{
 __uint64_t __dr0;
 __uint64_t __dr1;
 __uint64_t __dr2;
 __uint64_t __dr3;
 __uint64_t __dr4;
 __uint64_t __dr5;
 __uint64_t __dr6;
 __uint64_t __dr7;
};
# 34 "/usr/include/i386/_mcontext.h" 2 3 4




struct __darwin_mcontext32
{
 struct __darwin_i386_exception_state __es;
 struct __darwin_i386_thread_state __ss;
 struct __darwin_i386_float_state __fs;
};


struct __darwin_mcontext_avx32
{
 struct __darwin_i386_exception_state __es;
 struct __darwin_i386_thread_state __ss;
 struct __darwin_i386_avx_state __fs;
};
# 76 "/usr/include/i386/_mcontext.h" 3 4
struct __darwin_mcontext64
{
 struct __darwin_x86_exception_state64 __es;
 struct __darwin_x86_thread_state64 __ss;
 struct __darwin_x86_float_state64 __fs;
};


struct __darwin_mcontext_avx64
{
 struct __darwin_x86_exception_state64 __es;
 struct __darwin_x86_thread_state64 __ss;
 struct __darwin_x86_avx_state64 __fs;
};
# 115 "/usr/include/i386/_mcontext.h" 3 4
typedef struct __darwin_mcontext64 *mcontext_t;
# 30 "/usr/include/machine/_mcontext.h" 2 3 4
# 146 "/usr/include/sys/signal.h" 2 3 4

# 1 "/usr/include/sys/_pthread/_pthread_attr_t.h" 1 3 4
/*
 * Copyright (c) 2003-2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */


typedef __darwin_pthread_attr_t pthread_attr_t;
# 148 "/usr/include/sys/signal.h" 2 3 4

# 1 "/usr/include/sys/_types/_sigaltstack.h" 1 3 4
/*
 * Copyright (c) 2003-2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */

/* Structure used in sigaltstack call. */






struct __darwin_sigaltstack
{
 void *ss_sp; /* signal stack base */
 __darwin_size_t ss_size; /* signal stack length */
 int ss_flags; /* SA_DISABLE and/or SA_ONSTACK */
};
typedef struct __darwin_sigaltstack stack_t; /* [???] signal stack */
# 150 "/usr/include/sys/signal.h" 2 3 4
# 1 "/usr/include/sys/_types/_ucontext.h" 1 3 4
/*
 * Copyright (c) 2003-2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */






struct __darwin_ucontext
{
 int uc_onstack;
 __darwin_sigset_t uc_sigmask; /* signal mask used by this context */
 struct __darwin_sigaltstack uc_stack; /* stack used by this context */
 struct __darwin_ucontext *uc_link; /* pointer to resuming context */
 __darwin_size_t uc_mcsize; /* size of the machine context passed in */
 struct __darwin_mcontext64 *uc_mcontext; /* pointer to machine specific context */



};

/* user context */
typedef struct __darwin_ucontext ucontext_t; /* [???] user context */
# 151 "/usr/include/sys/signal.h" 2 3 4


# 1 "/usr/include/sys/_types/_sigset_t.h" 1 3 4
/*
 * Copyright (c) 2003-2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */


typedef __darwin_sigset_t sigset_t;
# 154 "/usr/include/sys/signal.h" 2 3 4
# 1 "/usr/include/sys/_types/_size_t.h" 1 3 4
/*
 * Copyright (c) 2003-2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */


typedef __darwin_size_t size_t;
# 155 "/usr/include/sys/signal.h" 2 3 4
# 1 "/usr/include/sys/_types/_uid_t.h" 1 3 4
/*
 * Copyright (c) 2003-2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */


typedef __darwin_uid_t uid_t;
# 156 "/usr/include/sys/signal.h" 2 3 4

union sigval {
 /* Members as suggested by Annex C of POSIX 1003.1b. */
 int sival_int;
 void *sival_ptr;
};





struct sigevent {
 int sigev_notify; /* Notification type */
 int sigev_signo; /* Signal number */
 union sigval sigev_value; /* Signal value */
 void (*sigev_notify_function)(union sigval); /* Notification function */
 pthread_attr_t *sigev_notify_attributes; /* Notification attributes */
};


typedef struct __siginfo {
 int si_signo; /* signal number */
 int si_errno; /* errno association */
 int si_code; /* signal code */
 pid_t si_pid; /* sending process */
 uid_t si_uid; /* sender's ruid */
 int si_status; /* exit value */
 void *si_addr; /* faulting instruction */
 union sigval si_value; /* signal value */
 long si_band; /* band event for SIGPOLL */
 unsigned long __pad[7]; /* Reserved for Future Use */
} siginfo_t;


/* 
 * When the signal is SIGILL or SIGFPE, si_addr contains the address of 
 * the faulting instruction.
 * When the signal is SIGSEGV or SIGBUS, si_addr contains the address of 
 * the faulting memory reference. Although for x86 there are cases of SIGSEGV
 * for which si_addr cannot be determined and is NULL. 
 * If the signal is SIGCHLD, the si_pid field will contain the child process ID,
 *  si_status contains the exit value or signal and
 *  si_uid contains the real user ID of the process that sent the signal.
 */

/* Values for si_code */

/* Codes for SIGILL */
# 216 "/usr/include/sys/signal.h" 3 4
/* Codes for SIGFPE */
# 229 "/usr/include/sys/signal.h" 3 4
/* Codes for SIGSEGV */






/* Codes for SIGBUS */







/* Codes for SIGTRAP */



/* Codes for SIGCHLD */
# 259 "/usr/include/sys/signal.h" 3 4
/* Codes for SIGPOLL */







/* union for signal handlers */
union __sigaction_u {
 void (*__sa_handler)(int);
 void (*__sa_sigaction)(int, struct __siginfo *,
         void *);
};

/* Signal vector template for Kernel user boundary */
struct __sigaction {
 union __sigaction_u __sigaction_u; /* signal handler */
 void (*sa_tramp)(void *, int, int, siginfo_t *, void *);
 sigset_t sa_mask; /* signal mask to apply */
 int sa_flags; /* see signal options below */
};

/*
 * Signal vector "template" used in sigaction call.
 */
struct sigaction {
 union __sigaction_u __sigaction_u; /* signal handler */
 sigset_t sa_mask; /* signal mask to apply */
 int sa_flags; /* see signal options below */
};



/* if SA_SIGINFO is set, sa_sigaction is to be used instead of sa_handler. */
# 306 "/usr/include/sys/signal.h" 3 4
/* This will provide 64bit register set in a 32bit user address space */



/* the following are the only bits we support from user space, the 
 * rest are for kernel use only.
 */


/*
 * Flags for sigprocmask:
 */




/* POSIX 1003.1b required values. */







typedef void (*sig_t)(int); /* type of signal function */


/*
 * Structure used in sigaltstack call.
 */







/*
 * 4.3 compatibility:
 * Signal vector "template" used in sigvec call.
 */
struct sigvec {
 void (*sv_handler)(int); /* signal handler */
 int sv_mask; /* signal mask to apply */
 int sv_flags; /* see signal options below */
};
# 363 "/usr/include/sys/signal.h" 3 4
/*
 * Structure used in sigstack call.
 */
struct sigstack {
 char *ss_sp; /* signal stack pointer */
 int ss_onstack; /* current status */
};


/*
 * Macro for converting signal number to a mask suitable for
 * sigblock().
 */
# 384 "/usr/include/sys/signal.h" 3 4
/*
 * For historical reasons; programs expect signal's return value to be
 * defined by <sys/signal.h>.
 */
extern "C" {
void (*signal(int, void (*)(int)))(int);
}
# 110 "/usr/include/sys/wait.h" 2 3 4
# 1 "/usr/include/sys/resource.h" 1 3 4
/*
 * Copyright (c) 2000-2008 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
/* Copyright (c) 1995 NeXT Computer, Inc. All Rights Reserved */
/*
 * Copyright (c) 1982, 1986, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)resource.h	8.2 (Berkeley) 1/4/94
 */
# 72 "/usr/include/sys/resource.h" 3 4
# 1 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../lib/clang/3.5.0/include/stdint.h" 1 3 4
/*===---- stdint.h - Standard header for sized integer types --------------===*\
 *
 * Copyright (c) 2009 Chris Lattner
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
\*===----------------------------------------------------------------------===*/




/* If we're hosted, fall back to the system's stdint.h, which might have
 * additional definitions.
 */


// C99 7.18.3 Limits of other integer types
//
//  Footnote 219, 220: C++ implementations should define these macros only when
//  __STDC_LIMIT_MACROS is defined before <stdint.h> is included.
//
//  Footnote 222: C++ implementations should define these macros only when
//  __STDC_CONSTANT_MACROS is defined before <stdint.h> is included.
//
// C++11 [cstdint.syn]p2:
//
//  The macros defined by <cstdint> are provided unconditionally. In particular,
//  the symbols __STDC_LIMIT_MACROS and __STDC_CONSTANT_MACROS (mentioned in
//  footnotes 219, 220, and 222 in the C standard) play no role in C++.
//
// C11 removed the problematic footnotes.
//
// Work around this inconsistency by always defining those macros in C++ mode,
// so that a C library implementation which follows the C99 standard can be
// used in C++.
# 63 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../lib/clang/3.5.0/include/stdint.h" 3 4
# 1 "/usr/include/stdint.h" 1 3 4
/*
 * Copyright (c) 2000-2010 Apple Inc.
 * All rights reserved.
 */
# 15 "/usr/include/stdint.h" 3 4
/* from ISO/IEC 988:1999 spec */

/* 7.18.1.1 Exact-width integer types */

# 1 "/usr/include/sys/_types/_int8_t.h" 1 3 4
/*
 * Copyright (c) 2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */


typedef signed char int8_t;
# 19 "/usr/include/stdint.h" 2 3 4
# 1 "/usr/include/sys/_types/_int16_t.h" 1 3 4
/*
 * Copyright (c) 2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */


typedef short int16_t;
# 20 "/usr/include/stdint.h" 2 3 4
# 1 "/usr/include/sys/_types/_int32_t.h" 1 3 4
/*
 * Copyright (c) 2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */


typedef int int32_t;
# 21 "/usr/include/stdint.h" 2 3 4
# 1 "/usr/include/sys/_types/_int64_t.h" 1 3 4
/*
 * Copyright (c) 2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */


typedef long long int64_t;
# 22 "/usr/include/stdint.h" 2 3 4

# 1 "/usr/include/_types/_uint8_t.h" 1 3 4
/*
 * Copyright (c) 2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */



typedef unsigned char uint8_t;
# 24 "/usr/include/stdint.h" 2 3 4
# 1 "/usr/include/_types/_uint16_t.h" 1 3 4
/*
 * Copyright (c) 2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */



typedef unsigned short uint16_t;
# 25 "/usr/include/stdint.h" 2 3 4
# 1 "/usr/include/_types/_uint32_t.h" 1 3 4
/*
 * Copyright (c) 2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */



typedef unsigned int uint32_t;
# 26 "/usr/include/stdint.h" 2 3 4
# 1 "/usr/include/_types/_uint64_t.h" 1 3 4
/*
 * Copyright (c) 2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */



typedef unsigned long long uint64_t;
# 27 "/usr/include/stdint.h" 2 3 4

/* 7.18.1.2 Minimum-width integer types */
typedef int8_t int_least8_t;
typedef int16_t int_least16_t;
typedef int32_t int_least32_t;
typedef int64_t int_least64_t;
typedef uint8_t uint_least8_t;
typedef uint16_t uint_least16_t;
typedef uint32_t uint_least32_t;
typedef uint64_t uint_least64_t;


/* 7.18.1.3 Fastest-width integer types */
typedef int8_t int_fast8_t;
typedef int16_t int_fast16_t;
typedef int32_t int_fast32_t;
typedef int64_t int_fast64_t;
typedef uint8_t uint_fast8_t;
typedef uint16_t uint_fast16_t;
typedef uint32_t uint_fast32_t;
typedef uint64_t uint_fast64_t;


/* 7.18.1.4 Integer types capable of holding object pointers */



# 1 "/usr/include/sys/_types/_intptr_t.h" 1 3 4
/*
 * Copyright (c) 2003-2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */


typedef __darwin_intptr_t intptr_t;
# 54 "/usr/include/stdint.h" 2 3 4
# 1 "/usr/include/sys/_types/_uintptr_t.h" 1 3 4
/*
 * Copyright (c) 2003-2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */


typedef unsigned long uintptr_t;
# 55 "/usr/include/stdint.h" 2 3 4


/* 7.18.1.5 Greatest-width integer types */

# 1 "/usr/include/_types/_intmax_t.h" 1 3 4
/*
 * Copyright (c) 2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */




typedef long int intmax_t;
# 59 "/usr/include/stdint.h" 2 3 4
# 1 "/usr/include/_types/_uintmax_t.h" 1 3 4
/*
 * Copyright (c) 2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */




typedef long unsigned int uintmax_t;
# 60 "/usr/include/stdint.h" 2 3 4

/* 7.18.2 Limits of specified-width integer types:
 *   These #defines specify the minimum and maximum limits
 *   of each of the types declared above.
 */


/* 7.18.2.1 Limits of exact-width integer types */







   /*
      Note:  the literal "most negative int" cannot be written in C --
      the rules in the standard (section 6.4.4.1 in C99) will give it
      an unsigned type, so INT32_MIN (and the most negative member of
      any larger signed type) must be written via a constant expression.
   */
# 89 "/usr/include/stdint.h" 3 4
/* 7.18.2.2 Limits of minimum-width integer types */
# 105 "/usr/include/stdint.h" 3 4
/* 7.18.2.3 Limits of fastest minimum-width integer types */
# 121 "/usr/include/stdint.h" 3 4
/* 7.18.2.4 Limits of integer types capable of holding object pointers */
# 137 "/usr/include/stdint.h" 3 4
/* 7.18.2.5 Limits of greatest-width integer types */





/* 7.18.3 "Other" */
# 170 "/usr/include/stdint.h" 3 4
/* WCHAR_MIN should be 0 if wchar_t is an unsigned type and
   (-WCHAR_MAX-1) if wchar_t is a signed type.  Unfortunately,
   it turns out that -fshort-wchar changes the signedness of
   the type. */
# 188 "/usr/include/stdint.h" 3 4
/* 7.18.4 Macros for integer constants */
# 64 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../lib/clang/3.5.0/include/stdint.h" 2 3 4
# 73 "/usr/include/sys/resource.h" 2 3 4




/* [XSI] The timeval structure shall be defined as described in
 * <sys/time.h>
 */

# 1 "/usr/include/sys/_types/_timeval.h" 1 3 4
/*
 * Copyright (c) 2003-2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */


struct timeval
{
 __darwin_time_t tv_sec; /* seconds */
 __darwin_suseconds_t tv_usec; /* and microseconds */
};
# 81 "/usr/include/sys/resource.h" 2 3 4

/* The id_t type shall be defined as described in <sys/types.h> */



/*
 * Resource limit type (low 63 bits, excluding the sign bit)
 */
typedef __uint64_t rlim_t;


/*****
 * PRIORITY
 */

/*
 * Possible values of the first parameter to getpriority()/setpriority(),
 * used to indicate the type of the second parameter.
 */
# 109 "/usr/include/sys/resource.h" 3 4
/*
 * Range limitations for the value of the third parameter to setpriority().
 */



/* 
 * use PRIO_DARWIN_BG to set the current thread into "background" state
 * which lowers CPU, disk IO, and networking priorites until thread terminates
 * or "background" state is revoked
 */


/*
 * use PRIO_DARWIN_NONUI to restrict a process's ability to make calls to
 * the GPU. (deprecated)
 */






/*****
 * RESOURCE USAGE
 */

/*
 * Possible values of the first parameter to getrusage(), used to indicate
 * the scope of the information to be returned.
 */



/*
 * A structure representing an accounting of resource utilization.  The
 * address of an instance of this structure is the second parameter to
 * getrusage().
 *
 * Note: All values other than ru_utime and ru_stime are implementaiton
 *       defined and subject to change in a future release.  Their use
 *       is discouraged for standards compliant programs.
 */
struct rusage {
 struct timeval ru_utime; /* user time used (PL) */
 struct timeval ru_stime; /* system time used (PL) */



 /*
	 * Informational aliases for source compatibility with programs
	 * that need more information than that provided by standards,
	 * and which do not mind being OS-dependent.
	 */
 long ru_maxrss; /* max resident set size (PL) */

 long ru_ixrss; /* integral shared memory size (NU) */
 long ru_idrss; /* integral unshared data (NU)  */
 long ru_isrss; /* integral unshared stack (NU) */
 long ru_minflt; /* page reclaims (NU) */
 long ru_majflt; /* page faults (NU) */
 long ru_nswap; /* swaps (NU) */
 long ru_inblock; /* block input operations (atomic) */
 long ru_oublock; /* block output operations (atomic) */
 long ru_msgsnd; /* messages sent (atomic) */
 long ru_msgrcv; /* messages received (atomic) */
 long ru_nsignals; /* signals received (atomic) */
 long ru_nvcsw; /* voluntary context switches (atomic) */
 long ru_nivcsw; /* involuntary " */


};


/*
 * Flavors for proc_pid_rusage().
 */






typedef void *rusage_info_t;

struct rusage_info_v0 {
 uint8_t ri_uuid[16];
 uint64_t ri_user_time;
 uint64_t ri_system_time;
 uint64_t ri_pkg_idle_wkups;
 uint64_t ri_interrupt_wkups;
 uint64_t ri_pageins;
 uint64_t ri_wired_size;
 uint64_t ri_resident_size;
 uint64_t ri_phys_footprint;
 uint64_t ri_proc_start_abstime;
 uint64_t ri_proc_exit_abstime;
};

struct rusage_info_v1 {
 uint8_t ri_uuid[16];
 uint64_t ri_user_time;
 uint64_t ri_system_time;
 uint64_t ri_pkg_idle_wkups;
 uint64_t ri_interrupt_wkups;
 uint64_t ri_pageins;
 uint64_t ri_wired_size;
 uint64_t ri_resident_size;
 uint64_t ri_phys_footprint;
 uint64_t ri_proc_start_abstime;
 uint64_t ri_proc_exit_abstime;
 uint64_t ri_child_user_time;
 uint64_t ri_child_system_time;
 uint64_t ri_child_pkg_idle_wkups;
 uint64_t ri_child_interrupt_wkups;
 uint64_t ri_child_pageins;
 uint64_t ri_child_elapsed_abstime;
};

struct rusage_info_v2 {
 uint8_t ri_uuid[16];
 uint64_t ri_user_time;
 uint64_t ri_system_time;
 uint64_t ri_pkg_idle_wkups;
 uint64_t ri_interrupt_wkups;
 uint64_t ri_pageins;
 uint64_t ri_wired_size;
 uint64_t ri_resident_size;
 uint64_t ri_phys_footprint;
 uint64_t ri_proc_start_abstime;
 uint64_t ri_proc_exit_abstime;
 uint64_t ri_child_user_time;
 uint64_t ri_child_system_time;
 uint64_t ri_child_pkg_idle_wkups;
 uint64_t ri_child_interrupt_wkups;
 uint64_t ri_child_pageins;
 uint64_t ri_child_elapsed_abstime;
 uint64_t ri_diskio_bytesread;
 uint64_t ri_diskio_byteswritten;
};

struct rusage_info_v3 {
 uint8_t ri_uuid[16];
 uint64_t ri_user_time;
 uint64_t ri_system_time;
 uint64_t ri_pkg_idle_wkups;
 uint64_t ri_interrupt_wkups;
 uint64_t ri_pageins;
 uint64_t ri_wired_size;
 uint64_t ri_resident_size;
 uint64_t ri_phys_footprint;
 uint64_t ri_proc_start_abstime;
 uint64_t ri_proc_exit_abstime;
 uint64_t ri_child_user_time;
 uint64_t ri_child_system_time;
 uint64_t ri_child_pkg_idle_wkups;
 uint64_t ri_child_interrupt_wkups;
 uint64_t ri_child_pageins;
 uint64_t ri_child_elapsed_abstime;
 uint64_t ri_diskio_bytesread;
 uint64_t ri_diskio_byteswritten;
 uint64_t ri_cpu_time_qos_default;
 uint64_t ri_cpu_time_qos_maintenance;
 uint64_t ri_cpu_time_qos_background;
 uint64_t ri_cpu_time_qos_utility;
 uint64_t ri_cpu_time_qos_legacy;
 uint64_t ri_cpu_time_qos_user_initiated;
 uint64_t ri_cpu_time_qos_user_interactive;
 uint64_t ri_billed_system_time;
 uint64_t ri_serviced_system_time;
};

typedef struct rusage_info_v3 rusage_info_current;





/*****
 * RESOURCE LIMITS
 */

/*
 * Symbolic constants for resource limits; since all limits are representable
 * as a type rlim_t, we are permitted to define RLIM_SAVED_* in terms of
 * RLIM_INFINITY.
 */




/*
 * Possible values of the first parameter to getrlimit()/setrlimit(), to
 * indicate for which resource the operation is being performed.
 */
# 321 "/usr/include/sys/resource.h" 3 4
/*
 * A structure representing a resource limit.  The address of an instance
 * of this structure is the second parameter to getrlimit()/setrlimit().
 */
struct rlimit {
 rlim_t rlim_cur; /* current (soft) limit */
 rlim_t rlim_max; /* maximum value for rlim_cur */
};


/*
 * proc_rlimit_control()
 *
 * Resource limit flavors
 */




/*
 * Flags for wakeups monitor control.
 */





/*
 * Flags for CPU usage monitor control.
 */


struct proc_rlimit_control_wakeupmon {
 uint32_t wm_flags;
 int32_t wm_rate;
};

/* I/O type */


/* scope */




/* I/O Priority */







/* compatibility with older names */







extern "C" {
int getpriority(int, id_t);

int getiopolicy_np(int, int) __attribute__((availability(macosx,introduced=10.5)));

int getrlimit(int, struct rlimit *) __asm("_" "getrlimit" );
int getrusage(int, struct rusage *);
int setpriority(int, id_t, int);

int setiopolicy_np(int, int, int) __attribute__((availability(macosx,introduced=10.5)));

int setrlimit(int, const struct rlimit *) __asm("_" "setrlimit" );
}
# 111 "/usr/include/sys/wait.h" 2 3 4

/*
 * Option bits for the third argument of wait4.  WNOHANG causes the
 * wait to not hang if there are no stopped or terminated processes, rather
 * returning an error indication in this case (pid==0).  WUNTRACED
 * indicates that the caller should receive status about untraced children
 * which stop due to signals.  If children are stopped and a wait without
 * this option is done, it is as though they were still running... nothing
 * about them is returned.
 */



/*
 * Macros to test the exit status returned by wait
 * and extract the relevant values.
 */







/* These macros are permited, as they are in the implementation namespace */



/*
 * [XSI] The <sys/wait.h> header shall define the following macros for
 * analysis of process status values
 */





/* 0x13 == SIGCONT */
# 162 "/usr/include/sys/wait.h" 3 4
/*
 * [XSI] The following symbolic constants shall be defined as possible
 * values for the fourth argument to waitid().
 */
/* WNOHANG already defined for wait4() */
/* WUNTRACED defined for wait4() but not for waitid() */


/* waitid() parameter */







/* POSIX extensions and 4.2/4.3 compatability: */

/*
 * Tokens for special values of the "pid" parameter to wait4.
 */




# 1 "/usr/include/machine/endian.h" 1 3 4
/*
 * Copyright (c) 2000-2007 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
/*
 * Copyright 1995 NeXT Computer, Inc. All rights reserved.
 */





# 1 "/usr/include/i386/endian.h" 1 3 4
/*
 * Copyright (c) 2000-2002 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
/*
 * Copyright 1995 NeXT Computer, Inc. All rights reserved.
 */
/*
 * Copyright (c) 1987, 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)endian.h	8.1 (Berkeley) 6/11/93
 */





/*
 * Define _NOQUAD if the compiler does NOT support 64-bit integers.
 */
/* #define _NOQUAD */

/*
 * Define the order of 32-bit words in 64-bit words.
 */



/*
 * Definitions for byte order, according to byte significance from low
 * address to high.
 */
# 99 "/usr/include/i386/endian.h" 3 4
# 1 "/usr/include/sys/_endian.h" 1 3 4
/*
 * Copyright (c) 2004, 2006 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */

/*
 * Copyright (c) 1995 NeXT Computer, Inc. All rights reserved.
 * Copyright (c) 2000-2002 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
/*
 * Copyright (c) 1987, 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */






/*
 * Macros for network/external number representation conversion.
 */
# 130 "/usr/include/sys/_endian.h" 3 4
# 1 "/usr/include/libkern/_OSByteOrder.h" 1 3 4
/*
 * Copyright (c) 2006 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */




/*
 * This header is normally included from <libkern/OSByteOrder.h>.  However,
 * <sys/_endian.h> also includes this in the case of little-endian
 * architectures, so that we can map OSByteOrder routines to the hton* and ntoh*
 * macros.  This results in the asymmetry below; we only include
 * <libkern/arch/_OSByteOrder.h> for little-endian architectures.
 */



/* Macros for swapping constant values in the preprocessing stage. */
# 66 "/usr/include/libkern/_OSByteOrder.h" 3 4
# 1 "/usr/include/libkern/i386/_OSByteOrder.h" 1 3 4
/*
 * Copyright (c) 2006-2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
# 42 "/usr/include/libkern/i386/_OSByteOrder.h" 3 4
/* Generic byte swapping functions. */

static inline
__uint16_t
_OSSwapInt16(
    __uint16_t _data
)
{
    return ((__uint16_t)((_data << 8) | (_data >> 8)));
}

static inline
__uint32_t
_OSSwapInt32(
    __uint32_t _data
)
{

    return __builtin_bswap32(_data);




}


static inline
__uint64_t
_OSSwapInt64(
    __uint64_t _data
)
{
    return __builtin_bswap64(_data);
}
# 67 "/usr/include/libkern/_OSByteOrder.h" 2 3 4
# 131 "/usr/include/sys/_endian.h" 2 3 4
# 100 "/usr/include/i386/endian.h" 2 3 4
# 36 "/usr/include/machine/endian.h" 2 3 4
# 187 "/usr/include/sys/wait.h" 2 3 4

/*
 * Deprecated:
 * Structure of the information in the status word returned by wait4.
 * If w_stopval==_WSTOPPED, then the second structure describes
 * the information returned, else the first.
 */
union wait {
 int w_status; /* used in syscall */
 /*
	 * Terminated process status.
	 */
 struct {

  unsigned int w_Termsig:7, /* termination signal */
    w_Coredump:1, /* core dump indicator */
    w_Retcode:8, /* exit code if w_termsig==0 */
    w_Filler:16; /* upper bits filler */







 } w_T;
 /*
	 * Stopped process status.  Returned
	 * only for traced children unless requested
	 * with the WUNTRACED option bit.
	 */
 struct {

  unsigned int w_Stopval:8, /* == W_STOPPED if stopped */
    w_Stopsig:8, /* signal that stopped us */
    w_Filler:16; /* upper bits filler */






 } w_S;
};
# 247 "/usr/include/sys/wait.h" 3 4
extern "C" {
pid_t wait(int *) __asm("_" "wait" );
pid_t waitpid(pid_t, int *, int) __asm("_" "waitpid" );

int waitid(idtype_t, id_t, siginfo_t *, int) __asm("_" "waitid" );


pid_t wait3(int *, int, struct rusage *);
pid_t wait4(pid_t, int *, int, struct rusage *);

}
# 66 "/usr/include/stdlib.h" 2 3 4

# 1 "/usr/include/alloca.h" 1 3 4
/*
 * Copyright (c) 2003 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
# 31 "/usr/include/alloca.h" 3 4
extern "C" {
void *alloca(size_t); /* built-in for gcc */
}


/* built-in for gcc 3 */
# 68 "/usr/include/stdlib.h" 2 3 4



/* DO NOT REMOVE THIS COMMENT: fixincludes needs to see:
 * _GCC_SIZE_T */




# 1 "/usr/include/sys/_types/_ct_rune_t.h" 1 3 4
/*
 * Copyright (c) 2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */



typedef __darwin_ct_rune_t ct_rune_t;
# 77 "/usr/include/stdlib.h" 2 3 4
# 1 "/usr/include/sys/_types/_rune_t.h" 1 3 4
/*
 * Copyright (c) 2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */


typedef __darwin_rune_t rune_t;
# 78 "/usr/include/stdlib.h" 2 3 4


# 1 "/usr/include/sys/_types/_wchar_t.h" 1 3 4
/*
 * Copyright (c) 2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */

/* wchar_t is a built-in type in C++ */
# 81 "/usr/include/stdlib.h" 2 3 4

typedef struct {
 int quot; /* quotient */
 int rem; /* remainder */
} div_t;

typedef struct {
 long quot; /* quotient */
 long rem; /* remainder */
} ldiv_t;


typedef struct {
 long long quot;
 long long rem;
} lldiv_t;



# 1 "/usr/include/sys/_types/_null.h" 1 3 4
/*
 * Copyright (c) 2003-2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
# 100 "/usr/include/stdlib.h" 2 3 4
# 117 "/usr/include/stdlib.h" 3 4
extern int __mb_cur_max;
# 127 "/usr/include/stdlib.h" 3 4
extern "C" {
void abort(void) __attribute__((noreturn));
int abs(int) __attribute__((const));
int atexit(void (*)(void));
double atof(const char *);
int atoi(const char *);
long atol(const char *);

long long
  atoll(const char *);

void *bsearch(const void *, const void *, size_t,
     size_t, int (*)(const void *, const void *));
void *calloc(size_t, size_t);
div_t div(int, int) __attribute__((const));
void exit(int) __attribute__((noreturn));
void free(void *);
char *getenv(const char *);
long labs(long) __attribute__((const));
ldiv_t ldiv(long, long) __attribute__((const));

long long
  llabs(long long);
lldiv_t lldiv(long long, long long);

void *malloc(size_t);
int mblen(const char *, size_t);
size_t mbstowcs(wchar_t * , const char * , size_t);
int mbtowc(wchar_t * , const char * , size_t);
int posix_memalign(void **, size_t, size_t) __attribute__((availability(macosx,introduced=10.6)));
void qsort(void *, size_t, size_t,
     int (*)(const void *, const void *));
int rand(void);
void *realloc(void *, size_t);
void srand(unsigned);
double strtod(const char *, char **) __asm("_" "strtod" );
float strtof(const char *, char **) __asm("_" "strtof" );
long strtol(const char *, char **, int);
long double
  strtold(const char *, char **);

long long
  strtoll(const char *, char **, int);

unsigned long
  strtoul(const char *, char **, int);

unsigned long long
  strtoull(const char *, char **, int);

int system(const char *) __asm("_" "system" ) __attribute__((availability(macosx,introduced=10.0)));
size_t wcstombs(char * , const wchar_t * , size_t);
int wctomb(char *, wchar_t);


void _Exit(int) __attribute__((noreturn));
long a64l(const char *);
double drand48(void);
char *ecvt(double, int, int *, int *); /* LEGACY */
double erand48(unsigned short[3]);
char *fcvt(double, int, int *, int *); /* LEGACY */
char *gcvt(double, int, char *); /* LEGACY */
int getsubopt(char **, char * const *, char **);
int grantpt(int);

char *initstate(unsigned, char *, size_t); /* no  __DARWIN_ALIAS needed */



long jrand48(unsigned short[3]);
char *l64a(long);
void lcong48(unsigned short[7]);
long lrand48(void);
char *mktemp(char *);
int mkstemp(char *);
long mrand48(void);
long nrand48(unsigned short[3]);
int posix_openpt(int);
char *ptsname(int);
int putenv(char *) __asm("_" "putenv" );
long random(void);
int rand_r(unsigned *);

char *realpath(const char * , char * ) __asm("_" "realpath" "$DARWIN_EXTSN");



unsigned short
 *seed48(unsigned short[3]);
int setenv(const char *, const char *, int) __asm("_" "setenv" );

void setkey(const char *) __asm("_" "setkey" );



char *setstate(const char *);
void srand48(long);

void srandom(unsigned);



int unlockpt(int);

int unsetenv(const char *) __asm("_" "unsetenv" );







# 1 "/usr/include/machine/types.h" 1 3 4
/*
 * Copyright (c) 2000-2007 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
/*
 * Copyright 1995 NeXT Computer, Inc. All rights reserved.
 */





# 1 "/usr/include/i386/types.h" 1 3 4
/*
 * Copyright (c) 2000-2008 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
/*
 * Copyright 1995 NeXT Computer, Inc. All rights reserved.
 */
/*
 * Copyright (c) 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)types.h	8.3 (Berkeley) 1/5/94
 */







/*
 * Basic integral types.  Omit the typedef if
 * not possible for a machine/compiler combination.
 */





typedef unsigned char u_int8_t;
typedef unsigned short u_int16_t;
typedef unsigned int u_int32_t;
typedef unsigned long long u_int64_t;


typedef int64_t register_t;
# 96 "/usr/include/i386/types.h" 3 4
/* These types are used for reserving the largest possible size. */
typedef u_int64_t user_addr_t;
typedef u_int64_t user_size_t;
typedef int64_t user_ssize_t;
typedef int64_t user_long_t;
typedef u_int64_t user_ulong_t;
typedef int64_t user_time_t;
typedef int64_t user_off_t;






/* This defines the size of syscall arguments after copying into the kernel: */
typedef u_int64_t syscall_arg_t;
# 36 "/usr/include/machine/types.h" 2 3 4
# 239 "/usr/include/stdlib.h" 2 3 4

# 1 "/usr/include/sys/_types/_dev_t.h" 1 3 4
/*
 * Copyright (c) 2003-2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */


typedef __darwin_dev_t dev_t; /* device number */
# 241 "/usr/include/stdlib.h" 2 3 4
# 1 "/usr/include/sys/_types/_mode_t.h" 1 3 4
/*
 * Copyright (c) 2003-2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */


typedef __darwin_mode_t mode_t;
# 242 "/usr/include/stdlib.h" 2 3 4

u_int32_t arc4random(void);
void arc4random_addrandom(unsigned char * /*dat*/, int /*datlen*/);
void arc4random_buf(void * /*buf*/, size_t /*nbytes*/) __attribute__((availability(macosx,introduced=10.7)));
void arc4random_stir(void);
u_int32_t
  arc4random_uniform(u_int32_t /*upper_bound*/) __attribute__((availability(macosx,introduced=10.7)));

int atexit_b(void (^)(void)) __attribute__((availability(macosx,introduced=10.6)));
void *bsearch_b(const void *, const void *, size_t,
     size_t, int (^)(const void *, const void *)) __attribute__((availability(macosx,introduced=10.6)));


  /* getcap(3) functions */
char *cgetcap(char *, const char *, int);
int cgetclose(void);
int cgetent(char **, char **, const char *);
int cgetfirst(char **, char **);
int cgetmatch(const char *, const char *);
int cgetnext(char **, char **);
int cgetnum(char *, const char *, long *);
int cgetset(const char *);
int cgetstr(char *, const char *, char **);
int cgetustr(char *, const char *, char **);

int daemon(int, int) __asm("_" "daemon" "$1050") __attribute__((availability(macosx,introduced=10.0,deprecated=10.5)));
char *devname(dev_t, mode_t);
char *devname_r(dev_t, mode_t, char *buf, int len);
char *getbsize(int *, long *);
int getloadavg(double [], int);
const char
 *getprogname(void);

int heapsort(void *, size_t, size_t,
     int (*)(const void *, const void *));

int heapsort_b(void *, size_t, size_t,
     int (^)(const void *, const void *)) __attribute__((availability(macosx,introduced=10.6)));

int mergesort(void *, size_t, size_t,
     int (*)(const void *, const void *));

int mergesort_b(void *, size_t, size_t,
     int (^)(const void *, const void *)) __attribute__((availability(macosx,introduced=10.6)));

void psort(void *, size_t, size_t,
     int (*)(const void *, const void *)) __attribute__((availability(macosx,introduced=10.6)));

void psort_b(void *, size_t, size_t,
     int (^)(const void *, const void *)) __attribute__((availability(macosx,introduced=10.6)));

void psort_r(void *, size_t, size_t, void *,
     int (*)(void *, const void *, const void *)) __attribute__((availability(macosx,introduced=10.6)));

void qsort_b(void *, size_t, size_t,
     int (^)(const void *, const void *)) __attribute__((availability(macosx,introduced=10.6)));

void qsort_r(void *, size_t, size_t, void *,
     int (*)(void *, const void *, const void *));
int radixsort(const unsigned char **, int, const unsigned char *,
     unsigned);
void setprogname(const char *);
int sradixsort(const unsigned char **, int, const unsigned char *,
     unsigned);
void sranddev(void);
void srandomdev(void);
void *reallocf(void *, size_t);

long long
  strtoq(const char *, char **, int);
unsigned long long
  strtouq(const char *, char **, int);

extern char *suboptarg; /* getsubopt(3) external variable */
void *valloc(size_t);


/* Poison the following routines if -fshort-wchar is set */



}
# 2 "tessapi-quality.cpp" 2
# 1 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/iostream" 1 3
// -*- C++ -*-
//===--------------------------- iostream ---------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is dual licensed under the MIT and the University of Illinois Open
// Source Licenses. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//




/*
    iostream synopsis

#include <ios>
#include <streambuf>
#include <istream>
#include <ostream>

namespace std {

extern istream cin;
extern ostream cout;
extern ostream cerr;
extern ostream clog;
extern wistream wcin;
extern wostream wcout;
extern wostream wcerr;
extern wostream wclog;

}  // std

*/


# 1 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/__config" 1 3
// -*- C++ -*-
//===--------------------------- __config ---------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is dual licensed under the MIT and the University of Illinois Open
// Source Licenses. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
# 16 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/__config" 3
# 227 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/__config" 3
typedef __char16_t char16_t;
typedef __char32_t char32_t;
# 302 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/__config" 3
// Objective-C++ features (opt-in)
# 355 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/__config" 3
// Inline namespaces are available in Clang regardless of C++ dialect.




namespace std {
  inline namespace __1 {
  }
}
# 537 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/__config" 3
template <bool> struct __static_assert_test;
template <> struct __static_assert_test<true> {};
template <unsigned> struct __static_assert_check {};
# 677 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/__config" 3
// Try to find out if RTTI is disabled.
// g++ and cl.exe have RTTI on by default and define a macro when it is.
// g++ only defines the macro in 4.3.2 and onwards.
# 38 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/iostream" 2 3
# 1 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/ios" 1 3
// -*- C++ -*-
//===---------------------------- ios -------------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is dual licensed under the MIT and the University of Illinois Open
// Source Licenses. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//




/*
    ios synopsis

#include <iosfwd>

namespace std
{

typedef OFF_T streamoff;
typedef SZ_T streamsize;
template <class stateT> class fpos;

class ios_base
{
public:
    class failure;

    typedef T1 fmtflags;
    static constexpr fmtflags boolalpha;
    static constexpr fmtflags dec;
    static constexpr fmtflags fixed;
    static constexpr fmtflags hex;
    static constexpr fmtflags internal;
    static constexpr fmtflags left;
    static constexpr fmtflags oct;
    static constexpr fmtflags right;
    static constexpr fmtflags scientific;
    static constexpr fmtflags showbase;
    static constexpr fmtflags showpoint;
    static constexpr fmtflags showpos;
    static constexpr fmtflags skipws;
    static constexpr fmtflags unitbuf;
    static constexpr fmtflags uppercase;
    static constexpr fmtflags adjustfield;
    static constexpr fmtflags basefield;
    static constexpr fmtflags floatfield;

    typedef T2 iostate;
    static constexpr iostate badbit;
    static constexpr iostate eofbit;
    static constexpr iostate failbit;
    static constexpr iostate goodbit;

    typedef T3 openmode;
    static constexpr openmode app;
    static constexpr openmode ate;
    static constexpr openmode binary;
    static constexpr openmode in;
    static constexpr openmode out;
    static constexpr openmode trunc;

    typedef T4 seekdir;
    static constexpr seekdir beg;
    static constexpr seekdir cur;
    static constexpr seekdir end;

    class Init;

    // 27.5.2.2 fmtflags state:
    fmtflags flags() const;
    fmtflags flags(fmtflags fmtfl);
    fmtflags setf(fmtflags fmtfl);
    fmtflags setf(fmtflags fmtfl, fmtflags mask);
    void unsetf(fmtflags mask);

    streamsize precision() const;
    streamsize precision(streamsize prec);
    streamsize width() const;
    streamsize width(streamsize wide);

    // 27.5.2.3 locales:
    locale imbue(const locale& loc);
    locale getloc() const;

    // 27.5.2.5 storage:
    static int xalloc();
    long& iword(int index);
    void*& pword(int index);

    // destructor
    virtual ~ios_base();

    // 27.5.2.6 callbacks;
    enum event { erase_event, imbue_event, copyfmt_event };
    typedef void (*event_callback)(event, ios_base&, int index);
    void register_callback(event_callback fn, int index);

    ios_base(const ios_base&) = delete;
    ios_base& operator=(const ios_base&) = delete;

    static bool sync_with_stdio(bool sync = true);

protected:
    ios_base();
};

template <class charT, class traits = char_traits<charT> >
class basic_ios
    : public ios_base
{
public:
    // types:
    typedef charT char_type;
    typedef typename traits::int_type int_type;
    typedef typename traits::pos_type pos_type;
    typedef typename traits::off_type off_type;
    typedef traits traits_type;

    operator unspecified-bool-type() const;
    bool operator!() const;
    iostate rdstate() const;
    void clear(iostate state = goodbit);
    void setstate(iostate state);
    bool good() const;
    bool eof() const;
    bool fail() const;
    bool bad() const;

    iostate exceptions() const;
    void exceptions(iostate except);

    // 27.5.4.1 Constructor/destructor:
    explicit basic_ios(basic_streambuf<charT,traits>* sb);
    virtual ~basic_ios();

    // 27.5.4.2 Members:
    basic_ostream<charT,traits>* tie() const;
    basic_ostream<charT,traits>* tie(basic_ostream<charT,traits>* tiestr);

    basic_streambuf<charT,traits>* rdbuf() const;
    basic_streambuf<charT,traits>* rdbuf(basic_streambuf<charT,traits>* sb);

    basic_ios& copyfmt(const basic_ios& rhs);

    char_type fill() const;
    char_type fill(char_type ch);

    locale imbue(const locale& loc);

    char narrow(char_type c, char dfault) const;
    char_type widen(char c) const;

    basic_ios(const basic_ios& ) = delete;
    basic_ios& operator=(const basic_ios&) = delete;

protected:
    basic_ios();
    void init(basic_streambuf<charT,traits>* sb);
    void move(basic_ios& rhs);
    void swap(basic_ios& rhs) noexcept;
    void set_rdbuf(basic_streambuf<charT, traits>* sb);
};

// 27.5.5, manipulators:
ios_base& boolalpha (ios_base& str);
ios_base& noboolalpha(ios_base& str);
ios_base& showbase (ios_base& str);
ios_base& noshowbase (ios_base& str);
ios_base& showpoint (ios_base& str);
ios_base& noshowpoint(ios_base& str);
ios_base& showpos (ios_base& str);
ios_base& noshowpos (ios_base& str);
ios_base& skipws (ios_base& str);
ios_base& noskipws (ios_base& str);
ios_base& uppercase (ios_base& str);
ios_base& nouppercase(ios_base& str);
ios_base& unitbuf (ios_base& str);
ios_base& nounitbuf (ios_base& str);

// 27.5.5.2 adjustfield:
ios_base& internal (ios_base& str);
ios_base& left (ios_base& str);
ios_base& right (ios_base& str);

// 27.5.5.3 basefield:
ios_base& dec (ios_base& str);
ios_base& hex (ios_base& str);
ios_base& oct (ios_base& str);

// 27.5.5.4 floatfield:
ios_base& fixed (ios_base& str);
ios_base& scientific (ios_base& str);
ios_base& hexfloat (ios_base& str);
ios_base& defaultfloat(ios_base& str);

// 27.5.5.5 error reporting:
enum class io_errc
{
    stream = 1
};

concept_map ErrorCodeEnum<io_errc> { };
error_code make_error_code(io_errc e) noexcept; 
error_condition make_error_condition(io_errc e) noexcept; 
storage-class-specifier const error_category& iostream_category() noexcept;

}  // std

*/



# 1 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/iosfwd" 1 3
// -*- C++ -*-
//===--------------------------- iosfwd -----------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is dual licensed under the MIT and the University of Illinois Open
// Source Licenses. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//




/*
    iosfwd synopsis

namespace std
{

template<class charT> struct char_traits;
template<class T>     class allocator;

class ios_base;
template <class charT, class traits = char_traits<charT> > class basic_ios;

template <class charT, class traits = char_traits<charT> > class basic_streambuf;
template <class charT, class traits = char_traits<charT> > class basic_istream;
template <class charT, class traits = char_traits<charT> > class basic_ostream;
template <class charT, class traits = char_traits<charT> > class basic_iostream;

template <class charT, class traits = char_traits<charT>, class Allocator = allocator<charT> >
    class basic_stringbuf;
template <class charT, class traits = char_traits<charT>, class Allocator = allocator<charT> >
    class basic_istringstream;
template <class charT, class traits = char_traits<charT>, class Allocator = allocator<charT> >
    class basic_ostringstream;
template <class charT, class traits = char_traits<charT>, class Allocator = allocator<charT> >
    class basic_stringstream;

template <class charT, class traits = char_traits<charT> > class basic_filebuf;
template <class charT, class traits = char_traits<charT> > class basic_ifstream;
template <class charT, class traits = char_traits<charT> > class basic_ofstream;
template <class charT, class traits = char_traits<charT> > class basic_fstream;

template <class charT, class traits = char_traits<charT> > class istreambuf_iterator;
template <class charT, class traits = char_traits<charT> > class ostreambuf_iterator;

typedef basic_ios<char>              ios;
typedef basic_ios<wchar_t>           wios;

typedef basic_streambuf<char>        streambuf;
typedef basic_istream<char>          istream;
typedef basic_ostream<char>          ostream;
typedef basic_iostream<char>         iostream;

typedef basic_stringbuf<char>        stringbuf;
typedef basic_istringstream<char>    istringstream;
typedef basic_ostringstream<char>    ostringstream;
typedef basic_stringstream<char>     stringstream;

typedef basic_filebuf<char>          filebuf;
typedef basic_ifstream<char>         ifstream;
typedef basic_ofstream<char>         ofstream;
typedef basic_fstream<char>          fstream;

typedef basic_streambuf<wchar_t>     wstreambuf;
typedef basic_istream<wchar_t>       wistream;
typedef basic_ostream<wchar_t>       wostream;
typedef basic_iostream<wchar_t>      wiostream;

typedef basic_stringbuf<wchar_t>     wstringbuf;
typedef basic_istringstream<wchar_t> wistringstream;
typedef basic_ostringstream<wchar_t> wostringstream;
typedef basic_stringstream<wchar_t>  wstringstream;

typedef basic_filebuf<wchar_t>       wfilebuf;
typedef basic_ifstream<wchar_t>      wifstream;
typedef basic_ofstream<wchar_t>      wofstream;
typedef basic_fstream<wchar_t>       wfstream;

template <class state> class fpos;
typedef fpos<char_traits<char>::state_type>    streampos;
typedef fpos<char_traits<wchar_t>::state_type> wstreampos;

}  // std

*/



# 1 "/usr/include/wchar.h" 1 3 4
/*-
 * Copyright (c)1999 Citrus Project,
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * $FreeBSD: /repoman/r/ncvs/src/include/wchar.h,v 1.34 2003/03/13 06:29:53 tjr Exp $
 */

/*-
 * Copyright (c) 1999, 2000 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Julian Coleman.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 *	$NetBSD: wchar.h,v 1.8 2000/12/22 05:31:42 itojun Exp $
 */
# 76 "/usr/include/wchar.h" 3 4
# 1 "/usr/include/sys/_types/_mbstate_t.h" 1 3 4
/*
 * Copyright (c) 2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */



typedef __darwin_mbstate_t mbstate_t;
# 77 "/usr/include/wchar.h" 2 3 4


# 1 "/usr/include/sys/_types/_wchar_t.h" 1 3 4
/*
 * Copyright (c) 2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */

/* wchar_t is a built-in type in C++ */
# 80 "/usr/include/wchar.h" 2 3 4
# 89 "/usr/include/wchar.h" 3 4
# 1 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../lib/clang/3.5.0/include/stdarg.h" 1 3 4
/*===---- stdarg.h - Variable argument handling ----------------------------===
 *
 * Copyright (c) 2008 Eli Friedman
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 *===-----------------------------------------------------------------------===
 */





typedef __builtin_va_list va_list;






/* GCC always defines __va_copy, but does not define va_copy unless in c99 mode
 * or -ansi is not specified, since it was not part of C90.
 */






/* Hack required to make standard headers work, at least on Ubuntu */



typedef __builtin_va_list __gnuc_va_list;
# 90 "/usr/include/wchar.h" 2 3 4
# 1 "/usr/include/stdio.h" 1 3 4
/*
 * Copyright (c) 2000, 2005, 2007, 2009, 2010 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_LICENSE_HEADER_END@
 */
/*-
 * Copyright (c) 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Chris Torek.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)stdio.h	8.5 (Berkeley) 4/29/95
 */
# 69 "/usr/include/stdio.h" 3 4
/* DO NOT REMOVE THIS COMMENT: fixincludes needs to see:
 * __gnuc_va_list and include <stdarg.h> */

# 1 "/usr/include/sys/_types/_va_list.h" 1 3 4
/*
 * Copyright (c) 2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */



typedef __darwin_va_list va_list;
# 72 "/usr/include/stdio.h" 2 3 4



# 1 "/usr/include/sys/stdio.h" 1 3 4
/*
 * Copyright (c) 2013 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
# 37 "/usr/include/sys/stdio.h" 3 4
extern "C" {

int renameat(int, const char *, int, const char *) __attribute__((availability(macosx,introduced=10.10)));

}
# 76 "/usr/include/stdio.h" 2 3 4

typedef __darwin_off_t fpos_t;



/*
 * NB: to fit things in six character monocase externals, the stdio
 * code uses the prefix `__s' for stdio objects, typically followed
 * by a three-character attempt at a mnemonic.
 */

/* stdio buffers */
struct __sbuf {
 unsigned char *_base;
 int _size;
};

/* hold a buncha junk that would grow the ABI */
struct __sFILEX;

/*
 * stdio state variables.
 *
 * The following always hold:
 *
 *	if (_flags&(__SLBF|__SWR)) == (__SLBF|__SWR),
 *		_lbfsize is -_bf._size, else _lbfsize is 0
 *	if _flags&__SRD, _w is 0
 *	if _flags&__SWR, _r is 0
 *
 * This ensures that the getc and putc macros (or inline functions) never
 * try to write or read from a file that is in `read' or `write' mode.
 * (Moreover, they can, and do, automatically switch from read mode to
 * write mode, and back, on "r+" and "w+" files.)
 *
 * _lbfsize is used only to make the inline line-buffered output stream
 * code as compact as possible.
 *
 * _ub, _up, and _ur are used when ungetc() pushes back more characters
 * than fit in the current _bf, or when ungetc() pushes back a character
 * that does not match the previous one in _bf.  When this happens,
 * _ub._base becomes non-nil (i.e., a stream has ungetc() data iff
 * _ub._base!=NULL) and _up and _ur save the current values of _p and _r.
 *
 * NB: see WARNING above before changing the layout of this structure!
 */
typedef struct __sFILE {
 unsigned char *_p; /* current position in (some) buffer */
 int _r; /* read space left for getc() */
 int _w; /* write space left for putc() */
 short _flags; /* flags, below; this FILE is free if 0 */
 short _file; /* fileno, if Unix descriptor, else -1 */
 struct __sbuf _bf; /* the buffer (at least 1 byte, if !NULL) */
 int _lbfsize; /* 0 or -_bf._size, for inline putc */

 /* operations */
 void *_cookie; /* cookie passed to io functions */
 int (*_close)(void *);
 int (*_read) (void *, char *, int);
 fpos_t (*_seek) (void *, fpos_t, int);
 int (*_write)(void *, const char *, int);

 /* separate buffer for long sequences of ungetc() */
 struct __sbuf _ub; /* ungetc buffer */
 struct __sFILEX *_extra; /* additions to FILE to not break ABI */
 int _ur; /* saved _r when _r is counting ungetc data */

 /* tricks to meet minimum requirements even when malloc() fails */
 unsigned char _ubuf[3]; /* guarantee an ungetc() buffer */
 unsigned char _nbuf[1]; /* guarantee a getc() buffer */

 /* separate buffer for fgetln() when line crosses buffer boundary */
 struct __sbuf _lb; /* buffer for fgetln() */

 /* Unix stdio files get aligned to block boundaries on fseek() */
 int _blksize; /* stat.st_blksize (may be != _bf._size) */
 fpos_t _offset; /* current lseek offset (see WARNING) */
} FILE;

extern "C" {
extern FILE *__stdinp;
extern FILE *__stdoutp;
extern FILE *__stderrp;
}





 /* RD and WR are never simultaneously asserted */
# 179 "/usr/include/stdio.h" 3 4
/*
 * The following three definitions are for ANSI C, which took them
 * from System V, which brilliantly took internal interface macros and
 * made them official arguments to setvbuf(), without renaming them.
 * Hence, these ugly _IOxxx names are *supposed* to appear in user code.
 *
 * Although numbered as their counterparts above, the implementation
 * does not rely on this.
 */







    /* must be == _POSIX_STREAM_MAX <limits.h> */



/* System V/ANSI C; this is the wrong way to do this, do *not* use these. */
# 228 "/usr/include/stdio.h" 3 4
/* ANSI-C */

extern "C" {
void clearerr(FILE *);
int fclose(FILE *);
int feof(FILE *);
int ferror(FILE *);
int fflush(FILE *);
int fgetc(FILE *);
int fgetpos(FILE * , fpos_t *);
char *fgets(char * , int, FILE *);



FILE *fopen(const char * , const char * ) __asm("_" "fopen" );

int fprintf(FILE * , const char * , ...) __attribute__((__format__ (__printf__, 2, 3)));
int fputc(int, FILE *);
int fputs(const char * , FILE * ) __asm("_" "fputs" );
size_t fread(void * , size_t, size_t, FILE * );
FILE *freopen(const char * , const char * ,
                 FILE * ) __asm("_" "freopen" );
int fscanf(FILE * , const char * , ...) __attribute__((__format__ (__scanf__, 2, 3)));
int fseek(FILE *, long, int);
int fsetpos(FILE *, const fpos_t *);
long ftell(FILE *);
size_t fwrite(const void * , size_t, size_t, FILE * ) __asm("_" "fwrite" );
int getc(FILE *);
int getchar(void);
char *gets(char *);
void perror(const char *);
int printf(const char * , ...) __attribute__((__format__ (__printf__, 1, 2)));
int putc(int, FILE *);
int putchar(int);
int puts(const char *);
int remove(const char *);
int rename (const char *, const char *);
void rewind(FILE *);
int scanf(const char * , ...) __attribute__((__format__ (__scanf__, 1, 2)));
void setbuf(FILE * , char * );
int setvbuf(FILE * , char * , int, size_t);
int sprintf(char * , const char * , ...) __attribute__((__format__ (__printf__, 2, 3)));
int sscanf(const char * , const char * , ...) __attribute__((__format__ (__scanf__, 2, 3)));
FILE *tmpfile(void);


__attribute__((deprecated("This function is provided for compatibility reasons only.  Due to security concerns inherent in the design of tmpnam(3), it is highly recommended that you use mkstemp(3) instead.")))

char *tmpnam(char *);
int ungetc(int, FILE *);
int vfprintf(FILE * , const char * , va_list) __attribute__((__format__ (__printf__, 2, 0)));
int vprintf(const char * , va_list) __attribute__((__format__ (__printf__, 1, 0)));
int vsprintf(char * , const char * , va_list) __attribute__((__format__ (__printf__, 2, 0)));
}



/* Additional functionality provided by:
 * POSIX.1-1988
 */




extern "C" {

/* Multiply defined in stdio.h and unistd.h by SUS */

char *ctermid(char *);





FILE *fdopen(int, const char *) __asm("_" "fdopen" );

int fileno(FILE *);
}



/* Additional functionality provided by:
 * POSIX.2-1992 C Language Binding Option
 */


extern "C" {
int pclose(FILE *);



FILE *popen(const char *, const char *) __asm("_" "popen" );

}





/* Additional functionality provided by:
 * POSIX.1c-1995,
 * POSIX.1i-1995,
 * and the omnibus ISO/IEC 9945-1: 1996
 */



/* Functions internal to the implementation. */
extern "C" {
int __srget(FILE *);
int __svfscanf(FILE *, const char *, va_list) __attribute__((__format__ (__scanf__, 2, 0)));
int __swbuf(int, FILE *);
}

/*
 * The __sfoo macros are here so that we can
 * define function versions in the C library.
 */


inline __attribute__ ((__always_inline__)) int __sputc(int _c, FILE *_p) {
 if (--_p->_w >= 0 || (_p->_w >= _p->_lbfsize && (char)_c != '\n'))
  return (*_p->_p++ = _c);
 else
  return (__swbuf(_c, _p));
}
# 373 "/usr/include/stdio.h" 3 4
extern "C" {
void flockfile(FILE *);
int ftrylockfile(FILE *);
void funlockfile(FILE *);
int getc_unlocked(FILE *);
int getchar_unlocked(void);
int putc_unlocked(int, FILE *);
int putchar_unlocked(int);

/* Removed in Issue 6 */

int getw(FILE *);
int putw(int, FILE *);



__attribute__((deprecated("This function is provided for compatibility reasons only.  Due to security concerns inherent in the design of tempnam(3), it is highly recommended that you use mkstemp(3) instead.")))

char *tempnam(const char *, const char *) __asm("_" "tempnam" );
}
# 405 "/usr/include/stdio.h" 3 4
/* Additional functionality provided by:
 * POSIX.1-2001
 * ISO C99
 */



# 1 "/usr/include/sys/_types/_off_t.h" 1 3 4
/*
 * Copyright (c) 2003-2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */


typedef __darwin_off_t off_t;
# 412 "/usr/include/stdio.h" 2 3 4

extern "C" {
int fseeko(FILE *, off_t, int);
off_t ftello(FILE *);
}



extern "C" {
int snprintf(char * , size_t, const char * , ...) __attribute__((__format__ (__printf__, 3, 4)));
int vfscanf(FILE * , const char * , va_list) __attribute__((__format__ (__scanf__, 2, 0)));
int vscanf(const char * , va_list) __attribute__((__format__ (__scanf__, 1, 0)));
int vsnprintf(char * , size_t, const char * , va_list) __attribute__((__format__ (__printf__, 3, 0)));
int vsscanf(const char * , const char * , va_list) __attribute__((__format__ (__scanf__, 2, 0)));
}




/* Additional functionality provided by:
 * POSIX.1-2008
 */



# 1 "/usr/include/sys/_types/_ssize_t.h" 1 3 4
/*
 * Copyright (c) 2003-2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */


typedef __darwin_ssize_t ssize_t;
# 437 "/usr/include/stdio.h" 2 3 4

extern "C" {
int dprintf(int, const char * , ...) __attribute__((__format__ (__printf__, 2, 3))) __attribute__((availability(macosx,introduced=10.7)));
int vdprintf(int, const char * , va_list) __attribute__((__format__ (__printf__, 2, 0))) __attribute__((availability(macosx,introduced=10.7)));
ssize_t getdelim(char ** , size_t * , int, FILE * ) __attribute__((availability(macosx,introduced=10.7)));
ssize_t getline(char ** , size_t * , FILE * ) __attribute__((availability(macosx,introduced=10.7)));
}




/* Darwin extensions */


extern "C" {
extern const int sys_nerr; /* perror(3) external variables */
extern const char *const sys_errlist[];

int asprintf(char ** , const char * , ...) __attribute__((__format__ (__printf__, 2, 3)));
char *ctermid_r(char *);
char *fgetln(FILE *, size_t *);
const char *fmtcheck(const char *, const char *);
int fpurge(FILE *);
void setbuffer(FILE *, char *, int);
int setlinebuf(FILE *);
int vasprintf(char ** , const char * , va_list) __attribute__((__format__ (__printf__, 2, 0)));
FILE *zopen(const char *, const char *, int);


/*
 * Stdio function-access interface.
 */
FILE *funopen(const void *,
                 int (*)(void *, char *, int),
                 int (*)(void *, const char *, int),
                 fpos_t (*)(void *, fpos_t, int),
                 int (*)(void *));
}
# 91 "/usr/include/wchar.h" 2 3 4
# 1 "/usr/include/time.h" 1 3 4
/*
 * Copyright (c) 2000 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
/*
 * Copyright (c) 1989, 1993
 *	The Regents of the University of California.  All rights reserved.
 * (c) UNIX System Laboratories, Inc.
 * All or some portions of this file are derived from material licensed
 * to the University of California by American Telephone and Telegraph
 * Co. or Unix System Laboratories, Inc. and are reproduced herein with
 * the permission of UNIX System Laboratories, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)time.h	8.3 (Berkeley) 1/21/94
 */






# 1 "/usr/include/sys/_types/_clock_t.h" 1 3 4
/*
 * Copyright (c) 2003-2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */


typedef __darwin_clock_t clock_t;
# 68 "/usr/include/time.h" 2 3 4


# 1 "/usr/include/sys/_types/_time_t.h" 1 3 4
/*
 * Copyright (c) 2003-2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */


typedef __darwin_time_t time_t;
# 71 "/usr/include/time.h" 2 3 4
# 1 "/usr/include/sys/_types/_timespec.h" 1 3 4
/*
 * Copyright (c) 2003-2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */


struct timespec
{
 __darwin_time_t tv_sec;
 long tv_nsec;
};
# 72 "/usr/include/time.h" 2 3 4

struct tm {
 int tm_sec; /* seconds after the minute [0-60] */
 int tm_min; /* minutes after the hour [0-59] */
 int tm_hour; /* hours since midnight [0-23] */
 int tm_mday; /* day of the month [1-31] */
 int tm_mon; /* months since January [0-11] */
 int tm_year; /* years since 1900 */
 int tm_wday; /* days since Sunday [0-6] */
 int tm_yday; /* days since January 1 [0-365] */
 int tm_isdst; /* Daylight Savings Time flag */
 long tm_gmtoff; /* offset from CUT in seconds */
 char *tm_zone; /* timezone abbreviation */
};
# 96 "/usr/include/time.h" 3 4
extern char *tzname[];


extern int getdate_err;

extern long timezone __asm("_" "timezone" );

extern int daylight;

extern "C" {
char *asctime(const struct tm *);
clock_t clock(void) __asm("_" "clock" );
char *ctime(const time_t *);
double difftime(time_t, time_t);
struct tm *getdate(const char *);
struct tm *gmtime(const time_t *);
struct tm *localtime(const time_t *);
time_t mktime(struct tm *) __asm("_" "mktime" );
size_t strftime(char * , size_t, const char * , const struct tm * ) __asm("_" "strftime" );
char *strptime(const char * , const char * , struct tm * ) __asm("_" "strptime" );
time_t time(time_t *);


void tzset(void);


/* [TSF] Thread safe functions */
char *asctime_r(const struct tm * , char * );
char *ctime_r(const time_t *, char *);
struct tm *gmtime_r(const time_t * , struct tm * );
struct tm *localtime_r(const time_t * , struct tm * );


time_t posix2time(time_t);



void tzsetwall(void);
time_t time2posix(time_t);
time_t timelocal(struct tm * const);
time_t timegm(struct tm * const);



int nanosleep(const struct timespec *, struct timespec *) __asm("_" "nanosleep" );

}
# 92 "/usr/include/wchar.h" 2 3 4
# 1 "/usr/include/_wctype.h" 1 3 4
/*-
 * Copyright (c)1999 Citrus Project,
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 */

/*
 * Common header for wctype.h and wchar.h
 *
 * Contains everything required by wctype.h except:
 *
 *	#include <_types/_wctrans_t.h>
 *	int iswblank(wint_t);
 *	wint_t towctrans(wint_t, wctrans_t);
 *	wctrans_t wctrans(const char *);
 */








# 1 "/usr/include/sys/_types/_wint_t.h" 1 3 4
/*
 * Copyright (c) 2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */



typedef __darwin_wint_t wint_t;
# 46 "/usr/include/_wctype.h" 2 3 4

# 1 "/usr/include/_types/_wctype_t.h" 1 3 4
/*
 * Copyright (c) 2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */



typedef __darwin_wctype_t wctype_t;
# 48 "/usr/include/_wctype.h" 2 3 4
# 57 "/usr/include/_wctype.h" 3 4
# 1 "/usr/include/ctype.h" 1 3 4
/*
 * Copyright (c) 2000, 2005, 2008 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
/*
 * Copyright (c) 1989, 1993
 *	The Regents of the University of California.  All rights reserved.
 * (c) UNIX System Laboratories, Inc.
 * All or some portions of this file are derived from material licensed
 * to the University of California by American Telephone and Telegraph
 * Co. or Unix System Laboratories, Inc. and are reproduced herein with
 * the permission of UNIX System Laboratories, Inc.
 *
 * This code is derived from software contributed to Berkeley by
 * Paul Borman at Krystal Technologies.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)ctype.h	8.4 (Berkeley) 1/21/94
 */






# 1 "/usr/include/runetype.h" 1 3 4
/*-
 * Copyright (c) 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Paul Borman at Krystal Technologies.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)runetype.h	8.1 (Berkeley) 6/2/93
 */
# 49 "/usr/include/runetype.h" 3 4
# 1 "/usr/include/sys/_types/_wchar_t.h" 1 3 4
/*
 * Copyright (c) 2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */

/* wchar_t is a built-in type in C++ */
# 50 "/usr/include/runetype.h" 2 3 4







/*
 * The lower 8 bits of runetype[] contain the digit value of the rune.
 */
typedef struct {
 __darwin_rune_t __min; /* First rune of the range */
 __darwin_rune_t __max; /* Last rune (inclusive) of the range */
 __darwin_rune_t __map; /* What first maps to in maps */
 __uint32_t *__types; /* Array of types in range */
} _RuneEntry;

typedef struct {
 int __nranges; /* Number of ranges stored */
 _RuneEntry *__ranges; /* Pointer to the ranges */
} _RuneRange;

typedef struct {
 char __name[14]; /* CHARCLASS_NAME_MAX = 14 */
 __uint32_t __mask; /* charclass mask */
} _RuneCharClass;

typedef struct {
 char __magic[8]; /* Magic saying what version we are */
 char __encoding[32]; /* ASCII name of this encoding */

 __darwin_rune_t (*__sgetrune)(const char *, __darwin_size_t, char const **);
 int (*__sputrune)(__darwin_rune_t, char *, __darwin_size_t, char **);
 __darwin_rune_t __invalid_rune;

 __uint32_t __runetype[(1 <<8 )];
 __darwin_rune_t __maplower[(1 <<8 )];
 __darwin_rune_t __mapupper[(1 <<8 )];

 /*
	 * The following are to deal with Runes larger than _CACHED_RUNES - 1.
	 * Their data is actually contiguous with this structure so as to make
	 * it easier to read/write from/to disk.
	 */
 _RuneRange __runetype_ext;
 _RuneRange __maplower_ext;
 _RuneRange __mapupper_ext;

 void *__variable; /* Data which depends on the encoding */
 int __variable_len; /* how long that data is */

 /*
	 * extra fields to deal with arbitrary character classes
	 */
 int __ncharclasses;
 _RuneCharClass *__charclasses;
} _RuneLocale;



extern "C" {
extern _RuneLocale _DefaultRuneLocale;
extern _RuneLocale *_CurrentRuneLocale;
}
# 71 "/usr/include/ctype.h" 2 3 4
# 121 "/usr/include/ctype.h" 3 4
/*
 * Use inline functions if we are allowed to and the compiler supports them.
 */



/* See comments in <machine/_type.h> about __darwin_ct_rune_t. */
extern "C" {
unsigned long ___runetype(__darwin_ct_rune_t);
__darwin_ct_rune_t ___tolower(__darwin_ct_rune_t);
__darwin_ct_rune_t ___toupper(__darwin_ct_rune_t);
}

inline int
isascii(int _c)
{
 return ((_c & ~0x7F) == 0);
}
# 147 "/usr/include/ctype.h" 3 4
extern "C" {
int __maskrune(__darwin_ct_rune_t, unsigned long);
}


inline int
__istype(__darwin_ct_rune_t _c, unsigned long _f)
{



 return (isascii(_c) ? !!(_DefaultRuneLocale.__runetype[_c] & _f)
  : !!__maskrune(_c, _f));

}

inline __darwin_ct_rune_t
__isctype(__darwin_ct_rune_t _c, unsigned long _f)
{



 return (_c < 0 || _c >= (1 <<8 )) ? 0 :
  !!(_DefaultRuneLocale.__runetype[_c] & _f);

}
# 187 "/usr/include/ctype.h" 3 4
extern "C" {
__darwin_ct_rune_t __toupper(__darwin_ct_rune_t);
__darwin_ct_rune_t __tolower(__darwin_ct_rune_t);
}


inline int
__wcwidth(__darwin_ct_rune_t _c)
{
 unsigned int _x;

 if (_c == 0)
  return (0);
 _x = (unsigned int)__maskrune(_c, 0xe0000000L|0x00040000L);
 if ((_x & 0xe0000000L) != 0)
  return ((_x & 0xe0000000L) >> 30);
 return ((_x & 0x00040000L) != 0 ? 1 : -1);
}






inline int
isalnum(int _c)
{
 return (__istype(_c, 0x00000100L|0x00000400L));
}

inline int
isalpha(int _c)
{
 return (__istype(_c, 0x00000100L));
}

inline int
isblank(int _c)
{
 return (__istype(_c, 0x00020000L));
}

inline int
iscntrl(int _c)
{
 return (__istype(_c, 0x00000200L));
}

/* ANSI -- locale independent */
inline int
isdigit(int _c)
{
 return (__isctype(_c, 0x00000400L));
}

inline int
isgraph(int _c)
{
 return (__istype(_c, 0x00000800L));
}

inline int
islower(int _c)
{
 return (__istype(_c, 0x00001000L));
}

inline int
isprint(int _c)
{
 return (__istype(_c, 0x00040000L));
}

inline int
ispunct(int _c)
{
 return (__istype(_c, 0x00002000L));
}

inline int
isspace(int _c)
{
 return (__istype(_c, 0x00004000L));
}

inline int
isupper(int _c)
{
 return (__istype(_c, 0x00008000L));
}

/* ANSI -- locale independent */
inline int
isxdigit(int _c)
{
 return (__isctype(_c, 0x00010000L));
}

inline int
toascii(int _c)
{
 return (_c & 0x7F);
}

inline int
tolower(int _c)
{
        return (__tolower(_c));
}

inline int
toupper(int _c)
{
        return (__toupper(_c));
}


inline int
digittoint(int _c)
{
 return (__maskrune(_c, 0x0F));
}

inline int
ishexnumber(int _c)
{
 return (__istype(_c, 0x00010000L));
}

inline int
isideogram(int _c)
{
 return (__istype(_c, 0x00080000L));
}

inline int
isnumber(int _c)
{
 return (__istype(_c, 0x00000400L));
}

inline int
isphonogram(int _c)
{
 return (__istype(_c, 0x00200000L));
}

inline int
isrune(int _c)
{
 return (__istype(_c, 0xFFFFFFF0L));
}

inline int
isspecial(int _c)
{
 return (__istype(_c, 0x00100000L));
}
# 58 "/usr/include/_wctype.h" 2 3 4

/*
 * Use inline functions if we are allowed to and the compiler supports them.
 */



inline int
iswalnum(wint_t _wc)
{
 return (__istype(_wc, 0x00000100L|0x00000400L));
}

inline int
iswalpha(wint_t _wc)
{
 return (__istype(_wc, 0x00000100L));
}

inline int
iswcntrl(wint_t _wc)
{
 return (__istype(_wc, 0x00000200L));
}

inline int
iswctype(wint_t _wc, wctype_t _charclass)
{
 return (__istype(_wc, _charclass));
}

inline int
iswdigit(wint_t _wc)
{
 return (__isctype(_wc, 0x00000400L));
}

inline int
iswgraph(wint_t _wc)
{
 return (__istype(_wc, 0x00000800L));
}

inline int
iswlower(wint_t _wc)
{
 return (__istype(_wc, 0x00001000L));
}

inline int
iswprint(wint_t _wc)
{
 return (__istype(_wc, 0x00040000L));
}

inline int
iswpunct(wint_t _wc)
{
 return (__istype(_wc, 0x00002000L));
}

inline int
iswspace(wint_t _wc)
{
 return (__istype(_wc, 0x00004000L));
}

inline int
iswupper(wint_t _wc)
{
 return (__istype(_wc, 0x00008000L));
}

inline int
iswxdigit(wint_t _wc)
{
 return (__isctype(_wc, 0x00010000L));
}

inline wint_t
towlower(wint_t _wc)
{
        return (__tolower(_wc));
}

inline wint_t
towupper(wint_t _wc)
{
        return (__toupper(_wc));
}
# 170 "/usr/include/_wctype.h" 3 4
extern "C" {
wctype_t
 wctype(const char *);
}
# 93 "/usr/include/wchar.h" 2 3 4


/* Initially added in Issue 4 */
extern "C" {
wint_t btowc(int);
wint_t fgetwc(FILE *);
wchar_t *fgetws(wchar_t * , int, FILE * );
wint_t fputwc(wchar_t, FILE *);
int fputws(const wchar_t * , FILE * );
int fwide(FILE *, int);
int fwprintf(FILE * , const wchar_t * , ...);
int fwscanf(FILE * , const wchar_t * , ...);
wint_t getwc(FILE *);
wint_t getwchar(void);
size_t mbrlen(const char * , size_t, mbstate_t * );
size_t mbrtowc(wchar_t * , const char * , size_t,
     mbstate_t * );
int mbsinit(const mbstate_t *);
size_t mbsrtowcs(wchar_t * , const char ** , size_t,
     mbstate_t * );
wint_t putwc(wchar_t, FILE *);
wint_t putwchar(wchar_t);
int swprintf(wchar_t * , size_t, const wchar_t * , ...);
int swscanf(const wchar_t * , const wchar_t * , ...);
wint_t ungetwc(wint_t, FILE *);
int vfwprintf(FILE * , const wchar_t * ,
     __darwin_va_list);
int vswprintf(wchar_t * , size_t, const wchar_t * ,
     __darwin_va_list);
int vwprintf(const wchar_t * , __darwin_va_list);
size_t wcrtomb(char * , wchar_t, mbstate_t * );
wchar_t *wcscat(wchar_t * , const wchar_t * );
wchar_t *wcschr(const wchar_t *, wchar_t);
int wcscmp(const wchar_t *, const wchar_t *);
int wcscoll(const wchar_t *, const wchar_t *);
wchar_t *wcscpy(wchar_t * , const wchar_t * );
size_t wcscspn(const wchar_t *, const wchar_t *);
size_t wcsftime(wchar_t * , size_t, const wchar_t * ,
     const struct tm * ) __asm("_" "wcsftime" );
size_t wcslen(const wchar_t *);
wchar_t *wcsncat(wchar_t * , const wchar_t * , size_t);
int wcsncmp(const wchar_t *, const wchar_t *, size_t);
wchar_t *wcsncpy(wchar_t * , const wchar_t * , size_t);
wchar_t *wcspbrk(const wchar_t *, const wchar_t *);
wchar_t *wcsrchr(const wchar_t *, wchar_t);
size_t wcsrtombs(char * , const wchar_t ** , size_t,
     mbstate_t * );
size_t wcsspn(const wchar_t *, const wchar_t *);
wchar_t *wcsstr(const wchar_t * , const wchar_t * );
size_t wcsxfrm(wchar_t * , const wchar_t * , size_t);
int wctob(wint_t);
double wcstod(const wchar_t * , wchar_t ** );
wchar_t *wcstok(wchar_t * , const wchar_t * ,
     wchar_t ** );
long wcstol(const wchar_t * , wchar_t ** , int);
unsigned long
  wcstoul(const wchar_t * , wchar_t ** , int);
wchar_t *wmemchr(const wchar_t *, wchar_t, size_t);
int wmemcmp(const wchar_t *, const wchar_t *, size_t);
wchar_t *wmemcpy(wchar_t * , const wchar_t * , size_t);
wchar_t *wmemmove(wchar_t *, const wchar_t *, size_t);
wchar_t *wmemset(wchar_t *, wchar_t, size_t);
int wprintf(const wchar_t * , ...);
int wscanf(const wchar_t * , ...);
int wcswidth(const wchar_t *, size_t);
int wcwidth(wchar_t);
}



/* Additional functionality provided by:
 * POSIX.1-2001
 * ISO C99
 */


extern "C" {
int vfwscanf(FILE * , const wchar_t * ,
     __darwin_va_list);
int vswscanf(const wchar_t * , const wchar_t * ,
     __darwin_va_list);
int vwscanf(const wchar_t * , __darwin_va_list);
float wcstof(const wchar_t * , wchar_t ** );
long double
 wcstold(const wchar_t * , wchar_t ** );

long long
 wcstoll(const wchar_t * , wchar_t ** , int);
unsigned long long
 wcstoull(const wchar_t * , wchar_t ** , int);

}




/* Additional functionality provided by:
 * POSIX.1-2008
 */


extern "C" {
size_t mbsnrtowcs(wchar_t * , const char ** , size_t,
            size_t, mbstate_t * );
wchar_t *wcpcpy(wchar_t * , const wchar_t * ) __attribute__((availability(macosx,introduced=10.7)));
wchar_t *wcpncpy(wchar_t * , const wchar_t * , size_t) __attribute__((availability(macosx,introduced=10.7)));
wchar_t *wcsdup(const wchar_t *) __attribute__((availability(macosx,introduced=10.7)));
int wcscasecmp(const wchar_t *, const wchar_t *) __attribute__((availability(macosx,introduced=10.7)));
int wcsncasecmp(const wchar_t *, const wchar_t *, size_t n) __attribute__((availability(macosx,introduced=10.7)));
size_t wcsnlen(const wchar_t *, size_t) __attribute__((availability(macosx,introduced=10.7)));
size_t wcsnrtombs(char * , const wchar_t ** , size_t,
            size_t, mbstate_t * );
}




/* Darwin extensions */


extern "C" {
wchar_t *fgetwln(FILE * , size_t *) __attribute__((availability(macosx,introduced=10.7)));
size_t wcslcat(wchar_t *, const wchar_t *, size_t);
size_t wcslcpy(wchar_t *, const wchar_t *, size_t);
}



/* Poison the following routines if -fshort-wchar is set */
# 91 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/iosfwd" 2 3
# 94 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/iosfwd" 3


namespace std {inline namespace __1 {

class __attribute__ ((__type_visibility__("default"))) ios_base;

template<class _CharT> struct __attribute__ ((__type_visibility__("default"))) char_traits;
template<class _Tp> class __attribute__ ((__type_visibility__("default"))) allocator;

template <class _CharT, class _Traits = char_traits<_CharT> >
    class __attribute__ ((__type_visibility__("default"))) basic_ios;

template <class _CharT, class _Traits = char_traits<_CharT> >
    class __attribute__ ((__type_visibility__("default"))) basic_streambuf;
template <class _CharT, class _Traits = char_traits<_CharT> >
    class __attribute__ ((__type_visibility__("default"))) basic_istream;
template <class _CharT, class _Traits = char_traits<_CharT> >
    class __attribute__ ((__type_visibility__("default"))) basic_ostream;
template <class _CharT, class _Traits = char_traits<_CharT> >
    class __attribute__ ((__type_visibility__("default"))) basic_iostream;

template <class _CharT, class _Traits = char_traits<_CharT>,
          class _Allocator = allocator<_CharT> >
    class __attribute__ ((__type_visibility__("default"))) basic_stringbuf;
template <class _CharT, class _Traits = char_traits<_CharT>,
          class _Allocator = allocator<_CharT> >
    class __attribute__ ((__type_visibility__("default"))) basic_istringstream;
template <class _CharT, class _Traits = char_traits<_CharT>,
          class _Allocator = allocator<_CharT> >
    class __attribute__ ((__type_visibility__("default"))) basic_ostringstream;
template <class _CharT, class _Traits = char_traits<_CharT>,
          class _Allocator = allocator<_CharT> >
    class __attribute__ ((__type_visibility__("default"))) basic_stringstream;

template <class _CharT, class _Traits = char_traits<_CharT> >
    class __attribute__ ((__type_visibility__("default"))) basic_filebuf;
template <class _CharT, class _Traits = char_traits<_CharT> >
    class __attribute__ ((__type_visibility__("default"))) basic_ifstream;
template <class _CharT, class _Traits = char_traits<_CharT> >
    class __attribute__ ((__type_visibility__("default"))) basic_ofstream;
template <class _CharT, class _Traits = char_traits<_CharT> >
    class __attribute__ ((__type_visibility__("default"))) basic_fstream;

template <class _CharT, class _Traits = char_traits<_CharT> >
    class __attribute__ ((__type_visibility__("default"))) istreambuf_iterator;
template <class _CharT, class _Traits = char_traits<_CharT> >
    class __attribute__ ((__type_visibility__("default"))) ostreambuf_iterator;

typedef basic_ios<char> ios;
typedef basic_ios<wchar_t> wios;

typedef basic_streambuf<char> streambuf;
typedef basic_istream<char> istream;
typedef basic_ostream<char> ostream;
typedef basic_iostream<char> iostream;

typedef basic_stringbuf<char> stringbuf;
typedef basic_istringstream<char> istringstream;
typedef basic_ostringstream<char> ostringstream;
typedef basic_stringstream<char> stringstream;

typedef basic_filebuf<char> filebuf;
typedef basic_ifstream<char> ifstream;
typedef basic_ofstream<char> ofstream;
typedef basic_fstream<char> fstream;

typedef basic_streambuf<wchar_t> wstreambuf;
typedef basic_istream<wchar_t> wistream;
typedef basic_ostream<wchar_t> wostream;
typedef basic_iostream<wchar_t> wiostream;

typedef basic_stringbuf<wchar_t> wstringbuf;
typedef basic_istringstream<wchar_t> wistringstream;
typedef basic_ostringstream<wchar_t> wostringstream;
typedef basic_stringstream<wchar_t> wstringstream;

typedef basic_filebuf<wchar_t> wfilebuf;
typedef basic_ifstream<wchar_t> wifstream;
typedef basic_ofstream<wchar_t> wofstream;
typedef basic_fstream<wchar_t> wfstream;

template <class _State> class __attribute__ ((__type_visibility__("default"))) fpos;
typedef fpos<mbstate_t> streampos;
typedef fpos<mbstate_t> wstreampos;

typedef fpos<mbstate_t> u16streampos;
typedef fpos<mbstate_t> u32streampos;


typedef long long streamoff; // for char_traits in <string>

template <class _CharT, // for <stdexcept>
          class _Traits = char_traits<_CharT>,
          class _Allocator = allocator<_CharT> >
    class __attribute__ ((__type_visibility__("default"))) basic_string;
typedef basic_string<char, char_traits<char>, allocator<char> > string;
typedef basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> > wstring;

} }
# 216 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/ios" 2 3
# 1 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/__locale" 1 3
// -*- C++ -*-
//===----------------------------------------------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is dual licensed under the MIT and the University of Illinois Open
// Source Licenses. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//






# 1 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/string" 1 3
// -*- C++ -*-
//===--------------------------- string -----------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//




/*
    string synopsis

namespace std
{

template <class stateT>
class fpos
{
private:
    stateT st;
public:
    fpos(streamoff = streamoff());

    operator streamoff() const;

    stateT state() const;
    void state(stateT);

    fpos& operator+=(streamoff);
    fpos  operator+ (streamoff) const;
    fpos& operator-=(streamoff);
    fpos  operator- (streamoff) const;
};

template <class stateT> streamoff operator-(const fpos<stateT>& x, const fpos<stateT>& y);

template <class stateT> bool operator==(const fpos<stateT>& x, const fpos<stateT>& y);
template <class stateT> bool operator!=(const fpos<stateT>& x, const fpos<stateT>& y);

template <class charT>
struct char_traits
{
    typedef charT     char_type;
    typedef ...       int_type;
    typedef streamoff off_type;
    typedef streampos pos_type;
    typedef mbstate_t state_type;

    static void assign(char_type& c1, const char_type& c2) noexcept;
    static constexpr bool eq(char_type c1, char_type c2) noexcept;
    static constexpr bool lt(char_type c1, char_type c2) noexcept;

    static int              compare(const char_type* s1, const char_type* s2, size_t n);
    static size_t           length(const char_type* s);
    static const char_type* find(const char_type* s, size_t n, const char_type& a);
    static char_type*       move(char_type* s1, const char_type* s2, size_t n);
    static char_type*       copy(char_type* s1, const char_type* s2, size_t n);
    static char_type*       assign(char_type* s, size_t n, char_type a);

    static constexpr int_type  not_eof(int_type c) noexcept;
    static constexpr char_type to_char_type(int_type c) noexcept;
    static constexpr int_type  to_int_type(char_type c) noexcept;
    static constexpr bool      eq_int_type(int_type c1, int_type c2) noexcept;
    static constexpr int_type  eof() noexcept;
};

template <> struct char_traits<char>;
template <> struct char_traits<wchar_t>;

template<class charT, class traits = char_traits<charT>, class Allocator = allocator<charT> >
class basic_string
{
public:
// types:
    typedef traits traits_type;
    typedef typename traits_type::char_type value_type;
    typedef Allocator allocator_type;
    typedef typename allocator_type::size_type size_type;
    typedef typename allocator_type::difference_type difference_type;
    typedef typename allocator_type::reference reference;
    typedef typename allocator_type::const_reference const_reference;
    typedef typename allocator_type::pointer pointer;
    typedef typename allocator_type::const_pointer const_pointer;
    typedef implementation-defined iterator;
    typedef implementation-defined const_iterator;
    typedef std::reverse_iterator<iterator> reverse_iterator;
    typedef std::reverse_iterator<const_iterator> const_reverse_iterator;

    static const size_type npos = -1;

    basic_string()
        noexcept(is_nothrow_default_constructible<allocator_type>::value);
    explicit basic_string(const allocator_type& a);
    basic_string(const basic_string& str);
    basic_string(basic_string&& str)
        noexcept(is_nothrow_move_constructible<allocator_type>::value);
    basic_string(const basic_string& str, size_type pos, size_type n = npos,
                 const allocator_type& a = allocator_type());
    basic_string(const value_type* s, const allocator_type& a = allocator_type());
    basic_string(const value_type* s, size_type n, const allocator_type& a = allocator_type());
    basic_string(size_type n, value_type c, const allocator_type& a = allocator_type());
    template<class InputIterator>
        basic_string(InputIterator begin, InputIterator end,
                     const allocator_type& a = allocator_type());
    basic_string(initializer_list<value_type>, const Allocator& = Allocator());
    basic_string(const basic_string&, const Allocator&);
    basic_string(basic_string&&, const Allocator&);

    ~basic_string();

    basic_string& operator=(const basic_string& str);
    basic_string& operator=(basic_string&& str)
        noexcept(
             allocator_type::propagate_on_container_move_assignment::value &&
             is_nothrow_move_assignable<allocator_type>::value);
    basic_string& operator=(const value_type* s);
    basic_string& operator=(value_type c);
    basic_string& operator=(initializer_list<value_type>);

    iterator       begin() noexcept;
    const_iterator begin() const noexcept;
    iterator       end() noexcept;
    const_iterator end() const noexcept;

    reverse_iterator       rbegin() noexcept;
    const_reverse_iterator rbegin() const noexcept;
    reverse_iterator       rend() noexcept;
    const_reverse_iterator rend() const noexcept;

    const_iterator         cbegin() const noexcept;
    const_iterator         cend() const noexcept;
    const_reverse_iterator crbegin() const noexcept;
    const_reverse_iterator crend() const noexcept;

    size_type size() const noexcept;
    size_type length() const noexcept;
    size_type max_size() const noexcept;
    size_type capacity() const noexcept;

    void resize(size_type n, value_type c);
    void resize(size_type n);

    void reserve(size_type res_arg = 0);
    void shrink_to_fit();
    void clear() noexcept;
    bool empty() const noexcept;

    const_reference operator[](size_type pos) const;
    reference       operator[](size_type pos);

    const_reference at(size_type n) const;
    reference       at(size_type n);

    basic_string& operator+=(const basic_string& str);
    basic_string& operator+=(const value_type* s);
    basic_string& operator+=(value_type c);
    basic_string& operator+=(initializer_list<value_type>);

    basic_string& append(const basic_string& str);
    basic_string& append(const basic_string& str, size_type pos, size_type n=npos); //C++14
    basic_string& append(const value_type* s, size_type n);
    basic_string& append(const value_type* s);
    basic_string& append(size_type n, value_type c);
    template<class InputIterator>
        basic_string& append(InputIterator first, InputIterator last);
    basic_string& append(initializer_list<value_type>);

    void push_back(value_type c);
    void pop_back();
    reference       front();
    const_reference front() const;
    reference       back();
    const_reference back() const;

    basic_string& assign(const basic_string& str);
    basic_string& assign(basic_string&& str);
    basic_string& assign(const basic_string& str, size_type pos, size_type n=npos); // C++14
    basic_string& assign(const value_type* s, size_type n);
    basic_string& assign(const value_type* s);
    basic_string& assign(size_type n, value_type c);
    template<class InputIterator>
        basic_string& assign(InputIterator first, InputIterator last);
    basic_string& assign(initializer_list<value_type>);

    basic_string& insert(size_type pos1, const basic_string& str);
    basic_string& insert(size_type pos1, const basic_string& str,
                         size_type pos2, size_type n);
    basic_string& insert(size_type pos, const value_type* s, size_type n=npos); //C++14
    basic_string& insert(size_type pos, const value_type* s);
    basic_string& insert(size_type pos, size_type n, value_type c);
    iterator      insert(const_iterator p, value_type c);
    iterator      insert(const_iterator p, size_type n, value_type c);
    template<class InputIterator>
        iterator insert(const_iterator p, InputIterator first, InputIterator last);
    iterator      insert(const_iterator p, initializer_list<value_type>);

    basic_string& erase(size_type pos = 0, size_type n = npos);
    iterator      erase(const_iterator position);
    iterator      erase(const_iterator first, const_iterator last);

    basic_string& replace(size_type pos1, size_type n1, const basic_string& str);
    basic_string& replace(size_type pos1, size_type n1, const basic_string& str,
                          size_type pos2, size_type n2=npos); // C++14
    basic_string& replace(size_type pos, size_type n1, const value_type* s, size_type n2);
    basic_string& replace(size_type pos, size_type n1, const value_type* s);
    basic_string& replace(size_type pos, size_type n1, size_type n2, value_type c);
    basic_string& replace(const_iterator i1, const_iterator i2, const basic_string& str);
    basic_string& replace(const_iterator i1, const_iterator i2, const value_type* s, size_type n);
    basic_string& replace(const_iterator i1, const_iterator i2, const value_type* s);
    basic_string& replace(const_iterator i1, const_iterator i2, size_type n, value_type c);
    template<class InputIterator>
        basic_string& replace(const_iterator i1, const_iterator i2, InputIterator j1, InputIterator j2);
    basic_string& replace(const_iterator i1, const_iterator i2, initializer_list<value_type>);

    size_type copy(value_type* s, size_type n, size_type pos = 0) const;
    basic_string substr(size_type pos = 0, size_type n = npos) const;

    void swap(basic_string& str)
        noexcept(!allocator_type::propagate_on_container_swap::value ||
                 __is_nothrow_swappable<allocator_type>::value)

    const value_type* c_str() const noexcept;
    const value_type* data() const noexcept;

    allocator_type get_allocator() const noexcept;

    size_type find(const basic_string& str, size_type pos = 0) const noexcept;
    size_type find(const value_type* s, size_type pos, size_type n) const noexcept;
    size_type find(const value_type* s, size_type pos = 0) const noexcept;
    size_type find(value_type c, size_type pos = 0) const noexcept;

    size_type rfind(const basic_string& str, size_type pos = npos) const noexcept;
    size_type rfind(const value_type* s, size_type pos, size_type n) const noexcept;
    size_type rfind(const value_type* s, size_type pos = npos) const noexcept;
    size_type rfind(value_type c, size_type pos = npos) const noexcept;

    size_type find_first_of(const basic_string& str, size_type pos = 0) const noexcept;
    size_type find_first_of(const value_type* s, size_type pos, size_type n) const noexcept;
    size_type find_first_of(const value_type* s, size_type pos = 0) const noexcept;
    size_type find_first_of(value_type c, size_type pos = 0) const noexcept;

    size_type find_last_of(const basic_string& str, size_type pos = npos) const noexcept;
    size_type find_last_of(const value_type* s, size_type pos, size_type n) const noexcept;
    size_type find_last_of(const value_type* s, size_type pos = npos) const noexcept;
    size_type find_last_of(value_type c, size_type pos = npos) const noexcept;

    size_type find_first_not_of(const basic_string& str, size_type pos = 0) const noexcept;
    size_type find_first_not_of(const value_type* s, size_type pos, size_type n) const noexcept;
    size_type find_first_not_of(const value_type* s, size_type pos = 0) const noexcept;
    size_type find_first_not_of(value_type c, size_type pos = 0) const noexcept;

    size_type find_last_not_of(const basic_string& str, size_type pos = npos) const noexcept;
    size_type find_last_not_of(const value_type* s, size_type pos, size_type n) const noexcept;
    size_type find_last_not_of(const value_type* s, size_type pos = npos) const noexcept;
    size_type find_last_not_of(value_type c, size_type pos = npos) const noexcept;

    int compare(const basic_string& str) const noexcept;
    int compare(size_type pos1, size_type n1, const basic_string& str) const;
    int compare(size_type pos1, size_type n1, const basic_string& str,
                size_type pos2, size_type n2=npos) const; // C++14
    int compare(const value_type* s) const noexcept;
    int compare(size_type pos1, size_type n1, const value_type* s) const;
    int compare(size_type pos1, size_type n1, const value_type* s, size_type n2) const;

    bool __invariants() const;
};

template<class charT, class traits, class Allocator>
basic_string<charT, traits, Allocator>
operator+(const basic_string<charT, traits, Allocator>& lhs,
          const basic_string<charT, traits, Allocator>& rhs);

template<class charT, class traits, class Allocator>
basic_string<charT, traits, Allocator>
operator+(const charT* lhs , const basic_string<charT,traits,Allocator>&rhs);

template<class charT, class traits, class Allocator>
basic_string<charT, traits, Allocator>
operator+(charT lhs, const basic_string<charT,traits,Allocator>& rhs);

template<class charT, class traits, class Allocator>
basic_string<charT, traits, Allocator>
operator+(const basic_string<charT, traits, Allocator>& lhs, const charT* rhs);

template<class charT, class traits, class Allocator>
basic_string<charT, traits, Allocator>
operator+(const basic_string<charT, traits, Allocator>& lhs, charT rhs);

template<class charT, class traits, class Allocator>
bool operator==(const basic_string<charT, traits, Allocator>& lhs,
                const basic_string<charT, traits, Allocator>& rhs) noexcept;

template<class charT, class traits, class Allocator>
bool operator==(const charT* lhs, const basic_string<charT, traits, Allocator>& rhs) noexcept;

template<class charT, class traits, class Allocator>
bool operator==(const basic_string<charT,traits,Allocator>& lhs, const charT* rhs) noexcept;

template<class charT, class traits, class Allocator>
bool operator!=(const basic_string<charT,traits,Allocator>& lhs,
                const basic_string<charT, traits, Allocator>& rhs) noexcept;

template<class charT, class traits, class Allocator>
bool operator!=(const charT* lhs, const basic_string<charT, traits, Allocator>& rhs) noexcept;

template<class charT, class traits, class Allocator>
bool operator!=(const basic_string<charT, traits, Allocator>& lhs, const charT* rhs) noexcept;

template<class charT, class traits, class Allocator>
bool operator< (const basic_string<charT, traits, Allocator>& lhs,
                const basic_string<charT, traits, Allocator>& rhs) noexcept;

template<class charT, class traits, class Allocator>
bool operator< (const basic_string<charT, traits, Allocator>& lhs, const charT* rhs) noexcept;

template<class charT, class traits, class Allocator>
bool operator< (const charT* lhs, const basic_string<charT, traits, Allocator>& rhs) noexcept;

template<class charT, class traits, class Allocator>
bool operator> (const basic_string<charT, traits, Allocator>& lhs,
                const basic_string<charT, traits, Allocator>& rhs) noexcept;

template<class charT, class traits, class Allocator>
bool operator> (const basic_string<charT, traits, Allocator>& lhs, const charT* rhs) noexcept;

template<class charT, class traits, class Allocator>
bool operator> (const charT* lhs, const basic_string<charT, traits, Allocator>& rhs) noexcept;

template<class charT, class traits, class Allocator>
bool operator<=(const basic_string<charT, traits, Allocator>& lhs,
                const basic_string<charT, traits, Allocator>& rhs) noexcept;

template<class charT, class traits, class Allocator>
bool operator<=(const basic_string<charT, traits, Allocator>& lhs, const charT* rhs) noexcept;

template<class charT, class traits, class Allocator>
bool operator<=(const charT* lhs, const basic_string<charT, traits, Allocator>& rhs) noexcept;

template<class charT, class traits, class Allocator>
bool operator>=(const basic_string<charT, traits, Allocator>& lhs,
                const basic_string<charT, traits, Allocator>& rhs) noexcept;

template<class charT, class traits, class Allocator>
bool operator>=(const basic_string<charT, traits, Allocator>& lhs, const charT* rhs) noexcept;

template<class charT, class traits, class Allocator>
bool operator>=(const charT* lhs, const basic_string<charT, traits, Allocator>& rhs) noexcept;

template<class charT, class traits, class Allocator>
void swap(basic_string<charT, traits, Allocator>& lhs,
          basic_string<charT, traits, Allocator>& rhs)
            noexcept(noexcept(lhs.swap(rhs)));

template<class charT, class traits, class Allocator>
basic_istream<charT, traits>&
operator>>(basic_istream<charT, traits>& is, basic_string<charT, traits, Allocator>& str);

template<class charT, class traits, class Allocator>
basic_ostream<charT, traits>&
operator<<(basic_ostream<charT, traits>& os, const basic_string<charT, traits, Allocator>& str);

template<class charT, class traits, class Allocator>
basic_istream<charT, traits>&
getline(basic_istream<charT, traits>& is, basic_string<charT, traits, Allocator>& str,
        charT delim);

template<class charT, class traits, class Allocator>
basic_istream<charT, traits>&
getline(basic_istream<charT, traits>& is, basic_string<charT, traits, Allocator>& str);

typedef basic_string<char>    string;
typedef basic_string<wchar_t> wstring;
typedef basic_string<char16_t> u16string;
typedef basic_string<char32_t> u32string;

int                stoi  (const string& str, size_t* idx = 0, int base = 10);
long               stol  (const string& str, size_t* idx = 0, int base = 10);
unsigned long      stoul (const string& str, size_t* idx = 0, int base = 10);
long long          stoll (const string& str, size_t* idx = 0, int base = 10);
unsigned long long stoull(const string& str, size_t* idx = 0, int base = 10);

float       stof (const string& str, size_t* idx = 0);
double      stod (const string& str, size_t* idx = 0);
long double stold(const string& str, size_t* idx = 0);

string to_string(int val);
string to_string(unsigned val);
string to_string(long val);
string to_string(unsigned long val);
string to_string(long long val);
string to_string(unsigned long long val);
string to_string(float val);
string to_string(double val);
string to_string(long double val);

int                stoi  (const wstring& str, size_t* idx = 0, int base = 10);
long               stol  (const wstring& str, size_t* idx = 0, int base = 10);
unsigned long      stoul (const wstring& str, size_t* idx = 0, int base = 10);
long long          stoll (const wstring& str, size_t* idx = 0, int base = 10);
unsigned long long stoull(const wstring& str, size_t* idx = 0, int base = 10);

float       stof (const wstring& str, size_t* idx = 0);
double      stod (const wstring& str, size_t* idx = 0);
long double stold(const wstring& str, size_t* idx = 0);

wstring to_wstring(int val);
wstring to_wstring(unsigned val);
wstring to_wstring(long val);
wstring to_wstring(unsigned long val);
wstring to_wstring(long long val);
wstring to_wstring(unsigned long long val);
wstring to_wstring(float val);
wstring to_wstring(double val);
wstring to_wstring(long double val);

template <> struct hash<string>;
template <> struct hash<u16string>;
template <> struct hash<u32string>;
template <> struct hash<wstring>;

basic_string<char>     operator "" s( const char *str,     size_t len ); // C++14
basic_string<wchar_t>  operator "" s( const wchar_t *str,  size_t len ); // C++14
basic_string<char16_t> operator "" s( const char16_t *str, size_t len ); // C++14
basic_string<char32_t> operator "" s( const char32_t *str, size_t len ); // C++14

}  // std

*/




# 1 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/cstring" 1 3
// -*- C++ -*-
//===--------------------------- cstring ----------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//




/*
    cstring synopsis

Macros:

    NULL

namespace std
{

Types:

    size_t

void* memcpy(void* restrict s1, const void* restrict s2, size_t n);
void* memmove(void* s1, const void* s2, size_t n);
char* strcpy (char* restrict s1, const char* restrict s2);
char* strncpy(char* restrict s1, const char* restrict s2, size_t n);
char* strcat (char* restrict s1, const char* restrict s2);
char* strncat(char* restrict s1, const char* restrict s2, size_t n);
int memcmp(const void* s1, const void* s2, size_t n);
int strcmp (const char* s1, const char* s2);
int strncmp(const char* s1, const char* s2, size_t n);
int strcoll(const char* s1, const char* s2);
size_t strxfrm(char* restrict s1, const char* restrict s2, size_t n);
const void* memchr(const void* s, int c, size_t n);
      void* memchr(      void* s, int c, size_t n);
const char* strchr(const char* s, int c);
      char* strchr(      char* s, int c);
size_t strcspn(const char* s1, const char* s2);
const char* strpbrk(const char* s1, const char* s2);
      char* strpbrk(      char* s1, const char* s2);
const char* strrchr(const char* s, int c);
      char* strrchr(      char* s, int c);
size_t strspn(const char* s1, const char* s2);
const char* strstr(const char* s1, const char* s2);
      char* strstr(      char* s1, const char* s2);
char* strtok(char* restrict s1, const char* restrict s2);
void* memset(void* s, int c, size_t n);
char* strerror(int errnum);
size_t strlen(const char* s);

}  // std

*/



# 1 "/usr/include/string.h" 1 3 4
/*
 * Copyright (c) 2000, 2007, 2010 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_LICENSE_HEADER_END@
 */
/*-
 * Copyright (c) 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)string.h	8.1 (Berkeley) 6/2/93
 */
# 67 "/usr/include/string.h" 3 4
/* ANSI-C */

extern "C" {
void *memchr(const void *, int, size_t);
int memcmp(const void *, const void *, size_t);
void *memcpy(void *, const void *, size_t);
void *memmove(void *, const void *, size_t);
void *memset(void *, int, size_t);
char *strcat(char *, const char *);
char *strchr(const char *, int);
int strcmp(const char *, const char *);
int strcoll(const char *, const char *);
char *strcpy(char *, const char *);
size_t strcspn(const char *, const char *);
char *strerror(int) __asm("_" "strerror" );
size_t strlen(const char *);
char *strncat(char *, const char *, size_t);
int strncmp(const char *, const char *, size_t);
char *strncpy(char *, const char *, size_t);
char *strpbrk(const char *, const char *);
char *strrchr(const char *, int);
size_t strspn(const char *, const char *);
char *strstr(const char *, const char *);
char *strtok(char *, const char *);
size_t strxfrm(char *, const char *, size_t);
}



/* Additional functionality provided by:
 * POSIX.1c-1995,
 * POSIX.1i-1995,
 * and the omnibus ISO/IEC 9945-1: 1996
 */


extern "C" {
char *strtok_r(char *, const char *, char **);
}




/* Additional functionality provided by:
 * POSIX.1-2001
 */


extern "C" {
int strerror_r(int, char *, size_t);
char *strdup(const char *);
void *memccpy(void *, const void *, int, size_t);
}




/* Additional functionality provided by:
 * POSIX.1-2008
 */


extern "C" {
char *stpcpy(char *, const char *);
char *stpncpy(char *, const char *, size_t) __attribute__((availability(macosx,introduced=10.7)));
char *strndup(const char *, size_t) __attribute__((availability(macosx,introduced=10.7)));
size_t strnlen(const char *, size_t) __attribute__((availability(macosx,introduced=10.7)));
char *strsignal(int sig);
}


/* C11 Annex K */



# 1 "/usr/include/sys/_types/_rsize_t.h" 1 3 4
/*
 * Copyright (c) 2003-2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */


typedef __darwin_size_t rsize_t;
# 142 "/usr/include/string.h" 2 3 4
# 1 "/usr/include/sys/_types/_errno_t.h" 1 3 4
/*
 * Copyright (c) 2003-2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */


typedef int errno_t;
# 143 "/usr/include/string.h" 2 3 4

extern "C" {
errno_t memset_s(void *, rsize_t, int, rsize_t) __attribute__((availability(macosx,introduced=10.9)));
}


/* Darwin extensions */




extern "C" {
void *memmem(const void *, size_t, const void *, size_t) __attribute__((availability(macosx,introduced=10.7)));
void memset_pattern4(void *, const void *, size_t) __attribute__((availability(macosx,introduced=10.5)));
void memset_pattern8(void *, const void *, size_t) __attribute__((availability(macosx,introduced=10.5)));
void memset_pattern16(void *, const void *, size_t) __attribute__((availability(macosx,introduced=10.5)));

char *strcasestr(const char *, const char *);
char *strnstr(const char *, const char *, size_t);
size_t strlcat(char *, const char *, size_t);
size_t strlcpy(char *, const char *, size_t);
void strmode(int, char *);
char *strsep(char **, const char *);

/* SUS places swab() in unistd.h.  It is listed here for source compatibility */
void swab(const void * , void * , ssize_t);
}

/* Some functions historically defined in string.h were placed in strings.h
 * by SUS.  We are using "strings.h" instead of <strings.h> to avoid an issue
 * where /Developer/Headers/FlatCarbon/Strings.h could be included instead on
 * case-insensitive file systems.
 */

# 1 "/usr/include/strings.h" 1 3 4
/*
 * Copyright (c) 2000, 2007, 2010 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
/*-
 * Copyright (c) 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)strings.h	8.1 (Berkeley) 6/2/93
 */
# 67 "/usr/include/strings.h" 3 4
extern "C" {
/* Removed in Issue 7 */

int bcmp(const void *, const void *, size_t) ;
void bcopy(const void *, void *, size_t) ;
void bzero(void *, size_t) ;
char *index(const char *, int) ;
char *rindex(const char *, int) ;


int ffs(int);
int strcasecmp(const char *, const char *);
int strncasecmp(const char *, const char *, size_t);
}

/* Darwin extensions */

extern "C" {
int ffsl(long) __attribute__((availability(macosx,introduced=10.5)));
int ffsll(long long) __attribute__((availability(macosx,introduced=10.9)));
int fls(int) __attribute__((availability(macosx,introduced=10.5)));
int flsl(long) __attribute__((availability(macosx,introduced=10.5)));
int flsll(long long) __attribute__((availability(macosx,introduced=10.9)));
}


# 1 "/usr/include/string.h" 1 3 4
/*
 * Copyright (c) 2000, 2007, 2010 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_LICENSE_HEADER_END@
 */
/*-
 * Copyright (c) 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)string.h	8.1 (Berkeley) 6/2/93
 */
# 93 "/usr/include/strings.h" 2 3 4
# 177 "/usr/include/string.h" 2 3 4
# 62 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/cstring" 2 3
# 65 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/cstring" 3


namespace std {inline namespace __1 {

using ::size_t;
using ::memcpy;
using ::memmove;
using ::strcpy;
using ::strncpy;
using ::strcat;
using ::strncat;
using ::memcmp;
using ::strcmp;
using ::strncmp;
using ::strcoll;
using ::strxfrm;

using ::memchr;

using ::strchr;

using ::strcspn;

using ::strpbrk;

using ::strrchr;

using ::strspn;

using ::strstr;

// MSVCRT, GNU libc and its derivates already have the correct prototype in <string.h> #ifdef __cplusplus

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) char* strchr( char* __s, int __c) {return ::strchr(__s, __c);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) char* strpbrk( char* __s1, const char* __s2) {return ::strpbrk(__s1, __s2);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) char* strrchr( char* __s, int __c) {return ::strrchr(__s, __c);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) void* memchr( void* __s, int __c, size_t __n) {return ::memchr(__s, __c, __n);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) char* strstr( char* __s1, const char* __s2) {return ::strstr(__s1, __s2);}


using ::strtok;
using ::memset;
using ::strerror;
using ::strlen;

} }
# 437 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/string" 2 3
# 1 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/cstdio" 1 3
// -*- C++ -*-
//===---------------------------- cstdio ----------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is dual licensed under the MIT and the University of Illinois Open
// Source Licenses. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//




/*
    cstdio synopsis

Macros:

    BUFSIZ
    EOF
    FILENAME_MAX
    FOPEN_MAX
    L_tmpnam
    NULL
    SEEK_CUR
    SEEK_END
    SEEK_SET
    TMP_MAX
    _IOFBF
    _IOLBF
    _IONBF
    stderr
    stdin
    stdout

namespace std
{

Types:

FILE
fpos_t
size_t

int remove(const char* filename);
int rename(const char* old, const char* new);
FILE* tmpfile(void);
char* tmpnam(char* s);
int fclose(FILE* stream);
int fflush(FILE* stream);
FILE* fopen(const char* restrict filename, const char* restrict mode);
FILE* freopen(const char* restrict filename, const char * restrict mode,
              FILE * restrict stream);
void setbuf(FILE* restrict stream, char* restrict buf);
int setvbuf(FILE* restrict stream, char* restrict buf, int mode, size_t size);
int fprintf(FILE* restrict stream, const char* restrict format, ...);
int fscanf(FILE* restrict stream, const char * restrict format, ...);
int printf(const char* restrict format, ...);
int scanf(const char* restrict format, ...);
int snprintf(char* restrict s, size_t n, const char* restrict format, ...);    // C99
int sprintf(char* restrict s, const char* restrict format, ...);
int sscanf(const char* restrict s, const char* restrict format, ...);
int vfprintf(FILE* restrict stream, const char* restrict format, va_list arg);
int vfscanf(FILE* restrict stream, const char* restrict format, va_list arg);  // C99
int vprintf(const char* restrict format, va_list arg);
int vscanf(const char* restrict format, va_list arg);                          // C99
int vsnprintf(char* restrict s, size_t n, const char* restrict format,         // C99
              va_list arg);
int vsprintf(char* restrict s, const char* restrict format, va_list arg);
int vsscanf(const char* restrict s, const char* restrict format, va_list arg); // C99
int fgetc(FILE* stream);
char* fgets(char* restrict s, int n, FILE* restrict stream);
int fputc(int c, FILE* stream);
int fputs(const char* restrict s, FILE* restrict stream);
int getc(FILE* stream);
int getchar(void);
char* gets(char* s);  // removed in C++14
int putc(int c, FILE* stream);
int putchar(int c);
int puts(const char* s);
int ungetc(int c, FILE* stream);
size_t fread(void* restrict ptr, size_t size, size_t nmemb,
             FILE* restrict stream);
size_t fwrite(const void* restrict ptr, size_t size, size_t nmemb,
              FILE* restrict stream);
int fgetpos(FILE* restrict stream, fpos_t* restrict pos);
int fseek(FILE* stream, long offset, int whence);
int fsetpos(FILE*stream, const fpos_t* pos);
long ftell(FILE* stream);
void rewind(FILE* stream);
void clearerr(FILE* stream);
int feof(FILE* stream);
int ferror(FILE* stream);
void perror(const char* s);

}  // std
*/
# 104 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/cstdio" 3


// snprintf
# 123 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/cstdio" 3
namespace std {inline namespace __1 {

using ::FILE;
using ::fpos_t;
using ::size_t;

using ::remove;
using ::rename;
using ::tmpfile;
using ::tmpnam;
using ::fclose;
using ::fflush;
using ::fopen;
using ::freopen;
using ::setbuf;
using ::setvbuf;
using ::fprintf;
using ::fscanf;
using ::printf;
using ::scanf;
using ::snprintf;
using ::sprintf;
using ::sscanf;

using ::vfprintf;
using ::vfscanf;
using ::vscanf;
using ::vsscanf;

using ::vprintf;
using ::vsnprintf;
using ::vsprintf;
using ::fgetc;
using ::fgets;
using ::fputc;
using ::fputs;
using ::getc;
using ::getchar;

using ::gets;

using ::putc;
using ::putchar;
using ::puts;
using ::ungetc;
using ::fread;
using ::fwrite;
using ::fgetpos;
using ::fseek;
using ::fsetpos;
using ::ftell;
using ::rewind;
using ::clearerr;
using ::feof;
using ::ferror;
using ::perror;

} }
# 438 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/string" 2 3
# 1 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/cwchar" 1 3
// -*- C++ -*-
//===--------------------------- cwchar -----------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is dual licensed under the MIT and the University of Illinois Open
// Source Licenses. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//




/*
    cwchar synopsis

Macros:

    NULL
    WCHAR_MAX
    WCHAR_MIN
    WEOF

namespace std
{

Types:

    mbstate_t
    size_t
    tm
    wint_t

int fwprintf(FILE* restrict stream, const wchar_t* restrict format, ...);
int fwscanf(FILE* restrict stream, const wchar_t* restrict format, ...);
int swprintf(wchar_t* restrict s, size_t n, const wchar_t* restrict format, ...);
int swscanf(const wchar_t* restrict s, const wchar_t* restrict format, ...);
int vfwprintf(FILE* restrict stream, const wchar_t* restrict format, va_list arg);
int vfwscanf(FILE* restrict stream, const wchar_t* restrict format, va_list arg);  // C99
int vswprintf(wchar_t* restrict s, size_t n, const wchar_t* restrict format, va_list arg);
int vswscanf(const wchar_t* restrict s, const wchar_t* restrict format, va_list arg);  // C99
int vwprintf(const wchar_t* restrict format, va_list arg);
int vwscanf(const wchar_t* restrict format, va_list arg);  // C99
int wprintf(const wchar_t* restrict format, ...);
int wscanf(const wchar_t* restrict format, ...);
wint_t fgetwc(FILE* stream);
wchar_t* fgetws(wchar_t* restrict s, int n, FILE* restrict stream);
wint_t fputwc(wchar_t c, FILE* stream);
int fputws(const wchar_t* restrict s, FILE* restrict stream);
int fwide(FILE* stream, int mode);
wint_t getwc(FILE* stream);
wint_t getwchar();
wint_t putwc(wchar_t c, FILE* stream);
wint_t putwchar(wchar_t c);
wint_t ungetwc(wint_t c, FILE* stream);
double wcstod(const wchar_t* restrict nptr, wchar_t** restrict endptr);
float wcstof(const wchar_t* restrict nptr, wchar_t** restrict endptr);         // C99
long double wcstold(const wchar_t* restrict nptr, wchar_t** restrict endptr);  // C99
long wcstol(const wchar_t* restrict nptr, wchar_t** restrict endptr, int base);
long long wcstoll(const wchar_t* restrict nptr, wchar_t** restrict endptr, int base);  // C99
unsigned long wcstoul(const wchar_t* restrict nptr, wchar_t** restrict endptr, int base);
unsigned long long wcstoull(const wchar_t* restrict nptr, wchar_t** restrict endptr, int base);  // C99
wchar_t* wcscpy(wchar_t* restrict s1, const wchar_t* restrict s2);
wchar_t* wcsncpy(wchar_t* restrict s1, const wchar_t* restrict s2, size_t n);
wchar_t* wcscat(wchar_t* restrict s1, const wchar_t* restrict s2);
wchar_t* wcsncat(wchar_t* restrict s1, const wchar_t* restrict s2, size_t n);
int wcscmp(const wchar_t* s1, const wchar_t* s2);
int wcscoll(const wchar_t* s1, const wchar_t* s2);
int wcsncmp(const wchar_t* s1, const wchar_t* s2, size_t n);
size_t wcsxfrm(wchar_t* restrict s1, const wchar_t* restrict s2, size_t n);
const wchar_t* wcschr(const wchar_t* s, wchar_t c);
      wchar_t* wcschr(      wchar_t* s, wchar_t c);
size_t wcscspn(const wchar_t* s1, const wchar_t* s2);
size_t wcslen(const wchar_t* s);
const wchar_t* wcspbrk(const wchar_t* s1, const wchar_t* s2);
      wchar_t* wcspbrk(      wchar_t* s1, const wchar_t* s2);
const wchar_t* wcsrchr(const wchar_t* s, wchar_t c);
      wchar_t* wcsrchr(      wchar_t* s, wchar_t c);
size_t wcsspn(const wchar_t* s1, const wchar_t* s2);
const wchar_t* wcsstr(const wchar_t* s1, const wchar_t* s2);
      wchar_t* wcsstr(      wchar_t* s1, const wchar_t* s2);
wchar_t* wcstok(wchar_t* restrict s1, const wchar_t* restrict s2, wchar_t** restrict ptr);
const wchar_t* wmemchr(const wchar_t* s, wchar_t c, size_t n);
      wchar_t* wmemchr(      wchar_t* s, wchar_t c, size_t n);
int wmemcmp(wchar_t* restrict s1, const wchar_t* restrict s2, size_t n);
wchar_t* wmemcpy(wchar_t* restrict s1, const wchar_t* restrict s2, size_t n);
wchar_t* wmemmove(wchar_t* s1, const wchar_t* s2, size_t n);
wchar_t* wmemset(wchar_t* s, wchar_t c, size_t n);
size_t wcsftime(wchar_t* restrict s, size_t maxsize, const wchar_t* restrict format,
                const tm* restrict timeptr);
wint_t btowc(int c);
int wctob(wint_t c);
int mbsinit(const mbstate_t* ps);
size_t mbrlen(const char* restrict s, size_t n, mbstate_t* restrict ps);
size_t mbrtowc(wchar_t* restrict pwc, const char* restrict s, size_t n, mbstate_t* restrict ps);
size_t wcrtomb(char* restrict s, wchar_t wc, mbstate_t* restrict ps);
size_t mbsrtowcs(wchar_t* restrict dst, const char** restrict src, size_t len,
                 mbstate_t* restrict ps);
size_t wcsrtombs(char* restrict dst, const wchar_t** restrict src, size_t len,
                 mbstate_t* restrict ps);

}  // std

*/



# 1 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/cwctype" 1 3
// -*- C++ -*-
//===--------------------------- cwctype ----------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is dual licensed under the MIT and the University of Illinois Open
// Source Licenses. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//




/*
    cwctype synopsis

Macros:

    WEOF

namespace std
{

Types:

    wint_t
    wctrans_t
    wctype_t

int iswalnum(wint_t wc);
int iswalpha(wint_t wc);
int iswblank(wint_t wc);  // C99
int iswcntrl(wint_t wc);
int iswdigit(wint_t wc);
int iswgraph(wint_t wc);
int iswlower(wint_t wc);
int iswprint(wint_t wc);
int iswpunct(wint_t wc);
int iswspace(wint_t wc);
int iswupper(wint_t wc);
int iswxdigit(wint_t wc);
int iswctype(wint_t wc, wctype_t desc);
wctype_t wctype(const char* property);
wint_t towlower(wint_t wc);
wint_t towupper(wint_t wc);
wint_t towctrans(wint_t wc, wctrans_t desc);
wctrans_t wctrans(const char* property);

}  // std

*/



# 1 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/cctype" 1 3
// -*- C++ -*-
//===---------------------------- cctype ----------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is dual licensed under the MIT and the University of Illinois Open
// Source Licenses. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//




/*
    cctype synopsis

namespace std
{

int isalnum(int c);
int isalpha(int c);
int isblank(int c);  // C99
int iscntrl(int c);
int isdigit(int c);
int isgraph(int c);
int islower(int c);
int isprint(int c);
int ispunct(int c);
int isspace(int c);
int isupper(int c);
int isxdigit(int c);
int tolower(int c);
int toupper(int c);

}  // std
*/
# 46 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/cctype" 3


namespace std {inline namespace __1 {






using ::isalnum;







using ::isalpha;







using ::isblank;







using ::iscntrl;







using ::isdigit;







using ::isgraph;







using ::islower;







using ::isprint;







using ::ispunct;







using ::isspace;







using ::isupper;







using ::isxdigit;







using ::tolower;







using ::toupper;


} }
# 55 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/cwctype" 2 3
# 1 "/usr/include/wctype.h" 1 3 4
/*-
 * Copyright (c)1999 Citrus Project,
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	citrus Id: wctype.h,v 1.4 2000/12/21 01:50:21 itojun Exp
 *	$NetBSD: wctype.h,v 1.3 2000/12/22 14:16:16 itojun Exp $
 * $FreeBSD: /repoman/r/ncvs/src/include/wctype.h,v 1.10 2002/08/21 16:19:55 mike Exp $
 */







# 1 "/usr/include/_types/_wctrans_t.h" 1 3 4
/*
 * Copyright (c) 2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */



typedef __darwin_wctrans_t wctrans_t;
# 37 "/usr/include/wctype.h" 2 3 4






/*
 * Use inline functions if we are allowed to and the compiler supports them.
 */



inline int
iswblank(wint_t _wc)
{
 return (__istype(_wc, 0x00020000L));
}


inline int
iswascii(wint_t _wc)
{
 return ((_wc & ~0x7F) == 0);
}

inline int
iswhexnumber(wint_t _wc)
{
 return (__istype(_wc, 0x00010000L));
}

inline int
iswideogram(wint_t _wc)
{
 return (__istype(_wc, 0x00080000L));
}

inline int
iswnumber(wint_t _wc)
{
 return (__istype(_wc, 0x00000400L));
}

inline int
iswphonogram(wint_t _wc)
{
 return (__istype(_wc, 0x00200000L));
}

inline int
iswrune(wint_t _wc)
{
 return (__istype(_wc, 0xFFFFFFF0L));
}

inline int
iswspecial(wint_t _wc)
{
 return (__istype(_wc, 0x00100000L));
}
# 117 "/usr/include/wctype.h" 3 4
extern "C" {

wint_t nextwctype(wint_t, wctype_t);

wint_t towctrans(wint_t, wctrans_t);
wctrans_t
 wctrans(const char *);
}
# 56 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/cwctype" 2 3
# 59 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/cwctype" 3


namespace std {inline namespace __1 {

using ::wint_t;
using ::wctrans_t;
using ::wctype_t;






using ::iswalnum;







using ::iswalpha;







using ::iswblank;







using ::iswcntrl;







using ::iswdigit;







using ::iswgraph;







using ::iswlower;







using ::iswprint;







using ::iswpunct;







using ::iswspace;







using ::iswupper;







using ::iswxdigit;







using ::iswctype;







using ::wctype;







using ::towlower;







using ::towupper;







using ::towctrans;







using ::wctrans;


} }
# 108 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/cwchar" 2 3
# 115 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/cwchar" 3


namespace std {inline namespace __1 {

using ::mbstate_t;
using ::size_t;
using ::tm;
using ::wint_t;
using ::FILE;
using ::fwprintf;
using ::fwscanf;
using ::swprintf;
using ::vfwprintf;
using ::vswprintf;
using ::vwprintf;

using ::swscanf;
using ::vfwscanf;
using ::vswscanf;
using ::vwscanf;

using ::wprintf;
using ::wscanf;
using ::fgetwc;
using ::fgetws;
using ::fputwc;
using ::fputws;
using ::fwide;
using ::getwc;
using ::getwchar;
using ::putwc;
using ::putwchar;
using ::ungetwc;
using ::wcstod;

using ::wcstof;
using ::wcstold;

using ::wcstol;

using ::wcstoll;

using ::wcstoul;

using ::wcstoull;

using ::wcscpy;
using ::wcsncpy;
using ::wcscat;
using ::wcsncat;
using ::wcscmp;
using ::wcscoll;
using ::wcsncmp;
using ::wcsxfrm;
# 180 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/cwchar" 3
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) const wchar_t* wcschr(const wchar_t* __s, wchar_t __c) {return ::wcschr(__s, __c);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) wchar_t* wcschr( wchar_t* __s, wchar_t __c) {return ::wcschr(__s, __c);}

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) const wchar_t* wcspbrk(const wchar_t* __s1, const wchar_t* __s2) {return ::wcspbrk(__s1, __s2);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) wchar_t* wcspbrk( wchar_t* __s1, const wchar_t* __s2) {return ::wcspbrk(__s1, __s2);}

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) const wchar_t* wcsrchr(const wchar_t* __s, wchar_t __c) {return ::wcsrchr(__s, __c);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) wchar_t* wcsrchr( wchar_t* __s, wchar_t __c) {return ::wcsrchr(__s, __c);}

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) const wchar_t* wcsstr(const wchar_t* __s1, const wchar_t* __s2) {return ::wcsstr(__s1, __s2);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) wchar_t* wcsstr( wchar_t* __s1, const wchar_t* __s2) {return ::wcsstr(__s1, __s2);}

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) const wchar_t* wmemchr(const wchar_t* __s, wchar_t __c, size_t __n) {return ::wmemchr(__s, __c, __n);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) wchar_t* wmemchr( wchar_t* __s, wchar_t __c, size_t __n) {return ::wmemchr(__s, __c, __n);}



using ::wcscspn;
using ::wcslen;
using ::wcsspn;
using ::wcstok;
using ::wmemcmp;
using ::wmemcpy;
using ::wmemmove;
using ::wmemset;
using ::wcsftime;
using ::btowc;
using ::wctob;
using ::mbsinit;
using ::mbrlen;
using ::mbrtowc;
using ::wcrtomb;
using ::mbsrtowcs;
using ::wcsrtombs;

} }
# 439 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/string" 2 3
# 1 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/algorithm" 1 3
// -*- C++ -*-
//===-------------------------- algorithm ---------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is dual licensed under the MIT and the University of Illinois Open
// Source Licenses. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//




/*
    algorithm synopsis

#include <initializer_list>

namespace std
{

template <class InputIterator, class Predicate>
    bool
    all_of(InputIterator first, InputIterator last, Predicate pred);

template <class InputIterator, class Predicate>
    bool
    any_of(InputIterator first, InputIterator last, Predicate pred);

template <class InputIterator, class Predicate>
    bool
    none_of(InputIterator first, InputIterator last, Predicate pred);

template <class InputIterator, class Function>
    Function
    for_each(InputIterator first, InputIterator last, Function f);

template <class InputIterator, class T>
    InputIterator
    find(InputIterator first, InputIterator last, const T& value);

template <class InputIterator, class Predicate>
    InputIterator
    find_if(InputIterator first, InputIterator last, Predicate pred);

template<class InputIterator, class Predicate>
    InputIterator
    find_if_not(InputIterator first, InputIterator last, Predicate pred);

template <class ForwardIterator1, class ForwardIterator2>
    ForwardIterator1
    find_end(ForwardIterator1 first1, ForwardIterator1 last1,
             ForwardIterator2 first2, ForwardIterator2 last2);

template <class ForwardIterator1, class ForwardIterator2, class BinaryPredicate>
    ForwardIterator1
    find_end(ForwardIterator1 first1, ForwardIterator1 last1,
             ForwardIterator2 first2, ForwardIterator2 last2, BinaryPredicate pred);

template <class ForwardIterator1, class ForwardIterator2>
    ForwardIterator1
    find_first_of(ForwardIterator1 first1, ForwardIterator1 last1,
                  ForwardIterator2 first2, ForwardIterator2 last2);

template <class ForwardIterator1, class ForwardIterator2, class BinaryPredicate>
    ForwardIterator1
    find_first_of(ForwardIterator1 first1, ForwardIterator1 last1,
                  ForwardIterator2 first2, ForwardIterator2 last2, BinaryPredicate pred);

template <class ForwardIterator>
    ForwardIterator
    adjacent_find(ForwardIterator first, ForwardIterator last);

template <class ForwardIterator, class BinaryPredicate>
    ForwardIterator
    adjacent_find(ForwardIterator first, ForwardIterator last, BinaryPredicate pred);

template <class InputIterator, class T>
    typename iterator_traits<InputIterator>::difference_type
    count(InputIterator first, InputIterator last, const T& value);

template <class InputIterator, class Predicate>
    typename iterator_traits<InputIterator>::difference_type
    count_if(InputIterator first, InputIterator last, Predicate pred);

template <class InputIterator1, class InputIterator2>
    pair<InputIterator1, InputIterator2>
    mismatch(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2);

template <class InputIterator1, class InputIterator2>
    pair<InputIterator1, InputIterator2>
    mismatch(InputIterator1 first1, InputIterator1 last1, 
             InputIterator2 first2, InputIterator2 last2); // **C++14**

template <class InputIterator1, class InputIterator2, class BinaryPredicate>
    pair<InputIterator1, InputIterator2>
    mismatch(InputIterator1 first1, InputIterator1 last1,
             InputIterator2 first2, BinaryPredicate pred);

template <class InputIterator1, class InputIterator2, class BinaryPredicate>
    pair<InputIterator1, InputIterator2>
    mismatch(InputIterator1 first1, InputIterator1 last1,
             InputIterator2 first2, InputIterator2 last2,
             BinaryPredicate pred); // **C++14**

template <class InputIterator1, class InputIterator2>
    bool
    equal(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2);

template <class InputIterator1, class InputIterator2>
    bool
    equal(InputIterator1 first1, InputIterator1 last1, 
          InputIterator2 first2, InputIterator2 last2); // **C++14**

template <class InputIterator1, class InputIterator2, class BinaryPredicate>
    bool
    equal(InputIterator1 first1, InputIterator1 last1,
          InputIterator2 first2, BinaryPredicate pred);

template <class InputIterator1, class InputIterator2, class BinaryPredicate>
    bool
    equal(InputIterator1 first1, InputIterator1 last1,
          InputIterator2 first2, InputIterator2 last2,
          BinaryPredicate pred); // **C++14**

template<class ForwardIterator1, class ForwardIterator2>
    bool
    is_permutation(ForwardIterator1 first1, ForwardIterator1 last1,
                   ForwardIterator2 first2);

template<class ForwardIterator1, class ForwardIterator2>
    bool
    is_permutation(ForwardIterator1 first1, ForwardIterator1 last1,
                   ForwardIterator2 first2, ForwardIterator2 last2); // **C++14**

template<class ForwardIterator1, class ForwardIterator2, class BinaryPredicate>
    bool
    is_permutation(ForwardIterator1 first1, ForwardIterator1 last1,
                   ForwardIterator2 first2, BinaryPredicate pred);

template<class ForwardIterator1, class ForwardIterator2, class BinaryPredicate>
    bool
    is_permutation(ForwardIterator1 first1, ForwardIterator1 last1,
                   ForwardIterator2 first2, ForwardIterator2 last2,
                   BinaryPredicate pred);  // **C++14**

template <class ForwardIterator1, class ForwardIterator2>
    ForwardIterator1
    search(ForwardIterator1 first1, ForwardIterator1 last1,
           ForwardIterator2 first2, ForwardIterator2 last2);

template <class ForwardIterator1, class ForwardIterator2, class BinaryPredicate>
    ForwardIterator1
    search(ForwardIterator1 first1, ForwardIterator1 last1,
           ForwardIterator2 first2, ForwardIterator2 last2, BinaryPredicate pred);

template <class ForwardIterator, class Size, class T>
    ForwardIterator
    search_n(ForwardIterator first, ForwardIterator last, Size count, const T& value);

template <class ForwardIterator, class Size, class T, class BinaryPredicate>
    ForwardIterator
    search_n(ForwardIterator first, ForwardIterator last,
             Size count, const T& value, BinaryPredicate pred);

template <class InputIterator, class OutputIterator>
    OutputIterator
    copy(InputIterator first, InputIterator last, OutputIterator result);

template<class InputIterator, class OutputIterator, class Predicate>
    OutputIterator
    copy_if(InputIterator first, InputIterator last,
            OutputIterator result, Predicate pred);

template<class InputIterator, class Size, class OutputIterator>
    OutputIterator
    copy_n(InputIterator first, Size n, OutputIterator result);

template <class BidirectionalIterator1, class BidirectionalIterator2>
    BidirectionalIterator2
    copy_backward(BidirectionalIterator1 first, BidirectionalIterator1 last,
                  BidirectionalIterator2 result);

template <class ForwardIterator1, class ForwardIterator2>
    ForwardIterator2
    swap_ranges(ForwardIterator1 first1, ForwardIterator1 last1, ForwardIterator2 first2);

template <class ForwardIterator1, class ForwardIterator2>
    void
    iter_swap(ForwardIterator1 a, ForwardIterator2 b);

template <class InputIterator, class OutputIterator, class UnaryOperation>
    OutputIterator
    transform(InputIterator first, InputIterator last, OutputIterator result, UnaryOperation op);

template <class InputIterator1, class InputIterator2, class OutputIterator, class BinaryOperation>
    OutputIterator
    transform(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2,
              OutputIterator result, BinaryOperation binary_op);

template <class ForwardIterator, class T>
    void
    replace(ForwardIterator first, ForwardIterator last, const T& old_value, const T& new_value);

template <class ForwardIterator, class Predicate, class T>
    void
    replace_if(ForwardIterator first, ForwardIterator last, Predicate pred, const T& new_value);

template <class InputIterator, class OutputIterator, class T>
    OutputIterator
    replace_copy(InputIterator first, InputIterator last, OutputIterator result,
                 const T& old_value, const T& new_value);

template <class InputIterator, class OutputIterator, class Predicate, class T>
    OutputIterator
    replace_copy_if(InputIterator first, InputIterator last, OutputIterator result, Predicate pred, const T& new_value);

template <class ForwardIterator, class T>
    void
    fill(ForwardIterator first, ForwardIterator last, const T& value);

template <class OutputIterator, class Size, class T>
    OutputIterator
    fill_n(OutputIterator first, Size n, const T& value);

template <class ForwardIterator, class Generator>
    void
    generate(ForwardIterator first, ForwardIterator last, Generator gen);

template <class OutputIterator, class Size, class Generator>
    OutputIterator
    generate_n(OutputIterator first, Size n, Generator gen);

template <class ForwardIterator, class T>
    ForwardIterator
    remove(ForwardIterator first, ForwardIterator last, const T& value);

template <class ForwardIterator, class Predicate>
    ForwardIterator
    remove_if(ForwardIterator first, ForwardIterator last, Predicate pred);

template <class InputIterator, class OutputIterator, class T>
    OutputIterator
    remove_copy(InputIterator first, InputIterator last, OutputIterator result, const T& value);

template <class InputIterator, class OutputIterator, class Predicate>
    OutputIterator
    remove_copy_if(InputIterator first, InputIterator last, OutputIterator result, Predicate pred);

template <class ForwardIterator>
    ForwardIterator
    unique(ForwardIterator first, ForwardIterator last);

template <class ForwardIterator, class BinaryPredicate>
    ForwardIterator
    unique(ForwardIterator first, ForwardIterator last, BinaryPredicate pred);

template <class InputIterator, class OutputIterator>
    OutputIterator
    unique_copy(InputIterator first, InputIterator last, OutputIterator result);

template <class InputIterator, class OutputIterator, class BinaryPredicate>
    OutputIterator
    unique_copy(InputIterator first, InputIterator last, OutputIterator result, BinaryPredicate pred);

template <class BidirectionalIterator>
    void
    reverse(BidirectionalIterator first, BidirectionalIterator last);

template <class BidirectionalIterator, class OutputIterator>
    OutputIterator
    reverse_copy(BidirectionalIterator first, BidirectionalIterator last, OutputIterator result);

template <class ForwardIterator>
    ForwardIterator
    rotate(ForwardIterator first, ForwardIterator middle, ForwardIterator last);

template <class ForwardIterator, class OutputIterator>
    OutputIterator
    rotate_copy(ForwardIterator first, ForwardIterator middle, ForwardIterator last, OutputIterator result);

template <class RandomAccessIterator>
    void
    random_shuffle(RandomAccessIterator first, RandomAccessIterator last); // deprecated in C++14

template <class RandomAccessIterator, class RandomNumberGenerator>
    void
    random_shuffle(RandomAccessIterator first, RandomAccessIterator last,
                   RandomNumberGenerator& rand);  // deprecated in C++14

template<class RandomAccessIterator, class UniformRandomNumberGenerator>
    void shuffle(RandomAccessIterator first, RandomAccessIterator last,
                 UniformRandomNumberGenerator&& g);

template <class InputIterator, class Predicate>
    bool
    is_partitioned(InputIterator first, InputIterator last, Predicate pred);

template <class ForwardIterator, class Predicate>
    ForwardIterator
    partition(ForwardIterator first, ForwardIterator last, Predicate pred);

template <class InputIterator, class OutputIterator1,
          class OutputIterator2, class Predicate>
    pair<OutputIterator1, OutputIterator2>
    partition_copy(InputIterator first, InputIterator last,
                   OutputIterator1 out_true, OutputIterator2 out_false,
                   Predicate pred);

template <class ForwardIterator, class Predicate>
    ForwardIterator
    stable_partition(ForwardIterator first, ForwardIterator last, Predicate pred);

template<class ForwardIterator, class Predicate>
    ForwardIterator
    partition_point(ForwardIterator first, ForwardIterator last, Predicate pred);

template <class ForwardIterator>
    bool
    is_sorted(ForwardIterator first, ForwardIterator last);

template <class ForwardIterator, class Compare>
    bool
    is_sorted(ForwardIterator first, ForwardIterator last, Compare comp);

template<class ForwardIterator>
    ForwardIterator
    is_sorted_until(ForwardIterator first, ForwardIterator last);

template <class ForwardIterator, class Compare>
    ForwardIterator
    is_sorted_until(ForwardIterator first, ForwardIterator last, Compare comp);

template <class RandomAccessIterator>
    void
    sort(RandomAccessIterator first, RandomAccessIterator last);

template <class RandomAccessIterator, class Compare>
    void
    sort(RandomAccessIterator first, RandomAccessIterator last, Compare comp);

template <class RandomAccessIterator>
    void
    stable_sort(RandomAccessIterator first, RandomAccessIterator last);

template <class RandomAccessIterator, class Compare>
    void
    stable_sort(RandomAccessIterator first, RandomAccessIterator last, Compare comp);

template <class RandomAccessIterator>
    void
    partial_sort(RandomAccessIterator first, RandomAccessIterator middle, RandomAccessIterator last);

template <class RandomAccessIterator, class Compare>
    void
    partial_sort(RandomAccessIterator first, RandomAccessIterator middle, RandomAccessIterator last, Compare comp);

template <class InputIterator, class RandomAccessIterator>
    RandomAccessIterator
    partial_sort_copy(InputIterator first, InputIterator last,
                      RandomAccessIterator result_first, RandomAccessIterator result_last);

template <class InputIterator, class RandomAccessIterator, class Compare>
    RandomAccessIterator
    partial_sort_copy(InputIterator first, InputIterator last,
                      RandomAccessIterator result_first, RandomAccessIterator result_last, Compare comp);

template <class RandomAccessIterator>
    void
    nth_element(RandomAccessIterator first, RandomAccessIterator nth, RandomAccessIterator last);

template <class RandomAccessIterator, class Compare>
    void
    nth_element(RandomAccessIterator first, RandomAccessIterator nth, RandomAccessIterator last, Compare comp);

template <class ForwardIterator, class T>
    ForwardIterator
    lower_bound(ForwardIterator first, ForwardIterator last, const T& value);

template <class ForwardIterator, class T, class Compare>
    ForwardIterator
    lower_bound(ForwardIterator first, ForwardIterator last, const T& value, Compare comp);

template <class ForwardIterator, class T>
    ForwardIterator
    upper_bound(ForwardIterator first, ForwardIterator last, const T& value);

template <class ForwardIterator, class T, class Compare>
    ForwardIterator
    upper_bound(ForwardIterator first, ForwardIterator last, const T& value, Compare comp);

template <class ForwardIterator, class T>
    pair<ForwardIterator, ForwardIterator>
    equal_range(ForwardIterator first, ForwardIterator last, const T& value);

template <class ForwardIterator, class T, class Compare>
    pair<ForwardIterator, ForwardIterator>
    equal_range(ForwardIterator first, ForwardIterator last, const T& value, Compare comp);

template <class ForwardIterator, class T>
    bool
    binary_search(ForwardIterator first, ForwardIterator last, const T& value);

template <class ForwardIterator, class T, class Compare>
    bool
    binary_search(ForwardIterator first, ForwardIterator last, const T& value, Compare comp);

template <class InputIterator1, class InputIterator2, class OutputIterator>
    OutputIterator
    merge(InputIterator1 first1, InputIterator1 last1,
          InputIterator2 first2, InputIterator2 last2, OutputIterator result);

template <class InputIterator1, class InputIterator2, class OutputIterator, class Compare>
    OutputIterator
    merge(InputIterator1 first1, InputIterator1 last1,
          InputIterator2 first2, InputIterator2 last2, OutputIterator result, Compare comp);

template <class BidirectionalIterator>
    void
    inplace_merge(BidirectionalIterator first, BidirectionalIterator middle, BidirectionalIterator last);

template <class BidirectionalIterator, class Compare>
    void
    inplace_merge(BidirectionalIterator first, BidirectionalIterator middle, BidirectionalIterator last, Compare comp);

template <class InputIterator1, class InputIterator2>
    bool
    includes(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2);

template <class InputIterator1, class InputIterator2, class Compare>
    bool
    includes(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, Compare comp);

template <class InputIterator1, class InputIterator2, class OutputIterator>
    OutputIterator
    set_union(InputIterator1 first1, InputIterator1 last1,
              InputIterator2 first2, InputIterator2 last2, OutputIterator result);

template <class InputIterator1, class InputIterator2, class OutputIterator, class Compare>
    OutputIterator
    set_union(InputIterator1 first1, InputIterator1 last1,
              InputIterator2 first2, InputIterator2 last2, OutputIterator result, Compare comp);

template <class InputIterator1, class InputIterator2, class OutputIterator>
    OutputIterator
    set_intersection(InputIterator1 first1, InputIterator1 last1,
                     InputIterator2 first2, InputIterator2 last2, OutputIterator result);

template <class InputIterator1, class InputIterator2, class OutputIterator, class Compare>
    OutputIterator
    set_intersection(InputIterator1 first1, InputIterator1 last1,
                     InputIterator2 first2, InputIterator2 last2, OutputIterator result, Compare comp);

template <class InputIterator1, class InputIterator2, class OutputIterator>
    OutputIterator
    set_difference(InputIterator1 first1, InputIterator1 last1,
                   InputIterator2 first2, InputIterator2 last2, OutputIterator result);

template <class InputIterator1, class InputIterator2, class OutputIterator, class Compare>
    OutputIterator
    set_difference(InputIterator1 first1, InputIterator1 last1,
                   InputIterator2 first2, InputIterator2 last2, OutputIterator result, Compare comp);

template <class InputIterator1, class InputIterator2, class OutputIterator>
    OutputIterator
    set_symmetric_difference(InputIterator1 first1, InputIterator1 last1,
                             InputIterator2 first2, InputIterator2 last2, OutputIterator result);

template <class InputIterator1, class InputIterator2, class OutputIterator, class Compare>
    OutputIterator
    set_symmetric_difference(InputIterator1 first1, InputIterator1 last1,
                             InputIterator2 first2, InputIterator2 last2, OutputIterator result, Compare comp);

template <class RandomAccessIterator>
    void
    push_heap(RandomAccessIterator first, RandomAccessIterator last);

template <class RandomAccessIterator, class Compare>
    void
    push_heap(RandomAccessIterator first, RandomAccessIterator last, Compare comp);

template <class RandomAccessIterator>
    void
    pop_heap(RandomAccessIterator first, RandomAccessIterator last);

template <class RandomAccessIterator, class Compare>
    void
    pop_heap(RandomAccessIterator first, RandomAccessIterator last, Compare comp);

template <class RandomAccessIterator>
    void
    make_heap(RandomAccessIterator first, RandomAccessIterator last);

template <class RandomAccessIterator, class Compare>
    void
    make_heap(RandomAccessIterator first, RandomAccessIterator last, Compare comp);

template <class RandomAccessIterator>
    void
    sort_heap(RandomAccessIterator first, RandomAccessIterator last);

template <class RandomAccessIterator, class Compare>
    void
    sort_heap(RandomAccessIterator first, RandomAccessIterator last, Compare comp);

template <class RandomAccessIterator>
    bool
    is_heap(RandomAccessIterator first, RandomAccessiterator last);

template <class RandomAccessIterator, class Compare>
    bool
    is_heap(RandomAccessIterator first, RandomAccessiterator last, Compare comp);

template <class RandomAccessIterator>
    RandomAccessIterator
    is_heap_until(RandomAccessIterator first, RandomAccessiterator last);

template <class RandomAccessIterator, class Compare>
    RandomAccessIterator
    is_heap_until(RandomAccessIterator first, RandomAccessiterator last, Compare comp);

template <class ForwardIterator>
    ForwardIterator
    min_element(ForwardIterator first, ForwardIterator last);

template <class ForwardIterator, class Compare>
    ForwardIterator
    min_element(ForwardIterator first, ForwardIterator last, Compare comp);

template <class T>
    const T&
    min(const T& a, const T& b);  // constexpr in C++14

template <class T, class Compare>
    const T&
    min(const T& a, const T& b, Compare comp);  // constexpr in C++14

template<class T>
    T
    min(initializer_list<T> t);  // constexpr in C++14

template<class T, class Compare>
    T
    min(initializer_list<T> t, Compare comp);  // constexpr in C++14

template <class ForwardIterator>
    ForwardIterator
    max_element(ForwardIterator first, ForwardIterator last);

template <class ForwardIterator, class Compare>
    ForwardIterator
    max_element(ForwardIterator first, ForwardIterator last, Compare comp);

template <class T>
    const T&
    max(const T& a, const T& b); // constexpr in C++14

template <class T, class Compare>
    const T&
    max(const T& a, const T& b, Compare comp);  // constexpr in C++14

template<class T>
    T
    max(initializer_list<T> t);  // constexpr in C++14

template<class T, class Compare>
    T
    max(initializer_list<T> t, Compare comp);  // constexpr in C++14

template<class ForwardIterator>
    pair<ForwardIterator, ForwardIterator>
    minmax_element(ForwardIterator first, ForwardIterator last);

template<class ForwardIterator, class Compare>
    pair<ForwardIterator, ForwardIterator>
    minmax_element(ForwardIterator first, ForwardIterator last, Compare comp);

template<class T>
    pair<const T&, const T&>
    minmax(const T& a, const T& b);  // constexpr in C++14

template<class T, class Compare>
    pair<const T&, const T&>
    minmax(const T& a, const T& b, Compare comp);  // constexpr in C++14

template<class T>
    pair<T, T>
    minmax(initializer_list<T> t);  // constexpr in C++14

template<class T, class Compare>
    pair<T, T>
    minmax(initializer_list<T> t, Compare comp);  // constexpr in C++14

template <class InputIterator1, class InputIterator2>
    bool
    lexicographical_compare(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2);

template <class InputIterator1, class InputIterator2, class Compare>
    bool
    lexicographical_compare(InputIterator1 first1, InputIterator1 last1,
                            InputIterator2 first2, InputIterator2 last2, Compare comp);

template <class BidirectionalIterator>
    bool
    next_permutation(BidirectionalIterator first, BidirectionalIterator last);

template <class BidirectionalIterator, class Compare>
    bool
    next_permutation(BidirectionalIterator first, BidirectionalIterator last, Compare comp);

template <class BidirectionalIterator>
    bool
    prev_permutation(BidirectionalIterator first, BidirectionalIterator last);

template <class BidirectionalIterator, class Compare>
    bool
    prev_permutation(BidirectionalIterator first, BidirectionalIterator last, Compare comp);

}  // std

*/



# 1 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/initializer_list" 1 3
// -*- C++ -*-
//===----------------------- initializer_list -----------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is dual licensed under the MIT and the University of Illinois Open
// Source Licenses. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//




/*
    initializer_list synopsis

namespace std
{

template<class E>
class initializer_list
{
public:
    typedef E        value_type;
    typedef const E& reference;
    typedef const E& const_reference;
    typedef size_t   size_type;

    typedef const E* iterator;
    typedef const E* const_iterator;

    initializer_list() noexcept; // constexpr in C++14

    size_t   size()  const noexcept; // constexpr in C++14
    const E* begin() const noexcept; // constexpr in C++14
    const E* end()   const noexcept; // constexpr in C++14
};

template<class E> const E* begin(initializer_list<E> il) noexcept; // constexpr in C++14
template<class E> const E* end(initializer_list<E> il) noexcept; // constexpr in C++14

}  // std

*/



# 1 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/cstddef" 1 3
// -*- C++ -*-
//===--------------------------- cstddef ----------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is dual licensed under the MIT and the University of Illinois Open
// Source Licenses. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//




/*
    cstddef synopsis

Macros:

    offsetof(type,member-designator)
    NULL

namespace std
{

Types:

    ptrdiff_t
    size_t
    max_align_t
    nullptr_t

}  // std

*/




# 1 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../lib/clang/3.5.0/include/stddef.h" 1 3 4
/*===---- stddef.h - Basic type definitions --------------------------------===
 *
 * Copyright (c) 2008 Eli Friedman
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 *===-----------------------------------------------------------------------===
 */
# 38 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../lib/clang/3.5.0/include/stddef.h" 3 4
/* __need_wint_t is intentionally not defined here. */




/* Always define ptrdiff_t when modules are available. */



typedef long int ptrdiff_t;
# 64 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../lib/clang/3.5.0/include/stddef.h" 3 4
/* ISO9899:2011 7.20 (C11 Annex K): Define rsize_t if __STDC_WANT_LIB_EXT1__ is
 * enabled. */
# 133 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../lib/clang/3.5.0/include/stddef.h" 3 4
/* Some C libraries expect to see a wint_t here. Others (notably MinGW) will use
__WINT_TYPE__ directly; accommodate both by requiring __need_wint_t */
# 39 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/cstddef" 2 3
# 42 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/cstddef" 3


namespace std {inline namespace __1 {

using ::ptrdiff_t;
using ::size_t;





typedef long double max_align_t;




struct __attribute__ ((__type_visibility__("default"))) nullptr_t
{
    void* __lx;

    struct __nat {int __for_bool_;};

    __attribute__ ((__visibility__("hidden"), __always_inline__)) nullptr_t() : __lx(0) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) nullptr_t(int __nat::*) : __lx(0) {}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) operator int __nat::*() const {return 0;}

    template <class _Tp>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        operator _Tp* () const {return 0;}

    template <class _Tp, class _Up>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        operator _Tp _Up::* () const {return 0;}

    friend __attribute__ ((__visibility__("hidden"), __always_inline__)) bool operator==(nullptr_t, nullptr_t) {return true;}
    friend __attribute__ ((__visibility__("hidden"), __always_inline__)) bool operator!=(nullptr_t, nullptr_t) {return false;}
    friend __attribute__ ((__visibility__("hidden"), __always_inline__)) bool operator<(nullptr_t, nullptr_t) {return false;}
    friend __attribute__ ((__visibility__("hidden"), __always_inline__)) bool operator<=(nullptr_t, nullptr_t) {return true;}
    friend __attribute__ ((__visibility__("hidden"), __always_inline__)) bool operator>(nullptr_t, nullptr_t) {return false;}
    friend __attribute__ ((__visibility__("hidden"), __always_inline__)) bool operator>=(nullptr_t, nullptr_t) {return true;}
};

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) nullptr_t __get_nullptr_t() {return nullptr_t(0);}





} }
# 48 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/initializer_list" 2 3
# 51 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/initializer_list" 3


namespace std // purposefully not versioned
{
# 116 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/initializer_list" 3
} // std
# 625 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/algorithm" 2 3
# 1 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/type_traits" 1 3
// -*- C++ -*-
//===------------------------ type_traits ---------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is dual licensed under the MIT and the University of Illinois Open
// Source Licenses. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//




/*
    type_traits synopsis

namespace std
{

    // helper class:
    template <class T, T v> struct integral_constant;
    typedef integral_constant<bool, true>  true_type;
    typedef integral_constant<bool, false> false_type;

    // helper traits
    template <bool, class T = void> struct enable_if;
    template <bool, class T, class F> struct conditional;

    // Primary classification traits:
    template <class T> struct is_void;
    template <class T> struct is_null_pointer;  // C++14
    template <class T> struct is_integral;
    template <class T> struct is_floating_point;
    template <class T> struct is_array;
    template <class T> struct is_pointer;
    template <class T> struct is_lvalue_reference;
    template <class T> struct is_rvalue_reference;
    template <class T> struct is_member_object_pointer;
    template <class T> struct is_member_function_pointer;
    template <class T> struct is_enum;
    template <class T> struct is_union;
    template <class T> struct is_class;
    template <class T> struct is_function;

    // Secondary classification traits:
    template <class T> struct is_reference;
    template <class T> struct is_arithmetic;
    template <class T> struct is_fundamental;
    template <class T> struct is_member_pointer;
    template <class T> struct is_scalar;
    template <class T> struct is_object;
    template <class T> struct is_compound;

    // Const-volatile properties and transformations:
    template <class T> struct is_const;
    template <class T> struct is_volatile;
    template <class T> struct remove_const;
    template <class T> struct remove_volatile;
    template <class T> struct remove_cv;
    template <class T> struct add_const;
    template <class T> struct add_volatile;
    template <class T> struct add_cv;

    // Reference transformations:
    template <class T> struct remove_reference;
    template <class T> struct add_lvalue_reference;
    template <class T> struct add_rvalue_reference;

    // Pointer transformations:
    template <class T> struct remove_pointer;
    template <class T> struct add_pointer;

    // Integral properties:
    template <class T> struct is_signed;
    template <class T> struct is_unsigned;
    template <class T> struct make_signed;
    template <class T> struct make_unsigned;

    // Array properties and transformations:
    template <class T> struct rank;
    template <class T, unsigned I = 0> struct extent;
    template <class T> struct remove_extent;
    template <class T> struct remove_all_extents;

    // Member introspection:
    template <class T> struct is_pod;
    template <class T> struct is_trivial;
    template <class T> struct is_trivially_copyable;
    template <class T> struct is_standard_layout;
    template <class T> struct is_literal_type;
    template <class T> struct is_empty;
    template <class T> struct is_polymorphic;
    template <class T> struct is_abstract;
    template <class T> struct is_final; // C++14

    template <class T, class... Args> struct is_constructible;
    template <class T>                struct is_default_constructible;
    template <class T>                struct is_copy_constructible;
    template <class T>                struct is_move_constructible;
    template <class T, class U>       struct is_assignable;
    template <class T>                struct is_copy_assignable;
    template <class T>                struct is_move_assignable;
    template <class T>                struct is_destructible;

    template <class T, class... Args> struct is_trivially_constructible;
    template <class T>                struct is_trivially_default_constructible;
    template <class T>                struct is_trivially_copy_constructible;
    template <class T>                struct is_trivially_move_constructible;
    template <class T, class U>       struct is_trivially_assignable;
    template <class T>                struct is_trivially_copy_assignable;
    template <class T>                struct is_trivially_move_assignable;
    template <class T>                struct is_trivially_destructible;

    template <class T, class... Args> struct is_nothrow_constructible;
    template <class T>                struct is_nothrow_default_constructible;
    template <class T>                struct is_nothrow_copy_constructible;
    template <class T>                struct is_nothrow_move_constructible;
    template <class T, class U>       struct is_nothrow_assignable;
    template <class T>                struct is_nothrow_copy_assignable;
    template <class T>                struct is_nothrow_move_assignable;
    template <class T>                struct is_nothrow_destructible;

    template <class T> struct has_virtual_destructor;

    // Relationships between types:
    template <class T, class U> struct is_same;
    template <class Base, class Derived> struct is_base_of;
    template <class From, class To> struct is_convertible;

    // Alignment properties and transformations:
    template <class T> struct alignment_of;
    template <size_t Len, size_t Align = most_stringent_alignment_requirement>
        struct aligned_storage;
    template <size_t Len, class... Types> struct aligned_union;

    template <class T> struct decay;
    template <class... T> struct common_type;
    template <class T> struct underlying_type;
    template <class> class result_of; // undefined
    template <class Fn, class... ArgTypes> class result_of<Fn(ArgTypes...)>;

    // const-volatile modifications:
    template <class T>
      using remove_const_t    = typename remove_const<T>::type;  // C++14
    template <class T>
      using remove_volatile_t = typename remove_volatile<T>::type;  // C++14
    template <class T>
      using remove_cv_t       = typename remove_cv<T>::type;  // C++14
    template <class T>
      using add_const_t       = typename add_const<T>::type;  // C++14
    template <class T>
      using add_volatile_t    = typename add_volatile<T>::type;  // C++14
    template <class T>
      using add_cv_t          = typename add_cv<T>::type;  // C++14
  
    // reference modifications:
    template <class T>
      using remove_reference_t     = typename remove_reference<T>::type;  // C++14
    template <class T>
      using add_lvalue_reference_t = typename add_lvalue_reference<T>::type;  // C++14
    template <class T>
      using add_rvalue_reference_t = typename add_rvalue_reference<T>::type;  // C++14
  
    // sign modifications:
    template <class T>
      using make_signed_t   = typename make_signed<T>::type;  // C++14
    template <class T>
      using make_unsigned_t = typename make_unsigned<T>::type;  // C++14
  
    // array modifications:
    template <class T>
      using remove_extent_t      = typename remove_extent<T>::type;  // C++14
    template <class T>
      using remove_all_extents_t = typename remove_all_extents<T>::type;  // C++14

    // pointer modifications:
    template <class T>
      using remove_pointer_t = typename remove_pointer<T>::type;  // C++14
    template <class T>
      using add_pointer_t    = typename add_pointer<T>::type;  // C++14

    // other transformations:
    template <size_t Len, std::size_t Align=default-alignment>
      using aligned_storage_t = typename aligned_storage<Len,Align>::type;  // C++14
    template <std::size_t Len, class... Types>
      using aligned_union_t   = typename aligned_union<Len,Types...>::type;  // C++14
    template <class T>
      using decay_t           = typename decay<T>::type;  // C++14
    template <bool b, class T=void>
      using enable_if_t       = typename enable_if<b,T>::type;  // C++14
    template <bool b, class T, class F>
      using conditional_t     = typename conditional<b,T,F>::type;  // C++14
    template <class... T>
      using common_type_t     = typename common_type<T...>::type;  // C++14
    template <class T>
      using underlying_type_t = typename underlying_type<T>::type;  // C++14
    template <class F, class... ArgTypes>
      using result_of_t       = typename result_of<F(ArgTypes...)>::type;  // C++14

}  // std

*/
# 208 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/type_traits" 3


namespace std {inline namespace __1 {

template <bool _Bp, class _If, class _Then>
    struct __attribute__ ((__type_visibility__("default"))) conditional {typedef _If type;};
template <class _If, class _Then>
    struct __attribute__ ((__type_visibility__("default"))) conditional<false, _If, _Then> {typedef _Then type;};





template <bool, class _Tp = void> struct __attribute__ ((__type_visibility__("default"))) enable_if {};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) enable_if<true, _Tp> {typedef _Tp type;};






struct __two {char __lx[2];};

// helper class:

template <class _Tp, _Tp __v>
struct __attribute__ ((__type_visibility__("default"))) integral_constant
{
    static const _Tp value = __v;
    typedef _Tp value_type;
    typedef integral_constant type;
    __attribute__ ((__visibility__("hidden"), __always_inline__))
                          operator value_type() const throw() {return value;}




};

template <class _Tp, _Tp __v>
                  const _Tp integral_constant<_Tp, __v>::value;

typedef integral_constant<bool, true> true_type;
typedef integral_constant<bool, false> false_type;

// is_const

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_const : public false_type {};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_const<_Tp const> : public true_type {};

// is_volatile

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_volatile : public false_type {};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_volatile<_Tp volatile> : public true_type {};

// remove_const

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_const {typedef _Tp type;};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_const<const _Tp> {typedef _Tp type;};




// remove_volatile

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_volatile {typedef _Tp type;};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_volatile<volatile _Tp> {typedef _Tp type;};




// remove_cv

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_cv
{typedef typename remove_volatile<typename remove_const<_Tp>::type>::type type;};




// is_void

template <class _Tp> struct __libcpp_is_void : public false_type {};
template <> struct __libcpp_is_void<void> : public true_type {};

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_void
    : public __libcpp_is_void<typename remove_cv<_Tp>::type> {};

// __is_nullptr_t

template <class _Tp> struct __is_nullptr_t_impl : public false_type {};
template <> struct __is_nullptr_t_impl<nullptr_t> : public true_type {};

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) __is_nullptr_t
    : public __is_nullptr_t_impl<typename remove_cv<_Tp>::type> {};






// is_integral

template <class _Tp> struct __libcpp_is_integral : public false_type {};
template <> struct __libcpp_is_integral<bool> : public true_type {};
template <> struct __libcpp_is_integral<char> : public true_type {};
template <> struct __libcpp_is_integral<signed char> : public true_type {};
template <> struct __libcpp_is_integral<unsigned char> : public true_type {};
template <> struct __libcpp_is_integral<wchar_t> : public true_type {};

template <> struct __libcpp_is_integral<char16_t> : public true_type {};
template <> struct __libcpp_is_integral<char32_t> : public true_type {};

template <> struct __libcpp_is_integral<short> : public true_type {};
template <> struct __libcpp_is_integral<unsigned short> : public true_type {};
template <> struct __libcpp_is_integral<int> : public true_type {};
template <> struct __libcpp_is_integral<unsigned int> : public true_type {};
template <> struct __libcpp_is_integral<long> : public true_type {};
template <> struct __libcpp_is_integral<unsigned long> : public true_type {};
template <> struct __libcpp_is_integral<long long> : public true_type {};
template <> struct __libcpp_is_integral<unsigned long long> : public true_type {};

template <> struct __libcpp_is_integral<__int128_t> : public true_type {};
template <> struct __libcpp_is_integral<__uint128_t> : public true_type {};


template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_integral
    : public __libcpp_is_integral<typename remove_cv<_Tp>::type> {};

// is_floating_point

template <class _Tp> struct __libcpp_is_floating_point : public false_type {};
template <> struct __libcpp_is_floating_point<float> : public true_type {};
template <> struct __libcpp_is_floating_point<double> : public true_type {};
template <> struct __libcpp_is_floating_point<long double> : public true_type {};

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_floating_point
    : public __libcpp_is_floating_point<typename remove_cv<_Tp>::type> {};

// is_array

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_array
    : public false_type {};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_array<_Tp[]>
    : public true_type {};
template <class _Tp, size_t _Np> struct __attribute__ ((__type_visibility__("default"))) is_array<_Tp[_Np]>
    : public true_type {};

// is_pointer

template <class _Tp> struct __libcpp_is_pointer : public false_type {};
template <class _Tp> struct __libcpp_is_pointer<_Tp*> : public true_type {};

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_pointer
    : public __libcpp_is_pointer<typename remove_cv<_Tp>::type> {};

// is_reference

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_lvalue_reference : public false_type {};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_lvalue_reference<_Tp&> : public true_type {};

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_rvalue_reference : public false_type {};




template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_reference : public false_type {};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_reference<_Tp&> : public true_type {};




// is_union



template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_union
    : public integral_constant<bool, __is_union(_Tp)> {};
# 394 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/type_traits" 3
// is_class



template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_class
    : public integral_constant<bool, __is_class(_Tp)> {};
# 414 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/type_traits" 3
// is_same

template <class _Tp, class _Up> struct __attribute__ ((__type_visibility__("default"))) is_same : public false_type {};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_same<_Tp, _Tp> : public true_type {};

// is_function

namespace __libcpp_is_function_imp
{
template <class _Tp> char __test(_Tp*);
template <class _Tp> __two __test(...);
template <class _Tp> _Tp& __source();
}

template <class _Tp, bool = is_class<_Tp>::value ||
                            is_union<_Tp>::value ||
                            is_void<_Tp>::value ||
                            is_reference<_Tp>::value ||
                            __is_nullptr_t<_Tp>::value >
struct __libcpp_is_function
    : public integral_constant<bool, sizeof(__libcpp_is_function_imp::__test<_Tp>(__libcpp_is_function_imp::__source<_Tp>())) == 1>
    {};
template <class _Tp> struct __libcpp_is_function<_Tp, true> : public false_type {};

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_function
    : public __libcpp_is_function<_Tp> {};

// is_member_function_pointer

// template <class _Tp> struct            __libcpp_is_member_function_pointer             : public false_type {};
// template <class _Tp, class _Up> struct __libcpp_is_member_function_pointer<_Tp _Up::*> : public is_function<_Tp> {};
// 

template <class _MP, bool _IsMemberFuctionPtr, bool _IsMemberObjectPtr>
struct __member_pointer_traits_imp
{ // forward declaration; specializations later
};


namespace __libcpp_is_member_function_pointer_imp {
    template <typename _Tp>
    char __test(typename std::__member_pointer_traits_imp<_Tp, true, false>::_FnType *);

    template <typename>
    std::__two __test(...);
};

template <class _Tp> struct __libcpp_is_member_function_pointer
    : public integral_constant<bool, sizeof(__libcpp_is_member_function_pointer_imp::__test<_Tp>(std::__1::__get_nullptr_t())) == 1> {};

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_member_function_pointer
    : public __libcpp_is_member_function_pointer<typename remove_cv<_Tp>::type> {};

// is_member_pointer

template <class _Tp> struct __libcpp_is_member_pointer : public false_type {};
template <class _Tp, class _Up> struct __libcpp_is_member_pointer<_Tp _Up::*> : public true_type {};

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_member_pointer
    : public __libcpp_is_member_pointer<typename remove_cv<_Tp>::type> {};

// is_member_object_pointer

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_member_object_pointer
    : public integral_constant<bool, is_member_pointer<_Tp>::value &&
                                    !is_member_function_pointer<_Tp>::value> {};

// is_enum



template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_enum
    : public integral_constant<bool, __is_enum(_Tp)> {};
# 504 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/type_traits" 3
// is_arithmetic

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_arithmetic
    : public integral_constant<bool, is_integral<_Tp>::value ||
                                     is_floating_point<_Tp>::value> {};

// is_fundamental

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_fundamental
    : public integral_constant<bool, is_void<_Tp>::value ||
                                     __is_nullptr_t<_Tp>::value ||
                                     is_arithmetic<_Tp>::value> {};

// is_scalar

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_scalar
    : public integral_constant<bool, is_arithmetic<_Tp>::value ||
                                     is_member_pointer<_Tp>::value ||
                                     is_pointer<_Tp>::value ||
                                     __is_nullptr_t<_Tp>::value ||
                                     is_enum<_Tp>::value > {};

template <> struct __attribute__ ((__type_visibility__("default"))) is_scalar<nullptr_t> : public true_type {};

// is_object

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_object
    : public integral_constant<bool, is_scalar<_Tp>::value ||
                                     is_array<_Tp>::value ||
                                     is_union<_Tp>::value ||
                                     is_class<_Tp>::value > {};

// is_compound

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_compound
    : public integral_constant<bool, !is_fundamental<_Tp>::value> {};

// add_const

template <class _Tp, bool = is_reference<_Tp>::value ||
                            is_function<_Tp>::value ||
                            is_const<_Tp>::value >
struct __add_const {typedef _Tp type;};

template <class _Tp>
struct __add_const<_Tp, false> {typedef const _Tp type;};

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) add_const
    {typedef typename __add_const<_Tp>::type type;};





// add_volatile

template <class _Tp, bool = is_reference<_Tp>::value ||
                            is_function<_Tp>::value ||
                            is_volatile<_Tp>::value >
struct __add_volatile {typedef _Tp type;};

template <class _Tp>
struct __add_volatile<_Tp, false> {typedef volatile _Tp type;};

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) add_volatile
    {typedef typename __add_volatile<_Tp>::type type;};





// add_cv

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) add_cv
    {typedef typename add_const<typename add_volatile<_Tp>::type>::type type;};





// remove_reference

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_reference {typedef _Tp type;};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_reference<_Tp&> {typedef _Tp type;};
# 596 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/type_traits" 3
// add_lvalue_reference

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) add_lvalue_reference {typedef _Tp& type;};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) add_lvalue_reference<_Tp&> {typedef _Tp& type;}; // for older compiler
template <> struct __attribute__ ((__type_visibility__("default"))) add_lvalue_reference<void> {typedef void type;};
template <> struct __attribute__ ((__type_visibility__("default"))) add_lvalue_reference<const void> {typedef const void type;};
template <> struct __attribute__ ((__type_visibility__("default"))) add_lvalue_reference<volatile void> {typedef volatile void type;};
template <> struct __attribute__ ((__type_visibility__("default"))) add_lvalue_reference<const volatile void> {typedef const volatile void type;};
# 631 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/type_traits" 3
template <class _Tp>
typename add_lvalue_reference<_Tp>::type
declval();



struct __any
{
    __any(...);
};

// remove_pointer

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_pointer {typedef _Tp type;};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_pointer<_Tp*> {typedef _Tp type;};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_pointer<_Tp* const> {typedef _Tp type;};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_pointer<_Tp* volatile> {typedef _Tp type;};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_pointer<_Tp* const volatile> {typedef _Tp type;};





// add_pointer

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) add_pointer
    {typedef typename remove_reference<_Tp>::type* type;};





// is_signed

template <class _Tp, bool = is_integral<_Tp>::value>
struct __libcpp_is_signed_impl : public integral_constant<bool, _Tp(-1) < _Tp(0)> {};

template <class _Tp>
struct __libcpp_is_signed_impl<_Tp, false> : public true_type {}; // floating point

template <class _Tp, bool = is_arithmetic<_Tp>::value>
struct __libcpp_is_signed : public __libcpp_is_signed_impl<_Tp> {};

template <class _Tp> struct __libcpp_is_signed<_Tp, false> : public false_type {};

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_signed : public __libcpp_is_signed<_Tp> {};

// is_unsigned

template <class _Tp, bool = is_integral<_Tp>::value>
struct __libcpp_is_unsigned_impl : public integral_constant<bool, _Tp(0) < _Tp(-1)> {};

template <class _Tp>
struct __libcpp_is_unsigned_impl<_Tp, false> : public false_type {}; // floating point

template <class _Tp, bool = is_arithmetic<_Tp>::value>
struct __libcpp_is_unsigned : public __libcpp_is_unsigned_impl<_Tp> {};

template <class _Tp> struct __libcpp_is_unsigned<_Tp, false> : public false_type {};

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_unsigned : public __libcpp_is_unsigned<_Tp> {};

// rank

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) rank
    : public integral_constant<size_t, 0> {};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) rank<_Tp[]>
    : public integral_constant<size_t, rank<_Tp>::value + 1> {};
template <class _Tp, size_t _Np> struct __attribute__ ((__type_visibility__("default"))) rank<_Tp[_Np]>
    : public integral_constant<size_t, rank<_Tp>::value + 1> {};

// extent

template <class _Tp, unsigned _Ip = 0> struct __attribute__ ((__type_visibility__("default"))) extent
    : public integral_constant<size_t, 0> {};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) extent<_Tp[], 0>
    : public integral_constant<size_t, 0> {};
template <class _Tp, unsigned _Ip> struct __attribute__ ((__type_visibility__("default"))) extent<_Tp[], _Ip>
    : public integral_constant<size_t, extent<_Tp, _Ip-1>::value> {};
template <class _Tp, size_t _Np> struct __attribute__ ((__type_visibility__("default"))) extent<_Tp[_Np], 0>
    : public integral_constant<size_t, _Np> {};
template <class _Tp, size_t _Np, unsigned _Ip> struct __attribute__ ((__type_visibility__("default"))) extent<_Tp[_Np], _Ip>
    : public integral_constant<size_t, extent<_Tp, _Ip-1>::value> {};

// remove_extent

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_extent
    {typedef _Tp type;};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_extent<_Tp[]>
    {typedef _Tp type;};
template <class _Tp, size_t _Np> struct __attribute__ ((__type_visibility__("default"))) remove_extent<_Tp[_Np]>
    {typedef _Tp type;};





// remove_all_extents

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_all_extents
    {typedef _Tp type;};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_all_extents<_Tp[]>
    {typedef typename remove_all_extents<_Tp>::type type;};
template <class _Tp, size_t _Np> struct __attribute__ ((__type_visibility__("default"))) remove_all_extents<_Tp[_Np]>
    {typedef typename remove_all_extents<_Tp>::type type;};





// decay

template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) decay
{
private:
    typedef typename remove_reference<_Tp>::type _Up;
public:
    typedef typename conditional
                     <
                         is_array<_Up>::value,
                         typename remove_extent<_Up>::type*,
                         typename conditional
                         <
                              is_function<_Up>::value,
                              typename add_pointer<_Up>::type,
                              typename remove_cv<_Up>::type
                         >::type
                     >::type type;
};





// is_abstract

namespace __is_abstract_imp
{
template <class _Tp> char __test(_Tp (*)[1]);
template <class _Tp> __two __test(...);
}

template <class _Tp, bool = is_class<_Tp>::value>
struct __libcpp_abstract : public integral_constant<bool, sizeof(__is_abstract_imp::__test<_Tp>(0)) != 1> {};

template <class _Tp> struct __libcpp_abstract<_Tp, false> : public false_type {};

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_abstract : public __libcpp_abstract<_Tp> {};

// is_final






// is_base_of



template <class _Bp, class _Dp>
struct __attribute__ ((__type_visibility__("default"))) is_base_of
    : public integral_constant<bool, __is_base_of(_Bp, _Dp)> {};
# 823 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/type_traits" 3
// is_convertible



template <class _T1, class _T2> struct __attribute__ ((__type_visibility__("default"))) is_convertible
    : public integral_constant<bool, __is_convertible_to(_T1, _T2) &&
                                     !is_abstract<_T2>::value> {};
# 942 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/type_traits" 3
// is_empty



template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_empty
    : public integral_constant<bool, __is_empty(_Tp)> {};
# 973 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/type_traits" 3
// is_polymorphic



template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_polymorphic
    : public integral_constant<bool, __is_polymorphic(_Tp)> {};
# 993 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/type_traits" 3
// has_virtual_destructor



template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) has_virtual_destructor
    : public integral_constant<bool, __has_virtual_destructor(_Tp)> {};
# 1007 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/type_traits" 3
// alignment_of

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) alignment_of
    : public integral_constant<size_t, __alignof__(_Tp)> {};

// aligned_storage

template <class _Hp, class _Tp>
struct __type_list
{
    typedef _Hp _Head;
    typedef _Tp _Tail;
};

struct __nat
{






};

template <class _Tp>
struct __align_type
{
    static const size_t value = alignment_of<_Tp>::value;
    typedef _Tp type;
};

struct __struct_double {long double __lx;};
struct __struct_double4 {double __lx[4];};

typedef
    __type_list<__align_type<unsigned char>,
    __type_list<__align_type<unsigned short>,
    __type_list<__align_type<unsigned int>,
    __type_list<__align_type<unsigned long>,
    __type_list<__align_type<unsigned long long>,
    __type_list<__align_type<double>,
    __type_list<__align_type<long double>,
    __type_list<__align_type<__struct_double>,
    __type_list<__align_type<__struct_double4>,
    __type_list<__align_type<int*>,
    __nat
    > > > > > > > > > > __all_types;

template <class _TL, size_t _Align> struct __find_pod;

template <class _Hp, size_t _Align>
struct __find_pod<__type_list<_Hp, __nat>, _Align>
{
    typedef typename conditional<
                             _Align == _Hp::value,
                             typename _Hp::type,
                             void
                         >::type type;
};

template <class _Hp, class _Tp, size_t _Align>
struct __find_pod<__type_list<_Hp, _Tp>, _Align>
{
    typedef typename conditional<
                             _Align == _Hp::value,
                             typename _Hp::type,
                             typename __find_pod<_Tp, _Align>::type
                         >::type type;
};

template <class _TL, size_t _Len> struct __find_max_align;

template <class _Hp, size_t _Len>
struct __find_max_align<__type_list<_Hp, __nat>, _Len> : public integral_constant<size_t, _Hp::value> {};

template <size_t _Len, size_t _A1, size_t _A2>
struct __select_align
{
private:
    static const size_t __min = _A2 < _A1 ? _A2 : _A1;
    static const size_t __max = _A1 < _A2 ? _A2 : _A1;
public:
    static const size_t value = _Len < __max ? __min : __max;
};

template <class _Hp, class _Tp, size_t _Len>
struct __find_max_align<__type_list<_Hp, _Tp>, _Len>
    : public integral_constant<size_t, __select_align<_Len, _Hp::value, __find_max_align<_Tp, _Len>::value>::value> {};

template <size_t _Len, size_t _Align = __find_max_align<__all_types, _Len>::value>
struct __attribute__ ((__type_visibility__("default"))) aligned_storage
{
    typedef typename __find_pod<__all_types, _Align>::type _Aligner;
    typedef __static_assert_check<sizeof(__static_assert_test<(!is_void<_Aligner>::value)>)> __t1100;
    union type
    {
        _Aligner __align;
        unsigned char __data[_Len];
    };
};
# 1123 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/type_traits" 3
template <size_t _Len>struct __attribute__ ((__type_visibility__("default"))) aligned_storage<_Len, 0x1>{ struct __attribute__((__aligned__(0x1))) type { unsigned char __lx[_Len]; };};
template <size_t _Len>struct __attribute__ ((__type_visibility__("default"))) aligned_storage<_Len, 0x2>{ struct __attribute__((__aligned__(0x2))) type { unsigned char __lx[_Len]; };};
template <size_t _Len>struct __attribute__ ((__type_visibility__("default"))) aligned_storage<_Len, 0x4>{ struct __attribute__((__aligned__(0x4))) type { unsigned char __lx[_Len]; };};
template <size_t _Len>struct __attribute__ ((__type_visibility__("default"))) aligned_storage<_Len, 0x8>{ struct __attribute__((__aligned__(0x8))) type { unsigned char __lx[_Len]; };};
template <size_t _Len>struct __attribute__ ((__type_visibility__("default"))) aligned_storage<_Len, 0x10>{ struct __attribute__((__aligned__(0x10))) type { unsigned char __lx[_Len]; };};
template <size_t _Len>struct __attribute__ ((__type_visibility__("default"))) aligned_storage<_Len, 0x20>{ struct __attribute__((__aligned__(0x20))) type { unsigned char __lx[_Len]; };};
template <size_t _Len>struct __attribute__ ((__type_visibility__("default"))) aligned_storage<_Len, 0x40>{ struct __attribute__((__aligned__(0x40))) type { unsigned char __lx[_Len]; };};
template <size_t _Len>struct __attribute__ ((__type_visibility__("default"))) aligned_storage<_Len, 0x80>{ struct __attribute__((__aligned__(0x80))) type { unsigned char __lx[_Len]; };};
template <size_t _Len>struct __attribute__ ((__type_visibility__("default"))) aligned_storage<_Len, 0x100>{ struct __attribute__((__aligned__(0x100))) type { unsigned char __lx[_Len]; };};
template <size_t _Len>struct __attribute__ ((__type_visibility__("default"))) aligned_storage<_Len, 0x200>{ struct __attribute__((__aligned__(0x200))) type { unsigned char __lx[_Len]; };};
template <size_t _Len>struct __attribute__ ((__type_visibility__("default"))) aligned_storage<_Len, 0x400>{ struct __attribute__((__aligned__(0x400))) type { unsigned char __lx[_Len]; };};
template <size_t _Len>struct __attribute__ ((__type_visibility__("default"))) aligned_storage<_Len, 0x800>{ struct __attribute__((__aligned__(0x800))) type { unsigned char __lx[_Len]; };};
template <size_t _Len>struct __attribute__ ((__type_visibility__("default"))) aligned_storage<_Len, 0x1000>{ struct __attribute__((__aligned__(0x1000))) type { unsigned char __lx[_Len]; };};
template <size_t _Len>struct __attribute__ ((__type_visibility__("default"))) aligned_storage<_Len, 0x2000>{ struct __attribute__((__aligned__(0x2000))) type { unsigned char __lx[_Len]; };};
// MSDN says that MSVC does not support alignment beyond 8192 (=0x2000)

template <size_t _Len>struct __attribute__ ((__type_visibility__("default"))) aligned_storage<_Len, 0x4000>{ struct __attribute__((__aligned__(0x4000))) type { unsigned char __lx[_Len]; };};
# 1180 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/type_traits" 3
template <class _Tp>
struct __numeric_type
{
   static void __test(...);
   static float __test(float);
   static double __test(char);
   static double __test(int);
   static double __test(unsigned);
   static double __test(long);
   static double __test(unsigned long);
   static double __test(long long);
   static double __test(unsigned long long);
   static double __test(double);
   static long double __test(long double);

   typedef __typeof__(__test(declval<_Tp>())) type;
   static const bool value = !is_same<type, void>::value;
};

template <>
struct __numeric_type<void>
{
   static const bool value = true;
};

// __promote

template <class _A1, class _A2 = void, class _A3 = void,
          bool = __numeric_type<_A1>::value &&
                 __numeric_type<_A2>::value &&
                 __numeric_type<_A3>::value>
class __promote
{
    static const bool value = false;
};

template <class _A1, class _A2, class _A3>
class __promote<_A1, _A2, _A3, true>
{
private:
    typedef typename __promote<_A1>::type __type1;
    typedef typename __promote<_A2>::type __type2;
    typedef typename __promote<_A3>::type __type3;
public:
    typedef __typeof__(__type1() + __type2() + __type3()) type;
    static const bool value = true;
};

template <class _A1, class _A2>
class __promote<_A1, _A2, void, true>
{
private:
    typedef typename __promote<_A1>::type __type1;
    typedef typename __promote<_A2>::type __type2;
public:
    typedef __typeof__(__type1() + __type2()) type;
    static const bool value = true;
};

template <class _A1>
class __promote<_A1, void, void, true>
{
public:
    typedef typename __numeric_type<_A1>::type type;
    static const bool value = true;
    static const bool __does_not_throw = false;
};
# 1260 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/type_traits" 3
// make_signed / make_unsigned

typedef
    __type_list<signed char,
    __type_list<signed short,
    __type_list<signed int,
    __type_list<signed long,
    __type_list<signed long long,

    __type_list<__int128_t,

    __nat

    >

    > > > > > __signed_types;

typedef
    __type_list<unsigned char,
    __type_list<unsigned short,
    __type_list<unsigned int,
    __type_list<unsigned long,
    __type_list<unsigned long long,

    __type_list<__uint128_t,

    __nat

    >

    > > > > > __unsigned_types;

template <class _TypeList, size_t _Size, bool = _Size <= sizeof(typename _TypeList::_Head)> struct __find_first;

template <class _Hp, class _Tp, size_t _Size>
struct __find_first<__type_list<_Hp, _Tp>, _Size, true>
{
    typedef _Hp type;
};

template <class _Hp, class _Tp, size_t _Size>
struct __find_first<__type_list<_Hp, _Tp>, _Size, false>
{
    typedef typename __find_first<_Tp, _Size>::type type;
};

template <class _Tp, class _Up, bool = is_const<typename remove_reference<_Tp>::type>::value,
                             bool = is_volatile<typename remove_reference<_Tp>::type>::value>
struct __apply_cv
{
    typedef _Up type;
};

template <class _Tp, class _Up>
struct __apply_cv<_Tp, _Up, true, false>
{
    typedef const _Up type;
};

template <class _Tp, class _Up>
struct __apply_cv<_Tp, _Up, false, true>
{
    typedef volatile _Up type;
};

template <class _Tp, class _Up>
struct __apply_cv<_Tp, _Up, true, true>
{
    typedef const volatile _Up type;
};

template <class _Tp, class _Up>
struct __apply_cv<_Tp&, _Up, false, false>
{
    typedef _Up& type;
};

template <class _Tp, class _Up>
struct __apply_cv<_Tp&, _Up, true, false>
{
    typedef const _Up& type;
};

template <class _Tp, class _Up>
struct __apply_cv<_Tp&, _Up, false, true>
{
    typedef volatile _Up& type;
};

template <class _Tp, class _Up>
struct __apply_cv<_Tp&, _Up, true, true>
{
    typedef const volatile _Up& type;
};

template <class _Tp, bool = is_integral<_Tp>::value || is_enum<_Tp>::value>
struct __make_signed {};

template <class _Tp>
struct __make_signed<_Tp, true>
{
    typedef typename __find_first<__signed_types, sizeof(_Tp)>::type type;
};

template <> struct __make_signed<bool, true> {};
template <> struct __make_signed< signed short, true> {typedef short type;};
template <> struct __make_signed<unsigned short, true> {typedef short type;};
template <> struct __make_signed< signed int, true> {typedef int type;};
template <> struct __make_signed<unsigned int, true> {typedef int type;};
template <> struct __make_signed< signed long, true> {typedef long type;};
template <> struct __make_signed<unsigned long, true> {typedef long type;};
template <> struct __make_signed< signed long long, true> {typedef long long type;};
template <> struct __make_signed<unsigned long long, true> {typedef long long type;};

template <> struct __make_signed<__int128_t, true> {typedef __int128_t type;};
template <> struct __make_signed<__uint128_t, true> {typedef __int128_t type;};


template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) make_signed
{
    typedef typename __apply_cv<_Tp, typename __make_signed<typename remove_cv<_Tp>::type>::type>::type type;
};





template <class _Tp, bool = is_integral<_Tp>::value || is_enum<_Tp>::value>
struct __make_unsigned {};

template <class _Tp>
struct __make_unsigned<_Tp, true>
{
    typedef typename __find_first<__unsigned_types, sizeof(_Tp)>::type type;
};

template <> struct __make_unsigned<bool, true> {};
template <> struct __make_unsigned< signed short, true> {typedef unsigned short type;};
template <> struct __make_unsigned<unsigned short, true> {typedef unsigned short type;};
template <> struct __make_unsigned< signed int, true> {typedef unsigned int type;};
template <> struct __make_unsigned<unsigned int, true> {typedef unsigned int type;};
template <> struct __make_unsigned< signed long, true> {typedef unsigned long type;};
template <> struct __make_unsigned<unsigned long, true> {typedef unsigned long type;};
template <> struct __make_unsigned< signed long long, true> {typedef unsigned long long type;};
template <> struct __make_unsigned<unsigned long long, true> {typedef unsigned long long type;};

template <> struct __make_unsigned<__int128_t, true> {typedef __uint128_t type;};
template <> struct __make_unsigned<__uint128_t, true> {typedef __uint128_t type;};


template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) make_unsigned
{
    typedef typename __apply_cv<_Tp, typename __make_unsigned<typename remove_cv<_Tp>::type>::type>::type type;
};







template <class _Tp, class _Up = void, class V = void>
struct __attribute__ ((__type_visibility__("default"))) common_type
{
public:
    typedef typename common_type<typename common_type<_Tp, _Up>::type, V>::type type;
};

template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) common_type<_Tp, void, void>
{
public:
    typedef typename decay<_Tp>::type type;
};

template <class _Tp, class _Up>
struct __attribute__ ((__type_visibility__("default"))) common_type<_Tp, _Up, void>
{
private:




    static _Tp __t();
    static _Up __u();

public:
    typedef typename remove_reference<__typeof__(true ? __t() : __u())>::type type;
};
# 1485 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/type_traits" 3
// is_assignable

template<typename, typename _Tp> struct __select_2nd { typedef _Tp type; };

template <class _Tp, class _Arg>
typename __select_2nd<__typeof__((std::__1::declval<_Tp>() = std::__1::declval<_Arg>())), true_type>::type



__is_assignable_test(_Tp, _Arg&);


template <class _Arg>
false_type



__is_assignable_test(__any, _Arg&);


template <class _Tp, class _Arg, bool = is_void<_Tp>::value || is_void<_Arg>::value>
struct __is_assignable_imp
    : public common_type
        <
            __typeof__(__is_assignable_test(declval<_Tp>(), declval<_Arg>()))
        >::type {};

template <class _Tp, class _Arg>
struct __is_assignable_imp<_Tp, _Arg, true>
    : public false_type
{
};

template <class _Tp, class _Arg>
struct is_assignable
    : public __is_assignable_imp<_Tp, _Arg> {};

// is_copy_assignable

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_copy_assignable
    : public is_assignable<typename add_lvalue_reference<_Tp>::type,
                     const typename add_lvalue_reference<_Tp>::type> {};

// is_move_assignable

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_move_assignable




    : public is_copy_assignable<_Tp> {};


// is_destructible

//	if it's a reference, return true
//	if it's a function, return false
//	if it's   void,     return false
//	if it's an array of unknown bound, return false
//	Otherwise, return "std::declval<_Up&>().~_Up()" is well-formed
//    where _Up is remove_all_extents<_Tp>::type

template <class>
struct __is_destructible_apply { typedef int type; };

template <typename _Tp>
struct __is_destructor_wellformed {
 template <typename _Tp1>
 static char __test (
        typename __is_destructible_apply<__typeof__(std::__1::declval<_Tp1&>().~_Tp1())>::type
    );

 template <typename _Tp1>
 static __two __test (...);

 static const bool value = sizeof(__test<_Tp>(12)) == sizeof(char);
};

template <class _Tp, bool>
struct __destructible_imp;

template <class _Tp>
struct __destructible_imp<_Tp, false>
   : public std::__1::integral_constant<bool,
        __is_destructor_wellformed<typename std::__1::remove_all_extents<_Tp>::type>::value> {};

template <class _Tp>
struct __destructible_imp<_Tp, true>
    : public std::__1::true_type {};

template <class _Tp, bool>
struct __destructible_false;

template <class _Tp>
struct __destructible_false<_Tp, false> : public __destructible_imp<_Tp, std::__1::is_reference<_Tp>::value> {};

template <class _Tp>
struct __destructible_false<_Tp, true> : public std::__1::false_type {};

template <class _Tp>
struct is_destructible
    : public __destructible_false<_Tp, std::__1::is_function<_Tp>::value> {};

template <class _Tp>
struct is_destructible<_Tp[]>
    : public std::__1::false_type {};

template <>
struct is_destructible<void>
    : public std::__1::false_type {};

// move
# 1629 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/type_traits" 3
template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_Tp&
move(_Tp& __t)
{
    return __t;
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
const _Tp&
move(const _Tp& __t)
{
    return __t;
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_Tp&
forward(typename std::remove_reference<_Tp>::type& __t) throw()
{
    return __t;
}


template <class _Tp>
class __rv
{
    typedef typename remove_reference<_Tp>::type _Trr;
    _Trr& t_;
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    _Trr* operator->() {return &t_;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit __rv(_Trr& __t) : t_(__t) {}
};
# 1680 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/type_traits" 3
template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename decay<_Tp>::type
__decay_copy(const _Tp& __t)
{
    return std::__1::forward<_Tp>(__t);
}
# 1794 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/type_traits" 3
template <class _Rp, class _Class>
struct __member_pointer_traits_imp<_Rp (_Class::*)(), true, false>
{
    typedef _Class _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) ();
};

template <class _Rp, class _Class, class _P0>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_P0), true, false>
{
    typedef _Class _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_P0);
};

template <class _Rp, class _Class, class _P0, class _P1>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1), true, false>
{
    typedef _Class _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_P0, _P1);
};

template <class _Rp, class _Class, class _P0, class _P1, class _P2>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2), true, false>
{
    typedef _Class _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_P0, _P1, _P2);
};

template <class _Rp, class _Class>
struct __member_pointer_traits_imp<_Rp (_Class::*)() const, true, false>
{
    typedef _Class const _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) ();
};

template <class _Rp, class _Class, class _P0>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_P0) const, true, false>
{
    typedef _Class const _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_P0);
};

template <class _Rp, class _Class, class _P0, class _P1>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1) const, true, false>
{
    typedef _Class const _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_P0, _P1);
};

template <class _Rp, class _Class, class _P0, class _P1, class _P2>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2) const, true, false>
{
    typedef _Class const _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_P0, _P1, _P2);
};

template <class _Rp, class _Class>
struct __member_pointer_traits_imp<_Rp (_Class::*)() volatile, true, false>
{
    typedef _Class volatile _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) ();
};

template <class _Rp, class _Class, class _P0>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_P0) volatile, true, false>
{
    typedef _Class volatile _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_P0);
};

template <class _Rp, class _Class, class _P0, class _P1>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1) volatile, true, false>
{
    typedef _Class volatile _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_P0, _P1);
};

template <class _Rp, class _Class, class _P0, class _P1, class _P2>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2) volatile, true, false>
{
    typedef _Class volatile _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_P0, _P1, _P2);
};

template <class _Rp, class _Class>
struct __member_pointer_traits_imp<_Rp (_Class::*)() const volatile, true, false>
{
    typedef _Class const volatile _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) ();
};

template <class _Rp, class _Class, class _P0>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_P0) const volatile, true, false>
{
    typedef _Class const volatile _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_P0);
};

template <class _Rp, class _Class, class _P0, class _P1>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1) const volatile, true, false>
{
    typedef _Class const volatile _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_P0, _P1);
};

template <class _Rp, class _Class, class _P0, class _P1, class _P2>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2) const volatile, true, false>
{
    typedef _Class const volatile _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_P0, _P1, _P2);
};



template <class _Rp, class _Class>
struct __member_pointer_traits_imp<_Rp _Class::*, false, true>
{
    typedef _Class _ClassType;
    typedef _Rp _ReturnType;
};

template <class _MP>
struct __member_pointer_traits
    : public __member_pointer_traits_imp<typename remove_cv<_MP>::type,
                    is_member_function_pointer<_MP>::value,
                    is_member_object_pointer<_MP>::value>
{
//     typedef ... _ClassType;
//     typedef ... _ReturnType;
//     typedef ... _FnType;
};

// result_of

template <class _Callable> class result_of;



template <class _Fn, bool, bool>
class __result_of
{
};

template <class _Fn>
class __result_of<_Fn(), true, false>
{
public:
    typedef __typeof__(declval<_Fn>()()) type;
};

template <class _Fn, class _A0>
class __result_of<_Fn(_A0), true, false>
{
public:
    typedef __typeof__(declval<_Fn>()(declval<_A0>())) type;
};

template <class _Fn, class _A0, class _A1>
class __result_of<_Fn(_A0, _A1), true, false>
{
public:
    typedef __typeof__(declval<_Fn>()(declval<_A0>(), declval<_A1>())) type;
};

template <class _Fn, class _A0, class _A1, class _A2>
class __result_of<_Fn(_A0, _A1, _A2), true, false>
{
public:
    typedef __typeof__(declval<_Fn>()(declval<_A0>(), declval<_A1>(), declval<_A2>())) type;
};

template <class _MP, class _Tp, bool _IsMemberFunctionPtr>
struct __result_of_mp;

// member function pointer

template <class _MP, class _Tp>
struct __result_of_mp<_MP, _Tp, true>
    : public common_type<typename __member_pointer_traits<_MP>::_ReturnType>
{
};

// member data pointer

template <class _MP, class _Tp, bool>
struct __result_of_mdp;

template <class _Rp, class _Class, class _Tp>
struct __result_of_mdp<_Rp _Class::*, _Tp, false>
{
    typedef typename __apply_cv<__typeof__(*std::__1::declval<_Tp>()), _Rp>::type& type;
};

template <class _Rp, class _Class, class _Tp>
struct __result_of_mdp<_Rp _Class::*, _Tp, true>
{
    typedef typename __apply_cv<_Tp, _Rp>::type& type;
};

template <class _Rp, class _Class, class _Tp>
struct __result_of_mp<_Rp _Class::*, _Tp, false>
    : public __result_of_mdp<_Rp _Class::*, _Tp,
            is_base_of<_Class, typename remove_reference<_Tp>::type>::value>
{
};



template <class _Fn, class _Tp>
class __result_of<_Fn(_Tp), false, true> // _Fn must be member pointer
    : public __result_of_mp<typename remove_reference<_Fn>::type,
                            _Tp,
                            is_member_function_pointer<typename remove_reference<_Fn>::type>::value>
{
};

template <class _Fn, class _Tp, class _A0>
class __result_of<_Fn(_Tp, _A0), false, true> // _Fn must be member pointer
    : public __result_of_mp<typename remove_reference<_Fn>::type,
                            _Tp,
                            is_member_function_pointer<typename remove_reference<_Fn>::type>::value>
{
};

template <class _Fn, class _Tp, class _A0, class _A1>
class __result_of<_Fn(_Tp, _A0, _A1), false, true> // _Fn must be member pointer
    : public __result_of_mp<typename remove_reference<_Fn>::type,
                            _Tp,
                            is_member_function_pointer<typename remove_reference<_Fn>::type>::value>
{
};

template <class _Fn, class _Tp, class _A0, class _A1, class _A2>
class __result_of<_Fn(_Tp, _A0, _A1, _A2), false, true> // _Fn must be member pointer
    : public __result_of_mp<typename remove_reference<_Fn>::type,
                            _Tp,
                            is_member_function_pointer<typename remove_reference<_Fn>::type>::value>
{
};

// result_of

template <class _Fn>
class __attribute__ ((__type_visibility__("default"))) result_of<_Fn()>
    : public __result_of<_Fn(),
                         is_class<typename remove_reference<_Fn>::type>::value ||
                         is_function<typename remove_reference<_Fn>::type>::value,
                         is_member_pointer<typename remove_reference<_Fn>::type>::value
                        >
{
};

template <class _Fn, class _A0>
class __attribute__ ((__type_visibility__("default"))) result_of<_Fn(_A0)>
    : public __result_of<_Fn(_A0),
                         is_class<typename remove_reference<_Fn>::type>::value ||
                         is_function<typename remove_reference<_Fn>::type>::value,
                         is_member_pointer<typename remove_reference<_Fn>::type>::value
                        >
{
};

template <class _Fn, class _A0, class _A1>
class __attribute__ ((__type_visibility__("default"))) result_of<_Fn(_A0, _A1)>
    : public __result_of<_Fn(_A0, _A1),
                         is_class<typename remove_reference<_Fn>::type>::value ||
                         is_function<typename remove_reference<_Fn>::type>::value,
                         is_member_pointer<typename remove_reference<_Fn>::type>::value
                        >
{
};

template <class _Fn, class _A0, class _A1, class _A2>
class __attribute__ ((__type_visibility__("default"))) result_of<_Fn(_A0, _A1, _A2)>
    : public __result_of<_Fn(_A0, _A1, _A2),
                         is_class<typename remove_reference<_Fn>::type>::value ||
                         is_function<typename remove_reference<_Fn>::type>::value,
                         is_member_pointer<typename remove_reference<_Fn>::type>::value
                        >
{
};



// template <class T, class... Args> struct is_constructible;

namespace __is_construct
{
struct __nat {};
}



template <class _Tp, class ..._Args>
struct __attribute__ ((__type_visibility__("default"))) is_constructible
    : public integral_constant<bool, __is_constructible(_Tp, _Args...)>
    {};
# 2405 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/type_traits" 3
// is_default_constructible

template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_default_constructible
    : public is_constructible<_Tp>
    {};

// is_copy_constructible

template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_copy_constructible
    : public is_constructible<_Tp, const typename add_lvalue_reference<_Tp>::type>
    {};

// is_move_constructible

template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_move_constructible



    : public is_copy_constructible<_Tp>

    {};

// is_trivially_constructible
# 2486 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/type_traits" 3
template <class _Tp, class _A0 = __is_construct::__nat,
                     class _A1 = __is_construct::__nat>
struct __attribute__ ((__type_visibility__("default"))) is_trivially_constructible
    : false_type
{
};



template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_trivially_constructible<_Tp, __is_construct::__nat,
                                                       __is_construct::__nat>
    : integral_constant<bool, __is_trivially_constructible(_Tp)>
{
};

template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_trivially_constructible<_Tp, _Tp,
                                                       __is_construct::__nat>
    : integral_constant<bool, __is_trivially_constructible(_Tp, _Tp)>
{
};

template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_trivially_constructible<_Tp, const _Tp&,
                                                       __is_construct::__nat>
    : integral_constant<bool, __is_trivially_constructible(_Tp, const _Tp&)>
{
};

template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_trivially_constructible<_Tp, _Tp&,
                                                       __is_construct::__nat>
    : integral_constant<bool, __is_trivially_constructible(_Tp, _Tp&)>
{
};
# 2557 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/type_traits" 3
// is_trivially_default_constructible

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_trivially_default_constructible
    : public is_trivially_constructible<_Tp>
    {};

// is_trivially_copy_constructible

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_trivially_copy_constructible
    : public is_trivially_constructible<_Tp, typename add_lvalue_reference<const _Tp>::type>
    {};

// is_trivially_move_constructible

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_trivially_move_constructible



    : public is_trivially_copy_constructible<_Tp>

    {};

// is_trivially_assignable



template <class _Tp, class _Arg>
struct is_trivially_assignable
    : integral_constant<bool, __is_trivially_assignable(_Tp, _Arg)>
{
};
# 2617 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/type_traits" 3
// is_trivially_copy_assignable

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_trivially_copy_assignable
    : public is_trivially_assignable<typename add_lvalue_reference<_Tp>::type,
                               const typename add_lvalue_reference<_Tp>::type>
    {};

// is_trivially_move_assignable

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_trivially_move_assignable
    : public is_trivially_assignable<typename add_lvalue_reference<_Tp>::type,



                                     typename add_lvalue_reference<_Tp>::type>

    {};

// is_trivially_destructible



template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_trivially_destructible
    : public integral_constant<bool, __has_trivial_destructor(_Tp)> {};
# 2653 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/type_traits" 3
// is_nothrow_constructible
# 2750 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/type_traits" 3
template <class _Tp, class _A0 = __is_construct::__nat,
                     class _A1 = __is_construct::__nat>
struct __attribute__ ((__type_visibility__("default"))) is_nothrow_constructible
    : false_type
{
};

template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_nothrow_constructible<_Tp, __is_construct::__nat,
                                                       __is_construct::__nat>

    : integral_constant<bool, __has_nothrow_constructor(_Tp)>



{
};

template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_nothrow_constructible<_Tp, _Tp,
                                                       __is_construct::__nat>

    : integral_constant<bool, __has_nothrow_copy(_Tp)>



{
};

template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_nothrow_constructible<_Tp, const _Tp&,
                                                       __is_construct::__nat>

    : integral_constant<bool, __has_nothrow_copy(_Tp)>



{
};

template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_nothrow_constructible<_Tp, _Tp&,
                                                       __is_construct::__nat>

    : integral_constant<bool, __has_nothrow_copy(_Tp)>



{
};




// is_nothrow_default_constructible

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_nothrow_default_constructible
    : public is_nothrow_constructible<_Tp>
    {};

// is_nothrow_copy_constructible

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_nothrow_copy_constructible
    : public is_nothrow_constructible<_Tp, const typename add_lvalue_reference<_Tp>::type>
    {};

// is_nothrow_move_constructible

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_nothrow_move_constructible



    : public is_nothrow_copy_constructible<_Tp>

    {};

// is_nothrow_assignable
# 2852 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/type_traits" 3
template <class _Tp, class _Arg>
struct __attribute__ ((__type_visibility__("default"))) is_nothrow_assignable
    : public false_type {};

template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_nothrow_assignable<_Tp&, _Tp>

    : integral_constant<bool, __has_nothrow_assign(_Tp)> {};




template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_nothrow_assignable<_Tp&, _Tp&>

    : integral_constant<bool, __has_nothrow_assign(_Tp)> {};




template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_nothrow_assignable<_Tp&, const _Tp&>

    : integral_constant<bool, __has_nothrow_assign(_Tp)> {};
# 2894 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/type_traits" 3
// is_nothrow_copy_assignable

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_nothrow_copy_assignable
    : public is_nothrow_assignable<typename add_lvalue_reference<_Tp>::type,
                               const typename add_lvalue_reference<_Tp>::type>
    {};

// is_nothrow_move_assignable

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_nothrow_move_assignable
    : public is_nothrow_assignable<typename add_lvalue_reference<_Tp>::type,



                                     typename add_lvalue_reference<_Tp>::type>

    {};

// is_nothrow_destructible
# 2960 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/type_traits" 3
template <class _Tp> struct __libcpp_nothrow_destructor
    : public integral_constant<bool, is_scalar<_Tp>::value ||
                                     is_reference<_Tp>::value> {};

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_nothrow_destructible
    : public __libcpp_nothrow_destructor<typename remove_all_extents<_Tp>::type> {};



// is_pod



template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_pod
    : public integral_constant<bool, __is_pod(_Tp)> {};
# 2986 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/type_traits" 3
// is_literal_type;

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_literal_type

    : public integral_constant<bool, __is_literal(_Tp)>




    {};

// is_standard_layout;

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_standard_layout

    : public integral_constant<bool, __is_standard_layout(_Tp)>



    {};

// is_trivially_copyable;

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_trivially_copyable

    : public integral_constant<bool, __is_trivially_copyable(_Tp)>



    {};

// is_trivial;

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_trivial

    : public integral_constant<bool, __is_trivial(_Tp)>




    {};
# 3297 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/type_traits" 3
template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))







void

swap(_Tp& __x, _Tp& __y)

{
    _Tp __t(std::__1::move(__x));
    __x = std::__1::move(__y);
    __y = std::__1::move(__t);
}

template <class _ForwardIterator1, class _ForwardIterator2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)
    //                                  _NOEXCEPT_(_NOEXCEPT_(swap(*__a, *__b)))


{
    swap(*__a, *__b);
}

// __swappable

namespace __detail
{

using std::__1::swap;
__nat swap(__any, __any);

template <class _Tp>
struct __swappable
{
    typedef __typeof__(swap(std::__1::declval<_Tp&>(), std::__1::declval<_Tp&>())) type;
    static const bool value = !is_same<type, __nat>::value;
};

} // __detail

template <class _Tp>
struct __is_swappable
    : public integral_constant<bool, __detail::__swappable<_Tp>::value>
{
};
# 3373 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/type_traits" 3
template <class _Tp>
struct __is_nothrow_swappable
    : public false_type
{
};





template <class _Tp>
struct underlying_type
{
    typedef __underlying_type(_Tp) type;
};
# 3426 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/type_traits" 3
} }
# 626 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/algorithm" 2 3

# 1 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/utility" 1 3
// -*- C++ -*-
//===-------------------------- utility -----------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is dual licensed under the MIT and the University of Illinois Open
// Source Licenses. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//




/*
    utility synopsis

namespace std
{

template <class T>
    void
    swap(T& a, T& b);

namespace rel_ops
{
    template<class T> bool operator!=(const T&, const T&);
    template<class T> bool operator> (const T&, const T&);
    template<class T> bool operator<=(const T&, const T&);
    template<class T> bool operator>=(const T&, const T&);
}

template<class T>
void
swap(T& a, T& b) noexcept(is_nothrow_move_constructible<T>::value &&
                          is_nothrow_move_assignable<T>::value);

template <class T, size_t N>
void
swap(T (&a)[N], T (&b)[N]) noexcept(noexcept(swap(*a, *b)));

template <class T> T&& forward(typename remove_reference<T>::type& t) noexcept;  // constexpr in C++14
template <class T> T&& forward(typename remove_reference<T>::type&& t) noexcept; // constexpr in C++14

template <class T> typename remove_reference<T>::type&& move(T&&) noexcept;      // constexpr in C++14

template <class T>
    typename conditional
    <
        !is_nothrow_move_constructible<T>::value && is_copy_constructible<T>::value,
        const T&,
        T&&
    >::type
    move_if_noexcept(T& x) noexcept; // constexpr in C++14

template <class T> typename add_rvalue_reference<T>::type declval() noexcept;

template <class T1, class T2>
struct pair
{
    typedef T1 first_type;
    typedef T2 second_type;

    T1 first;
    T2 second;

    pair(const pair&) = default;
    pair(pair&&) = default;
    constexpr pair();
    pair(const T1& x, const T2& y);                          // constexpr in C++14
    template <class U, class V> pair(U&& x, V&& y);          // constexpr in C++14
    template <class U, class V> pair(const pair<U, V>& p);   // constexpr in C++14
    template <class U, class V> pair(pair<U, V>&& p);        // constexpr in C++14
    template <class... Args1, class... Args2>
        pair(piecewise_construct_t, tuple<Args1...> first_args,
             tuple<Args2...> second_args);

    template <class U, class V> pair& operator=(const pair<U, V>& p);
    pair& operator=(pair&& p) noexcept(is_nothrow_move_assignable<T1>::value &&
                                       is_nothrow_move_assignable<T2>::value);
    template <class U, class V> pair& operator=(pair<U, V>&& p);

    void swap(pair& p) noexcept(noexcept(swap(first, p.first)) &&
                                noexcept(swap(second, p.second)));
};

template <class T1, class T2> bool operator==(const pair<T1,T2>&, const pair<T1,T2>&); // constexpr in C++14
template <class T1, class T2> bool operator!=(const pair<T1,T2>&, const pair<T1,T2>&); // constexpr in C++14
template <class T1, class T2> bool operator< (const pair<T1,T2>&, const pair<T1,T2>&); // constexpr in C++14
template <class T1, class T2> bool operator> (const pair<T1,T2>&, const pair<T1,T2>&); // constexpr in C++14
template <class T1, class T2> bool operator>=(const pair<T1,T2>&, const pair<T1,T2>&); // constexpr in C++14
template <class T1, class T2> bool operator<=(const pair<T1,T2>&, const pair<T1,T2>&); // constexpr in C++14

template <class T1, class T2> pair<V1, V2> make_pair(T1&&, T2&&);   // constexpr in C++14
template <class T1, class T2>
void
swap(pair<T1, T2>& x, pair<T1, T2>& y) noexcept(noexcept(x.swap(y)));

struct piecewise_construct_t { };
constexpr piecewise_construct_t piecewise_construct = piecewise_construct_t();

template <class T> class tuple_size;
template <size_t I, class T> class tuple_element;

template <class T1, class T2> struct tuple_size<pair<T1, T2> >;
template <class T1, class T2> struct tuple_element<0, pair<T1, T2> >;
template <class T1, class T2> struct tuple_element<1, pair<T1, T2> >;

template<size_t I, class T1, class T2>
    typename tuple_element<I, pair<T1, T2> >::type&
    get(pair<T1, T2>&) noexcept; // constexpr in C++14

template<size_t I, class T1, class T2>
    const typename const tuple_element<I, pair<T1, T2> >::type&
    get(const pair<T1, T2>&) noexcept; // constexpr in C++14

template<size_t I, class T1, class T2>
    typename tuple_element<I, pair<T1, T2> >::type&&
    get(pair<T1, T2>&&) noexcept; // constexpr in C++14

template<class T1, class T2>
    constexpr T1& get(pair<T1, T2>&) noexcept; // C++14

template<size_t I, class T1, class T2>
    constexpr T1 const& get(pair<T1, T2> const &) noexcept; // C++14

template<size_t I, class T1, class T2>
    constexpr T1&& get(pair<T1, T2>&&) noexcept; // C++14

// C++14

template<class T, T... I>
struct integer_sequence
{
    typedef T value_type;

    static constexpr size_t size() noexcept;
};

template<size_t... I>
  using index_sequence = integer_sequence<size_t, I...>;

template<class T, T N>
  using make_integer_sequence = integer_sequence<T, 0, 1, ..., N-1>;
template<size_t N>
  using make_index_sequence = make_integer_sequence<size_t, N>;

template<class... T>
  using index_sequence_for = make_index_sequence<sizeof...(T)>;

template<class T, class U=T> 
    T exchange(T& obj, U&& new_value);
}  // std

*/



# 1 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/__tuple" 1 3
// -*- C++ -*-
//===----------------------------------------------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is dual licensed under the MIT and the University of Illinois Open
// Source Licenses. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
# 20 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/__tuple" 3




# 1 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/__tuple_03" 1 3
// -*- C++ -*-
//===----------------------------------------------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is dual licensed under the MIT and the University of Illinois Open
// Source Licenses. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
# 18 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/__tuple_03" 3


namespace std {inline namespace __1 {

template <class _Tp> class __attribute__ ((__type_visibility__("default"))) tuple_size;
template <size_t _Ip, class _Tp> class __attribute__ ((__type_visibility__("default"))) tuple_element;

} }
# 25 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/__tuple" 2 3
# 158 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/utility" 2 3
# 162 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/utility" 3


namespace std {inline namespace __1 {

namespace rel_ops
{

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator!=(const _Tp& __x, const _Tp& __y)
{
    return !(__x == __y);
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator> (const _Tp& __x, const _Tp& __y)
{
    return __y < __x;
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator<=(const _Tp& __x, const _Tp& __y)
{
    return !(__y < __x);
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator>=(const _Tp& __x, const _Tp& __y)
{
    return !(__x < __y);
}

} // rel_ops

// swap_ranges

template <class _ForwardIterator1, class _ForwardIterator2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_ForwardIterator2
swap_ranges(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2)
{
    for(; __first1 != __last1; ++__first1, ++__first2)
        swap(*__first1, *__first2);
    return __first2;
}

template<class _Tp, size_t _Np>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
swap(_Tp (&__a)[_Np], _Tp (&__b)[_Np])
{
    std::__1::swap_ranges(__a, __a + _Np, __b);
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
# 233 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/utility" 3
const _Tp&

move_if_noexcept(_Tp& __x) throw()
{
    return std::__1::move(__x);
}

struct __attribute__ ((__type_visibility__("default"))) piecewise_construct_t { };

extern const piecewise_construct_t piecewise_construct;// = piecewise_construct_t();




template <class _T1, class _T2>
struct __attribute__ ((__type_visibility__("default"))) pair
{
    typedef _T1 first_type;
    typedef _T2 second_type;

    _T1 first;
    _T2 second;

    // pair(const pair&) = default;
    // pair(pair&&) = default;

    __attribute__ ((__visibility__("hidden"), __always_inline__)) pair() : first(), second() {}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    pair(const _T1& __x, const _T2& __y)
        : first(__x), second(__y) {}

    template<class _U1, class _U2>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        pair(const pair<_U1, _U2>& __p




                                      )
            : first(__p.first), second(__p.second) {}
# 289 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/utility" 3
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    pair& operator=(const pair& __p)


    {
        first = __p.first;
        second = __p.second;
        return *this;
    }
# 381 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/utility" 3
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void
    swap(pair& __p)

    {
        std::__1::iter_swap(&first, &__p.first);
        std::__1::iter_swap(&second, &__p.second);
    }
private:
# 398 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/utility" 3
};

template <class _T1, class _T2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator==(const pair<_T1,_T2>& __x, const pair<_T1,_T2>& __y)
{
    return __x.first == __y.first && __x.second == __y.second;
}

template <class _T1, class _T2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator!=(const pair<_T1,_T2>& __x, const pair<_T1,_T2>& __y)
{
    return !(__x == __y);
}

template <class _T1, class _T2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator< (const pair<_T1,_T2>& __x, const pair<_T1,_T2>& __y)
{
    return __x.first < __y.first || (!(__y.first < __x.first) && __x.second < __y.second);
}

template <class _T1, class _T2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator> (const pair<_T1,_T2>& __x, const pair<_T1,_T2>& __y)
{
    return __y < __x;
}

template <class _T1, class _T2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator>=(const pair<_T1,_T2>& __x, const pair<_T1,_T2>& __y)
{
    return !(__x < __y);
}

template <class _T1, class _T2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator<=(const pair<_T1,_T2>& __x, const pair<_T1,_T2>& __y)
{
    return !(__y < __x);
}

template <class _T1, class _T2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    __is_swappable<_T1>::value &&
    __is_swappable<_T2>::value,
    void
>::type
swap(pair<_T1, _T2>& __x, pair<_T1, _T2>& __y)


{
    __x.swap(__y);
}
# 496 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/utility" 3
template <class _T1, class _T2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
pair<_T1,_T2>
make_pair(_T1 __x, _T2 __y)
{
    return pair<_T1, _T2>(__x, __y);
}



template <class _T1, class _T2>
  class __attribute__ ((__type_visibility__("default"))) tuple_size<pair<_T1, _T2> >
    : public integral_constant<size_t, 2> {};

template <class _T1, class _T2>
  class __attribute__ ((__type_visibility__("default"))) tuple_size<const pair<_T1, _T2> >
    : public integral_constant<size_t, 2> {};

template <class _T1, class _T2>
class __attribute__ ((__type_visibility__("default"))) tuple_element<0, pair<_T1, _T2> >
{
public:
    typedef _T1 type;
};

template <class _T1, class _T2>
class __attribute__ ((__type_visibility__("default"))) tuple_element<1, pair<_T1, _T2> >
{
public:
    typedef _T2 type;
};

template <class _T1, class _T2>
class __attribute__ ((__type_visibility__("default"))) tuple_element<0, const pair<_T1, _T2> >
{
public:
    typedef const _T1 type;
};

template <class _T1, class _T2>
class __attribute__ ((__type_visibility__("default"))) tuple_element<1, const pair<_T1, _T2> >
{
public:
    typedef const _T2 type;
};

template <size_t _Ip> struct __get_pair;

template <>
struct __get_pair<0>
{
    template <class _T1, class _T2>
    static
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    _T1&
    get(pair<_T1, _T2>& __p) throw() {return __p.first;}

    template <class _T1, class _T2>
    static
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const _T1&
    get(const pair<_T1, _T2>& __p) throw() {return __p.first;}
# 568 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/utility" 3
};

template <>
struct __get_pair<1>
{
    template <class _T1, class _T2>
    static
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    _T2&
    get(pair<_T1, _T2>& __p) throw() {return __p.second;}

    template <class _T1, class _T2>
    static
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const _T2&
    get(const pair<_T1, _T2>& __p) throw() {return __p.second;}
# 594 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/utility" 3
};

template <size_t _Ip, class _T1, class _T2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename tuple_element<_Ip, pair<_T1, _T2> >::type&
get(pair<_T1, _T2>& __p) throw()
{
    return __get_pair<_Ip>::get(__p);
}

template <size_t _Ip, class _T1, class _T2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
const typename tuple_element<_Ip, pair<_T1, _T2> >::type&
get(const pair<_T1, _T2>& __p) throw()
{
    return __get_pair<_Ip>::get(__p);
}
# 766 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/utility" 3
} }
# 628 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/algorithm" 2 3
# 1 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/memory" 1 3
// -*- C++ -*-
//===-------------------------- memory ------------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is dual licensed under the MIT and the University of Illinois Open
// Source Licenses. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//




/*
    memory synopsis

namespace std
{

struct allocator_arg_t { };
constexpr allocator_arg_t allocator_arg = allocator_arg_t();

template <class T, class Alloc> struct uses_allocator;

template <class Ptr>
struct pointer_traits
{
    typedef Ptr pointer;
    typedef <details> element_type;
    typedef <details> difference_type;

    template <class U> using rebind = <details>;

    static pointer pointer_to(<details>);
};

template <class T>
struct pointer_traits<T*>
{
    typedef T* pointer;
    typedef T element_type;
    typedef ptrdiff_t difference_type;

    template <class U> using rebind = U*;

    static pointer pointer_to(<details>) noexcept;
};

template <class Alloc>
struct allocator_traits
{
    typedef Alloc                        allocator_type;
    typedef typename allocator_type::value_type
                                         value_type;

    typedef Alloc::pointer | value_type* pointer;
    typedef Alloc::const_pointer
          | pointer_traits<pointer>::rebind<const value_type>
                                         const_pointer;
    typedef Alloc::void_pointer
          | pointer_traits<pointer>::rebind<void>
                                         void_pointer;
    typedef Alloc::const_void_pointer
          | pointer_traits<pointer>::rebind<const void>
                                         const_void_pointer;
    typedef Alloc::difference_type
          | pointer_traits<pointer>::difference_type
                                         difference_type;
    typedef Alloc::size_type
          | make_unsigned<difference_type>::type
                                         size_type;
    typedef Alloc::propagate_on_container_copy_assignment
          | false_type                   propagate_on_container_copy_assignment;
    typedef Alloc::propagate_on_container_move_assignment
          | false_type                   propagate_on_container_move_assignment;
    typedef Alloc::propagate_on_container_swap
          | false_type                   propagate_on_container_swap;

    template <class T> using rebind_alloc  = Alloc::rebind<U>::other | Alloc<T, Args...>;
    template <class T> using rebind_traits = allocator_traits<rebind_alloc<T>>;

    static pointer allocate(allocator_type& a, size_type n);
    static pointer allocate(allocator_type& a, size_type n, const_void_pointer hint);

    static void deallocate(allocator_type& a, pointer p, size_type n) noexcept;

    template <class T, class... Args>
        static void construct(allocator_type& a, T* p, Args&&... args);

    template <class T>
        static void destroy(allocator_type& a, T* p);

    static size_type max_size(const allocator_type& a); // noexcept in C++14

    static allocator_type
        select_on_container_copy_construction(const allocator_type& a);
};

template <>
class allocator<void>
{
public:
    typedef void*                                 pointer;
    typedef const void*                           const_pointer;
    typedef void                                  value_type;

    template <class _Up> struct rebind {typedef allocator<_Up> other;};
};

template <class T>
class allocator
{
public:
    typedef size_t                                size_type;
    typedef ptrdiff_t                             difference_type;
    typedef T*                                    pointer;
    typedef const T*                              const_pointer;
    typedef typename add_lvalue_reference<T>::type       reference;
    typedef typename add_lvalue_reference<const T>::type const_reference;
    typedef T                                     value_type;

    template <class U> struct rebind {typedef allocator<U> other;};

    allocator() noexcept;
    allocator(const allocator&) noexcept;
    template <class U> allocator(const allocator<U>&) noexcept;
    ~allocator();
    pointer address(reference x) const noexcept;
    const_pointer address(const_reference x) const noexcept;
    pointer allocate(size_type, allocator<void>::const_pointer hint = 0);
    void deallocate(pointer p, size_type n) noexcept;
    size_type max_size() const noexcept;
    template<class U, class... Args>
        void construct(U* p, Args&&... args);
    template <class U>
        void destroy(U* p);
};

template <class T, class U>
bool operator==(const allocator<T>&, const allocator<U>&) noexcept;

template <class T, class U>
bool operator!=(const allocator<T>&, const allocator<U>&) noexcept;

template <class OutputIterator, class T>
class raw_storage_iterator
    : public iterator<output_iterator_tag,
                      T,                               // purposefully not C++03
                      ptrdiff_t,                       // purposefully not C++03
                      T*,                              // purposefully not C++03
                      raw_storage_iterator&>           // purposefully not C++03
{
public:
    explicit raw_storage_iterator(OutputIterator x);
    raw_storage_iterator& operator*();
    raw_storage_iterator& operator=(const T& element);
    raw_storage_iterator& operator++();
    raw_storage_iterator  operator++(int);
};

template <class T> pair<T*,ptrdiff_t> get_temporary_buffer(ptrdiff_t n) noexcept;
template <class T> void               return_temporary_buffer(T* p) noexcept;

template <class T> T* addressof(T& r) noexcept;

template <class InputIterator, class ForwardIterator>
ForwardIterator
uninitialized_copy(InputIterator first, InputIterator last, ForwardIterator result);

template <class InputIterator, class Size, class ForwardIterator>
ForwardIterator
uninitialized_copy_n(InputIterator first, Size n, ForwardIterator result);

template <class ForwardIterator, class T>
void uninitialized_fill(ForwardIterator first, ForwardIterator last, const T& x);

template <class ForwardIterator, class Size, class T>
ForwardIterator
uninitialized_fill_n(ForwardIterator first, Size n, const T& x);

template <class Y> struct auto_ptr_ref {};

template<class X>
class auto_ptr
{
public:
    typedef X element_type;

    explicit auto_ptr(X* p =0) throw();
    auto_ptr(auto_ptr&) throw();
    template<class Y> auto_ptr(auto_ptr<Y>&) throw();
    auto_ptr& operator=(auto_ptr&) throw();
    template<class Y> auto_ptr& operator=(auto_ptr<Y>&) throw();
    auto_ptr& operator=(auto_ptr_ref<X> r) throw();
    ~auto_ptr() throw();

    typename add_lvalue_reference<X>::type operator*() const throw();
    X* operator->() const throw();
    X* get() const throw();
    X* release() throw();
    void reset(X* p =0) throw();

    auto_ptr(auto_ptr_ref<X>) throw();
    template<class Y> operator auto_ptr_ref<Y>() throw();
    template<class Y> operator auto_ptr<Y>() throw();
};

template <class T>
struct default_delete
{
    constexpr default_delete() noexcept = default;
    template <class U> default_delete(const default_delete<U>&) noexcept;

    void operator()(T*) const noexcept;
};

template <class T>
struct default_delete<T[]>
{
    constexpr default_delete() noexcept = default;
    void operator()(T*) const noexcept;
    template <class U> void operator()(U*) const = delete;
};

template <class T, class D = default_delete<T>>
class unique_ptr
{
public:
    typedef see below pointer;
    typedef T element_type;
    typedef D deleter_type;

    // constructors
    constexpr unique_ptr() noexcept;
    explicit unique_ptr(pointer p) noexcept;
    unique_ptr(pointer p, see below d1) noexcept;
    unique_ptr(pointer p, see below d2) noexcept;
    unique_ptr(unique_ptr&& u) noexcept;
    unique_ptr(nullptr_t) noexcept : unique_ptr() { }
    template <class U, class E>
        unique_ptr(unique_ptr<U, E>&& u) noexcept;
    template <class U>
        unique_ptr(auto_ptr<U>&& u) noexcept;

    // destructor
    ~unique_ptr();

    // assignment
    unique_ptr& operator=(unique_ptr&& u) noexcept;
    template <class U, class E> unique_ptr& operator=(unique_ptr<U, E>&& u) noexcept;
    unique_ptr& operator=(nullptr_t) noexcept;

    // observers
    typename add_lvalue_reference<T>::type operator*() const;
    pointer operator->() const noexcept;
    pointer get() const noexcept;
    deleter_type& get_deleter() noexcept;
    const deleter_type& get_deleter() const noexcept;
    explicit operator bool() const noexcept;

    // modifiers
    pointer release() noexcept;
    void reset(pointer p = pointer()) noexcept;
    void swap(unique_ptr& u) noexcept;
};

template <class T, class D>
class unique_ptr<T[], D>
{
public:
    typedef implementation-defined pointer;
    typedef T element_type;
    typedef D deleter_type;

    // constructors
    constexpr unique_ptr() noexcept;
    explicit unique_ptr(pointer p) noexcept;
    unique_ptr(pointer p, see below d) noexcept;
    unique_ptr(pointer p, see below d) noexcept;
    unique_ptr(unique_ptr&& u) noexcept;
    unique_ptr(nullptr_t) noexcept : unique_ptr() { }

    // destructor
    ~unique_ptr();

    // assignment
    unique_ptr& operator=(unique_ptr&& u) noexcept;
    unique_ptr& operator=(nullptr_t) noexcept;

    // observers
    T& operator[](size_t i) const;
    pointer get() const noexcept;
    deleter_type& get_deleter() noexcept;
    const deleter_type& get_deleter() const noexcept;
    explicit operator bool() const noexcept;

    // modifiers
    pointer release() noexcept;
    void reset(pointer p = pointer()) noexcept;
    void reset(nullptr_t) noexcept;
    template <class U> void reset(U) = delete;
    void swap(unique_ptr& u) noexcept;
};

template <class T, class D>
    void swap(unique_ptr<T, D>& x, unique_ptr<T, D>& y) noexcept;

template <class T1, class D1, class T2, class D2>
    bool operator==(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);
template <class T1, class D1, class T2, class D2>
    bool operator!=(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);
template <class T1, class D1, class T2, class D2>
    bool operator<(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);
template <class T1, class D1, class T2, class D2>
    bool operator<=(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);
template <class T1, class D1, class T2, class D2>
    bool operator>(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);
template <class T1, class D1, class T2, class D2>
    bool operator>=(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);

template <class T, class D>
    bool operator==(const unique_ptr<T, D>& x, nullptr_t) noexcept;
template <class T, class D>
    bool operator==(nullptr_t, const unique_ptr<T, D>& y) noexcept;
template <class T, class D>
    bool operator!=(const unique_ptr<T, D>& x, nullptr_t) noexcept;
template <class T, class D>
    bool operator!=(nullptr_t, const unique_ptr<T, D>& y) noexcept;

template <class T, class D>
    bool operator<(const unique_ptr<T, D>& x, nullptr_t);
template <class T, class D>
    bool operator<(nullptr_t, const unique_ptr<T, D>& y);
template <class T, class D>
    bool operator<=(const unique_ptr<T, D>& x, nullptr_t);
template <class T, class D>
    bool operator<=(nullptr_t, const unique_ptr<T, D>& y);
template <class T, class D>
    bool operator>(const unique_ptr<T, D>& x, nullptr_t);
template <class T, class D>
    bool operator>(nullptr_t, const unique_ptr<T, D>& y);
template <class T, class D>
    bool operator>=(const unique_ptr<T, D>& x, nullptr_t);
template <class T, class D>
    bool operator>=(nullptr_t, const unique_ptr<T, D>& y);

class bad_weak_ptr
    : public std::exception
{
    bad_weak_ptr() noexcept;
};

template<class T, class... Args> unique_ptr<T> make_unique(Args&&... args);     // C++14
template<class T>                unique_ptr<T> make_unique(size_t n);           // C++14
template<class T, class... Args> unspecified   make_unique(Args&&...) = delete; // C++14, T == U[N]

template<class T>
class shared_ptr
{
public:
    typedef T element_type;

    // constructors:
    constexpr shared_ptr() noexcept;
    template<class Y> explicit shared_ptr(Y* p);
    template<class Y, class D> shared_ptr(Y* p, D d);
    template<class Y, class D, class A> shared_ptr(Y* p, D d, A a);
    template <class D> shared_ptr(nullptr_t p, D d);
    template <class D, class A> shared_ptr(nullptr_t p, D d, A a);
    template<class Y> shared_ptr(const shared_ptr<Y>& r, T *p) noexcept;
    shared_ptr(const shared_ptr& r) noexcept;
    template<class Y> shared_ptr(const shared_ptr<Y>& r) noexcept;
    shared_ptr(shared_ptr&& r) noexcept;
    template<class Y> shared_ptr(shared_ptr<Y>&& r) noexcept;
    template<class Y> explicit shared_ptr(const weak_ptr<Y>& r);
    template<class Y> shared_ptr(auto_ptr<Y>&& r);
    template <class Y, class D> shared_ptr(unique_ptr<Y, D>&& r);
    shared_ptr(nullptr_t) : shared_ptr() { }

    // destructor:
    ~shared_ptr();

    // assignment:
    shared_ptr& operator=(const shared_ptr& r) noexcept;
    template<class Y> shared_ptr& operator=(const shared_ptr<Y>& r) noexcept;
    shared_ptr& operator=(shared_ptr&& r) noexcept;
    template<class Y> shared_ptr& operator=(shared_ptr<Y>&& r);
    template<class Y> shared_ptr& operator=(auto_ptr<Y>&& r);
    template <class Y, class D> shared_ptr& operator=(unique_ptr<Y, D>&& r);

    // modifiers:
    void swap(shared_ptr& r) noexcept;
    void reset() noexcept;
    template<class Y> void reset(Y* p);
    template<class Y, class D> void reset(Y* p, D d);
    template<class Y, class D, class A> void reset(Y* p, D d, A a);

    // observers:
    T* get() const noexcept;
    T& operator*() const noexcept;
    T* operator->() const noexcept;
    long use_count() const noexcept;
    bool unique() const noexcept;
    explicit operator bool() const noexcept;
    template<class U> bool owner_before(shared_ptr<U> const& b) const;
    template<class U> bool owner_before(weak_ptr<U> const& b) const;
};

// shared_ptr comparisons:
template<class T, class U>
    bool operator==(shared_ptr<T> const& a, shared_ptr<U> const& b) noexcept;
template<class T, class U>
    bool operator!=(shared_ptr<T> const& a, shared_ptr<U> const& b) noexcept;
template<class T, class U>
    bool operator<(shared_ptr<T> const& a, shared_ptr<U> const& b) noexcept;
template<class T, class U>
    bool operator>(shared_ptr<T> const& a, shared_ptr<U> const& b) noexcept;
template<class T, class U>
    bool operator<=(shared_ptr<T> const& a, shared_ptr<U> const& b) noexcept;
template<class T, class U>
    bool operator>=(shared_ptr<T> const& a, shared_ptr<U> const& b) noexcept;

template <class T>
    bool operator==(const shared_ptr<T>& x, nullptr_t) noexcept;
template <class T>
    bool operator==(nullptr_t, const shared_ptr<T>& y) noexcept;
template <class T>
    bool operator!=(const shared_ptr<T>& x, nullptr_t) noexcept;
template <class T>
    bool operator!=(nullptr_t, const shared_ptr<T>& y) noexcept;
template <class T>
    bool operator<(const shared_ptr<T>& x, nullptr_t) noexcept;
template <class T>
bool operator<(nullptr_t, const shared_ptr<T>& y) noexcept;
template <class T>
    bool operator<=(const shared_ptr<T>& x, nullptr_t) noexcept;
template <class T>
    bool operator<=(nullptr_t, const shared_ptr<T>& y) noexcept;
template <class T>
    bool operator>(const shared_ptr<T>& x, nullptr_t) noexcept;
template <class T>
    bool operator>(nullptr_t, const shared_ptr<T>& y) noexcept;
template <class T>
    bool operator>=(const shared_ptr<T>& x, nullptr_t) noexcept;
template <class T>
    bool operator>=(nullptr_t, const shared_ptr<T>& y) noexcept;

// shared_ptr specialized algorithms:
template<class T> void swap(shared_ptr<T>& a, shared_ptr<T>& b) noexcept;

// shared_ptr casts:
template<class T, class U>
    shared_ptr<T> static_pointer_cast(shared_ptr<U> const& r) noexcept;
template<class T, class U>
    shared_ptr<T> dynamic_pointer_cast(shared_ptr<U> const& r) noexcept;
template<class T, class U>
    shared_ptr<T> const_pointer_cast(shared_ptr<U> const& r) noexcept;

// shared_ptr I/O:
template<class E, class T, class Y>
    basic_ostream<E, T>& operator<< (basic_ostream<E, T>& os, shared_ptr<Y> const& p);

// shared_ptr get_deleter:
template<class D, class T> D* get_deleter(shared_ptr<T> const& p) noexcept;

template<class T, class... Args>
    shared_ptr<T> make_shared(Args&&... args);
template<class T, class A, class... Args>
    shared_ptr<T> allocate_shared(const A& a, Args&&... args);

template<class T>
class weak_ptr
{
public:
    typedef T element_type;

    // constructors
    constexpr weak_ptr() noexcept;
    template<class Y> weak_ptr(shared_ptr<Y> const& r) noexcept;
    weak_ptr(weak_ptr const& r) noexcept;
    template<class Y> weak_ptr(weak_ptr<Y> const& r) noexcept;
    weak_ptr(weak_ptr&& r) noexcept;                      // C++14
    template<class Y> weak_ptr(weak_ptr<Y>&& r) noexcept; // C++14

    // destructor
    ~weak_ptr();

    // assignment
    weak_ptr& operator=(weak_ptr const& r) noexcept;
    template<class Y> weak_ptr& operator=(weak_ptr<Y> const& r) noexcept;
    template<class Y> weak_ptr& operator=(shared_ptr<Y> const& r) noexcept;
    weak_ptr& operator=(weak_ptr&& r) noexcept;                      // C++14
    template<class Y> weak_ptr& operator=(weak_ptr<Y>&& r) noexcept; // C++14

    // modifiers
    void swap(weak_ptr& r) noexcept;
    void reset() noexcept;

    // observers
    long use_count() const noexcept;
    bool expired() const noexcept;
    shared_ptr<T> lock() const noexcept;
    template<class U> bool owner_before(shared_ptr<U> const& b) const;
    template<class U> bool owner_before(weak_ptr<U> const& b) const;
};

// weak_ptr specialized algorithms:
template<class T> void swap(weak_ptr<T>& a, weak_ptr<T>& b) noexcept;

// class owner_less:
template<class T> struct owner_less;

template<class T>
struct owner_less<shared_ptr<T>>
    : binary_function<shared_ptr<T>, shared_ptr<T>, bool>
{
    typedef bool result_type;
    bool operator()(shared_ptr<T> const&, shared_ptr<T> const&) const;
    bool operator()(shared_ptr<T> const&, weak_ptr<T> const&) const;
    bool operator()(weak_ptr<T> const&, shared_ptr<T> const&) const;
};

template<class T>
struct owner_less<weak_ptr<T>>
    : binary_function<weak_ptr<T>, weak_ptr<T>, bool>
{
    typedef bool result_type;
    bool operator()(weak_ptr<T> const&, weak_ptr<T> const&) const;
    bool operator()(shared_ptr<T> const&, weak_ptr<T> const&) const;
    bool operator()(weak_ptr<T> const&, shared_ptr<T> const&) const;
};

template<class T>
class enable_shared_from_this
{
protected:
    constexpr enable_shared_from_this() noexcept;
    enable_shared_from_this(enable_shared_from_this const&) noexcept;
    enable_shared_from_this& operator=(enable_shared_from_this const&) noexcept;
    ~enable_shared_from_this();
public:
    shared_ptr<T> shared_from_this();
    shared_ptr<T const> shared_from_this() const;
};

template<class T>
    bool atomic_is_lock_free(const shared_ptr<T>* p);
template<class T>
    shared_ptr<T> atomic_load(const shared_ptr<T>* p);
template<class T>
    shared_ptr<T> atomic_load_explicit(const shared_ptr<T>* p, memory_order mo);
template<class T>
    void atomic_store(shared_ptr<T>* p, shared_ptr<T> r);
template<class T>
    void atomic_store_explicit(shared_ptr<T>* p, shared_ptr<T> r, memory_order mo);
template<class T>
    shared_ptr<T> atomic_exchange(shared_ptr<T>* p, shared_ptr<T> r);
template<class T>
    shared_ptr<T>
    atomic_exchange_explicit(shared_ptr<T>* p, shared_ptr<T> r, memory_order mo);
template<class T>
    bool
    atomic_compare_exchange_weak(shared_ptr<T>* p, shared_ptr<T>* v, shared_ptr<T> w);
template<class T>
    bool
    atomic_compare_exchange_strong( shared_ptr<T>* p, shared_ptr<T>* v, shared_ptr<T> w);
template<class T>
    bool
    atomic_compare_exchange_weak_explicit(shared_ptr<T>* p, shared_ptr<T>* v,
                                          shared_ptr<T> w, memory_order success,
                                          memory_order failure);
template<class T>
    bool
    atomic_compare_exchange_strong_explicit(shared_ptr<T>* p, shared_ptr<T>* v,
                                            shared_ptr<T> w, memory_order success,
                                            memory_order failure);
// Hash support
template <class T> struct hash;
template <class T, class D> struct hash<unique_ptr<T, D> >;
template <class T> struct hash<shared_ptr<T> >;

// Pointer safety
enum class pointer_safety { relaxed, preferred, strict };
void declare_reachable(void *p);
template <class T> T *undeclare_reachable(T *p);
void declare_no_pointers(char *p, size_t n);
void undeclare_no_pointers(char *p, size_t n);
pointer_safety get_pointer_safety() noexcept;

void* align(size_t alignment, size_t size, void*& ptr, size_t& space);

}  // std

*/




# 1 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/typeinfo" 1 3
// -*- C++ -*-
//===-------------------------- typeinfo ----------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is dual licensed under the MIT and the University of Illinois Open
// Source Licenses. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//




/*

    typeinfo synopsis

namespace std {

class type_info
{
public:
    virtual ~type_info();

    bool operator==(const type_info& rhs) const noexcept;
    bool operator!=(const type_info& rhs) const noexcept;

    bool before(const type_info& rhs) const noexcept;
    size_t hash_code() const noexcept;
    const char* name() const noexcept;

    type_info(const type_info& rhs) = delete;
    type_info& operator=(const type_info& rhs) = delete;
};

class bad_cast
    : public exception
{
public:
    bad_cast() noexcept;
    bad_cast(const bad_cast&) noexcept;
    bad_cast& operator=(const bad_cast&) noexcept;
    virtual const char* what() const noexcept;
};

class bad_typeid
    : public exception
{
public:
    bad_typeid() noexcept;
    bad_typeid(const bad_typeid&) noexcept;
    bad_typeid& operator=(const bad_typeid&) noexcept;
    virtual const char* what() const noexcept;
};

}  // std

*/



# 1 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/exception" 1 3
// -*- C++ -*-
//===-------------------------- exception ---------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is dual licensed under the MIT and the University of Illinois Open
// Source Licenses. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//




/*
    exception synopsis

namespace std
{

class exception
{
public:
    exception() noexcept;
    exception(const exception&) noexcept;
    exception& operator=(const exception&) noexcept;
    virtual ~exception() noexcept;
    virtual const char* what() const noexcept;
};

class bad_exception
    : public exception
{
public:
    bad_exception() noexcept;
    bad_exception(const bad_exception&) noexcept;
    bad_exception& operator=(const bad_exception&) noexcept;
    virtual ~bad_exception() noexcept;
    virtual const char* what() const noexcept;
};

typedef void (*unexpected_handler)();
unexpected_handler set_unexpected(unexpected_handler  f ) noexcept;
unexpected_handler get_unexpected() noexcept;
[[noreturn]] void unexpected();

typedef void (*terminate_handler)();
terminate_handler set_terminate(terminate_handler  f ) noexcept;
terminate_handler get_terminate() noexcept;
[[noreturn]] void terminate() noexcept;

bool uncaught_exception() noexcept;

typedef unspecified exception_ptr;

exception_ptr current_exception() noexcept;
void rethrow_exception [[noreturn]] (exception_ptr p);
template<class E> exception_ptr make_exception_ptr(E e) noexcept;

class nested_exception
{
public:
    nested_exception() noexcept;
    nested_exception(const nested_exception&) noexcept = default;
    nested_exception& operator=(const nested_exception&) noexcept = default;
    virtual ~nested_exception() = default;

    // access functions
    [[noreturn]] void rethrow_nested() const;
    exception_ptr nested_ptr() const noexcept;
};

template <class T> [[noreturn]] void throw_with_nested(T&& t);
template <class E> void rethrow_if_nested(const E& e);

}  // std

*/
# 85 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/exception" 3


namespace std // purposefully not using versioning namespace
{

class __attribute__ ((__visibility__("default"))) exception
{
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) exception() throw() {}
    virtual ~exception() throw();
    virtual const char* what() const throw();
};

class __attribute__ ((__visibility__("default"))) bad_exception
    : public exception
{
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) bad_exception() throw() {}
    virtual ~bad_exception() throw();
    virtual const char* what() const throw();
};

typedef void (*unexpected_handler)();
__attribute__ ((__visibility__("default"))) unexpected_handler set_unexpected(unexpected_handler) throw();
__attribute__ ((__visibility__("default"))) unexpected_handler get_unexpected() throw();
__attribute__ ((noreturn)) __attribute__ ((__visibility__("default"))) void unexpected();

typedef void (*terminate_handler)();
__attribute__ ((__visibility__("default"))) terminate_handler set_terminate(terminate_handler) throw();
__attribute__ ((__visibility__("default"))) terminate_handler get_terminate() throw();
__attribute__ ((noreturn)) __attribute__ ((__visibility__("default"))) void terminate() throw();

__attribute__ ((__visibility__("default"))) bool uncaught_exception() throw();

class __attribute__ ((__type_visibility__("default"))) exception_ptr;

__attribute__ ((__visibility__("default"))) exception_ptr current_exception() throw();
__attribute__ ((noreturn)) __attribute__ ((__visibility__("default"))) void rethrow_exception(exception_ptr);

class __attribute__ ((__type_visibility__("default"))) exception_ptr
{
    void* __ptr_;
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) exception_ptr() throw() : __ptr_() {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) exception_ptr(nullptr_t) throw() : __ptr_() {}
    exception_ptr(const exception_ptr&) throw();
    exception_ptr& operator=(const exception_ptr&) throw();
    ~exception_ptr() throw();

    __attribute__ ((__visibility__("hidden"), __always_inline__))

        operator bool() const throw() {return __ptr_ != std::__1::__get_nullptr_t();}

    friend __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator==(const exception_ptr& __x, const exception_ptr& __y) throw()
        {return __x.__ptr_ == __y.__ptr_;}
    friend __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator!=(const exception_ptr& __x, const exception_ptr& __y) throw()
        {return !(__x == __y);}

    friend __attribute__ ((__visibility__("default"))) exception_ptr current_exception() throw();
    friend __attribute__ ((__visibility__("default"))) void rethrow_exception(exception_ptr);
};

template<class _Ep>
exception_ptr
make_exception_ptr(_Ep __e) throw()
{

    try
    {
        throw __e;
    }
    catch (...)
    {
        return current_exception();
    }

}

// nested_exception

class __attribute__ ((__visibility__("default"))) nested_exception
{
    exception_ptr __ptr_;
public:
    nested_exception() throw();
//     nested_exception(const nested_exception&) noexcept = default;
//     nested_exception& operator=(const nested_exception&) noexcept = default;
    virtual ~nested_exception() throw();

    // access functions
    __attribute__ ((noreturn)) void rethrow_nested() const;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) exception_ptr nested_ptr() const throw() {return __ptr_;}
};

template <class _Tp>
struct __nested
    : public _Tp,
      public nested_exception
{
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit __nested(const _Tp& __t) : _Tp(__t) {}
};

template <class _Tp>
__attribute__ ((noreturn))
void






throw_with_nested (_Tp& __t, typename enable_if<
                  is_class<_Tp>::value && !is_base_of<nested_exception, _Tp>::value
                                    >::type* = 0)

{

    throw __nested<typename remove_reference<_Tp>::type>(std::__1::forward<_Tp>(__t));

}

template <class _Tp>
__attribute__ ((noreturn))
void






throw_with_nested (_Tp& __t, typename enable_if<
                  !is_class<_Tp>::value || is_base_of<nested_exception, _Tp>::value
                                    >::type* = 0)

{

    throw std::__1::forward<_Tp>(__t);

}

template <class _Ep>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
rethrow_if_nested(const _Ep& __e, typename enable_if<
                                   is_polymorphic<_Ep>::value
                                                   >::type* = 0)
{
    const nested_exception* __nep = dynamic_cast<const nested_exception*>(&__e);
    if (__nep)
        __nep->rethrow_nested();
}

template <class _Ep>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
rethrow_if_nested(const _Ep&, typename enable_if<
                                   !is_polymorphic<_Ep>::value
                                                   >::type* = 0)
{
}

} // std
# 62 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/typeinfo" 2 3

# 1 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/cstdint" 1 3
// -*- C++ -*-
//===--------------------------- cstdint ----------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is dual licensed under the MIT and the University of Illinois Open
// Source Licenses. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//




/*
    cstdint synopsis

Macros:

    INT8_MIN
    INT16_MIN
    INT32_MIN
    INT64_MIN

    INT8_MAX
    INT16_MAX
    INT32_MAX
    INT64_MAX

    UINT8_MAX
    UINT16_MAX
    UINT32_MAX
    UINT64_MAX

    INT_LEAST8_MIN
    INT_LEAST16_MIN
    INT_LEAST32_MIN
    INT_LEAST64_MIN

    INT_LEAST8_MAX
    INT_LEAST16_MAX
    INT_LEAST32_MAX
    INT_LEAST64_MAX

    UINT_LEAST8_MAX
    UINT_LEAST16_MAX
    UINT_LEAST32_MAX
    UINT_LEAST64_MAX

    INT_FAST8_MIN
    INT_FAST16_MIN
    INT_FAST32_MIN
    INT_FAST64_MIN

    INT_FAST8_MAX
    INT_FAST16_MAX
    INT_FAST32_MAX
    INT_FAST64_MAX

    UINT_FAST8_MAX
    UINT_FAST16_MAX
    UINT_FAST32_MAX
    UINT_FAST64_MAX

    INTPTR_MIN
    INTPTR_MAX
    UINTPTR_MAX

    INTMAX_MIN
    INTMAX_MAX

    UINTMAX_MAX

    PTRDIFF_MIN
    PTRDIFF_MAX

    SIG_ATOMIC_MIN
    SIG_ATOMIC_MAX

    SIZE_MAX

    WCHAR_MIN
    WCHAR_MAX

    WINT_MIN
    WINT_MAX

    INT8_C(value)
    INT16_C(value)
    INT32_C(value)
    INT64_C(value)

    UINT8_C(value)
    UINT16_C(value)
    UINT32_C(value)
    UINT64_C(value)

    INTMAX_C(value)
    UINTMAX_C(value)

namespace std
{

Types:

    int8_t
    int16_t
    int32_t
    int64_t

    uint8_t
    uint16_t
    uint32_t
    uint64_t

    int_least8_t
    int_least16_t
    int_least32_t
    int_least64_t

    uint_least8_t
    uint_least16_t
    uint_least32_t
    uint_least64_t

    int_fast8_t
    int_fast16_t
    int_fast32_t
    int_fast64_t

    uint_fast8_t
    uint_fast16_t
    uint_fast32_t
    uint_fast64_t

    intptr_t
    uintptr_t

    intmax_t
    uintmax_t

}  // std
*/
# 149 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/cstdint" 3


namespace std {inline namespace __1 {

using::int8_t;
using::int16_t;
using::int32_t;
using::int64_t;

using::uint8_t;
using::uint16_t;
using::uint32_t;
using::uint64_t;

using::int_least8_t;
using::int_least16_t;
using::int_least32_t;
using::int_least64_t;

using::uint_least8_t;
using::uint_least16_t;
using::uint_least32_t;
using::uint_least64_t;

using::int_fast8_t;
using::int_fast16_t;
using::int_fast32_t;
using::int_fast64_t;

using::uint_fast8_t;
using::uint_fast16_t;
using::uint_fast32_t;
using::uint_fast64_t;

using::intptr_t;
using::uintptr_t;

using::intmax_t;
using::uintmax_t;

} }
# 64 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/typeinfo" 2 3
# 67 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/typeinfo" 3


namespace std // purposefully not using versioning namespace
{

class __attribute__ ((__visibility__("default"))) type_info
{
    type_info& operator=(const type_info&);
    type_info(const type_info&);
protected:

    const char* __type_name;





    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit type_info(const char* __n)

        : __type_name(__n) {}




public:
    virtual ~type_info();

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const char* name() const throw()

        {return __type_name;}




    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool before(const type_info& __arg) const throw()

        {return __type_name < __arg.__type_name;}






    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_t hash_code() const throw()

        {return *reinterpret_cast<const size_t*>(&__type_name);}
# 126 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/typeinfo" 3
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator==(const type_info& __arg) const throw()

        {return __type_name == __arg.__type_name;}






    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator!=(const type_info& __arg) const throw()
        {return !operator==(__arg);}







};

class __attribute__ ((__visibility__("default"))) bad_cast
    : public exception
{
public:
    bad_cast() throw();
    virtual ~bad_cast() throw();
    virtual const char* what() const throw();
};

class __attribute__ ((__visibility__("default"))) bad_typeid
    : public exception
{
public:
    bad_typeid() throw();
    virtual ~bad_typeid() throw();
    virtual const char* what() const throw();
};

} // std
# 599 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/memory" 2 3


# 1 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/new" 1 3
// -*- C++ -*-
//===----------------------------- new ------------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is dual licensed under the MIT and the University of Illinois Open
// Source Licenses. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//




/*
    new synopsis

namespace std
{

class bad_alloc
    : public exception
{
public:
    bad_alloc() noexcept;
    bad_alloc(const bad_alloc&) noexcept;
    bad_alloc& operator=(const bad_alloc&) noexcept;
    virtual const char* what() const noexcept;
};

class bad_array_length : public bad_alloc // C++14
{
public:
    bad_array_length() noexcept;
};

class bad_array_new_length : public bad_alloc
{
public:
    bad_array_new_length() noexcept;
};

struct nothrow_t {};
extern const nothrow_t nothrow;
typedef void (*new_handler)();
new_handler set_new_handler(new_handler new_p) noexcept;
new_handler get_new_handler() noexcept;

}  // std

void* operator new(std::size_t size);                                   // replaceable
void* operator new(std::size_t size, const std::nothrow_t&) noexcept;   // replaceable
void  operator delete(void* ptr) noexcept;                              // replaceable
void  operator delete(void* ptr, const std::nothrow_t&) noexcept;       // replaceable

void* operator new[](std::size_t size);                                 // replaceable
void* operator new[](std::size_t size, const std::nothrow_t&) noexcept; // replaceable
void  operator delete[](void* ptr) noexcept;                            // replaceable
void  operator delete[](void* ptr, const std::nothrow_t&) noexcept;     // replaceable

void* operator new  (std::size_t size, void* ptr) noexcept;
void* operator new[](std::size_t size, void* ptr) noexcept;
void  operator delete  (void* ptr, void*) noexcept;
void  operator delete[](void* ptr, void*) noexcept;

*/
# 73 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/new" 3


namespace std // purposefully not using versioning namespace
{

class __attribute__ ((__visibility__("default"))) bad_alloc
    : public exception
{
public:
    bad_alloc() throw();
    virtual ~bad_alloc() throw();
    virtual const char* what() const throw();
};

class __attribute__ ((__visibility__("default"))) bad_array_new_length
    : public bad_alloc
{
public:
    bad_array_new_length() throw();
    virtual ~bad_array_new_length() throw();
    virtual const char* what() const throw();
};
# 111 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/new" 3
__attribute__ ((__visibility__("default"))) void __throw_bad_alloc(); // not in C++ spec

struct __attribute__ ((__type_visibility__("default"))) nothrow_t {};
extern __attribute__ ((__visibility__("default"))) const nothrow_t nothrow;
typedef void (*new_handler)();
__attribute__ ((__visibility__("default"))) new_handler set_new_handler(new_handler) throw();
__attribute__ ((__visibility__("default"))) new_handler get_new_handler() throw();

} // std







__attribute__ ((__visibility__("default"))) void* operator new(std::size_t __sz)

    throw(std::bad_alloc)

;
__attribute__ ((__visibility__("default"))) void* operator new(std::size_t __sz, const std::nothrow_t&) throw() __attribute__((__malloc__));
__attribute__ ((__visibility__("default"))) void operator delete(void* __p) throw();
__attribute__ ((__visibility__("default"))) void operator delete(void* __p, const std::nothrow_t&) throw();

__attribute__ ((__visibility__("default"))) void* operator new[](std::size_t __sz)

    throw(std::bad_alloc)

;
__attribute__ ((__visibility__("default"))) void* operator new[](std::size_t __sz, const std::nothrow_t&) throw() __attribute__((__malloc__));
__attribute__ ((__visibility__("default"))) void operator delete[](void* __p) throw();
__attribute__ ((__visibility__("default"))) void operator delete[](void* __p, const std::nothrow_t&) throw();

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) void* operator new (std::size_t, void* __p) throw() {return __p;}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) void* operator new[](std::size_t, void* __p) throw() {return __p;}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) void operator delete (void*, void*) throw() {}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) void operator delete[](void*, void*) throw() {}

namespace std {inline namespace __1 {

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) void *__allocate(size_t __size) {



  return __builtin_operator_new(__size);

}

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) void __deallocate(void *__ptr) {



  __builtin_operator_delete(__ptr);

}

} }
# 602 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/memory" 2 3

# 1 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/limits" 1 3
// -*- C++ -*-
//===---------------------------- limits ----------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is dual licensed under the MIT and the University of Illinois Open
// Source Licenses. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//




/*
    limits synopsis

namespace std
{

template<class T>
class numeric_limits
{
public:
    static constexpr bool is_specialized = false;
    static constexpr T min() noexcept;
    static constexpr T max() noexcept;
    static constexpr T lowest() noexcept;

    static constexpr int  digits = 0;
    static constexpr int  digits10 = 0;
    static constexpr int  max_digits10 = 0;
    static constexpr bool is_signed = false;
    static constexpr bool is_integer = false;
    static constexpr bool is_exact = false;
    static constexpr int  radix = 0;
    static constexpr T epsilon() noexcept;
    static constexpr T round_error() noexcept;

    static constexpr int  min_exponent = 0;
    static constexpr int  min_exponent10 = 0;
    static constexpr int  max_exponent = 0;
    static constexpr int  max_exponent10 = 0;

    static constexpr bool has_infinity = false;
    static constexpr bool has_quiet_NaN = false;
    static constexpr bool has_signaling_NaN = false;
    static constexpr float_denorm_style has_denorm = denorm_absent;
    static constexpr bool has_denorm_loss = false;
    static constexpr T infinity() noexcept;
    static constexpr T quiet_NaN() noexcept;
    static constexpr T signaling_NaN() noexcept;
    static constexpr T denorm_min() noexcept;

    static constexpr bool is_iec559 = false;
    static constexpr bool is_bounded = false;
    static constexpr bool is_modulo = false;

    static constexpr bool traps = false;
    static constexpr bool tinyness_before = false;
    static constexpr float_round_style round_style = round_toward_zero;
};

enum float_round_style
{
    round_indeterminate       = -1,
    round_toward_zero         =  0,
    round_to_nearest          =  1,
    round_toward_infinity     =  2,
    round_toward_neg_infinity =  3
};

enum float_denorm_style
{
    denorm_indeterminate = -1,
    denorm_absent = 0,
    denorm_present = 1
};

template<> class numeric_limits<cv bool>;

template<> class numeric_limits<cv char>;
template<> class numeric_limits<cv signed char>;
template<> class numeric_limits<cv unsigned char>;
template<> class numeric_limits<cv wchar_t>;
template<> class numeric_limits<cv char16_t>;
template<> class numeric_limits<cv char32_t>;

template<> class numeric_limits<cv short>;
template<> class numeric_limits<cv int>;
template<> class numeric_limits<cv long>;
template<> class numeric_limits<cv long long>;
template<> class numeric_limits<cv unsigned short>;
template<> class numeric_limits<cv unsigned int>;
template<> class numeric_limits<cv unsigned long>;
template<> class numeric_limits<cv unsigned long long>;

template<> class numeric_limits<cv float>;
template<> class numeric_limits<cv double>;
template<> class numeric_limits<cv long double>;

}  // std

*/
# 107 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/limits" 3





# 1 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/__undef_min_max" 1 3
// -*- C++ -*-
//===----------------------------------------------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is dual licensed under the MIT and the University of Illinois Open
// Source Licenses. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
# 113 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/limits" 2 3
# 122 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/limits" 3
namespace std {inline namespace __1 {

enum float_round_style
{
    round_indeterminate = -1,
    round_toward_zero = 0,
    round_to_nearest = 1,
    round_toward_infinity = 2,
    round_toward_neg_infinity = 3
};

enum float_denorm_style
{
    denorm_indeterminate = -1,
    denorm_absent = 0,
    denorm_present = 1
};

template <class _Tp, bool = is_arithmetic<_Tp>::value>
class __libcpp_numeric_limits
{
protected:
    typedef _Tp type;

    static const bool is_specialized = false;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type min() throw() {return type();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type max() throw() {return type();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type lowest() throw() {return type();}

    static const int digits = 0;
    static const int digits10 = 0;
    static const int max_digits10 = 0;
    static const bool is_signed = false;
    static const bool is_integer = false;
    static const bool is_exact = false;
    static const int radix = 0;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type epsilon() throw() {return type();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type round_error() throw() {return type();}

    static const int min_exponent = 0;
    static const int min_exponent10 = 0;
    static const int max_exponent = 0;
    static const int max_exponent10 = 0;

    static const bool has_infinity = false;
    static const bool has_quiet_NaN = false;
    static const bool has_signaling_NaN = false;
    static const float_denorm_style has_denorm = denorm_absent;
    static const bool has_denorm_loss = false;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type infinity() throw() {return type();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type quiet_NaN() throw() {return type();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type signaling_NaN() throw() {return type();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type denorm_min() throw() {return type();}

    static const bool is_iec559 = false;
    static const bool is_bounded = false;
    static const bool is_modulo = false;

    static const bool traps = false;
    static const bool tinyness_before = false;
    static const float_round_style round_style = round_toward_zero;
};

template <class _Tp, int digits, bool is_signed>
struct __libcpp_compute_min
{
    static const _Tp value = _Tp(_Tp(1) << digits);
};

template <class _Tp, int digits>
struct __libcpp_compute_min<_Tp, digits, false>
{
    static const _Tp value = _Tp(0);
};

template <class _Tp>
class __libcpp_numeric_limits<_Tp, true>
{
protected:
    typedef _Tp type;

    static const bool is_specialized = true;

    static const bool is_signed = type(-1) < type(0);
    static const int digits = static_cast<int>(sizeof(type) * 8 - is_signed);
    static const int digits10 = digits * 3 / 10;
    static const int max_digits10 = 0;
    static const type __min = __libcpp_compute_min<type, digits, is_signed>::value;
    static const type __max = is_signed ? type(type(~0) ^ __min) : type(~0);
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type min() throw() {return __min;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type max() throw() {return __max;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type lowest() throw() {return min();}

    static const bool is_integer = true;
    static const bool is_exact = true;
    static const int radix = 2;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type epsilon() throw() {return type(0);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type round_error() throw() {return type(0);}

    static const int min_exponent = 0;
    static const int min_exponent10 = 0;
    static const int max_exponent = 0;
    static const int max_exponent10 = 0;

    static const bool has_infinity = false;
    static const bool has_quiet_NaN = false;
    static const bool has_signaling_NaN = false;
    static const float_denorm_style has_denorm = denorm_absent;
    static const bool has_denorm_loss = false;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type infinity() throw() {return type(0);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type quiet_NaN() throw() {return type(0);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type signaling_NaN() throw() {return type(0);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type denorm_min() throw() {return type(0);}

    static const bool is_iec559 = false;
    static const bool is_bounded = true;
    static const bool is_modulo = true;


    static const bool traps = true;



    static const bool tinyness_before = false;
    static const float_round_style round_style = round_toward_zero;
};

template <>
class __libcpp_numeric_limits<bool, true>
{
protected:
    typedef bool type;

    static const bool is_specialized = true;

    static const bool is_signed = false;
    static const int digits = 1;
    static const int digits10 = 0;
    static const int max_digits10 = 0;
    static const type __min = false;
    static const type __max = true;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type min() throw() {return __min;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type max() throw() {return __max;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type lowest() throw() {return min();}

    static const bool is_integer = true;
    static const bool is_exact = true;
    static const int radix = 2;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type epsilon() throw() {return type(0);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type round_error() throw() {return type(0);}

    static const int min_exponent = 0;
    static const int min_exponent10 = 0;
    static const int max_exponent = 0;
    static const int max_exponent10 = 0;

    static const bool has_infinity = false;
    static const bool has_quiet_NaN = false;
    static const bool has_signaling_NaN = false;
    static const float_denorm_style has_denorm = denorm_absent;
    static const bool has_denorm_loss = false;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type infinity() throw() {return type(0);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type quiet_NaN() throw() {return type(0);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type signaling_NaN() throw() {return type(0);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type denorm_min() throw() {return type(0);}

    static const bool is_iec559 = false;
    static const bool is_bounded = true;
    static const bool is_modulo = false;

    static const bool traps = false;
    static const bool tinyness_before = false;
    static const float_round_style round_style = round_toward_zero;
};

template <>
class __libcpp_numeric_limits<float, true>
{
protected:
    typedef float type;

    static const bool is_specialized = true;

    static const bool is_signed = true;
    static const int digits = 24;
    static const int digits10 = 6;
    static const int max_digits10 = 2+(digits * 30103)/100000;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type min() throw() {return 1.17549435e-38F;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type max() throw() {return 3.40282347e+38F;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type lowest() throw() {return -max();}

    static const bool is_integer = false;
    static const bool is_exact = false;
    static const int radix = 2;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type epsilon() throw() {return 1.19209290e-7F;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type round_error() throw() {return 0.5F;}

    static const int min_exponent = (-125);
    static const int min_exponent10 = (-37);
    static const int max_exponent = 128;
    static const int max_exponent10 = 38;

    static const bool has_infinity = true;
    static const bool has_quiet_NaN = true;
    static const bool has_signaling_NaN = true;
    static const float_denorm_style has_denorm = denorm_present;
    static const bool has_denorm_loss = false;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type infinity() throw() {return __builtin_huge_valf();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type quiet_NaN() throw() {return __builtin_nanf("");}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type signaling_NaN() throw() {return __builtin_nansf("");}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type denorm_min() throw() {return 1.40129846e-45F;}

    static const bool is_iec559 = true;
    static const bool is_bounded = true;
    static const bool is_modulo = false;

    static const bool traps = false;
    static const bool tinyness_before = false;
    static const float_round_style round_style = round_to_nearest;
};

template <>
class __libcpp_numeric_limits<double, true>
{
protected:
    typedef double type;

    static const bool is_specialized = true;

    static const bool is_signed = true;
    static const int digits = 53;
    static const int digits10 = 15;
    static const int max_digits10 = 2+(digits * 30103)/100000;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type min() throw() {return 2.2250738585072014e-308;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type max() throw() {return 1.7976931348623157e+308;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type lowest() throw() {return -max();}

    static const bool is_integer = false;
    static const bool is_exact = false;
    static const int radix = 2;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type epsilon() throw() {return 2.2204460492503131e-16;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type round_error() throw() {return 0.5;}

    static const int min_exponent = (-1021);
    static const int min_exponent10 = (-307);
    static const int max_exponent = 1024;
    static const int max_exponent10 = 308;

    static const bool has_infinity = true;
    static const bool has_quiet_NaN = true;
    static const bool has_signaling_NaN = true;
    static const float_denorm_style has_denorm = denorm_present;
    static const bool has_denorm_loss = false;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type infinity() throw() {return __builtin_huge_val();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type quiet_NaN() throw() {return __builtin_nan("");}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type signaling_NaN() throw() {return __builtin_nans("");}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type denorm_min() throw() {return 4.9406564584124654e-324;}

    static const bool is_iec559 = true;
    static const bool is_bounded = true;
    static const bool is_modulo = false;

    static const bool traps = false;
    static const bool tinyness_before = false;
    static const float_round_style round_style = round_to_nearest;
};

template <>
class __libcpp_numeric_limits<long double, true>
{
protected:
    typedef long double type;

    static const bool is_specialized = true;

    static const bool is_signed = true;
    static const int digits = 64;
    static const int digits10 = 18;
    static const int max_digits10 = 2+(digits * 30103)/100000;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type min() throw() {return 3.36210314311209350626e-4932L;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type max() throw() {return 1.18973149535723176502e+4932L;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type lowest() throw() {return -max();}

    static const bool is_integer = false;
    static const bool is_exact = false;
    static const int radix = 2;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type epsilon() throw() {return 1.08420217248550443401e-19L;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type round_error() throw() {return 0.5;}

    static const int min_exponent = (-16381);
    static const int min_exponent10 = (-4931);
    static const int max_exponent = 16384;
    static const int max_exponent10 = 4932;

    static const bool has_infinity = true;
    static const bool has_quiet_NaN = true;
    static const bool has_signaling_NaN = true;
    static const float_denorm_style has_denorm = denorm_present;
    static const bool has_denorm_loss = false;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type infinity() throw() {return __builtin_huge_vall();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type quiet_NaN() throw() {return __builtin_nanl("");}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type signaling_NaN() throw() {return __builtin_nansl("");}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type denorm_min() throw() {return 3.64519953188247460253e-4951L;}




    static const bool is_iec559 = true;

    static const bool is_bounded = true;
    static const bool is_modulo = false;

    static const bool traps = false;
    static const bool tinyness_before = false;
    static const float_round_style round_style = round_to_nearest;
};

template <class _Tp>
class __attribute__ ((__type_visibility__("default"))) numeric_limits
    : private __libcpp_numeric_limits<typename remove_cv<_Tp>::type>
{
    typedef __libcpp_numeric_limits<typename remove_cv<_Tp>::type> __base;
    typedef typename __base::type type;
public:
    static const bool is_specialized = __base::is_specialized;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type min() throw() {return __base::min();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type max() throw() {return __base::max();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type lowest() throw() {return __base::lowest();}

    static const int digits = __base::digits;
    static const int digits10 = __base::digits10;
    static const int max_digits10 = __base::max_digits10;
    static const bool is_signed = __base::is_signed;
    static const bool is_integer = __base::is_integer;
    static const bool is_exact = __base::is_exact;
    static const int radix = __base::radix;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type epsilon() throw() {return __base::epsilon();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type round_error() throw() {return __base::round_error();}

    static const int min_exponent = __base::min_exponent;
    static const int min_exponent10 = __base::min_exponent10;
    static const int max_exponent = __base::max_exponent;
    static const int max_exponent10 = __base::max_exponent10;

    static const bool has_infinity = __base::has_infinity;
    static const bool has_quiet_NaN = __base::has_quiet_NaN;
    static const bool has_signaling_NaN = __base::has_signaling_NaN;
    static const float_denorm_style has_denorm = __base::has_denorm;
    static const bool has_denorm_loss = __base::has_denorm_loss;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type infinity() throw() {return __base::infinity();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type quiet_NaN() throw() {return __base::quiet_NaN();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type signaling_NaN() throw() {return __base::signaling_NaN();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type denorm_min() throw() {return __base::denorm_min();}

    static const bool is_iec559 = __base::is_iec559;
    static const bool is_bounded = __base::is_bounded;
    static const bool is_modulo = __base::is_modulo;

    static const bool traps = __base::traps;
    static const bool tinyness_before = __base::tinyness_before;
    static const float_round_style round_style = __base::round_style;
};

template <class _Tp>
                      const bool numeric_limits<_Tp>::is_specialized;
template <class _Tp>
                      const int numeric_limits<_Tp>::digits;
template <class _Tp>
                      const int numeric_limits<_Tp>::digits10;
template <class _Tp>
                      const int numeric_limits<_Tp>::max_digits10;
template <class _Tp>
                      const bool numeric_limits<_Tp>::is_signed;
template <class _Tp>
                      const bool numeric_limits<_Tp>::is_integer;
template <class _Tp>
                      const bool numeric_limits<_Tp>::is_exact;
template <class _Tp>
                      const int numeric_limits<_Tp>::radix;
template <class _Tp>
                      const int numeric_limits<_Tp>::min_exponent;
template <class _Tp>
                      const int numeric_limits<_Tp>::min_exponent10;
template <class _Tp>
                      const int numeric_limits<_Tp>::max_exponent;
template <class _Tp>
                      const int numeric_limits<_Tp>::max_exponent10;
template <class _Tp>
                      const bool numeric_limits<_Tp>::has_infinity;
template <class _Tp>
                      const bool numeric_limits<_Tp>::has_quiet_NaN;
template <class _Tp>
                      const bool numeric_limits<_Tp>::has_signaling_NaN;
template <class _Tp>
                      const float_denorm_style numeric_limits<_Tp>::has_denorm;
template <class _Tp>
                      const bool numeric_limits<_Tp>::has_denorm_loss;
template <class _Tp>
                      const bool numeric_limits<_Tp>::is_iec559;
template <class _Tp>
                      const bool numeric_limits<_Tp>::is_bounded;
template <class _Tp>
                      const bool numeric_limits<_Tp>::is_modulo;
template <class _Tp>
                      const bool numeric_limits<_Tp>::traps;
template <class _Tp>
                      const bool numeric_limits<_Tp>::tinyness_before;
template <class _Tp>
                      const float_round_style numeric_limits<_Tp>::round_style;

template <class _Tp>
class __attribute__ ((__type_visibility__("default"))) numeric_limits<const _Tp>
    : private numeric_limits<_Tp>
{
    typedef numeric_limits<_Tp> __base;
    typedef _Tp type;
public:
    static const bool is_specialized = __base::is_specialized;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type min() throw() {return __base::min();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type max() throw() {return __base::max();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type lowest() throw() {return __base::lowest();}

    static const int digits = __base::digits;
    static const int digits10 = __base::digits10;
    static const int max_digits10 = __base::max_digits10;
    static const bool is_signed = __base::is_signed;
    static const bool is_integer = __base::is_integer;
    static const bool is_exact = __base::is_exact;
    static const int radix = __base::radix;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type epsilon() throw() {return __base::epsilon();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type round_error() throw() {return __base::round_error();}

    static const int min_exponent = __base::min_exponent;
    static const int min_exponent10 = __base::min_exponent10;
    static const int max_exponent = __base::max_exponent;
    static const int max_exponent10 = __base::max_exponent10;

    static const bool has_infinity = __base::has_infinity;
    static const bool has_quiet_NaN = __base::has_quiet_NaN;
    static const bool has_signaling_NaN = __base::has_signaling_NaN;
    static const float_denorm_style has_denorm = __base::has_denorm;
    static const bool has_denorm_loss = __base::has_denorm_loss;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type infinity() throw() {return __base::infinity();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type quiet_NaN() throw() {return __base::quiet_NaN();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type signaling_NaN() throw() {return __base::signaling_NaN();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type denorm_min() throw() {return __base::denorm_min();}

    static const bool is_iec559 = __base::is_iec559;
    static const bool is_bounded = __base::is_bounded;
    static const bool is_modulo = __base::is_modulo;

    static const bool traps = __base::traps;
    static const bool tinyness_before = __base::tinyness_before;
    static const float_round_style round_style = __base::round_style;
};

template <class _Tp>
                      const bool numeric_limits<const _Tp>::is_specialized;
template <class _Tp>
                      const int numeric_limits<const _Tp>::digits;
template <class _Tp>
                      const int numeric_limits<const _Tp>::digits10;
template <class _Tp>
                      const int numeric_limits<const _Tp>::max_digits10;
template <class _Tp>
                      const bool numeric_limits<const _Tp>::is_signed;
template <class _Tp>
                      const bool numeric_limits<const _Tp>::is_integer;
template <class _Tp>
                      const bool numeric_limits<const _Tp>::is_exact;
template <class _Tp>
                      const int numeric_limits<const _Tp>::radix;
template <class _Tp>
                      const int numeric_limits<const _Tp>::min_exponent;
template <class _Tp>
                      const int numeric_limits<const _Tp>::min_exponent10;
template <class _Tp>
                      const int numeric_limits<const _Tp>::max_exponent;
template <class _Tp>
                      const int numeric_limits<const _Tp>::max_exponent10;
template <class _Tp>
                      const bool numeric_limits<const _Tp>::has_infinity;
template <class _Tp>
                      const bool numeric_limits<const _Tp>::has_quiet_NaN;
template <class _Tp>
                      const bool numeric_limits<const _Tp>::has_signaling_NaN;
template <class _Tp>
                      const float_denorm_style numeric_limits<const _Tp>::has_denorm;
template <class _Tp>
                      const bool numeric_limits<const _Tp>::has_denorm_loss;
template <class _Tp>
                      const bool numeric_limits<const _Tp>::is_iec559;
template <class _Tp>
                      const bool numeric_limits<const _Tp>::is_bounded;
template <class _Tp>
                      const bool numeric_limits<const _Tp>::is_modulo;
template <class _Tp>
                      const bool numeric_limits<const _Tp>::traps;
template <class _Tp>
                      const bool numeric_limits<const _Tp>::tinyness_before;
template <class _Tp>
                      const float_round_style numeric_limits<const _Tp>::round_style;

template <class _Tp>
class __attribute__ ((__type_visibility__("default"))) numeric_limits<volatile _Tp>
    : private numeric_limits<_Tp>
{
    typedef numeric_limits<_Tp> __base;
    typedef _Tp type;
public:
    static const bool is_specialized = __base::is_specialized;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type min() throw() {return __base::min();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type max() throw() {return __base::max();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type lowest() throw() {return __base::lowest();}

    static const int digits = __base::digits;
    static const int digits10 = __base::digits10;
    static const int max_digits10 = __base::max_digits10;
    static const bool is_signed = __base::is_signed;
    static const bool is_integer = __base::is_integer;
    static const bool is_exact = __base::is_exact;
    static const int radix = __base::radix;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type epsilon() throw() {return __base::epsilon();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type round_error() throw() {return __base::round_error();}

    static const int min_exponent = __base::min_exponent;
    static const int min_exponent10 = __base::min_exponent10;
    static const int max_exponent = __base::max_exponent;
    static const int max_exponent10 = __base::max_exponent10;

    static const bool has_infinity = __base::has_infinity;
    static const bool has_quiet_NaN = __base::has_quiet_NaN;
    static const bool has_signaling_NaN = __base::has_signaling_NaN;
    static const float_denorm_style has_denorm = __base::has_denorm;
    static const bool has_denorm_loss = __base::has_denorm_loss;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type infinity() throw() {return __base::infinity();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type quiet_NaN() throw() {return __base::quiet_NaN();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type signaling_NaN() throw() {return __base::signaling_NaN();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type denorm_min() throw() {return __base::denorm_min();}

    static const bool is_iec559 = __base::is_iec559;
    static const bool is_bounded = __base::is_bounded;
    static const bool is_modulo = __base::is_modulo;

    static const bool traps = __base::traps;
    static const bool tinyness_before = __base::tinyness_before;
    static const float_round_style round_style = __base::round_style;
};

template <class _Tp>
                      const bool numeric_limits<volatile _Tp>::is_specialized;
template <class _Tp>
                      const int numeric_limits<volatile _Tp>::digits;
template <class _Tp>
                      const int numeric_limits<volatile _Tp>::digits10;
template <class _Tp>
                      const int numeric_limits<volatile _Tp>::max_digits10;
template <class _Tp>
                      const bool numeric_limits<volatile _Tp>::is_signed;
template <class _Tp>
                      const bool numeric_limits<volatile _Tp>::is_integer;
template <class _Tp>
                      const bool numeric_limits<volatile _Tp>::is_exact;
template <class _Tp>
                      const int numeric_limits<volatile _Tp>::radix;
template <class _Tp>
                      const int numeric_limits<volatile _Tp>::min_exponent;
template <class _Tp>
                      const int numeric_limits<volatile _Tp>::min_exponent10;
template <class _Tp>
                      const int numeric_limits<volatile _Tp>::max_exponent;
template <class _Tp>
                      const int numeric_limits<volatile _Tp>::max_exponent10;
template <class _Tp>
                      const bool numeric_limits<volatile _Tp>::has_infinity;
template <class _Tp>
                      const bool numeric_limits<volatile _Tp>::has_quiet_NaN;
template <class _Tp>
                      const bool numeric_limits<volatile _Tp>::has_signaling_NaN;
template <class _Tp>
                      const float_denorm_style numeric_limits<volatile _Tp>::has_denorm;
template <class _Tp>
                      const bool numeric_limits<volatile _Tp>::has_denorm_loss;
template <class _Tp>
                      const bool numeric_limits<volatile _Tp>::is_iec559;
template <class _Tp>
                      const bool numeric_limits<volatile _Tp>::is_bounded;
template <class _Tp>
                      const bool numeric_limits<volatile _Tp>::is_modulo;
template <class _Tp>
                      const bool numeric_limits<volatile _Tp>::traps;
template <class _Tp>
                      const bool numeric_limits<volatile _Tp>::tinyness_before;
template <class _Tp>
                      const float_round_style numeric_limits<volatile _Tp>::round_style;

template <class _Tp>
class __attribute__ ((__type_visibility__("default"))) numeric_limits<const volatile _Tp>
    : private numeric_limits<_Tp>
{
    typedef numeric_limits<_Tp> __base;
    typedef _Tp type;
public:
    static const bool is_specialized = __base::is_specialized;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type min() throw() {return __base::min();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type max() throw() {return __base::max();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type lowest() throw() {return __base::lowest();}

    static const int digits = __base::digits;
    static const int digits10 = __base::digits10;
    static const int max_digits10 = __base::max_digits10;
    static const bool is_signed = __base::is_signed;
    static const bool is_integer = __base::is_integer;
    static const bool is_exact = __base::is_exact;
    static const int radix = __base::radix;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type epsilon() throw() {return __base::epsilon();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type round_error() throw() {return __base::round_error();}

    static const int min_exponent = __base::min_exponent;
    static const int min_exponent10 = __base::min_exponent10;
    static const int max_exponent = __base::max_exponent;
    static const int max_exponent10 = __base::max_exponent10;

    static const bool has_infinity = __base::has_infinity;
    static const bool has_quiet_NaN = __base::has_quiet_NaN;
    static const bool has_signaling_NaN = __base::has_signaling_NaN;
    static const float_denorm_style has_denorm = __base::has_denorm;
    static const bool has_denorm_loss = __base::has_denorm_loss;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type infinity() throw() {return __base::infinity();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type quiet_NaN() throw() {return __base::quiet_NaN();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type signaling_NaN() throw() {return __base::signaling_NaN();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type denorm_min() throw() {return __base::denorm_min();}

    static const bool is_iec559 = __base::is_iec559;
    static const bool is_bounded = __base::is_bounded;
    static const bool is_modulo = __base::is_modulo;

    static const bool traps = __base::traps;
    static const bool tinyness_before = __base::tinyness_before;
    static const float_round_style round_style = __base::round_style;
};

template <class _Tp>
                      const bool numeric_limits<const volatile _Tp>::is_specialized;
template <class _Tp>
                      const int numeric_limits<const volatile _Tp>::digits;
template <class _Tp>
                      const int numeric_limits<const volatile _Tp>::digits10;
template <class _Tp>
                      const int numeric_limits<const volatile _Tp>::max_digits10;
template <class _Tp>
                      const bool numeric_limits<const volatile _Tp>::is_signed;
template <class _Tp>
                      const bool numeric_limits<const volatile _Tp>::is_integer;
template <class _Tp>
                      const bool numeric_limits<const volatile _Tp>::is_exact;
template <class _Tp>
                      const int numeric_limits<const volatile _Tp>::radix;
template <class _Tp>
                      const int numeric_limits<const volatile _Tp>::min_exponent;
template <class _Tp>
                      const int numeric_limits<const volatile _Tp>::min_exponent10;
template <class _Tp>
                      const int numeric_limits<const volatile _Tp>::max_exponent;
template <class _Tp>
                      const int numeric_limits<const volatile _Tp>::max_exponent10;
template <class _Tp>
                      const bool numeric_limits<const volatile _Tp>::has_infinity;
template <class _Tp>
                      const bool numeric_limits<const volatile _Tp>::has_quiet_NaN;
template <class _Tp>
                      const bool numeric_limits<const volatile _Tp>::has_signaling_NaN;
template <class _Tp>
                      const float_denorm_style numeric_limits<const volatile _Tp>::has_denorm;
template <class _Tp>
                      const bool numeric_limits<const volatile _Tp>::has_denorm_loss;
template <class _Tp>
                      const bool numeric_limits<const volatile _Tp>::is_iec559;
template <class _Tp>
                      const bool numeric_limits<const volatile _Tp>::is_bounded;
template <class _Tp>
                      const bool numeric_limits<const volatile _Tp>::is_modulo;
template <class _Tp>
                      const bool numeric_limits<const volatile _Tp>::traps;
template <class _Tp>
                      const bool numeric_limits<const volatile _Tp>::tinyness_before;
template <class _Tp>
                      const float_round_style numeric_limits<const volatile _Tp>::round_style;

} }
# 604 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/memory" 2 3
# 1 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/iterator" 1 3
// -*- C++ -*-
//===-------------------------- iterator ----------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is dual licensed under the MIT and the University of Illinois Open
// Source Licenses. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//




/*
    iterator synopsis

namespace std
{

template<class Iterator>
struct iterator_traits
{
    typedef typename Iterator::difference_type difference_type;
    typedef typename Iterator::value_type value_type;
    typedef typename Iterator::pointer pointer;
    typedef typename Iterator::reference reference;
    typedef typename Iterator::iterator_category iterator_category;
};

template<class T>
struct iterator_traits<T*>
{
    typedef ptrdiff_t difference_type;
    typedef T value_type;
    typedef T* pointer;
    typedef T& reference;
    typedef random_access_iterator_tag iterator_category;
};

template<class T>
struct iterator_traits<const T*>
{
    typedef ptrdiff_t difference_type;
    typedef T value_type;
    typedef const T* pointer;
    typedef const T& reference;
    typedef random_access_iterator_tag iterator_category;
};

template<class Category, class T, class Distance = ptrdiff_t,
         class Pointer = T*, class Reference = T&>
struct iterator
{
    typedef T         value_type;
    typedef Distance  difference_type;
    typedef Pointer   pointer;
    typedef Reference reference;
    typedef Category  iterator_category;
};

struct input_iterator_tag  {};
struct output_iterator_tag {};
struct forward_iterator_tag       : public input_iterator_tag         {};
struct bidirectional_iterator_tag : public forward_iterator_tag       {};
struct random_access_iterator_tag : public bidirectional_iterator_tag {};

// extension: second argument not conforming to C++03
template <class InputIterator>
void advance(InputIterator& i,
             typename iterator_traits<InputIterator>::difference_type n);

template <class InputIterator>
typename iterator_traits<InputIterator>::difference_type
distance(InputIterator first, InputIterator last);

template <class Iterator>
class reverse_iterator
    : public iterator<typename iterator_traits<Iterator>::iterator_category,
                      typename iterator_traits<Iterator>::value_type,
                      typename iterator_traits<Iterator>::difference_type,
                      typename iterator_traits<Iterator>::pointer,
                      typename iterator_traits<Iterator>::reference>
{
protected:
    Iterator current;
public:
    typedef Iterator                                            iterator_type;
    typedef typename iterator_traits<Iterator>::difference_type difference_type;
    typedef typename iterator_traits<Iterator>::reference       reference;
    typedef typename iterator_traits<Iterator>::pointer         pointer;

    reverse_iterator();
    explicit reverse_iterator(Iterator x);
    template <class U> reverse_iterator(const reverse_iterator<U>& u);
    Iterator base() const;
    reference operator*() const;
    pointer   operator->() const;
    reverse_iterator& operator++();
    reverse_iterator  operator++(int);
    reverse_iterator& operator--();
    reverse_iterator  operator--(int);
    reverse_iterator  operator+ (difference_type n) const;
    reverse_iterator& operator+=(difference_type n);
    reverse_iterator  operator- (difference_type n) const;
    reverse_iterator& operator-=(difference_type n);
    reference         operator[](difference_type n) const;
};

template <class Iterator1, class Iterator2>
bool
operator==(const reverse_iterator<Iterator1>& x, const reverse_iterator<Iterator2>& y);

template <class Iterator1, class Iterator2>
bool
operator<(const reverse_iterator<Iterator1>& x, const reverse_iterator<Iterator2>& y);

template <class Iterator1, class Iterator2>
bool
operator!=(const reverse_iterator<Iterator1>& x, const reverse_iterator<Iterator2>& y);

template <class Iterator1, class Iterator2>
bool
operator>(const reverse_iterator<Iterator1>& x, const reverse_iterator<Iterator2>& y);

template <class Iterator1, class Iterator2>
bool
operator>=(const reverse_iterator<Iterator1>& x, const reverse_iterator<Iterator2>& y);

template <class Iterator1, class Iterator2>
bool
operator<=(const reverse_iterator<Iterator1>& x, const reverse_iterator<Iterator2>& y);

template <class Iterator1, class Iterator2>
typename reverse_iterator<Iterator1>::difference_type
operator-(const reverse_iterator<Iterator1>& x, const reverse_iterator<Iterator2>& y);

template <class Iterator>
reverse_iterator<Iterator>
operator+(typename reverse_iterator<Iterator>::difference_type n, const reverse_iterator<Iterator>& x);

template <class Iterator> reverse_iterator<Iterator> make_reverse_iterator(Iterator i); // C++14

template <class Container>
class back_insert_iterator
{
protected:
    Container* container;
public:
    typedef Container                   container_type;
    typedef void                        value_type;
    typedef void                        difference_type;
    typedef back_insert_iterator<Cont>& reference;
    typedef void                        pointer;

    explicit back_insert_iterator(Container& x);
    back_insert_iterator& operator=(const typename Container::value_type& value);
    back_insert_iterator& operator*();
    back_insert_iterator& operator++();
    back_insert_iterator  operator++(int);
};

template <class Container> back_insert_iterator<Container> back_inserter(Container& x);

template <class Container>
class front_insert_iterator
{
protected:
    Container* container;
public:
    typedef Container                    container_type;
    typedef void                         value_type;
    typedef void                         difference_type;
    typedef front_insert_iterator<Cont>& reference;
    typedef void                         pointer;

    explicit front_insert_iterator(Container& x);
    front_insert_iterator& operator=(const typename Container::value_type& value);
    front_insert_iterator& operator*();
    front_insert_iterator& operator++();
    front_insert_iterator  operator++(int);
};

template <class Container> front_insert_iterator<Container> front_inserter(Container& x);

template <class Container>
class insert_iterator
{
protected:
    Container* container;
    typename Container::iterator iter;
public:
    typedef Container              container_type;
    typedef void                   value_type;
    typedef void                   difference_type;
    typedef insert_iterator<Cont>& reference;
    typedef void                   pointer;

    insert_iterator(Container& x, typename Container::iterator i);
    insert_iterator& operator=(const typename Container::value_type& value);
    insert_iterator& operator*();
    insert_iterator& operator++();
    insert_iterator& operator++(int);
};

template <class Container, class Iterator>
insert_iterator<Container> inserter(Container& x, Iterator i);

template <class T, class charT = char, class traits = char_traits<charT>, class Distance = ptrdiff_t>
class istream_iterator
    : public iterator<input_iterator_tag, T, Distance, const T*, const T&>
{
public:
    typedef charT char_type;
    typedef traits traits_type;
    typedef basic_istream<charT,traits> istream_type;

    istream_iterator();
    istream_iterator(istream_type& s);
    istream_iterator(const istream_iterator& x);
    ~istream_iterator();

    const T& operator*() const;
    const T* operator->() const;
    istream_iterator& operator++();
    istream_iterator  operator++(int);
};

template <class T, class charT, class traits, class Distance>
bool operator==(const istream_iterator<T,charT,traits,Distance>& x,
                const istream_iterator<T,charT,traits,Distance>& y);
template <class T, class charT, class traits, class Distance>
bool operator!=(const istream_iterator<T,charT,traits,Distance>& x,
                const istream_iterator<T,charT,traits,Distance>& y);

template <class T, class charT = char, class traits = char_traits<charT> >
class ostream_iterator
    : public iterator<output_iterator_tag, void, void, void ,void>
{
public:
    typedef charT char_type;
    typedef traits traits_type;
    typedef basic_ostream<charT,traits> ostream_type;

    ostream_iterator(ostream_type& s);
    ostream_iterator(ostream_type& s, const charT* delimiter);
    ostream_iterator(const ostream_iterator& x);
    ~ostream_iterator();
    ostream_iterator& operator=(const T& value);

    ostream_iterator& operator*();
    ostream_iterator& operator++();
    ostream_iterator& operator++(int);
};

template<class charT, class traits = char_traits<charT> >
class istreambuf_iterator
    : public iterator<input_iterator_tag, charT,
                      typename traits::off_type, unspecified,
                      charT>
{
public:
    typedef charT                         char_type;
    typedef traits                        traits_type;
    typedef typename traits::int_type     int_type;
    typedef basic_streambuf<charT,traits> streambuf_type;
    typedef basic_istream<charT,traits>   istream_type;

    istreambuf_iterator() noexcept;
    istreambuf_iterator(istream_type& s) noexcept;
    istreambuf_iterator(streambuf_type* s) noexcept;
    istreambuf_iterator(a-private-type) noexcept;

    charT                operator*() const;
    pointer operator->() const;
    istreambuf_iterator& operator++();
    a-private-type       operator++(int);

    bool equal(const istreambuf_iterator& b) const;
};

template <class charT, class traits>
bool operator==(const istreambuf_iterator<charT,traits>& a,
                const istreambuf_iterator<charT,traits>& b);
template <class charT, class traits>
bool operator!=(const istreambuf_iterator<charT,traits>& a,
                const istreambuf_iterator<charT,traits>& b);

template <class charT, class traits = char_traits<charT> >
class ostreambuf_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
{
public:
    typedef charT                         char_type;
    typedef traits                        traits_type;
    typedef basic_streambuf<charT,traits> streambuf_type;
    typedef basic_ostream<charT,traits>   ostream_type;

    ostreambuf_iterator(ostream_type& s) noexcept;
    ostreambuf_iterator(streambuf_type* s) noexcept;
    ostreambuf_iterator& operator=(charT c);
    ostreambuf_iterator& operator*();
    ostreambuf_iterator& operator++();
    ostreambuf_iterator& operator++(int);
    bool failed() const noexcept;
};

template <class C> auto begin(C& c) -> decltype(c.begin());
template <class C> auto begin(const C& c) -> decltype(c.begin());
template <class C> auto end(C& c) -> decltype(c.end());
template <class C> auto end(const C& c) -> decltype(c.end());
template <class T, size_t N> T* begin(T (&array)[N]);
template <class T, size_t N> T* end(T (&array)[N]);

template <class C> auto cbegin(const C& c) -> decltype(std::begin(c));        // C++14
template <class C> auto cend(const C& c) -> decltype(std::end(c));            // C++14
template <class C> auto rbegin(C& c) -> decltype(c.rbegin());                 // C++14
template <class C> auto rbegin(const C& c) -> decltype(c.rbegin());           // C++14
template <class C> auto rend(C& c) -> decltype(c.rend());                     // C++14
template <class C> auto rend(const C& c) -> decltype(c.rend());               // C++14
template <class E> reverse_iterator<const E*> rbegin(initializer_list<E> il); // C++14
template <class E> reverse_iterator<const E*> rend(initializer_list<E> il);   // C++14
template <class T, size_t N> reverse_iterator<T*> rbegin(T (&array)[N]);      // C++14
template <class T, size_t N> reverse_iterator<T*> rend(T (&array)[N]);        // C++14
template <class C> auto crbegin(const C& c) -> decltype(std::rbegin(c));      // C++14
template <class C> auto crend(const C& c) -> decltype(std::rend(c));          // C++14

}  // std

*/



# 1 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/__functional_base" 1 3
// -*- C++ -*-
//===----------------------------------------------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is dual licensed under the MIT and the University of Illinois Open
// Source Licenses. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
# 22 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/__functional_base" 3


namespace std {inline namespace __1 {

template <class _Arg, class _Result>
struct __attribute__ ((__type_visibility__("default"))) unary_function
{
    typedef _Arg argument_type;
    typedef _Result result_type;
};

template <class _Arg1, class _Arg2, class _Result>
struct __attribute__ ((__type_visibility__("default"))) binary_function
{
    typedef _Arg1 first_argument_type;
    typedef _Arg2 second_argument_type;
    typedef _Result result_type;
};

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) hash;

template <class _Tp>
struct __has_result_type
{
private:
    struct __two {char __lx; char __lxx;};
    template <class _Up> static __two __test(...);
    template <class _Up> static char __test(typename _Up::result_type* = 0);
public:
    static const bool value = sizeof(__test<_Tp>(0)) == 1;
};




template <class _Tp>

struct __attribute__ ((__type_visibility__("default"))) less : binary_function<_Tp, _Tp, bool>
{
                                  __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator()(const _Tp& __x, const _Tp& __y) const
        {return __x < __y;}
};
# 78 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/__functional_base" 3
// addressof

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_Tp*
addressof(_Tp& __x) throw()
{
    return (_Tp*)&reinterpret_cast<const volatile char&>(__x);
}
# 130 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/__functional_base" 3
# 1 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/__functional_base_03" 1 3
// -*- C++ -*-
//===----------------------------------------------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is dual licensed under the MIT and the University of Illinois Open
// Source Licenses. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//




// manual variadic expansion for <functional>

// __weak_result_type

template <class _Tp>
struct __derives_from_unary_function
{
private:
    struct __two {char __lx; char __lxx;};
    static __two __test(...);
    template <class _Ap, class _Rp>
        static unary_function<_Ap, _Rp>
        __test(const volatile unary_function<_Ap, _Rp>*);
public:
    static const bool value = !is_same<__typeof__(__test((_Tp*)0)), __two>::value;
    typedef __typeof__(__test((_Tp*)0)) type;
};

template <class _Tp>
struct __derives_from_binary_function
{
private:
    struct __two {char __lx; char __lxx;};
    static __two __test(...);
    template <class _A1, class _A2, class _Rp>
        static binary_function<_A1, _A2, _Rp>
        __test(const volatile binary_function<_A1, _A2, _Rp>*);
public:
    static const bool value = !is_same<__typeof__(__test((_Tp*)0)), __two>::value;
    typedef __typeof__(__test((_Tp*)0)) type;
};

template <class _Tp, bool = __derives_from_unary_function<_Tp>::value>
struct __maybe_derive_from_unary_function // bool is true
    : public __derives_from_unary_function<_Tp>::type
{
};

template <class _Tp>
struct __maybe_derive_from_unary_function<_Tp, false>
{
};

template <class _Tp, bool = __derives_from_binary_function<_Tp>::value>
struct __maybe_derive_from_binary_function // bool is true
    : public __derives_from_binary_function<_Tp>::type
{
};

template <class _Tp>
struct __maybe_derive_from_binary_function<_Tp, false>
{
};

template <class _Tp, bool = __has_result_type<_Tp>::value>
struct __weak_result_type_imp // bool is true
    : public __maybe_derive_from_unary_function<_Tp>,
      public __maybe_derive_from_binary_function<_Tp>
{
    typedef typename _Tp::result_type result_type;
};

template <class _Tp>
struct __weak_result_type_imp<_Tp, false>
    : public __maybe_derive_from_unary_function<_Tp>,
      public __maybe_derive_from_binary_function<_Tp>
{
};

template <class _Tp>
struct __weak_result_type
    : public __weak_result_type_imp<typename remove_reference<_Tp>::type>
{
};

// 0 argument case

template <class _Rp>
struct __weak_result_type<_Rp ()>
{
    typedef _Rp result_type;
};

template <class _Rp>
struct __weak_result_type<_Rp (&)()>
{
    typedef _Rp result_type;
};

template <class _Rp>
struct __weak_result_type<_Rp (*)()>
{
    typedef _Rp result_type;
};

// 1 argument case

template <class _Rp, class _A1>
struct __weak_result_type<_Rp (_A1)>
    : public unary_function<_A1, _Rp>
{
};

template <class _Rp, class _A1>
struct __weak_result_type<_Rp (&)(_A1)>
    : public unary_function<_A1, _Rp>
{
};

template <class _Rp, class _A1>
struct __weak_result_type<_Rp (*)(_A1)>
    : public unary_function<_A1, _Rp>
{
};

template <class _Rp, class _Cp>
struct __weak_result_type<_Rp (_Cp::*)()>
    : public unary_function<_Cp*, _Rp>
{
};

template <class _Rp, class _Cp>
struct __weak_result_type<_Rp (_Cp::*)() const>
    : public unary_function<const _Cp*, _Rp>
{
};

template <class _Rp, class _Cp>
struct __weak_result_type<_Rp (_Cp::*)() volatile>
    : public unary_function<volatile _Cp*, _Rp>
{
};

template <class _Rp, class _Cp>
struct __weak_result_type<_Rp (_Cp::*)() const volatile>
    : public unary_function<const volatile _Cp*, _Rp>
{
};

// 2 argument case

template <class _Rp, class _A1, class _A2>
struct __weak_result_type<_Rp (_A1, _A2)>
    : public binary_function<_A1, _A2, _Rp>
{
};

template <class _Rp, class _A1, class _A2>
struct __weak_result_type<_Rp (*)(_A1, _A2)>
    : public binary_function<_A1, _A2, _Rp>
{
};

template <class _Rp, class _A1, class _A2>
struct __weak_result_type<_Rp (&)(_A1, _A2)>
    : public binary_function<_A1, _A2, _Rp>
{
};

template <class _Rp, class _Cp, class _A1>
struct __weak_result_type<_Rp (_Cp::*)(_A1)>
    : public binary_function<_Cp*, _A1, _Rp>
{
};

template <class _Rp, class _Cp, class _A1>
struct __weak_result_type<_Rp (_Cp::*)(_A1) const>
    : public binary_function<const _Cp*, _A1, _Rp>
{
};

template <class _Rp, class _Cp, class _A1>
struct __weak_result_type<_Rp (_Cp::*)(_A1) volatile>
    : public binary_function<volatile _Cp*, _A1, _Rp>
{
};

template <class _Rp, class _Cp, class _A1>
struct __weak_result_type<_Rp (_Cp::*)(_A1) const volatile>
    : public binary_function<const volatile _Cp*, _A1, _Rp>
{
};

// 3 or more arguments

template <class _Rp, class _A1, class _A2, class _A3>
struct __weak_result_type<_Rp (_A1, _A2, _A3)>
{
    typedef _Rp result_type;
};

template <class _Rp, class _A1, class _A2, class _A3>
struct __weak_result_type<_Rp (&)(_A1, _A2, _A3)>
{
    typedef _Rp result_type;
};

template <class _Rp, class _A1, class _A2, class _A3>
struct __weak_result_type<_Rp (*)(_A1, _A2, _A3)>
{
    typedef _Rp result_type;
};

template <class _Rp, class _Cp, class _A1, class _A2>
struct __weak_result_type<_Rp (_Cp::*)(_A1, _A2)>
{
    typedef _Rp result_type;
};

template <class _Rp, class _Cp, class _A1, class _A2>
struct __weak_result_type<_Rp (_Cp::*)(_A1, _A2) const>
{
    typedef _Rp result_type;
};

template <class _Rp, class _Cp, class _A1, class _A2>
struct __weak_result_type<_Rp (_Cp::*)(_A1, _A2) volatile>
{
    typedef _Rp result_type;
};

// __invoke

// __ref_return0
//
// template <class _Tp, bool _HasResultType>
// struct ________ref_return0  // _HasResultType is true
// {
//     typedef typename _Tp::result_type type;
// };
//
// template <class _Tp>
// struct ________ref_return0<_Tp, false>
// {
//     typedef void type;
// };
//
// template <class _Tp, bool _IsClass>
// struct ____ref_return0  // _IsClass is true
//     : public ________ref_return0<_Tp, __has_result_type<typename remove_cv<_Tp>::type>::value>
// {
// };
//
// template <class _Tp, bool _HasResultType>
// struct ______ref_return0  // _HasResultType is true
// {
//     typedef typename __callable_type<_Tp>::result_type type;
// };
//
// template <class _Tp>
// struct ______ref_return0<_Tp, false>  // pointer to member data
// {
//     typedef void type;
// };
//
// template <class _Tp>
// struct ____ref_return0<_Tp, false>
//     : public ______ref_return0<typename remove_cv<_Tp>::type,
//                  __has_result_type<__callable_type<typename remove_cv<_Tp>::type> >::value>
// {
// };
//
// template <class _Tp>
// struct __ref_return0
//     : public ____ref_return0<typename remove_reference<_Tp>::type,
//                    is_class<typename remove_reference<_Tp>::type>::value>
// {
// };
//
// __ref_return1
//
// template <class _Tp, bool _IsClass, class _A0>
// struct ____ref_return1  // _IsClass is true
// {
//     typedef typename result_of<_Tp(_A0)>::type type;
// };
//
// template <class _Tp, bool _HasResultType, class _A0>
// struct ______ref_return1  // _HasResultType is true
// {
//     typedef typename __callable_type<_Tp>::result_type type;
// };
//
// template <class _Tp, class _A0, bool>
// struct __ref_return1_member_data1;
//
// template <class _Rp, class _Cp, class _A0>
// struct __ref_return1_member_data1<_Rp _Cp::*, _A0, true>
// {
//     typedef typename __apply_cv<_A0, _Rp>::type& type;
// };
//
// template <class _Rp, class _Cp, class _A0>
// struct __ref_return1_member_data1<_Rp _Cp::*, _A0, false>
// {
//     static _A0 __a;
//     typedef typename __apply_cv<decltype(*__a), _Rp>::type& type;
// };
//
// template <class _Tp, class _A0>
// struct __ref_return1_member_data;
//
// template <class _Rp, class _Cp, class _A0>
// struct __ref_return1_member_data<_Rp _Cp::*, _A0>
//     : public __ref_return1_member_data1<_Rp _Cp::*, _A0,
//                 is_same<typename remove_cv<_Cp>::type,
//                         typename remove_cv<typename remove_reference<_A0>::type>::type>::value>
// {
// };
//
// template <class _Tp, class _A0>
// struct ______ref_return1<_Tp, false, _A0>  // pointer to member data
//     : public __ref_return1_member_data<typename remove_cv<_Tp>::type, _A0>
// {
// };
//
// template <class _Tp, class _A0>
// struct ____ref_return1<_Tp, false, _A0>
//     : public ______ref_return1<typename remove_cv<_Tp>::type,
//                  __has_result_type<__callable_type<typename remove_cv<_Tp>::type> >::value, _A0>
// {
// };
//
// template <class _Tp, class _A0>
// struct __ref_return1
//     : public ____ref_return1<typename remove_reference<_Tp>::type,
//                    is_class<typename remove_reference<_Tp>::type>::value, _A0>
// {
// };
//
// __ref_return2
//
// template <class _Tp, bool _IsClass, class _A0, class _A1>
// struct ____ref_return2  // _IsClass is true
// {
//     typedef typename result_of<_Tp(_A0, _A1)>::type type;
// };
//
// template <class _Tp, bool _HasResultType, class _A0, class _A1>
// struct ______ref_return2  // _HasResultType is true
// {
//     typedef typename __callable_type<_Tp>::result_type type;
// };
//
// template <class _Tp>
// struct ______ref_return2<_Tp, false, class _A0, class _A1>  // pointer to member data
// {
//     static_assert(sizeof(_Tp) == 0, "An attempt has been made to `call` a pointer"
//                          " to member data with too many arguments.");
// };
//
// template <class _Tp, class _A0, class _A1>
// struct ____ref_return2<_Tp, false, _A0, _A1>
//     : public ______ref_return2<typename remove_cv<_Tp>::type,
//                  __has_result_type<__callable_type<typename remove_cv<_Tp>::type> >::value, _A0, _A1>
// {
// };
//
// template <class _Tp, class _A0, class _A1>
// struct __ref_return2
//     : public ____ref_return2<typename remove_reference<_Tp>::type,
//                    is_class<typename remove_reference<_Tp>::type>::value, _A0, _A1>
// {
// };
//
// __ref_return3
//
// template <class _Tp, bool _IsClass, class _A0, class _A1, class _A2>
// struct ____ref_return3  // _IsClass is true
// {
//     typedef typename result_of<_Tp(_A0, _A1, _A2)>::type type;
// };
//
// template <class _Tp, bool _HasResultType, class _A0, class _A1, class _A2>
// struct ______ref_return3  // _HasResultType is true
// {
//     typedef typename __callable_type<_Tp>::result_type type;
// };
//
// template <class _Tp>
// struct ______ref_return3<_Tp, false, class _A0, class _A1, class _A2>  // pointer to member data
// {
//     static_assert(sizeof(_Tp) == 0, "An attempt has been made to `call` a pointer"
//                          " to member data with too many arguments.");
// };
//
// template <class _Tp, class _A0, class _A1, class _A2>
// struct ____ref_return3<_Tp, false, _A0, _A1, _A2>
//     : public ______ref_return3<typename remove_cv<_Tp>::type,
//                  __has_result_type<__callable_type<typename remove_cv<_Tp>::type> >::value, _A0, _A1, _A2>
// {
// };
//
// template <class _Tp, class _A0, class _A1, class _A2>
// struct __ref_return3
//     : public ____ref_return3<typename remove_reference<_Tp>::type,
//                    is_class<typename remove_reference<_Tp>::type>::value, _A0, _A1, _A2>
// {
// };

// first bullet

template <class _Rp, class _Tp, class _T1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_base_of<_Tp, typename remove_reference<_T1>::type>::value,
    _Rp
>::type
__invoke(_Rp (_Tp::*__f)(), _T1& __t1)
{
    return (__t1.*__f)();
}

template <class _Rp, class _Tp, class _T1, class _A0>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_base_of<_Tp, typename remove_reference<_T1>::type>::value,
    _Rp
>::type
__invoke(_Rp (_Tp::*__f)(_A0), _T1& __t1, _A0& __a0)
{
    return (__t1.*__f)(__a0);
}

template <class _Rp, class _Tp, class _T1, class _A0, class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_base_of<_Tp, typename remove_reference<_T1>::type>::value,
    _Rp
>::type
__invoke(_Rp (_Tp::*__f)(_A0, _A1), _T1& __t1, _A0& __a0, _A1& __a1)
{
    return (__t1.*__f)(__a0, __a1);
}

template <class _Rp, class _Tp, class _T1, class _A0, class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_base_of<_Tp, typename remove_reference<_T1>::type>::value,
    _Rp
>::type
__invoke(_Rp (_Tp::*__f)(_A0, _A1, _A2), _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
{
    return (__t1.*__f)(__a0, __a1, __a2);
}

template <class _Rp, class _Tp, class _T1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_base_of<_Tp, typename remove_reference<_T1>::type>::value,
    _Rp
>::type
__invoke(_Rp (_Tp::*__f)() const, _T1& __t1)
{
    return (__t1.*__f)();
}

template <class _Rp, class _Tp, class _T1, class _A0>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_base_of<_Tp, typename remove_reference<_T1>::type>::value,
    _Rp
>::type
__invoke(_Rp (_Tp::*__f)(_A0) const, _T1& __t1, _A0& __a0)
{
    return (__t1.*__f)(__a0);
}

template <class _Rp, class _Tp, class _T1, class _A0, class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_base_of<_Tp, typename remove_reference<_T1>::type>::value,
    _Rp
>::type
__invoke(_Rp (_Tp::*__f)(_A0, _A1) const, _T1& __t1, _A0& __a0, _A1& __a1)
{
    return (__t1.*__f)(__a0, __a1);
}

template <class _Rp, class _Tp, class _T1, class _A0, class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_base_of<_Tp, typename remove_reference<_T1>::type>::value,
    _Rp
>::type
__invoke(_Rp (_Tp::*__f)(_A0, _A1, _A2) const, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
{
    return (__t1.*__f)(__a0, __a1, __a2);
}

template <class _Rp, class _Tp, class _T1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_base_of<_Tp, typename remove_reference<_T1>::type>::value,
    _Rp
>::type
__invoke(_Rp (_Tp::*__f)() volatile, _T1& __t1)
{
    return (__t1.*__f)();
}

template <class _Rp, class _Tp, class _T1, class _A0>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_base_of<_Tp, typename remove_reference<_T1>::type>::value,
    _Rp
>::type
__invoke(_Rp (_Tp::*__f)(_A0) volatile, _T1& __t1, _A0& __a0)
{
    return (__t1.*__f)(__a0);
}

template <class _Rp, class _Tp, class _T1, class _A0, class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_base_of<_Tp, typename remove_reference<_T1>::type>::value,
    _Rp
>::type
__invoke(_Rp (_Tp::*__f)(_A0, _A1) volatile, _T1& __t1, _A0& __a0, _A1& __a1)
{
    return (__t1.*__f)(__a0, __a1);
}

template <class _Rp, class _Tp, class _T1, class _A0, class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_base_of<_Tp, typename remove_reference<_T1>::type>::value,
    _Rp
>::type
__invoke(_Rp (_Tp::*__f)(_A0, _A1, _A2) volatile, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
{
    return (__t1.*__f)(__a0, __a1, __a2);
}

template <class _Rp, class _Tp, class _T1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_base_of<_Tp, typename remove_reference<_T1>::type>::value,
    _Rp
>::type
__invoke(_Rp (_Tp::*__f)() const volatile, _T1& __t1)
{
    return (__t1.*__f)();
}

template <class _Rp, class _Tp, class _T1, class _A0>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_base_of<_Tp, typename remove_reference<_T1>::type>::value,
    _Rp
>::type
__invoke(_Rp (_Tp::*__f)(_A0) const volatile, _T1& __t1, _A0& __a0)
{
    return (__t1.*__f)(__a0);
}

template <class _Rp, class _Tp, class _T1, class _A0, class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_base_of<_Tp, typename remove_reference<_T1>::type>::value,
    _Rp
>::type
__invoke(_Rp (_Tp::*__f)(_A0, _A1) const volatile, _T1& __t1, _A0& __a0, _A1& __a1)
{
    return (__t1.*__f)(__a0, __a1);
}

template <class _Rp, class _Tp, class _T1, class _A0, class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_base_of<_Tp, typename remove_reference<_T1>::type>::value,
    _Rp
>::type
__invoke(_Rp (_Tp::*__f)(_A0, _A1, _A2) const volatile, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
{
    return (__t1.*__f)(__a0, __a1, __a2);
}

// second bullet

template <class _Rp, class _Tp, class _T1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    !is_base_of<_Tp, typename remove_reference<_T1>::type>::value,
    _Rp
>::type
__invoke(_Rp (_Tp::*__f)(), _T1 __t1)
{
    return ((*__t1).*__f)();
}

template <class _Rp, class _Tp, class _T1, class _A0>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    !is_base_of<_Tp, typename remove_reference<_T1>::type>::value,
    _Rp
>::type
__invoke(_Rp (_Tp::*__f)(_A0), _T1 __t1, _A0& __a0)
{
    return ((*__t1).*__f)(__a0);
}

template <class _Rp, class _Tp, class _T1, class _A0, class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    !is_base_of<_Tp, typename remove_reference<_T1>::type>::value,
    _Rp
>::type
__invoke(_Rp (_Tp::*__f)(_A0, _A1), _T1 __t1, _A0& __a0, _A1& __a1)
{
    return ((*__t1).*__f)(__a0, __a1);
}

template <class _Rp, class _Tp, class _T1, class _A0, class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    !is_base_of<_Tp, typename remove_reference<_T1>::type>::value,
    _Rp
>::type
__invoke(_Rp (_Tp::*__f)(_A0, _A1, _A2), _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
{
    return ((*__t1).*__f)(__a0, __a1, __a2);
}

template <class _Rp, class _Tp, class _T1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    !is_base_of<_Tp, typename remove_reference<_T1>::type>::value,
    _Rp
>::type
__invoke(_Rp (_Tp::*__f)() const, _T1 __t1)
{
    return ((*__t1).*__f)();
}

template <class _Rp, class _Tp, class _T1, class _A0>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    !is_base_of<_Tp, typename remove_reference<_T1>::type>::value,
    _Rp
>::type
__invoke(_Rp (_Tp::*__f)(_A0) const, _T1 __t1, _A0& __a0)
{
    return ((*__t1).*__f)(__a0);
}

template <class _Rp, class _Tp, class _T1, class _A0, class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    !is_base_of<_Tp, typename remove_reference<_T1>::type>::value,
    _Rp
>::type
__invoke(_Rp (_Tp::*__f)(_A0, _A1) const, _T1 __t1, _A0& __a0, _A1& __a1)
{
    return ((*__t1).*__f)(__a0, __a1);
}

template <class _Rp, class _Tp, class _T1, class _A0, class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    !is_base_of<_Tp, typename remove_reference<_T1>::type>::value,
    _Rp
>::type
__invoke(_Rp (_Tp::*__f)(_A0, _A1, _A2) const, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
{
    return ((*__t1).*__f)(__a0, __a1, __a2);
}

template <class _Rp, class _Tp, class _T1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    !is_base_of<_Tp, typename remove_reference<_T1>::type>::value,
    _Rp
>::type
__invoke(_Rp (_Tp::*__f)() volatile, _T1 __t1)
{
    return ((*__t1).*__f)();
}

template <class _Rp, class _Tp, class _T1, class _A0>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    !is_base_of<_Tp, typename remove_reference<_T1>::type>::value,
    _Rp
>::type
__invoke(_Rp (_Tp::*__f)(_A0) volatile, _T1 __t1, _A0& __a0)
{
    return ((*__t1).*__f)(__a0);
}

template <class _Rp, class _Tp, class _T1, class _A0, class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    !is_base_of<_Tp, typename remove_reference<_T1>::type>::value,
    _Rp
>::type
__invoke(_Rp (_Tp::*__f)(_A0, _A1) volatile, _T1 __t1, _A0& __a0, _A1& __a1)
{
    return ((*__t1).*__f)(__a0, __a1);
}

template <class _Rp, class _Tp, class _T1, class _A0, class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    !is_base_of<_Tp, typename remove_reference<_T1>::type>::value,
    _Rp
>::type
__invoke(_Rp (_Tp::*__f)(_A0, _A1, _A2) volatile, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
{
    return ((*__t1).*__f)(__a0, __a1, __a2);
}

template <class _Rp, class _Tp, class _T1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    !is_base_of<_Tp, typename remove_reference<_T1>::type>::value,
    _Rp
>::type
__invoke(_Rp (_Tp::*__f)() const volatile, _T1 __t1)
{
    return ((*__t1).*__f)();
}

template <class _Rp, class _Tp, class _T1, class _A0>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    !is_base_of<_Tp, typename remove_reference<_T1>::type>::value,
    _Rp
>::type
__invoke(_Rp (_Tp::*__f)(_A0) const volatile, _T1 __t1, _A0& __a0)
{
    return ((*__t1).*__f)(__a0);
}

template <class _Rp, class _Tp, class _T1, class _A0, class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    !is_base_of<_Tp, typename remove_reference<_T1>::type>::value,
    _Rp
>::type
__invoke(_Rp (_Tp::*__f)(_A0, _A1) const volatile, _T1 __t1, _A0& __a0, _A1& __a1)
{
    return ((*__t1).*__f)(__a0, __a1);
}

template <class _Rp, class _Tp, class _T1, class _A0, class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    !is_base_of<_Tp, typename remove_reference<_T1>::type>::value,
    _Rp
>::type
__invoke(_Rp (_Tp::*__f)(_A0, _A1, _A2) const volatile, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
{
    return ((*__t1).*__f)(__a0, __a1, __a2);
}

// third bullet

template <class _Rp, class _Tp, class _T1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_base_of<_Tp, typename remove_reference<_T1>::type>::value,
    typename __apply_cv<_T1, _Rp>::type&
>::type
__invoke(_Rp _Tp::* __f, _T1& __t1)
{
    return __t1.*__f;
}

template <class _Rp, class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
__invoke(_Rp _Tp::*)
{
}

// template <class _Dp, class _Rp, class _Tp, class _T1>
// inline _LIBCPP_INLINE_VISIBILITY
// typename enable_if
// <
//     is_base_of<_Tp, typename remove_reference<_T1>::type>::value,
//     typename __ref_return1<_Rp _Tp::*, _T1>::type
// >::type
// __invoke(_Rp _Tp::* __f, _T1& __t1)
// {
//     return __t1.*__f;
// }

// forth bullet

template <class _T1, class _Rp, bool>
struct __4th_helper
{
};

template <class _T1, class _Rp>
struct __4th_helper<_T1, _Rp, true>
{
    typedef typename __apply_cv<__typeof__(*std::__1::declval<_T1>()), _Rp>::type type;
};

template <class _Rp, class _Tp, class _T1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename __4th_helper<_T1, _Rp,
                      !is_base_of<_Tp,
                                  typename remove_reference<_T1>::type
                                 >::value
                     >::type&
__invoke(_Rp _Tp::* __f, _T1& __t1)
{
    return (*__t1).*__f;
}

// template <class _Dp, class _Rp, class _Tp, class _T1>
// inline _LIBCPP_INLINE_VISIBILITY
// typename enable_if
// <
//     !is_base_of<_Tp, typename remove_reference<_T1>::type>::value,
//     typename __ref_return1<_Rp _Tp::*, _T1>::type
// >::type
// __invoke(_Rp _Tp::* __f, _T1 __t1)
// {
//     return (*__t1).*__f;
// }

// fifth bullet

template <class _Fp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
__typeof__(declval<_Fp>()())
__invoke(_Fp __f)
{
    return __f();
}

template <class _Fp, class _A0>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
__typeof__(declval<_Fp>()(declval<_A0&>()))
__invoke(_Fp __f, _A0& __a0)
{
    return __f(__a0);
}

template <class _Fp, class _A0, class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
__typeof__(declval<_Fp>()(declval<_A0&>(), declval<_A1&>()))
__invoke(_Fp __f, _A0& __a0, _A1& __a1)
{
    return __f(__a0, __a1);
}

template <class _Fp, class _A0, class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
__typeof__(declval<_Fp>()(declval<_A0&>(), declval<_A1&>(), declval<_A2&>()))
__invoke(_Fp __f, _A0& __a0, _A1& __a1, _A2& __a2)
{
    return __f(__a0, __a1, __a2);
}

// template <class _Rp, class _Fp>
// inline _LIBCPP_INLINE_VISIBILITY
// _Rp
// __invoke(_Fp& __f)
// {
//     return __f();
// }
//
// template <class _Rp, class _Fp, class _A0>
// inline _LIBCPP_INLINE_VISIBILITY
// typename enable_if
// <
//     !is_member_pointer<_Fp>::value,
//     _Rp
// >::type
// __invoke(_Fp& __f, _A0& __a0)
// {
//     return __f(__a0);
// }
//
// template <class _Rp, class _Fp, class _A0, class _A1>
// inline _LIBCPP_INLINE_VISIBILITY
// _Rp
// __invoke(_Fp& __f, _A0& __a0, _A1& __a1)
// {
//     return __f(__a0, __a1);
// }
//
// template <class _Rp, class _Fp, class _A0, class _A1, class _A2>
// inline _LIBCPP_INLINE_VISIBILITY
// _Rp
// __invoke(_Fp& __f, _A0& __a0, _A1& __a1, _A2& __a2)
// {
//     return __f(__a0, __a1, __a2);
// }

template <class _Tp>
struct __has_type
{
private:
    struct __two {char __lx; char __lxx;};
    template <class _Up> static __two __test(...);
    template <class _Up> static char __test(typename _Up::type* = 0);
public:
    static const bool value = sizeof(__test<_Tp>(0)) == 1;
};

template <class _Fp, bool = __has_result_type<__weak_result_type<_Fp> >::value>
struct __invoke_return
{
    typedef typename __weak_result_type<_Fp>::result_type type;
};

template <class _Fp>
struct __invoke_return<_Fp, false>
{
    typedef __typeof__(__invoke(std::__1::declval<_Fp>())) type;
};

template <class _Tp, class _A0>
struct __invoke_return0
{
    typedef __typeof__(__invoke(std::__1::declval<_Tp>(), std::__1::declval<_A0>())) type;
};

template <class _Rp, class _Tp, class _A0>
struct __invoke_return0<_Rp _Tp::*, _A0>
{
    typedef typename __apply_cv<_A0, _Rp>::type& type;
};

template <class _Rp, class _Tp, class _A0>
struct __invoke_return0<_Rp _Tp::*, _A0*>
{
    typedef typename __apply_cv<_A0, _Rp>::type& type;
};

template <class _Tp, class _A0, class _A1>
struct __invoke_return1
{
    typedef __typeof__(__invoke(std::__1::declval<_Tp>(), std::__1::declval<_A0>(), std::__1::declval<_A1>())) type;

};

template <class _Tp, class _A0, class _A1, class _A2>
struct __invoke_return2
{
    typedef __typeof__(__invoke(std::__1::declval<_Tp>(), std::__1::declval<_A0>(), std::__1::declval<_A1>(), std::__1::declval<_A2>())) type;


};

template <class _Tp>
class __attribute__ ((__type_visibility__("default"))) reference_wrapper
    : public __weak_result_type<_Tp>
{
public:
    // types
    typedef _Tp type;
private:
    type* __f_;

public:
    // construct/copy/destroy
    __attribute__ ((__visibility__("hidden"), __always_inline__)) reference_wrapper(type& __f) : __f_(&__f) {}

    // access
    __attribute__ ((__visibility__("hidden"), __always_inline__)) operator type& () const {return *__f_;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) type& get() const {return *__f_;}

    // invoke

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    typename __invoke_return<type&>::type
       operator() () const
       {
           return __invoke(get());
       }

    template <class _A0>
       __attribute__ ((__visibility__("hidden"), __always_inline__))
       typename __invoke_return0<type&, _A0>::type
          operator() (_A0& __a0) const
          {
              return __invoke(get(), __a0);
          }

    template <class _A0, class _A1>
       __attribute__ ((__visibility__("hidden"), __always_inline__))
       typename __invoke_return1<type&, _A0, _A1>::type
          operator() (_A0& __a0, _A1& __a1) const
          {
              return __invoke(get(), __a0, __a1);
          }

    template <class _A0, class _A1, class _A2>
       __attribute__ ((__visibility__("hidden"), __always_inline__))
       typename __invoke_return2<type&, _A0, _A1, _A2>::type
          operator() (_A0& __a0, _A1& __a1, _A2& __a2) const
          {
              return __invoke(get(), __a0, __a1, __a2);
          }
};

template <class _Tp> struct __is_reference_wrapper_impl : public false_type {};
template <class _Tp> struct __is_reference_wrapper_impl<reference_wrapper<_Tp> > : public true_type {};
template <class _Tp> struct __is_reference_wrapper
    : public __is_reference_wrapper_impl<typename remove_cv<_Tp>::type> {};

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
reference_wrapper<_Tp>
ref(_Tp& __t)
{
    return reference_wrapper<_Tp>(__t);
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
reference_wrapper<_Tp>
ref(reference_wrapper<_Tp> __t)
{
    return ref(__t.get());
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
reference_wrapper<const _Tp>
cref(const _Tp& __t)
{
    return reference_wrapper<const _Tp>(__t);
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
reference_wrapper<const _Tp>
cref(reference_wrapper<_Tp> __t)
{
    return cref(__t.get());
}
# 131 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/__functional_base" 2 3
# 521 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/__functional_base" 3
// allocator_arg_t

struct __attribute__ ((__type_visibility__("default"))) allocator_arg_t { };


extern const allocator_arg_t allocator_arg;




// uses_allocator

template <class _Tp>
struct __has_allocator_type
{
private:
    struct __two {char __lx; char __lxx;};
    template <class _Up> static __two __test(...);
    template <class _Up> static char __test(typename _Up::allocator_type* = 0);
public:
    static const bool value = sizeof(__test<_Tp>(0)) == 1;
};

template <class _Tp, class _Alloc, bool = __has_allocator_type<_Tp>::value>
struct __uses_allocator
    : public integral_constant<bool,
        is_convertible<_Alloc, typename _Tp::allocator_type>::value>
{
};

template <class _Tp, class _Alloc>
struct __uses_allocator<_Tp, _Alloc, false>
    : public false_type
{
};

template <class _Tp, class _Alloc>
struct __attribute__ ((__type_visibility__("default"))) uses_allocator
    : public __uses_allocator<_Tp, _Alloc>
{
};
# 613 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/__functional_base" 3
} }
# 333 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/iterator" 2 3
# 349 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/iterator" 3


namespace std {inline namespace __1 {

struct __attribute__ ((__type_visibility__("default"))) input_iterator_tag {};
struct __attribute__ ((__type_visibility__("default"))) output_iterator_tag {};
struct __attribute__ ((__type_visibility__("default"))) forward_iterator_tag : public input_iterator_tag {};
struct __attribute__ ((__type_visibility__("default"))) bidirectional_iterator_tag : public forward_iterator_tag {};
struct __attribute__ ((__type_visibility__("default"))) random_access_iterator_tag : public bidirectional_iterator_tag {};

template <class _Tp>
struct __has_iterator_category
{
private:
    struct __two {char __lx; char __lxx;};
    template <class _Up> static __two __test(...);
    template <class _Up> static char __test(typename _Up::iterator_category* = 0);
public:
    static const bool value = sizeof(__test<_Tp>(0)) == 1;
};

template <class _Iter, bool> struct __iterator_traits_impl {};

template <class _Iter>
struct __iterator_traits_impl<_Iter, true>
{
    typedef typename _Iter::difference_type difference_type;
    typedef typename _Iter::value_type value_type;
    typedef typename _Iter::pointer pointer;
    typedef typename _Iter::reference reference;
    typedef typename _Iter::iterator_category iterator_category;
};

template <class _Iter, bool> struct __iterator_traits {};

template <class _Iter>
struct __iterator_traits<_Iter, true>
    : __iterator_traits_impl
      <
        _Iter,
        is_convertible<typename _Iter::iterator_category, input_iterator_tag>::value ||
        is_convertible<typename _Iter::iterator_category, output_iterator_tag>::value
      >
{};

// iterator_traits<Iterator> will only have the nested types if Iterator::iterator_category
//    exists.  Else iterator_traits<Iterator> will be an empty class.  This is a
//    conforming extension which allows some programs to compile and behave as
//    the client expects instead of failing at compile time.

template <class _Iter>
struct __attribute__ ((__type_visibility__("default"))) iterator_traits
    : __iterator_traits<_Iter, __has_iterator_category<_Iter>::value> {};

template<class _Tp>
struct __attribute__ ((__type_visibility__("default"))) iterator_traits<_Tp*>
{
    typedef ptrdiff_t difference_type;
    typedef typename remove_const<_Tp>::type value_type;
    typedef _Tp* pointer;
    typedef _Tp& reference;
    typedef random_access_iterator_tag iterator_category;
};

template <class _Tp, class _Up, bool = __has_iterator_category<iterator_traits<_Tp> >::value>
struct __has_iterator_category_convertible_to
    : public integral_constant<bool, is_convertible<typename iterator_traits<_Tp>::iterator_category, _Up>::value>
{};

template <class _Tp, class _Up>
struct __has_iterator_category_convertible_to<_Tp, _Up, false> : public false_type {};

template <class _Tp>
struct __is_input_iterator : public __has_iterator_category_convertible_to<_Tp, input_iterator_tag> {};

template <class _Tp>
struct __is_forward_iterator : public __has_iterator_category_convertible_to<_Tp, forward_iterator_tag> {};

template <class _Tp>
struct __is_bidirectional_iterator : public __has_iterator_category_convertible_to<_Tp, bidirectional_iterator_tag> {};

template <class _Tp>
struct __is_random_access_iterator : public __has_iterator_category_convertible_to<_Tp, random_access_iterator_tag> {};

template<class _Category, class _Tp, class _Distance = ptrdiff_t,
         class _Pointer = _Tp*, class _Reference = _Tp&>
struct __attribute__ ((__type_visibility__("default"))) iterator
{
    typedef _Tp value_type;
    typedef _Distance difference_type;
    typedef _Pointer pointer;
    typedef _Reference reference;
    typedef _Category iterator_category;
};

template <class _InputIter>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void __advance(_InputIter& __i,
             typename iterator_traits<_InputIter>::difference_type __n, input_iterator_tag)
{
    for (; __n > 0; --__n)
        ++__i;
}

template <class _BiDirIter>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void __advance(_BiDirIter& __i,
             typename iterator_traits<_BiDirIter>::difference_type __n, bidirectional_iterator_tag)
{
    if (__n >= 0)
        for (; __n > 0; --__n)
            ++__i;
    else
        for (; __n < 0; ++__n)
            --__i;
}

template <class _RandIter>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void __advance(_RandIter& __i,
             typename iterator_traits<_RandIter>::difference_type __n, random_access_iterator_tag)
{
   __i += __n;
}

template <class _InputIter>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void advance(_InputIter& __i,
             typename iterator_traits<_InputIter>::difference_type __n)
{
    __advance(__i, __n, typename iterator_traits<_InputIter>::iterator_category());
}

template <class _InputIter>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename iterator_traits<_InputIter>::difference_type
__distance(_InputIter __first, _InputIter __last, input_iterator_tag)
{
    typename iterator_traits<_InputIter>::difference_type __r(0);
    for (; __first != __last; ++__first)
        ++__r;
    return __r;
}

template <class _RandIter>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename iterator_traits<_RandIter>::difference_type
__distance(_RandIter __first, _RandIter __last, random_access_iterator_tag)
{
    return __last - __first;
}

template <class _InputIter>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename iterator_traits<_InputIter>::difference_type
distance(_InputIter __first, _InputIter __last)
{
    return __distance(__first, __last, typename iterator_traits<_InputIter>::iterator_category());
}

template <class _ForwardIter>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_ForwardIter
next(_ForwardIter __x,
     typename iterator_traits<_ForwardIter>::difference_type __n = 1,
     typename enable_if<__is_forward_iterator<_ForwardIter>::value>::type* = 0)
{
    std::__1::advance(__x, __n);
    return __x;
}

template <class _BidiretionalIter>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_BidiretionalIter
prev(_BidiretionalIter __x,
     typename iterator_traits<_BidiretionalIter>::difference_type __n = 1,
     typename enable_if<__is_bidirectional_iterator<_BidiretionalIter>::value>::type* = 0)
{
    std::__1::advance(__x, -__n);
    return __x;
}

template <class _Iter>
class __attribute__ ((__type_visibility__("default"))) reverse_iterator
    : public iterator<typename iterator_traits<_Iter>::iterator_category,
                      typename iterator_traits<_Iter>::value_type,
                      typename iterator_traits<_Iter>::difference_type,
                      typename iterator_traits<_Iter>::pointer,
                      typename iterator_traits<_Iter>::reference>
{
private:
    mutable _Iter __t; // no longer used as of LWG #2360, not removed due to ABI break
protected:
    _Iter current;
public:
    typedef _Iter iterator_type;
    typedef typename iterator_traits<_Iter>::difference_type difference_type;
    typedef typename iterator_traits<_Iter>::reference reference;
    typedef typename iterator_traits<_Iter>::pointer pointer;

    __attribute__ ((__visibility__("hidden"), __always_inline__)) reverse_iterator() : current() {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit reverse_iterator(_Iter __x) : __t(__x), current(__x) {}
    template <class _Up> __attribute__ ((__visibility__("hidden"), __always_inline__)) reverse_iterator(const reverse_iterator<_Up>& __u)
        : __t(__u.base()), current(__u.base()) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) _Iter base() const {return current;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) reference operator*() const {_Iter __tmp = current; return *--__tmp;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) pointer operator->() const {return std::__1::addressof(operator*());}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) reverse_iterator& operator++() {--current; return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) reverse_iterator operator++(int)
        {reverse_iterator __tmp(*this); --current; return __tmp;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) reverse_iterator& operator--() {++current; return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) reverse_iterator operator--(int)
        {reverse_iterator __tmp(*this); ++current; return __tmp;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) reverse_iterator operator+ (difference_type __n) const
        {return reverse_iterator(current - __n);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) reverse_iterator& operator+=(difference_type __n)
        {current -= __n; return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) reverse_iterator operator- (difference_type __n) const
        {return reverse_iterator(current + __n);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) reverse_iterator& operator-=(difference_type __n)
        {current += __n; return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) reference operator[](difference_type __n) const
        {return current[-__n-1];}
};

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator==(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)
{
    return __x.base() == __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator<(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)
{
    return __x.base() > __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator!=(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)
{
    return __x.base() != __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator>(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)
{
    return __x.base() < __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator>=(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)
{
    return __x.base() <= __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator<=(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)
{
    return __x.base() >= __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename reverse_iterator<_Iter1>::difference_type
operator-(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)
{
    return __y.base() - __x.base();
}

template <class _Iter>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
reverse_iterator<_Iter>
operator+(typename reverse_iterator<_Iter>::difference_type __n, const reverse_iterator<_Iter>& __x)
{
    return reverse_iterator<_Iter>(__x.base() - __n);
}
# 647 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/iterator" 3
template <class _Container>
class __attribute__ ((__type_visibility__("default"))) back_insert_iterator
    : public iterator<output_iterator_tag,
                      void,
                      void,
                      void,
                      back_insert_iterator<_Container>&>
{
protected:
    _Container* container;
public:
    typedef _Container container_type;

    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit back_insert_iterator(_Container& __x) : container(std::__1::addressof(__x)) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) back_insert_iterator& operator=(const typename _Container::value_type& __value_)
        {container->push_back(__value_); return *this;}




    __attribute__ ((__visibility__("hidden"), __always_inline__)) back_insert_iterator& operator*() {return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) back_insert_iterator& operator++() {return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) back_insert_iterator operator++(int) {return *this;}
};

template <class _Container>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
back_insert_iterator<_Container>
back_inserter(_Container& __x)
{
    return back_insert_iterator<_Container>(__x);
}

template <class _Container>
class __attribute__ ((__type_visibility__("default"))) front_insert_iterator
    : public iterator<output_iterator_tag,
                      void,
                      void,
                      void,
                      front_insert_iterator<_Container>&>
{
protected:
    _Container* container;
public:
    typedef _Container container_type;

    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit front_insert_iterator(_Container& __x) : container(std::__1::addressof(__x)) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) front_insert_iterator& operator=(const typename _Container::value_type& __value_)
        {container->push_front(__value_); return *this;}




    __attribute__ ((__visibility__("hidden"), __always_inline__)) front_insert_iterator& operator*() {return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) front_insert_iterator& operator++() {return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) front_insert_iterator operator++(int) {return *this;}
};

template <class _Container>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
front_insert_iterator<_Container>
front_inserter(_Container& __x)
{
    return front_insert_iterator<_Container>(__x);
}

template <class _Container>
class __attribute__ ((__type_visibility__("default"))) insert_iterator
    : public iterator<output_iterator_tag,
                      void,
                      void,
                      void,
                      insert_iterator<_Container>&>
{
protected:
    _Container* container;
    typename _Container::iterator iter;
public:
    typedef _Container container_type;

    __attribute__ ((__visibility__("hidden"), __always_inline__)) insert_iterator(_Container& __x, typename _Container::iterator __i)
        : container(std::__1::addressof(__x)), iter(__i) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) insert_iterator& operator=(const typename _Container::value_type& __value_)
        {iter = container->insert(iter, __value_); ++iter; return *this;}




    __attribute__ ((__visibility__("hidden"), __always_inline__)) insert_iterator& operator*() {return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) insert_iterator& operator++() {return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) insert_iterator& operator++(int) {return *this;}
};

template <class _Container>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
insert_iterator<_Container>
inserter(_Container& __x, typename _Container::iterator __i)
{
    return insert_iterator<_Container>(__x, __i);
}

template <class _Tp, class _CharT = char,
          class _Traits = char_traits<_CharT>, class _Distance = ptrdiff_t>
class __attribute__ ((__type_visibility__("default"))) istream_iterator
    : public iterator<input_iterator_tag, _Tp, _Distance, const _Tp*, const _Tp&>
{
public:
    typedef _CharT char_type;
    typedef _Traits traits_type;
    typedef basic_istream<_CharT,_Traits> istream_type;
private:
    istream_type* __in_stream_;
    _Tp __value_;
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) istream_iterator() : __in_stream_(0) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) istream_iterator(istream_type& __s) : __in_stream_(&__s)
        {
            if (!(*__in_stream_ >> __value_))
                __in_stream_ = 0;
        }

    __attribute__ ((__visibility__("hidden"), __always_inline__)) const _Tp& operator*() const {return __value_;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) const _Tp* operator->() const {return &(operator*());}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) istream_iterator& operator++()
        {
            if (!(*__in_stream_ >> __value_))
                __in_stream_ = 0;
            return *this;
        }
    __attribute__ ((__visibility__("hidden"), __always_inline__)) istream_iterator operator++(int)
        {istream_iterator __t(*this); ++(*this); return __t;}

    friend __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator==(const istream_iterator& __x, const istream_iterator& __y)
        {return __x.__in_stream_ == __y.__in_stream_;}

    friend __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator!=(const istream_iterator& __x, const istream_iterator& __y)
        {return !(__x == __y);}
};

template <class _Tp, class _CharT = char, class _Traits = char_traits<_CharT> >
class __attribute__ ((__type_visibility__("default"))) ostream_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
{
public:
    typedef _CharT char_type;
    typedef _Traits traits_type;
    typedef basic_ostream<_CharT,_Traits> ostream_type;
private:
    ostream_type* __out_stream_;
    const char_type* __delim_;
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) ostream_iterator(ostream_type& __s)
        : __out_stream_(&__s), __delim_(0) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) ostream_iterator(ostream_type& __s, const _CharT* __delimiter)
        : __out_stream_(&__s), __delim_(__delimiter) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) ostream_iterator& operator=(const _Tp& __value_)
        {
            *__out_stream_ << __value_;
            if (__delim_)
                *__out_stream_ << __delim_;
            return *this;
        }

    __attribute__ ((__visibility__("hidden"), __always_inline__)) ostream_iterator& operator*() {return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) ostream_iterator& operator++() {return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) ostream_iterator& operator++(int) {return *this;}
};

template<class _CharT, class _Traits>
class __attribute__ ((__type_visibility__("default"))) istreambuf_iterator
    : public iterator<input_iterator_tag, _CharT,
                      typename _Traits::off_type, _CharT*,
                      _CharT>
{
public:
    typedef _CharT char_type;
    typedef _Traits traits_type;
    typedef typename _Traits::int_type int_type;
    typedef basic_streambuf<_CharT,_Traits> streambuf_type;
    typedef basic_istream<_CharT,_Traits> istream_type;
private:
    mutable streambuf_type* __sbuf_;

    class __proxy
    {
        char_type __keep_;
        streambuf_type* __sbuf_;
        __attribute__ ((__visibility__("hidden"), __always_inline__)) __proxy(char_type __c, streambuf_type* __s)
            : __keep_(__c), __sbuf_(__s) {}
        friend class istreambuf_iterator;
    public:
        __attribute__ ((__visibility__("hidden"), __always_inline__)) char_type operator*() const {return __keep_;}
    };

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool __test_for_eof() const
    {
        if (__sbuf_ && traits_type::eq_int_type(__sbuf_->sgetc(), traits_type::eof()))
            __sbuf_ = 0;
        return __sbuf_ == 0;
    }
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) istreambuf_iterator() throw() : __sbuf_(0) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) istreambuf_iterator(istream_type& __s) throw()
        : __sbuf_(__s.rdbuf()) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) istreambuf_iterator(streambuf_type* __s) throw()
        : __sbuf_(__s) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) istreambuf_iterator(const __proxy& __p) throw()
        : __sbuf_(__p.__sbuf_) {}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) char_type operator*() const
        {return static_cast<char_type>(__sbuf_->sgetc());}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) char_type* operator->() const {return std::__1::__get_nullptr_t();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) istreambuf_iterator& operator++()
        {
            __sbuf_->sbumpc();
            return *this;
        }
    __attribute__ ((__visibility__("hidden"), __always_inline__)) __proxy operator++(int)
        {
            return __proxy(__sbuf_->sbumpc(), __sbuf_);
        }

    __attribute__ ((__visibility__("hidden"), __always_inline__)) bool equal(const istreambuf_iterator& __b) const
        {return __test_for_eof() == __b.__test_for_eof();}
};

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool operator==(const istreambuf_iterator<_CharT,_Traits>& __a,
                const istreambuf_iterator<_CharT,_Traits>& __b)
                {return __a.equal(__b);}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool operator!=(const istreambuf_iterator<_CharT,_Traits>& __a,
                const istreambuf_iterator<_CharT,_Traits>& __b)
                {return !__a.equal(__b);}

template <class _CharT, class _Traits>
class __attribute__ ((__type_visibility__("default"))) ostreambuf_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
{
public:
    typedef _CharT char_type;
    typedef _Traits traits_type;
    typedef basic_streambuf<_CharT,_Traits> streambuf_type;
    typedef basic_ostream<_CharT,_Traits> ostream_type;
private:
    streambuf_type* __sbuf_;
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) ostreambuf_iterator(ostream_type& __s) throw()
        : __sbuf_(__s.rdbuf()) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) ostreambuf_iterator(streambuf_type* __s) throw()
        : __sbuf_(__s) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) ostreambuf_iterator& operator=(_CharT __c)
        {
            if (__sbuf_ && traits_type::eq_int_type(__sbuf_->sputc(__c), traits_type::eof()))
                __sbuf_ = 0;
            return *this;
        }
    __attribute__ ((__visibility__("hidden"), __always_inline__)) ostreambuf_iterator& operator*() {return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) ostreambuf_iterator& operator++() {return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) ostreambuf_iterator& operator++(int) {return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) bool failed() const throw() {return __sbuf_ == 0;}





    template <class _Ch, class _Tr>
    friend
    __attribute__ ((__visibility__("hidden")))
    ostreambuf_iterator<_Ch, _Tr>
    __pad_and_output(ostreambuf_iterator<_Ch, _Tr> __s,
                     const _Ch* __ob, const _Ch* __op, const _Ch* __oe,
                     ios_base& __iob, _Ch __fl);

};

template <class _Iter>
class __attribute__ ((__type_visibility__("default"))) move_iterator
{
private:
    _Iter __i;
public:
    typedef _Iter iterator_type;
    typedef typename iterator_traits<iterator_type>::iterator_category iterator_category;
    typedef typename iterator_traits<iterator_type>::value_type value_type;
    typedef typename iterator_traits<iterator_type>::difference_type difference_type;
    typedef typename iterator_traits<iterator_type>::pointer pointer;



    typedef typename iterator_traits<iterator_type>::reference reference;


    __attribute__ ((__visibility__("hidden"), __always_inline__)) move_iterator() : __i() {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit move_iterator(_Iter __x) : __i(__x) {}
    template <class _Up> __attribute__ ((__visibility__("hidden"), __always_inline__)) move_iterator(const move_iterator<_Up>& __u)
        : __i(__u.base()) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) _Iter base() const {return __i;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) reference operator*() const {
      return static_cast<reference>(*__i);
    }
    __attribute__ ((__visibility__("hidden"), __always_inline__)) pointer operator->() const {
      typename iterator_traits<iterator_type>::reference __ref = *__i;
      return &__ref;
    }
    __attribute__ ((__visibility__("hidden"), __always_inline__)) move_iterator& operator++() {++__i; return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) move_iterator operator++(int)
        {move_iterator __tmp(*this); ++__i; return __tmp;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) move_iterator& operator--() {--__i; return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) move_iterator operator--(int)
        {move_iterator __tmp(*this); --__i; return __tmp;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) move_iterator operator+ (difference_type __n) const
        {return move_iterator(__i + __n);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) move_iterator& operator+=(difference_type __n)
        {__i += __n; return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) move_iterator operator- (difference_type __n) const
        {return move_iterator(__i - __n);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) move_iterator& operator-=(difference_type __n)
        {__i -= __n; return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) reference operator[](difference_type __n) const
    {
      return static_cast<reference>(__i[__n]);
    }
};

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator==(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)
{
    return __x.base() == __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator<(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)
{
    return __x.base() < __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator!=(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)
{
    return __x.base() != __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator>(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)
{
    return __x.base() > __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator>=(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)
{
    return __x.base() >= __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator<=(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)
{
    return __x.base() <= __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename move_iterator<_Iter1>::difference_type
operator-(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)
{
    return __x.base() - __y.base();
}

template <class _Iter>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
move_iterator<_Iter>
operator+(typename move_iterator<_Iter>::difference_type __n, const move_iterator<_Iter>& __x)
{
    return move_iterator<_Iter>(__x.base() + __n);
}

template <class _Iter>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
move_iterator<_Iter>
make_move_iterator(_Iter __i)
{
    return move_iterator<_Iter>(__i);
}

// __wrap_iter

template <class _Iter> class __wrap_iter;

template <class _Iter1, class _Iter2>
__attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator==(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) throw();

template <class _Iter1, class _Iter2>
__attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator<(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) throw();

template <class _Iter1, class _Iter2>
__attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator!=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) throw();

template <class _Iter1, class _Iter2>
__attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator>(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) throw();

template <class _Iter1, class _Iter2>
__attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator>=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) throw();

template <class _Iter1, class _Iter2>
__attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator<=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) throw();

template <class _Iter1, class _Iter2>
__attribute__ ((__visibility__("hidden"), __always_inline__))
typename __wrap_iter<_Iter1>::difference_type
operator-(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) throw();

template <class _Iter>
__attribute__ ((__visibility__("hidden"), __always_inline__))
__wrap_iter<_Iter>
operator+(typename __wrap_iter<_Iter>::difference_type, __wrap_iter<_Iter>) throw();

template <class _Ip, class _Op> _Op __attribute__ ((__visibility__("hidden"), __always_inline__)) copy(_Ip, _Ip, _Op);
template <class _B1, class _B2> _B2 __attribute__ ((__visibility__("hidden"), __always_inline__)) copy_backward(_B1, _B1, _B2);
template <class _Ip, class _Op> _Op __attribute__ ((__visibility__("hidden"), __always_inline__)) move(_Ip, _Ip, _Op);
template <class _B1, class _B2> _B2 __attribute__ ((__visibility__("hidden"), __always_inline__)) move_backward(_B1, _B1, _B2);

template <class _Tp>
__attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_trivially_copy_assignable<_Tp>::value,
    _Tp*
>::type
__unwrap_iter(__wrap_iter<_Tp*>);

template <class _Iter>
class __wrap_iter
{
public:
    typedef _Iter iterator_type;
    typedef typename iterator_traits<iterator_type>::iterator_category iterator_category;
    typedef typename iterator_traits<iterator_type>::value_type value_type;
    typedef typename iterator_traits<iterator_type>::difference_type difference_type;
    typedef typename iterator_traits<iterator_type>::pointer pointer;
    typedef typename iterator_traits<iterator_type>::reference reference;
private:
    iterator_type __i;
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) __wrap_iter() throw()



    {



    }
    template <class _Up> __attribute__ ((__visibility__("hidden"), __always_inline__)) __wrap_iter(const __wrap_iter<_Up>& __u,
        typename enable_if<is_convertible<_Up, iterator_type>::value>::type* = 0) throw()
        : __i(__u.base())
    {



    }
# 1161 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/iterator" 3
    __attribute__ ((__visibility__("hidden"), __always_inline__)) reference operator*() const throw()
    {




        return *__i;
    }
    __attribute__ ((__visibility__("hidden"), __always_inline__)) pointer operator->() const throw()
    {




        return (pointer)&reinterpret_cast<const volatile char&>(*__i);
    }
    __attribute__ ((__visibility__("hidden"), __always_inline__)) __wrap_iter& operator++() throw()
    {




        ++__i;
        return *this;
    }
    __attribute__ ((__visibility__("hidden"), __always_inline__)) __wrap_iter operator++(int) throw()
        {__wrap_iter __tmp(*this); ++(*this); return __tmp;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) __wrap_iter& operator--() throw()
    {




        --__i;
        return *this;
    }
    __attribute__ ((__visibility__("hidden"), __always_inline__)) __wrap_iter operator--(int) throw()
        {__wrap_iter __tmp(*this); --(*this); return __tmp;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) __wrap_iter operator+ (difference_type __n) const throw()
        {__wrap_iter __w(*this); __w += __n; return __w;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) __wrap_iter& operator+=(difference_type __n) throw()
    {




        __i += __n;
        return *this;
    }
    __attribute__ ((__visibility__("hidden"), __always_inline__)) __wrap_iter operator- (difference_type __n) const throw()
        {return *this + (-__n);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) __wrap_iter& operator-=(difference_type __n) throw()
        {*this += -__n; return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) reference operator[](difference_type __n) const throw()
    {




        return __i[__n];
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__)) iterator_type base() const throw() {return __i;}

private:






    __attribute__ ((__visibility__("hidden"), __always_inline__)) __wrap_iter(iterator_type __x) throw() : __i(__x) {}


    template <class _Up> friend class __wrap_iter;
    template <class _CharT, class _Traits, class _Alloc> friend class basic_string;
    template <class _Tp, class _Alloc> friend class vector;

    template <class _Iter1, class _Iter2>
    friend
    bool
    operator==(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) throw();

    template <class _Iter1, class _Iter2>
    friend
    bool
    operator<(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) throw();

    template <class _Iter1, class _Iter2>
    friend
    bool
    operator!=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) throw();

    template <class _Iter1, class _Iter2>
    friend
    bool
    operator>(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) throw();

    template <class _Iter1, class _Iter2>
    friend
    bool
    operator>=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) throw();

    template <class _Iter1, class _Iter2>
    friend
    bool
    operator<=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) throw();

    template <class _Iter1, class _Iter2>
    friend
    typename __wrap_iter<_Iter1>::difference_type
    operator-(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) throw();

    template <class _Iter1>
    friend
    __wrap_iter<_Iter1>
    operator+(typename __wrap_iter<_Iter1>::difference_type, __wrap_iter<_Iter1>) throw();

    template <class _Ip, class _Op> friend _Op copy(_Ip, _Ip, _Op);
    template <class _B1, class _B2> friend _B2 copy_backward(_B1, _B1, _B2);
    template <class _Ip, class _Op> friend _Op move(_Ip, _Ip, _Op);
    template <class _B1, class _B2> friend _B2 move_backward(_B1, _B1, _B2);

    template <class _Tp>
    friend
    typename enable_if
    <
        is_trivially_copy_assignable<_Tp>::value,
        _Tp*
    >::type
    __unwrap_iter(__wrap_iter<_Tp*>);
};

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator==(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) throw()
{
    return __x.base() == __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator<(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) throw()
{




    return __x.base() < __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator!=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) throw()
{
    return !(__x == __y);
}

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator>(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) throw()
{
    return __y < __x;
}

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator>=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) throw()
{
    return !(__x < __y);
}

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator<=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) throw()
{
    return !(__y < __x);
}

template <class _Iter1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator!=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter1>& __y) throw()
{
    return !(__x == __y);
}

template <class _Iter1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator>(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter1>& __y) throw()
{
    return __y < __x;
}

template <class _Iter1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator>=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter1>& __y) throw()
{
    return !(__x < __y);
}

template <class _Iter1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator<=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter1>& __y) throw()
{
    return !(__y < __x);
}

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename __wrap_iter<_Iter1>::difference_type
operator-(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) throw()
{




    return __x.base() - __y.base();
}

template <class _Iter>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
__wrap_iter<_Iter>
operator+(typename __wrap_iter<_Iter>::difference_type __n,
          __wrap_iter<_Iter> __x) throw()
{
    __x += __n;
    return __x;
}

template <class _Tp, size_t _Np>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_Tp*
begin(_Tp (&__array)[_Np])
{
    return __array;
}

template <class _Tp, size_t _Np>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_Tp*
end(_Tp (&__array)[_Np])
{
    return __array + _Np;
}
# 1541 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/iterator" 3
template <class _Cp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename _Cp::iterator
begin(_Cp& __c)
{
    return __c.begin();
}

template <class _Cp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename _Cp::const_iterator
begin(const _Cp& __c)
{
    return __c.begin();
}

template <class _Cp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename _Cp::iterator
end(_Cp& __c)
{
    return __c.end();
}

template <class _Cp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename _Cp::const_iterator
end(const _Cp& __c)
{
    return __c.end();
}



} }
# 605 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/memory" 2 3


# 1 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/tuple" 1 3
// -*- C++ -*-
//===--------------------------- tuple ------------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//




/*
    tuple synopsis

namespace std
{

template <class... T>
class tuple {
public:
    constexpr tuple();
    explicit tuple(const T&...);  // constexpr in C++14
    template <class... U>
        explicit tuple(U&&...);  // constexpr in C++14
    tuple(const tuple&) = default;
    tuple(tuple&&) = default;
    template <class... U>
        tuple(const tuple<U...>&);  // constexpr in C++14
    template <class... U>
        tuple(tuple<U...>&&);  // constexpr in C++14
    template <class U1, class U2>
        tuple(const pair<U1, U2>&); // iff sizeof...(T) == 2 // constexpr in C++14
    template <class U1, class U2>
        tuple(pair<U1, U2>&&); // iff sizeof...(T) == 2  // constexpr in C++14

    // allocator-extended constructors
    template <class Alloc>
        tuple(allocator_arg_t, const Alloc& a);
    template <class Alloc>
        tuple(allocator_arg_t, const Alloc& a, const T&...);
    template <class Alloc, class... U>
        tuple(allocator_arg_t, const Alloc& a, U&&...);
    template <class Alloc>
        tuple(allocator_arg_t, const Alloc& a, const tuple&);
    template <class Alloc>
        tuple(allocator_arg_t, const Alloc& a, tuple&&);
    template <class Alloc, class... U>
        tuple(allocator_arg_t, const Alloc& a, const tuple<U...>&);
    template <class Alloc, class... U>
        tuple(allocator_arg_t, const Alloc& a, tuple<U...>&&);
    template <class Alloc, class U1, class U2>
        tuple(allocator_arg_t, const Alloc& a, const pair<U1, U2>&);
    template <class Alloc, class U1, class U2>
        tuple(allocator_arg_t, const Alloc& a, pair<U1, U2>&&);

    tuple& operator=(const tuple&);
    tuple&
        operator=(tuple&&) noexcept(AND(is_nothrow_move_assignable<T>::value ...));
    template <class... U>
        tuple& operator=(const tuple<U...>&);
    template <class... U>
        tuple& operator=(tuple<U...>&&);
    template <class U1, class U2>
        tuple& operator=(const pair<U1, U2>&); // iff sizeof...(T) == 2
    template <class U1, class U2>
        tuple& operator=(pair<U1, U2>&&); //iffsizeof...(T) == 2

    void swap(tuple&) noexcept(AND(swap(declval<T&>(), declval<T&>())...));
};

const unspecified ignore;

template <class... T> tuple<V...>  make_tuple(T&&...); // constexpr in C++14
template <class... T> tuple<ATypes...> forward_as_tuple(T&&...) noexcept; // constexpr in C++14
template <class... T> tuple<T&...> tie(T&...) noexcept; // constexpr in C++14
template <class... Tuples> tuple<CTypes...> tuple_cat(Tuples&&... tpls); // constexpr in C++14
  
// 20.4.1.4, tuple helper classes:
template <class T> class tuple_size; // undefined
template <class... T> class tuple_size<tuple<T...>>;
template <intsize_t I, class T> class tuple_element; // undefined
template <intsize_t I, class... T> class tuple_element<I, tuple<T...>>;
template <size_t _Ip, class ..._Tp>
  using tuple_element_t = typename tuple_element <_Ip, _Tp...>::type; // C++14

// 20.4.1.5, element access:
template <intsize_t I, class... T>
    typename tuple_element<I, tuple<T...>>::type&
    get(tuple<T...>&) noexcept; // constexpr in C++14
template <intsize_t I, class... T>
    typename const tuple_element<I, tuple<T...>>::type &
    get(const tuple<T...>&) noexcept; // constexpr in C++14
template <intsize_t I, class... T>
    typename tuple_element<I, tuple<T...>>::type&&
    get(tuple<T...>&&) noexcept; // constexpr in C++14

template <class T1, class... T>
    constexpr T1& get(tuple<T...>&) noexcept;  // C++14
template <class T1, class... T>
    constexpr T1 const& get(const tuple<T...>&) noexcept;   // C++14
template <class T1, class... T>
    constexpr T1&& get(tuple<T...>&&) noexcept;   // C++14

// 20.4.1.6, relational operators:
template<class... T, class... U> bool operator==(const tuple<T...>&, const tuple<U...>&); // constexpr in C++14
template<class... T, class... U> bool operator<(const tuple<T...>&, const tuple<U...>&);  // constexpr in C++14
template<class... T, class... U> bool operator!=(const tuple<T...>&, const tuple<U...>&); // constexpr in C++14
template<class... T, class... U> bool operator>(const tuple<T...>&, const tuple<U...>&);  // constexpr in C++14
template<class... T, class... U> bool operator<=(const tuple<T...>&, const tuple<U...>&); // constexpr in C++14
template<class... T, class... U> bool operator>=(const tuple<T...>&, const tuple<U...>&); // constexpr in C++14

template <class... Types, class Alloc>
  struct uses_allocator<tuple<Types...>, Alloc>;

template <class... Types>
  void
  swap(tuple<Types...>& x, tuple<Types...>& y) noexcept(noexcept(x.swap(y)));

}  // std

*/
# 134 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/tuple" 3


namespace std {inline namespace __1 {
# 1098 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/tuple" 3
} }
# 608 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/memory" 2 3
# 617 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/memory" 3
# 1 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/__undef_min_max" 1 3
// -*- C++ -*-
//===----------------------------------------------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is dual licensed under the MIT and the University of Illinois Open
// Source Licenses. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
# 618 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/memory" 2 3
# 621 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/memory" 3


namespace std {inline namespace __1 {

// addressof moved to <__functional_base>

template <class _Tp> class allocator;

template <>
class __attribute__ ((__type_visibility__("default"))) allocator<void>
{
public:
    typedef void* pointer;
    typedef const void* const_pointer;
    typedef void value_type;

    template <class _Up> struct rebind {typedef allocator<_Up> other;};
};

template <>
class __attribute__ ((__type_visibility__("default"))) allocator<const void>
{
public:
    typedef const void* pointer;
    typedef const void* const_pointer;
    typedef const void value_type;

    template <class _Up> struct rebind {typedef allocator<_Up> other;};
};

// pointer_traits

template <class _Tp>
struct __has_element_type
{
private:
    struct __two {char __lx; char __lxx;};
    template <class _Up> static __two __test(...);
    template <class _Up> static char __test(typename _Up::element_type* = 0);
public:
    static const bool value = sizeof(__test<_Tp>(0)) == 1;
};

template <class _Ptr, bool = __has_element_type<_Ptr>::value>
struct __pointer_traits_element_type;

template <class _Ptr>
struct __pointer_traits_element_type<_Ptr, true>
{
    typedef typename _Ptr::element_type type;
};
# 689 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/memory" 3
template <template <class> class _Sp, class _Tp>
struct __pointer_traits_element_type<_Sp<_Tp>, true>
{
    typedef typename _Sp<_Tp>::element_type type;
};

template <template <class> class _Sp, class _Tp>
struct __pointer_traits_element_type<_Sp<_Tp>, false>
{
    typedef _Tp type;
};

template <template <class, class> class _Sp, class _Tp, class _A0>
struct __pointer_traits_element_type<_Sp<_Tp, _A0>, true>
{
    typedef typename _Sp<_Tp, _A0>::element_type type;
};

template <template <class, class> class _Sp, class _Tp, class _A0>
struct __pointer_traits_element_type<_Sp<_Tp, _A0>, false>
{
    typedef _Tp type;
};

template <template <class, class, class> class _Sp, class _Tp, class _A0, class _A1>
struct __pointer_traits_element_type<_Sp<_Tp, _A0, _A1>, true>
{
    typedef typename _Sp<_Tp, _A0, _A1>::element_type type;
};

template <template <class, class, class> class _Sp, class _Tp, class _A0, class _A1>
struct __pointer_traits_element_type<_Sp<_Tp, _A0, _A1>, false>
{
    typedef _Tp type;
};

template <template <class, class, class, class> class _Sp, class _Tp, class _A0,
                                                           class _A1, class _A2>
struct __pointer_traits_element_type<_Sp<_Tp, _A0, _A1, _A2>, true>
{
    typedef typename _Sp<_Tp, _A0, _A1, _A2>::element_type type;
};

template <template <class, class, class, class> class _Sp, class _Tp, class _A0,
                                                           class _A1, class _A2>
struct __pointer_traits_element_type<_Sp<_Tp, _A0, _A1, _A2>, false>
{
    typedef _Tp type;
};



template <class _Tp>
struct __has_difference_type
{
private:
    struct __two {char __lx; char __lxx;};
    template <class _Up> static __two __test(...);
    template <class _Up> static char __test(typename _Up::difference_type* = 0);
public:
    static const bool value = sizeof(__test<_Tp>(0)) == 1;
};

template <class _Ptr, bool = __has_difference_type<_Ptr>::value>
struct __pointer_traits_difference_type
{
    typedef ptrdiff_t type;
};

template <class _Ptr>
struct __pointer_traits_difference_type<_Ptr, true>
{
    typedef typename _Ptr::difference_type type;
};

template <class _Tp, class _Up>
struct __has_rebind
{
private:
    struct __two {char __lx; char __lxx;};
    template <class _Xp> static __two __test(...);
    template <class _Xp> static char __test(typename _Xp::template rebind<_Up>* = 0);
public:
    static const bool value = sizeof(__test<_Tp>(0)) == 1;
};

template <class _Tp, class _Up, bool = __has_rebind<_Tp, _Up>::value>
struct __pointer_traits_rebind
{



    typedef typename _Tp::template rebind<_Up>::other type;

};
# 805 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/memory" 3
template <template <class> class _Sp, class _Tp, class _Up>
struct __pointer_traits_rebind<_Sp<_Tp>, _Up, true>
{



    typedef typename _Sp<_Tp>::template rebind<_Up>::other type;

};

template <template <class> class _Sp, class _Tp, class _Up>
struct __pointer_traits_rebind<_Sp<_Tp>, _Up, false>
{
    typedef _Sp<_Up> type;
};

template <template <class, class> class _Sp, class _Tp, class _A0, class _Up>
struct __pointer_traits_rebind<_Sp<_Tp, _A0>, _Up, true>
{



    typedef typename _Sp<_Tp, _A0>::template rebind<_Up>::other type;

};

template <template <class, class> class _Sp, class _Tp, class _A0, class _Up>
struct __pointer_traits_rebind<_Sp<_Tp, _A0>, _Up, false>
{
    typedef _Sp<_Up, _A0> type;
};

template <template <class, class, class> class _Sp, class _Tp, class _A0,
                                         class _A1, class _Up>
struct __pointer_traits_rebind<_Sp<_Tp, _A0, _A1>, _Up, true>
{



    typedef typename _Sp<_Tp, _A0, _A1>::template rebind<_Up>::other type;

};

template <template <class, class, class> class _Sp, class _Tp, class _A0,
                                         class _A1, class _Up>
struct __pointer_traits_rebind<_Sp<_Tp, _A0, _A1>, _Up, false>
{
    typedef _Sp<_Up, _A0, _A1> type;
};

template <template <class, class, class, class> class _Sp, class _Tp, class _A0,
                                                class _A1, class _A2, class _Up>
struct __pointer_traits_rebind<_Sp<_Tp, _A0, _A1, _A2>, _Up, true>
{



    typedef typename _Sp<_Tp, _A0, _A1, _A2>::template rebind<_Up>::other type;

};

template <template <class, class, class, class> class _Sp, class _Tp, class _A0,
                                                class _A1, class _A2, class _Up>
struct __pointer_traits_rebind<_Sp<_Tp, _A0, _A1, _A2>, _Up, false>
{
    typedef _Sp<_Up, _A0, _A1, _A2> type;
};



template <class _Ptr>
struct __attribute__ ((__type_visibility__("default"))) pointer_traits
{
    typedef _Ptr pointer;
    typedef typename __pointer_traits_element_type<pointer>::type element_type;
    typedef typename __pointer_traits_difference_type<pointer>::type difference_type;




    template <class _Up> struct rebind
        {typedef typename __pointer_traits_rebind<pointer, _Up>::type other;};


private:
    struct __nat {};
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static pointer pointer_to(typename conditional<is_void<element_type>::value,
                                           __nat, element_type>::type& __r)
        {return pointer::pointer_to(__r);}
};

template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) pointer_traits<_Tp*>
{
    typedef _Tp* pointer;
    typedef _Tp element_type;
    typedef ptrdiff_t difference_type;




    template <class _Up> struct rebind {typedef _Up* other;};


private:
    struct __nat {};
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static pointer pointer_to(typename conditional<is_void<element_type>::value,
                                      __nat, element_type>::type& __r) throw()
        {return std::__1::addressof(__r);}
};

// allocator_traits

namespace __has_pointer_type_imp
{
    template <class _Up> static __two __test(...);
    template <class _Up> static char __test(typename _Up::pointer* = 0);
}

template <class _Tp>
struct __has_pointer_type
    : public integral_constant<bool, sizeof(__has_pointer_type_imp::__test<_Tp>(0)) == 1>
{
};

namespace __pointer_type_imp
{

template <class _Tp, class _Dp, bool = __has_pointer_type<_Dp>::value>
struct __pointer_type
{
    typedef typename _Dp::pointer type;
};

template <class _Tp, class _Dp>
struct __pointer_type<_Tp, _Dp, false>
{
    typedef _Tp* type;
};

} // __pointer_type_imp

template <class _Tp, class _Dp>
struct __pointer_type
{
    typedef typename __pointer_type_imp::__pointer_type<_Tp, typename remove_reference<_Dp>::type>::type type;
};

template <class _Tp>
struct __has_const_pointer
{
private:
    struct __two {char __lx; char __lxx;};
    template <class _Up> static __two __test(...);
    template <class _Up> static char __test(typename _Up::const_pointer* = 0);
public:
    static const bool value = sizeof(__test<_Tp>(0)) == 1;
};

template <class _Tp, class _Ptr, class _Alloc, bool = __has_const_pointer<_Alloc>::value>
struct __const_pointer
{
    typedef typename _Alloc::const_pointer type;
};

template <class _Tp, class _Ptr, class _Alloc>
struct __const_pointer<_Tp, _Ptr, _Alloc, false>
{



    typedef typename pointer_traits<_Ptr>::template rebind<const _Tp>::other type;

};

template <class _Tp>
struct __has_void_pointer
{
private:
    struct __two {char __lx; char __lxx;};
    template <class _Up> static __two __test(...);
    template <class _Up> static char __test(typename _Up::void_pointer* = 0);
public:
    static const bool value = sizeof(__test<_Tp>(0)) == 1;
};

template <class _Ptr, class _Alloc, bool = __has_void_pointer<_Alloc>::value>
struct __void_pointer
{
    typedef typename _Alloc::void_pointer type;
};

template <class _Ptr, class _Alloc>
struct __void_pointer<_Ptr, _Alloc, false>
{



    typedef typename pointer_traits<_Ptr>::template rebind<void>::other type;

};

template <class _Tp>
struct __has_const_void_pointer
{
private:
    struct __two {char __lx; char __lxx;};
    template <class _Up> static __two __test(...);
    template <class _Up> static char __test(typename _Up::const_void_pointer* = 0);
public:
    static const bool value = sizeof(__test<_Tp>(0)) == 1;
};

template <class _Ptr, class _Alloc, bool = __has_const_void_pointer<_Alloc>::value>
struct __const_void_pointer
{
    typedef typename _Alloc::const_void_pointer type;
};

template <class _Ptr, class _Alloc>
struct __const_void_pointer<_Ptr, _Alloc, false>
{



    typedef typename pointer_traits<_Ptr>::template rebind<const void>::other type;

};

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_Tp*
__to_raw_pointer(_Tp* __p) throw()
{
    return __p;
}

template <class _Pointer>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename pointer_traits<_Pointer>::element_type*
__to_raw_pointer(_Pointer __p) throw()
{
    return std::__1::__to_raw_pointer(__p.operator->());
}

template <class _Tp>
struct __has_size_type
{
private:
    struct __two {char __lx; char __lxx;};
    template <class _Up> static __two __test(...);
    template <class _Up> static char __test(typename _Up::size_type* = 0);
public:
    static const bool value = sizeof(__test<_Tp>(0)) == 1;
};

template <class _Alloc, class _DiffType, bool = __has_size_type<_Alloc>::value>
struct __size_type
{
    typedef typename make_unsigned<_DiffType>::type type;
};

template <class _Alloc, class _DiffType>
struct __size_type<_Alloc, _DiffType, true>
{
    typedef typename _Alloc::size_type type;
};

template <class _Tp>
struct __has_propagate_on_container_copy_assignment
{
private:
    struct __two {char __lx; char __lxx;};
    template <class _Up> static __two __test(...);
    template <class _Up> static char __test(typename _Up::propagate_on_container_copy_assignment* = 0);
public:
    static const bool value = sizeof(__test<_Tp>(0)) == 1;
};

template <class _Alloc, bool = __has_propagate_on_container_copy_assignment<_Alloc>::value>
struct __propagate_on_container_copy_assignment
{
    typedef false_type type;
};

template <class _Alloc>
struct __propagate_on_container_copy_assignment<_Alloc, true>
{
    typedef typename _Alloc::propagate_on_container_copy_assignment type;
};

template <class _Tp>
struct __has_propagate_on_container_move_assignment
{
private:
    struct __two {char __lx; char __lxx;};
    template <class _Up> static __two __test(...);
    template <class _Up> static char __test(typename _Up::propagate_on_container_move_assignment* = 0);
public:
    static const bool value = sizeof(__test<_Tp>(0)) == 1;
};

template <class _Alloc, bool = __has_propagate_on_container_move_assignment<_Alloc>::value>
struct __propagate_on_container_move_assignment
{
    typedef false_type type;
};

template <class _Alloc>
struct __propagate_on_container_move_assignment<_Alloc, true>
{
    typedef typename _Alloc::propagate_on_container_move_assignment type;
};

template <class _Tp>
struct __has_propagate_on_container_swap
{
private:
    struct __two {char __lx; char __lxx;};
    template <class _Up> static __two __test(...);
    template <class _Up> static char __test(typename _Up::propagate_on_container_swap* = 0);
public:
    static const bool value = sizeof(__test<_Tp>(0)) == 1;
};

template <class _Alloc, bool = __has_propagate_on_container_swap<_Alloc>::value>
struct __propagate_on_container_swap
{
    typedef false_type type;
};

template <class _Alloc>
struct __propagate_on_container_swap<_Alloc, true>
{
    typedef typename _Alloc::propagate_on_container_swap type;
};

template <class _Tp, class _Up, bool = __has_rebind<_Tp, _Up>::value>
struct __has_rebind_other
{
private:
    struct __two {char __lx; char __lxx;};
    template <class _Xp> static __two __test(...);
    template <class _Xp> static char __test(typename _Xp::template rebind<_Up>::other* = 0);
public:
    static const bool value = sizeof(__test<_Tp>(0)) == 1;
};

template <class _Tp, class _Up>
struct __has_rebind_other<_Tp, _Up, false>
{
    static const bool value = false;
};

template <class _Tp, class _Up, bool = __has_rebind_other<_Tp, _Up>::value>
struct __allocator_traits_rebind
{
    typedef typename _Tp::template rebind<_Up>::other type;
};
# 1185 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/memory" 3
template <template <class> class _Alloc, class _Tp, class _Up>
struct __allocator_traits_rebind<_Alloc<_Tp>, _Up, true>
{
    typedef typename _Alloc<_Tp>::template rebind<_Up>::other type;
};

template <template <class> class _Alloc, class _Tp, class _Up>
struct __allocator_traits_rebind<_Alloc<_Tp>, _Up, false>
{
    typedef _Alloc<_Up> type;
};

template <template <class, class> class _Alloc, class _Tp, class _A0, class _Up>
struct __allocator_traits_rebind<_Alloc<_Tp, _A0>, _Up, true>
{
    typedef typename _Alloc<_Tp, _A0>::template rebind<_Up>::other type;
};

template <template <class, class> class _Alloc, class _Tp, class _A0, class _Up>
struct __allocator_traits_rebind<_Alloc<_Tp, _A0>, _Up, false>
{
    typedef _Alloc<_Up, _A0> type;
};

template <template <class, class, class> class _Alloc, class _Tp, class _A0,
                                         class _A1, class _Up>
struct __allocator_traits_rebind<_Alloc<_Tp, _A0, _A1>, _Up, true>
{
    typedef typename _Alloc<_Tp, _A0, _A1>::template rebind<_Up>::other type;
};

template <template <class, class, class> class _Alloc, class _Tp, class _A0,
                                         class _A1, class _Up>
struct __allocator_traits_rebind<_Alloc<_Tp, _A0, _A1>, _Up, false>
{
    typedef _Alloc<_Up, _A0, _A1> type;
};

template <template <class, class, class, class> class _Alloc, class _Tp, class _A0,
                                                class _A1, class _A2, class _Up>
struct __allocator_traits_rebind<_Alloc<_Tp, _A0, _A1, _A2>, _Up, true>
{
    typedef typename _Alloc<_Tp, _A0, _A1, _A2>::template rebind<_Up>::other type;
};

template <template <class, class, class, class> class _Alloc, class _Tp, class _A0,
                                                class _A1, class _A2, class _Up>
struct __allocator_traits_rebind<_Alloc<_Tp, _A0, _A1, _A2>, _Up, false>
{
    typedef _Alloc<_Up, _A0, _A1, _A2> type;
};
# 1264 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/memory" 3
template <class _Alloc, class _SizeType, class _ConstVoidPtr>
struct __has_allocate_hint
    : true_type
{
};
# 1365 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/memory" 3
template <class _Alloc, class _Pointer, class _Args>
struct __has_construct
    : false_type
{
};



template <class _Alloc, class _Pointer>
struct __has_destroy
    : false_type
{
};

template <class _Alloc>
struct __has_max_size
    : true_type
{
};

template <class _Alloc>
struct __has_select_on_container_copy_construction
    : false_type
{
};



template <class _Alloc, class _Ptr, bool = __has_difference_type<_Alloc>::value>
struct __alloc_traits_difference_type
{
    typedef typename pointer_traits<_Ptr>::difference_type type;
};

template <class _Alloc, class _Ptr>
struct __alloc_traits_difference_type<_Alloc, _Ptr, true>
{
    typedef typename _Alloc::difference_type type;
};

template <class _Alloc>
struct __attribute__ ((__type_visibility__("default"))) allocator_traits
{
    typedef _Alloc allocator_type;
    typedef typename allocator_type::value_type value_type;

    typedef typename __pointer_type<value_type, allocator_type>::type pointer;
    typedef typename __const_pointer<value_type, pointer, allocator_type>::type const_pointer;
    typedef typename __void_pointer<pointer, allocator_type>::type void_pointer;
    typedef typename __const_void_pointer<pointer, allocator_type>::type const_void_pointer;

    typedef typename __alloc_traits_difference_type<allocator_type, pointer>::type difference_type;
    typedef typename __size_type<allocator_type, difference_type>::type size_type;

    typedef typename __propagate_on_container_copy_assignment<allocator_type>::type
                     propagate_on_container_copy_assignment;
    typedef typename __propagate_on_container_move_assignment<allocator_type>::type
                     propagate_on_container_move_assignment;
    typedef typename __propagate_on_container_swap<allocator_type>::type
                     propagate_on_container_swap;






    template <class _Tp> struct rebind_alloc
        {typedef typename __allocator_traits_rebind<allocator_type, _Tp>::type other;};
    template <class _Tp> struct rebind_traits
        {typedef allocator_traits<typename rebind_alloc<_Tp>::other> other;};


    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static pointer allocate(allocator_type& __a, size_type __n)
        {return __a.allocate(__n);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static pointer allocate(allocator_type& __a, size_type __n, const_void_pointer __hint)
        {return allocate(__a, __n, __hint,
            __has_allocate_hint<allocator_type, size_type, const_void_pointer>());}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static void deallocate(allocator_type& __a, pointer __p, size_type __n) throw()
        {__a.deallocate(__p, __n);}
# 1456 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/memory" 3
    template <class _Tp>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        static void construct(allocator_type& __a, _Tp* __p)
            {
                ::new ((void*)__p) _Tp();
            }
    template <class _Tp, class _A0>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        static void construct(allocator_type& __a, _Tp* __p, const _A0& __a0)
            {
                ::new ((void*)__p) _Tp(__a0);
            }
    template <class _Tp, class _A0, class _A1>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        static void construct(allocator_type& __a, _Tp* __p, const _A0& __a0,
                              const _A1& __a1)
            {
                ::new ((void*)__p) _Tp(__a0, __a1);
            }
    template <class _Tp, class _A0, class _A1, class _A2>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        static void construct(allocator_type& __a, _Tp* __p, const _A0& __a0,
                              const _A1& __a1, const _A2& __a2)
            {
                ::new ((void*)__p) _Tp(__a0, __a1, __a2);
            }


    template <class _Tp>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        static void destroy(allocator_type& __a, _Tp* __p)
            {__destroy(__has_destroy<allocator_type, _Tp*>(), __a, __p);}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static size_type max_size(const allocator_type& __a) throw()
        {return __max_size(__has_max_size<const allocator_type>(), __a);}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static allocator_type
        select_on_container_copy_construction(const allocator_type& __a)
            {return select_on_container_copy_construction(
                __has_select_on_container_copy_construction<const allocator_type>(),
                __a);}

    template <class _Ptr>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        static
        void
        __construct_forward(allocator_type& __a, _Ptr __begin1, _Ptr __end1, _Ptr& __begin2)
        {
            for (; __begin1 != __end1; ++__begin1, ++__begin2)
                construct(__a, std::__1::__to_raw_pointer(__begin2), std::__1::move_if_noexcept(*__begin1));
        }

    template <class _Tp>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        static
        typename enable_if
        <
            (is_same<allocator_type, allocator<_Tp> >::value
                || !__has_construct<allocator_type, _Tp*, _Tp>::value) &&
             is_trivially_move_constructible<_Tp>::value,
            void
        >::type
        __construct_forward(allocator_type& __a, _Tp* __begin1, _Tp* __end1, _Tp*& __begin2)
        {
            ptrdiff_t _Np = __end1 - __begin1;
            std::__1::memcpy(__begin2, __begin1, _Np * sizeof(_Tp));
            __begin2 += _Np;
        }

    template <class _Ptr>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        static
        void
        __construct_backward(allocator_type& __a, _Ptr __begin1, _Ptr __end1, _Ptr& __end2)
        {
            while (__end1 != __begin1)
            {
                construct(__a, std::__1::__to_raw_pointer(__end2-1), std::__1::move_if_noexcept(*--__end1));
                --__end2;
            }
        }

    template <class _Tp>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        static
        typename enable_if
        <
            (is_same<allocator_type, allocator<_Tp> >::value
                || !__has_construct<allocator_type, _Tp*, _Tp>::value) &&
             is_trivially_move_constructible<_Tp>::value,
            void
        >::type
        __construct_backward(allocator_type& __a, _Tp* __begin1, _Tp* __end1, _Tp*& __end2)
        {
            ptrdiff_t _Np = __end1 - __begin1;
            __end2 -= _Np;
            std::__1::memcpy(__end2, __begin1, _Np * sizeof(_Tp));
        }

private:

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static pointer allocate(allocator_type& __a, size_type __n,
        const_void_pointer __hint, true_type)
        {return __a.allocate(__n, __hint);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static pointer allocate(allocator_type& __a, size_type __n,
        const_void_pointer, false_type)
        {return __a.allocate(__n);}
# 1581 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/memory" 3
    template <class _Tp>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        static void __destroy(true_type, allocator_type& __a, _Tp* __p)
            {__a.destroy(__p);}
    template <class _Tp>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        static void __destroy(false_type, allocator_type&, _Tp* __p)
            {
                __p->~_Tp();
            }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static size_type __max_size(true_type, const allocator_type& __a)
            {return __a.max_size();}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static size_type __max_size(false_type, const allocator_type&)
            {return numeric_limits<size_type>::max();}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static allocator_type
        select_on_container_copy_construction(true_type, const allocator_type& __a)
            {return __a.select_on_container_copy_construction();}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static allocator_type
        select_on_container_copy_construction(false_type, const allocator_type& __a)
            {return __a;}
};

// allocator

template <class _Tp>
class __attribute__ ((__type_visibility__("default"))) allocator
{
public:
    typedef size_t size_type;
    typedef ptrdiff_t difference_type;
    typedef _Tp* pointer;
    typedef const _Tp* const_pointer;
    typedef _Tp& reference;
    typedef const _Tp& const_reference;
    typedef _Tp value_type;

    typedef true_type propagate_on_container_move_assignment;

    template <class _Up> struct rebind {typedef allocator<_Up> other;};

    __attribute__ ((__visibility__("hidden"), __always_inline__)) allocator() throw() {}
    template <class _Up> __attribute__ ((__visibility__("hidden"), __always_inline__)) allocator(const allocator<_Up>&) throw() {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) pointer address(reference __x) const throw()
        {return std::__1::addressof(__x);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) const_pointer address(const_reference __x) const throw()
        {return std::__1::addressof(__x);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) pointer allocate(size_type __n, allocator<void>::const_pointer = 0)
        {return static_cast<pointer>(std::__1::__allocate(__n * sizeof(_Tp)));}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) void deallocate(pointer __p, size_type) throw()
        {std::__1::__deallocate((void*)__p);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) size_type max_size() const throw()
        {return size_type(~0) / sizeof(_Tp);}
# 1648 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/memory" 3
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        void
        construct(pointer __p)
        {
            ::new((void*)__p) _Tp();
        }


    template <class _A0>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        void
        construct(pointer __p, _A0& __a0)
        {
            ::new((void*)__p) _Tp(__a0);
        }
    template <class _A0>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        void
        construct(pointer __p, const _A0& __a0)
        {
            ::new((void*)__p) _Tp(__a0);
        }

    template <class _A0, class _A1>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        void
        construct(pointer __p, _A0& __a0, _A1& __a1)
        {
            ::new((void*)__p) _Tp(__a0, __a1);
        }
    template <class _A0, class _A1>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        void
        construct(pointer __p, const _A0& __a0, _A1& __a1)
        {
            ::new((void*)__p) _Tp(__a0, __a1);
        }
    template <class _A0, class _A1>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        void
        construct(pointer __p, _A0& __a0, const _A1& __a1)
        {
            ::new((void*)__p) _Tp(__a0, __a1);
        }
    template <class _A0, class _A1>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        void
        construct(pointer __p, const _A0& __a0, const _A1& __a1)
        {
            ::new((void*)__p) _Tp(__a0, __a1);
        }

    __attribute__ ((__visibility__("hidden"), __always_inline__)) void destroy(pointer __p) {__p->~_Tp();}
};

template <class _Tp>
class __attribute__ ((__type_visibility__("default"))) allocator<const _Tp>
{
public:
    typedef size_t size_type;
    typedef ptrdiff_t difference_type;
    typedef const _Tp* pointer;
    typedef const _Tp* const_pointer;
    typedef const _Tp& reference;
    typedef const _Tp& const_reference;
    typedef const _Tp value_type;

    typedef true_type propagate_on_container_move_assignment;

    template <class _Up> struct rebind {typedef allocator<_Up> other;};

    __attribute__ ((__visibility__("hidden"), __always_inline__)) allocator() throw() {}
    template <class _Up> __attribute__ ((__visibility__("hidden"), __always_inline__)) allocator(const allocator<_Up>&) throw() {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) const_pointer address(const_reference __x) const throw()
        {return std::__1::addressof(__x);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) pointer allocate(size_type __n, allocator<void>::const_pointer = 0)
        {return static_cast<pointer>(std::__1::__allocate(__n * sizeof(_Tp)));}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) void deallocate(pointer __p, size_type) throw()
        {std::__1::__deallocate((void*)__p);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) size_type max_size() const throw()
        {return size_type(~0) / sizeof(_Tp);}
# 1738 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/memory" 3
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        void
        construct(pointer __p)
        {
            ::new((void*)__p) _Tp();
        }


    template <class _A0>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        void
        construct(pointer __p, _A0& __a0)
        {
            ::new((void*)__p) _Tp(__a0);
        }
    template <class _A0>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        void
        construct(pointer __p, const _A0& __a0)
        {
            ::new((void*)__p) _Tp(__a0);
        }

    template <class _A0, class _A1>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        void
        construct(pointer __p, _A0& __a0, _A1& __a1)
        {
            ::new((void*)__p) _Tp(__a0, __a1);
        }
    template <class _A0, class _A1>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        void
        construct(pointer __p, const _A0& __a0, _A1& __a1)
        {
            ::new((void*)__p) _Tp(__a0, __a1);
        }
    template <class _A0, class _A1>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        void
        construct(pointer __p, _A0& __a0, const _A1& __a1)
        {
            ::new((void*)__p) _Tp(__a0, __a1);
        }
    template <class _A0, class _A1>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        void
        construct(pointer __p, const _A0& __a0, const _A1& __a1)
        {
            ::new((void*)__p) _Tp(__a0, __a1);
        }

    __attribute__ ((__visibility__("hidden"), __always_inline__)) void destroy(pointer __p) {__p->~_Tp();}
};

template <class _Tp, class _Up>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool operator==(const allocator<_Tp>&, const allocator<_Up>&) throw() {return true;}

template <class _Tp, class _Up>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool operator!=(const allocator<_Tp>&, const allocator<_Up>&) throw() {return false;}

template <class _OutputIterator, class _Tp>
class __attribute__ ((__type_visibility__("default"))) raw_storage_iterator
    : public iterator<output_iterator_tag,
                      _Tp, // purposefully not C++03
                      ptrdiff_t, // purposefully not C++03
                      _Tp*, // purposefully not C++03
                      raw_storage_iterator<_OutputIterator, _Tp>&> // purposefully not C++03
{
private:
    _OutputIterator __x_;
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit raw_storage_iterator(_OutputIterator __x) : __x_(__x) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) raw_storage_iterator& operator*() {return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) raw_storage_iterator& operator=(const _Tp& __element)
        {::new(&*__x_) _Tp(__element); return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) raw_storage_iterator& operator++() {++__x_; return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) raw_storage_iterator operator++(int)
        {raw_storage_iterator __t(*this); ++__x_; return __t;}
};

template <class _Tp>
pair<_Tp*, ptrdiff_t>
get_temporary_buffer(ptrdiff_t __n) throw()
{
    pair<_Tp*, ptrdiff_t> __r(0, 0);
    const ptrdiff_t __m = (~ptrdiff_t(0) ^
                           ptrdiff_t(ptrdiff_t(1) << (sizeof(ptrdiff_t) * 8 - 1)))
                           / sizeof(_Tp);
    if (__n > __m)
        __n = __m;
    while (__n > 0)
    {
        __r.first = static_cast<_Tp*>(::operator new(__n * sizeof(_Tp), nothrow));
        if (__r.first)
        {
            __r.second = __n;
            break;
        }
        __n /= 2;
    }
    return __r;
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void return_temporary_buffer(_Tp* __p) throw() {::operator delete(__p);}

template <class _Tp>
struct auto_ptr_ref
{
    _Tp* __ptr_;
};

template<class _Tp>
class __attribute__ ((__type_visibility__("default"))) auto_ptr
{
private:
    _Tp* __ptr_;
public:
    typedef _Tp element_type;

    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit auto_ptr(_Tp* __p = 0) throw() : __ptr_(__p) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) auto_ptr(auto_ptr& __p) throw() : __ptr_(__p.release()) {}
    template<class _Up> __attribute__ ((__visibility__("hidden"), __always_inline__)) auto_ptr(auto_ptr<_Up>& __p) throw()
        : __ptr_(__p.release()) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) auto_ptr& operator=(auto_ptr& __p) throw()
        {reset(__p.release()); return *this;}
    template<class _Up> __attribute__ ((__visibility__("hidden"), __always_inline__)) auto_ptr& operator=(auto_ptr<_Up>& __p) throw()
        {reset(__p.release()); return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) auto_ptr& operator=(auto_ptr_ref<_Tp> __p) throw()
        {reset(__p.__ptr_); return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) ~auto_ptr() throw() {delete __ptr_;}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) _Tp& operator*() const throw()
        {return *__ptr_;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) _Tp* operator->() const throw() {return __ptr_;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) _Tp* get() const throw() {return __ptr_;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) _Tp* release() throw()
    {
        _Tp* __t = __ptr_;
        __ptr_ = 0;
        return __t;
    }
    __attribute__ ((__visibility__("hidden"), __always_inline__)) void reset(_Tp* __p = 0) throw()
    {
        if (__ptr_ != __p)
            delete __ptr_;
        __ptr_ = __p;
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__)) auto_ptr(auto_ptr_ref<_Tp> __p) throw() : __ptr_(__p.__ptr_) {}
    template<class _Up> __attribute__ ((__visibility__("hidden"), __always_inline__)) operator auto_ptr_ref<_Up>() throw()
        {auto_ptr_ref<_Up> __t; __t.__ptr_ = release(); return __t;}
    template<class _Up> __attribute__ ((__visibility__("hidden"), __always_inline__)) operator auto_ptr<_Up>() throw()
        {return auto_ptr<_Up>(release());}
};

template <>
class __attribute__ ((__type_visibility__("default"))) auto_ptr<void>
{
public:
    typedef void element_type;
};

template <class _T1, class _T2, bool = is_same<typename remove_cv<_T1>::type,
                                                     typename remove_cv<_T2>::type>::value,
                                bool = is_empty<_T1>::value

                                       && !__is_final(_T1)

                                ,
                                bool = is_empty<_T2>::value

                                       && !__is_final(_T2)

         >
struct __libcpp_compressed_pair_switch;

template <class _T1, class _T2, bool IsSame>
struct __libcpp_compressed_pair_switch<_T1, _T2, IsSame, false, false> {enum {value = 0};};

template <class _T1, class _T2, bool IsSame>
struct __libcpp_compressed_pair_switch<_T1, _T2, IsSame, true, false> {enum {value = 1};};

template <class _T1, class _T2, bool IsSame>
struct __libcpp_compressed_pair_switch<_T1, _T2, IsSame, false, true> {enum {value = 2};};

template <class _T1, class _T2>
struct __libcpp_compressed_pair_switch<_T1, _T2, false, true, true> {enum {value = 3};};

template <class _T1, class _T2>
struct __libcpp_compressed_pair_switch<_T1, _T2, true, true, true> {enum {value = 1};};

template <class _T1, class _T2, unsigned = __libcpp_compressed_pair_switch<_T1, _T2>::value>
class __libcpp_compressed_pair_imp;

template <class _T1, class _T2>
class __libcpp_compressed_pair_imp<_T1, _T2, 0>
{
private:
    _T1 __first_;
    _T2 __second_;
public:
    typedef _T1 _T1_param;
    typedef _T2 _T2_param;

    typedef typename remove_reference<_T1>::type& _T1_reference;
    typedef typename remove_reference<_T2>::type& _T2_reference;

    typedef const typename remove_reference<_T1>::type& _T1_const_reference;
    typedef const typename remove_reference<_T2>::type& _T2_const_reference;

    __attribute__ ((__visibility__("hidden"), __always_inline__)) __libcpp_compressed_pair_imp() {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit __libcpp_compressed_pair_imp(_T1_param __t1)
        : __first_(std::__1::forward<_T1_param>(__t1)) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit __libcpp_compressed_pair_imp(_T2_param __t2)
        : __second_(std::__1::forward<_T2_param>(__t2)) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) __libcpp_compressed_pair_imp(_T1_param __t1, _T2_param __t2)
        : __first_(std::__1::forward<_T1_param>(__t1)), __second_(std::__1::forward<_T2_param>(__t2)) {}
# 2014 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/memory" 3
    __attribute__ ((__visibility__("hidden"), __always_inline__)) _T1_reference first() throw() {return __first_;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) _T1_const_reference first() const throw() {return __first_;}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) _T2_reference second() throw() {return __second_;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) _T2_const_reference second() const throw() {return __second_;}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) void swap(__libcpp_compressed_pair_imp& __x)


    {
        using std::__1::swap;
        swap(__first_, __x.__first_);
        swap(__second_, __x.__second_);
    }
};

template <class _T1, class _T2>
class __libcpp_compressed_pair_imp<_T1, _T2, 1>
    : private _T1
{
private:
    _T2 __second_;
public:
    typedef _T1 _T1_param;
    typedef _T2 _T2_param;

    typedef _T1& _T1_reference;
    typedef typename remove_reference<_T2>::type& _T2_reference;

    typedef const _T1& _T1_const_reference;
    typedef const typename remove_reference<_T2>::type& _T2_const_reference;

    __attribute__ ((__visibility__("hidden"), __always_inline__)) __libcpp_compressed_pair_imp() {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit __libcpp_compressed_pair_imp(_T1_param __t1)
        : _T1(std::__1::forward<_T1_param>(__t1)) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit __libcpp_compressed_pair_imp(_T2_param __t2)
        : __second_(std::__1::forward<_T2_param>(__t2)) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) __libcpp_compressed_pair_imp(_T1_param __t1, _T2_param __t2)
        : _T1(std::__1::forward<_T1_param>(__t1)), __second_(std::__1::forward<_T2_param>(__t2)) {}
# 2105 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/memory" 3
    __attribute__ ((__visibility__("hidden"), __always_inline__)) _T1_reference first() throw() {return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) _T1_const_reference first() const throw() {return *this;}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) _T2_reference second() throw() {return __second_;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) _T2_const_reference second() const throw() {return __second_;}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) void swap(__libcpp_compressed_pair_imp& __x)


    {
        using std::__1::swap;
        swap(__second_, __x.__second_);
    }
};

template <class _T1, class _T2>
class __libcpp_compressed_pair_imp<_T1, _T2, 2>
    : private _T2
{
private:
    _T1 __first_;
public:
    typedef _T1 _T1_param;
    typedef _T2 _T2_param;

    typedef typename remove_reference<_T1>::type& _T1_reference;
    typedef _T2& _T2_reference;

    typedef const typename remove_reference<_T1>::type& _T1_const_reference;
    typedef const _T2& _T2_const_reference;

    __attribute__ ((__visibility__("hidden"), __always_inline__)) __libcpp_compressed_pair_imp() {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit __libcpp_compressed_pair_imp(_T1_param __t1)
        : __first_(std::__1::forward<_T1_param>(__t1)) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit __libcpp_compressed_pair_imp(_T2_param __t2)
        : _T2(std::__1::forward<_T2_param>(__t2)) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) __libcpp_compressed_pair_imp(_T1_param __t1, _T2_param __t2)


        : _T2(std::__1::forward<_T2_param>(__t2)), __first_(std::__1::forward<_T1_param>(__t1)) {}
# 2198 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/memory" 3
    __attribute__ ((__visibility__("hidden"), __always_inline__)) _T1_reference first() throw() {return __first_;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) _T1_const_reference first() const throw() {return __first_;}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) _T2_reference second() throw() {return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) _T2_const_reference second() const throw() {return *this;}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) void swap(__libcpp_compressed_pair_imp& __x)


    {
        using std::__1::swap;
        swap(__first_, __x.__first_);
    }
};

template <class _T1, class _T2>
class __libcpp_compressed_pair_imp<_T1, _T2, 3>
    : private _T1,
      private _T2
{
public:
    typedef _T1 _T1_param;
    typedef _T2 _T2_param;

    typedef _T1& _T1_reference;
    typedef _T2& _T2_reference;

    typedef const _T1& _T1_const_reference;
    typedef const _T2& _T2_const_reference;

    __attribute__ ((__visibility__("hidden"), __always_inline__)) __libcpp_compressed_pair_imp() {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit __libcpp_compressed_pair_imp(_T1_param __t1)
        : _T1(std::__1::forward<_T1_param>(__t1)) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit __libcpp_compressed_pair_imp(_T2_param __t2)
        : _T2(std::__1::forward<_T2_param>(__t2)) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) __libcpp_compressed_pair_imp(_T1_param __t1, _T2_param __t2)
        : _T1(std::__1::forward<_T1_param>(__t1)), _T2(std::__1::forward<_T2_param>(__t2)) {}
# 2287 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/memory" 3
    __attribute__ ((__visibility__("hidden"), __always_inline__)) _T1_reference first() throw() {return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) _T1_const_reference first() const throw() {return *this;}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) _T2_reference second() throw() {return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) _T2_const_reference second() const throw() {return *this;}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) void swap(__libcpp_compressed_pair_imp&)


    {
    }
};

template <class _T1, class _T2>
class __compressed_pair
    : private __libcpp_compressed_pair_imp<_T1, _T2>
{
    typedef __libcpp_compressed_pair_imp<_T1, _T2> base;
public:
    typedef typename base::_T1_param _T1_param;
    typedef typename base::_T2_param _T2_param;

    typedef typename base::_T1_reference _T1_reference;
    typedef typename base::_T2_reference _T2_reference;

    typedef typename base::_T1_const_reference _T1_const_reference;
    typedef typename base::_T2_const_reference _T2_const_reference;

    __attribute__ ((__visibility__("hidden"), __always_inline__)) __compressed_pair() {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit __compressed_pair(_T1_param __t1)
        : base(std::__1::forward<_T1_param>(__t1)) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit __compressed_pair(_T2_param __t2)
        : base(std::__1::forward<_T2_param>(__t2)) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) __compressed_pair(_T1_param __t1, _T2_param __t2)
        : base(std::__1::forward<_T1_param>(__t1), std::__1::forward<_T2_param>(__t2)) {}
# 2370 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/memory" 3
    __attribute__ ((__visibility__("hidden"), __always_inline__)) _T1_reference first() throw() {return base::first();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) _T1_const_reference first() const throw() {return base::first();}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) _T2_reference second() throw() {return base::second();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) _T2_const_reference second() const throw() {return base::second();}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) void swap(__compressed_pair& __x)


        {base::swap(__x);}
};

template <class _T1, class _T2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
swap(__compressed_pair<_T1, _T2>& __x, __compressed_pair<_T1, _T2>& __y)


    {__x.swap(__y);}

// __same_or_less_cv_qualified

template <class _Ptr1, class _Ptr2,
          bool = is_same<typename remove_cv<typename pointer_traits<_Ptr1>::element_type>::type,
                         typename remove_cv<typename pointer_traits<_Ptr2>::element_type>::type
                        >::value
         >
struct __same_or_less_cv_qualified_imp
    : is_convertible<_Ptr1, _Ptr2> {};

template <class _Ptr1, class _Ptr2>
struct __same_or_less_cv_qualified_imp<_Ptr1, _Ptr2, false>
    : false_type {};

template <class _Ptr1, class _Ptr2, bool = is_pointer<_Ptr1>::value ||
                                           is_same<_Ptr1, _Ptr2>::value ||
                                           __has_element_type<_Ptr1>::value>
struct __same_or_less_cv_qualified
    : __same_or_less_cv_qualified_imp<_Ptr1, _Ptr2> {};

template <class _Ptr1, class _Ptr2>
struct __same_or_less_cv_qualified<_Ptr1, _Ptr2, false>
    : false_type {};

// default_delete

template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) default_delete
{



    __attribute__ ((__visibility__("hidden"), __always_inline__)) default_delete() throw() {}

    template <class _Up>
        __attribute__ ((__visibility__("hidden"), __always_inline__)) default_delete(const default_delete<_Up>&,
             typename enable_if<is_convertible<_Up*, _Tp*>::value>::type* = 0) throw() {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) void operator() (_Tp* __ptr) const throw()
        {
            typedef __static_assert_check<sizeof(__static_assert_test<(sizeof(_Tp) > 0)>)> __t2429;
            typedef __static_assert_check<sizeof(__static_assert_test<(!is_void<_Tp>::value)>)> __t2430;
            delete __ptr;
        }
};

template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) default_delete<_Tp[]>
{
public:



    __attribute__ ((__visibility__("hidden"), __always_inline__)) default_delete() throw() {}

    template <class _Up>
        __attribute__ ((__visibility__("hidden"), __always_inline__)) default_delete(const default_delete<_Up[]>&,
             typename enable_if<__same_or_less_cv_qualified<_Up*, _Tp*>::value>::type* = 0) throw() {}
    template <class _Up>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        void operator() (_Up* __ptr,
                         typename enable_if<__same_or_less_cv_qualified<_Up*, _Tp*>::value>::type* = 0) const throw()
        {
            typedef __static_assert_check<sizeof(__static_assert_test<(sizeof(_Tp) > 0)>)> __t2452;
            typedef __static_assert_check<sizeof(__static_assert_test<(!is_void<_Tp>::value)>)> __t2453;
            delete [] __ptr;
        }
};

template <class _Tp, class _Dp = default_delete<_Tp> >
class __attribute__ ((__type_visibility__("default"))) unique_ptr
{
public:
    typedef _Tp element_type;
    typedef _Dp deleter_type;
    typedef typename __pointer_type<_Tp, deleter_type>::type pointer;
private:
    __compressed_pair<pointer, deleter_type> __ptr_;


    unique_ptr(unique_ptr&);
    template <class _Up, class _Ep>
        unique_ptr(unique_ptr<_Up, _Ep>&);
    unique_ptr& operator=(unique_ptr&);
    template <class _Up, class _Ep>
        unique_ptr& operator=(unique_ptr<_Up, _Ep>&);


    struct __nat {int __for_bool_;};

    typedef typename remove_reference<deleter_type>::type& _Dp_reference;
    typedef const typename remove_reference<deleter_type>::type& _Dp_const_reference;
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) unique_ptr() throw()
        : __ptr_(pointer())
        {
            typedef __static_assert_check<sizeof(__static_assert_test<(!is_pointer<deleter_type>::value)>)> __t2486;

        }
    __attribute__ ((__visibility__("hidden"), __always_inline__)) unique_ptr(nullptr_t) throw()
        : __ptr_(pointer())
        {
            typedef __static_assert_check<sizeof(__static_assert_test<(!is_pointer<deleter_type>::value)>)> __t2492;

        }
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit unique_ptr(pointer __p) throw()
        : __ptr_(std::__1::move(__p))
        {
            typedef __static_assert_check<sizeof(__static_assert_test<(!is_pointer<deleter_type>::value)>)> __t2498;

        }
# 2568 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/memory" 3
    __attribute__ ((__visibility__("hidden"), __always_inline__)) operator __rv<unique_ptr>()
    {
        return __rv<unique_ptr>(*this);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__)) unique_ptr(__rv<unique_ptr> __u)
        : __ptr_(__u->release(), std::__1::forward<deleter_type>(__u->get_deleter())) {}

    template <class _Up, class _Ep>
    __attribute__ ((__visibility__("hidden"), __always_inline__)) unique_ptr& operator=(unique_ptr<_Up, _Ep> __u)
    {
        reset(__u.release());
        __ptr_.second() = std::__1::forward<deleter_type>(__u.get_deleter());
        return *this;
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__)) unique_ptr(pointer __p, deleter_type __d)
        : __ptr_(std::__1::move(__p), std::__1::move(__d)) {}

    template <class _Up>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
                typename enable_if<
                                      is_convertible<_Up*, _Tp*>::value &&
                                      is_same<_Dp, default_delete<_Tp> >::value,
                                      unique_ptr&
                                  >::type
        operator=(auto_ptr<_Up> __p)
            {reset(__p.release()); return *this;}


    __attribute__ ((__visibility__("hidden"), __always_inline__)) ~unique_ptr() {reset();}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) unique_ptr& operator=(nullptr_t) throw()
    {
        reset();
        return *this;
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__)) typename add_lvalue_reference<_Tp>::type operator*() const
        {return *__ptr_.first();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) pointer operator->() const throw() {return __ptr_.first();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) pointer get() const throw() {return __ptr_.first();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) _Dp_reference get_deleter() throw()
        {return __ptr_.second();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) _Dp_const_reference get_deleter() const throw()
        {return __ptr_.second();}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
                         operator bool() const throw()
        {return __ptr_.first() != std::__1::__get_nullptr_t();}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) pointer release() throw()
    {
        pointer __t = __ptr_.first();
        __ptr_.first() = pointer();
        return __t;
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__)) void reset(pointer __p = pointer()) throw()
    {
        pointer __tmp = __ptr_.first();
        __ptr_.first() = __p;
        if (__tmp)
            __ptr_.second()(__tmp);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__)) void swap(unique_ptr& __u) throw()
        {__ptr_.swap(__u.__ptr_);}
};

template <class _Tp, class _Dp>
class __attribute__ ((__type_visibility__("default"))) unique_ptr<_Tp[], _Dp>
{
public:
    typedef _Tp element_type;
    typedef _Dp deleter_type;
    typedef typename __pointer_type<_Tp, deleter_type>::type pointer;
private:
    __compressed_pair<pointer, deleter_type> __ptr_;


    unique_ptr(unique_ptr&);
    template <class _Up>
        unique_ptr(unique_ptr<_Up>&);
    unique_ptr& operator=(unique_ptr&);
    template <class _Up>
        unique_ptr& operator=(unique_ptr<_Up>&);


    struct __nat {int __for_bool_;};

    typedef typename remove_reference<deleter_type>::type& _Dp_reference;
    typedef const typename remove_reference<deleter_type>::type& _Dp_const_reference;
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) unique_ptr() throw()
        : __ptr_(pointer())
        {
            typedef __static_assert_check<sizeof(__static_assert_test<(!is_pointer<deleter_type>::value)>)> __t2665;

        }
    __attribute__ ((__visibility__("hidden"), __always_inline__)) unique_ptr(nullptr_t) throw()
        : __ptr_(pointer())
        {
            typedef __static_assert_check<sizeof(__static_assert_test<(!is_pointer<deleter_type>::value)>)> __t2671;

        }
# 2761 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/memory" 3
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit unique_ptr(pointer __p)
        : __ptr_(__p)
        {
            typedef __static_assert_check<sizeof(__static_assert_test<(!is_pointer<deleter_type>::value)>)> __t2765;

        }

    __attribute__ ((__visibility__("hidden"), __always_inline__)) unique_ptr(pointer __p, deleter_type __d)
        : __ptr_(__p, std::__1::forward<deleter_type>(__d)) {}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) unique_ptr(nullptr_t, deleter_type __d)
        : __ptr_(pointer(), std::__1::forward<deleter_type>(__d)) {}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) operator __rv<unique_ptr>()
    {
        return __rv<unique_ptr>(*this);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__)) unique_ptr(__rv<unique_ptr> __u)
        : __ptr_(__u->release(), std::__1::forward<deleter_type>(__u->get_deleter())) {}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) unique_ptr& operator=(__rv<unique_ptr> __u)
    {
        reset(__u->release());
        __ptr_.second() = std::__1::forward<deleter_type>(__u->get_deleter());
        return *this;
    }


    __attribute__ ((__visibility__("hidden"), __always_inline__)) ~unique_ptr() {reset();}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) unique_ptr& operator=(nullptr_t) throw()
    {
        reset();
        return *this;
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__)) typename add_lvalue_reference<_Tp>::type operator[](size_t __i) const
        {return __ptr_.first()[__i];}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) pointer get() const throw() {return __ptr_.first();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) _Dp_reference get_deleter() throw()
        {return __ptr_.second();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) _Dp_const_reference get_deleter() const throw()
        {return __ptr_.second();}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
                         operator bool() const throw()
        {return __ptr_.first() != std::__1::__get_nullptr_t();}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) pointer release() throw()
    {
        pointer __t = __ptr_.first();
        __ptr_.first() = pointer();
        return __t;
    }
# 2842 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/memory" 3
    __attribute__ ((__visibility__("hidden"), __always_inline__)) void reset(pointer __p = pointer())
    {
        pointer __tmp = __ptr_.first();
        __ptr_.first() = __p;
        if (__tmp)
            __ptr_.second()(__tmp);
    }


    __attribute__ ((__visibility__("hidden"), __always_inline__)) void swap(unique_ptr& __u) {__ptr_.swap(__u.__ptr_);}
private:


    template <class _Up>
        explicit unique_ptr(_Up);
    template <class _Up>
        unique_ptr(_Up __u,
                   typename conditional<
                                       is_reference<deleter_type>::value,
                                       deleter_type,
                                       typename add_lvalue_reference<const deleter_type>::type>::type,
                   typename enable_if
                      <
                         is_convertible<_Up, pointer>::value,
                         __nat
                      >::type = __nat());

};

template <class _Tp, class _Dp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
swap(unique_ptr<_Tp, _Dp>& __x, unique_ptr<_Tp, _Dp>& __y) throw() {__x.swap(__y);}

template <class _T1, class _D1, class _T2, class _D2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator==(const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {return __x.get() == __y.get();}

template <class _T1, class _D1, class _T2, class _D2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator!=(const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {return !(__x == __y);}

template <class _T1, class _D1, class _T2, class _D2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator< (const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y)
{
    typedef typename unique_ptr<_T1, _D1>::pointer _P1;
    typedef typename unique_ptr<_T2, _D2>::pointer _P2;
    typedef typename common_type<_P1, _P2>::type _V;
    return less<_V>()(__x.get(), __y.get());
}

template <class _T1, class _D1, class _T2, class _D2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator> (const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {return __y < __x;}

template <class _T1, class _D1, class _T2, class _D2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator<=(const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {return !(__y < __x);}

template <class _T1, class _D1, class _T2, class _D2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator>=(const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {return !(__x < __y);}

template <class _T1, class _D1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator==(const unique_ptr<_T1, _D1>& __x, nullptr_t) throw()
{
    return !__x;
}

template <class _T1, class _D1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator==(nullptr_t, const unique_ptr<_T1, _D1>& __x) throw()
{
    return !__x;
}

template <class _T1, class _D1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator!=(const unique_ptr<_T1, _D1>& __x, nullptr_t) throw()
{
    return static_cast<bool>(__x);
}

template <class _T1, class _D1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator!=(nullptr_t, const unique_ptr<_T1, _D1>& __x) throw()
{
    return static_cast<bool>(__x);
}

template <class _T1, class _D1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator<(const unique_ptr<_T1, _D1>& __x, nullptr_t)
{
    typedef typename unique_ptr<_T1, _D1>::pointer _P1;
    return less<_P1>()(__x.get(), std::__1::__get_nullptr_t());
}

template <class _T1, class _D1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator<(nullptr_t, const unique_ptr<_T1, _D1>& __x)
{
    typedef typename unique_ptr<_T1, _D1>::pointer _P1;
    return less<_P1>()(std::__1::__get_nullptr_t(), __x.get());
}

template <class _T1, class _D1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator>(const unique_ptr<_T1, _D1>& __x, nullptr_t)
{
    return std::__1::__get_nullptr_t() < __x;
}

template <class _T1, class _D1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator>(nullptr_t, const unique_ptr<_T1, _D1>& __x)
{
    return __x < std::__1::__get_nullptr_t();
}

template <class _T1, class _D1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator<=(const unique_ptr<_T1, _D1>& __x, nullptr_t)
{
    return !(std::__1::__get_nullptr_t() < __x);
}

template <class _T1, class _D1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator<=(nullptr_t, const unique_ptr<_T1, _D1>& __x)
{
    return !(__x < std::__1::__get_nullptr_t());
}

template <class _T1, class _D1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator>=(const unique_ptr<_T1, _D1>& __x, nullptr_t)
{
    return !(__x < std::__1::__get_nullptr_t());
}

template <class _T1, class _D1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator>=(nullptr_t, const unique_ptr<_T1, _D1>& __x)
{
    return !(std::__1::__get_nullptr_t() < __x);
}



template <class _Tp, class _Dp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
unique_ptr<_Tp, _Dp>
move(unique_ptr<_Tp, _Dp>& __t)
{
    return unique_ptr<_Tp, _Dp>(__rv<unique_ptr<_Tp, _Dp> >(__t));
}
# 3065 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/memory" 3
template <class _Tp> struct hash;

template <class _Size>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_Size
__loadword(const void* __p)
{
    _Size __r;
    std::memcpy(&__r, __p, sizeof(__r));
    return __r;
}

// We use murmur2 when size_t is 32 bits, and cityhash64 when size_t
// is 64 bits.  This is because cityhash64 uses 64bit x 64bit
// multiplication, which can be very slow on 32-bit systems.
template <class _Size, size_t = sizeof(_Size)*8>
struct __murmur2_or_cityhash;

template <class _Size>
struct __murmur2_or_cityhash<_Size, 32>
{
    _Size operator()(const void* __key, _Size __len);
};

// murmur2
template <class _Size>
_Size
__murmur2_or_cityhash<_Size, 32>::operator()(const void* __key, _Size __len)
{
    const _Size __m = 0x5bd1e995;
    const _Size __r = 24;
    _Size __h = __len;
    const unsigned char* __data = static_cast<const unsigned char*>(__key);
    for (; __len >= 4; __data += 4, __len -= 4)
    {
        _Size __k = __loadword<_Size>(__data);
        __k *= __m;
        __k ^= __k >> __r;
        __k *= __m;
        __h *= __m;
        __h ^= __k;
    }
    switch (__len)
    {
    case 3:
        __h ^= __data[2] << 16;
    case 2:
        __h ^= __data[1] << 8;
    case 1:
        __h ^= __data[0];
        __h *= __m;
    }
    __h ^= __h >> 13;
    __h *= __m;
    __h ^= __h >> 15;
    return __h;
}

template <class _Size>
struct __murmur2_or_cityhash<_Size, 64>
{
    _Size operator()(const void* __key, _Size __len);

 private:
  // Some primes between 2^63 and 2^64.
  static const _Size __k0 = 0xc3a5c85c97cb3127ULL;
  static const _Size __k1 = 0xb492b66fbe98f273ULL;
  static const _Size __k2 = 0x9ae16a3b2f90404fULL;
  static const _Size __k3 = 0xc949d7c7509e6557ULL;

  static _Size __rotate(_Size __val, int __shift) {
    return __shift == 0 ? __val : ((__val >> __shift) | (__val << (64 - __shift)));
  }

  static _Size __rotate_by_at_least_1(_Size __val, int __shift) {
    return (__val >> __shift) | (__val << (64 - __shift));
  }

  static _Size __shift_mix(_Size __val) {
    return __val ^ (__val >> 47);
  }

  static _Size __hash_len_16(_Size __u, _Size __v) {
    const _Size __mul = 0x9ddfea08eb382d69ULL;
    _Size __a = (__u ^ __v) * __mul;
    __a ^= (__a >> 47);
    _Size __b = (__v ^ __a) * __mul;
    __b ^= (__b >> 47);
    __b *= __mul;
    return __b;
  }

  static _Size __hash_len_0_to_16(const char* __s, _Size __len) {
    if (__len > 8) {
      const _Size __a = __loadword<_Size>(__s);
      const _Size __b = __loadword<_Size>(__s + __len - 8);
      return __hash_len_16(__a, __rotate_by_at_least_1(__b + __len, __len)) ^ __b;
    }
    if (__len >= 4) {
      const uint32_t __a = __loadword<uint32_t>(__s);
      const uint32_t __b = __loadword<uint32_t>(__s + __len - 4);
      return __hash_len_16(__len + (__a << 3), __b);
    }
    if (__len > 0) {
      const unsigned char __a = __s[0];
      const unsigned char __b = __s[__len >> 1];
      const unsigned char __c = __s[__len - 1];
      const uint32_t __y = static_cast<uint32_t>(__a) +
                           (static_cast<uint32_t>(__b) << 8);
      const uint32_t __z = __len + (static_cast<uint32_t>(__c) << 2);
      return __shift_mix(__y * __k2 ^ __z * __k3) * __k2;
    }
    return __k2;
  }

  static _Size __hash_len_17_to_32(const char *__s, _Size __len) {
    const _Size __a = __loadword<_Size>(__s) * __k1;
    const _Size __b = __loadword<_Size>(__s + 8);
    const _Size __c = __loadword<_Size>(__s + __len - 8) * __k2;
    const _Size __d = __loadword<_Size>(__s + __len - 16) * __k0;
    return __hash_len_16(__rotate(__a - __b, 43) + __rotate(__c, 30) + __d,
                         __a + __rotate(__b ^ __k3, 20) - __c + __len);
  }

  // Return a 16-byte hash for 48 bytes.  Quick and dirty.
  // Callers do best to use "random-looking" values for a and b.
  static pair<_Size, _Size> __weak_hash_len_32_with_seeds(
      _Size __w, _Size __x, _Size __y, _Size __z, _Size __a, _Size __b) {
    __a += __w;
    __b = __rotate(__b + __a + __z, 21);
    const _Size __c = __a;
    __a += __x;
    __a += __y;
    __b += __rotate(__a, 44);
    return pair<_Size, _Size>(__a + __z, __b + __c);
  }

  // Return a 16-byte hash for s[0] ... s[31], a, and b.  Quick and dirty.
  static pair<_Size, _Size> __weak_hash_len_32_with_seeds(
      const char* __s, _Size __a, _Size __b) {
    return __weak_hash_len_32_with_seeds(__loadword<_Size>(__s),
                                         __loadword<_Size>(__s + 8),
                                         __loadword<_Size>(__s + 16),
                                         __loadword<_Size>(__s + 24),
                                         __a,
                                         __b);
  }

  // Return an 8-byte hash for 33 to 64 bytes.
  static _Size __hash_len_33_to_64(const char *__s, size_t __len) {
    _Size __z = __loadword<_Size>(__s + 24);
    _Size __a = __loadword<_Size>(__s) +
                (__len + __loadword<_Size>(__s + __len - 16)) * __k0;
    _Size __b = __rotate(__a + __z, 52);
    _Size __c = __rotate(__a, 37);
    __a += __loadword<_Size>(__s + 8);
    __c += __rotate(__a, 7);
    __a += __loadword<_Size>(__s + 16);
    _Size __vf = __a + __z;
    _Size __vs = __b + __rotate(__a, 31) + __c;
    __a = __loadword<_Size>(__s + 16) + __loadword<_Size>(__s + __len - 32);
    __z += __loadword<_Size>(__s + __len - 8);
    __b = __rotate(__a + __z, 52);
    __c = __rotate(__a, 37);
    __a += __loadword<_Size>(__s + __len - 24);
    __c += __rotate(__a, 7);
    __a += __loadword<_Size>(__s + __len - 16);
    _Size __wf = __a + __z;
    _Size __ws = __b + __rotate(__a, 31) + __c;
    _Size __r = __shift_mix((__vf + __ws) * __k2 + (__wf + __vs) * __k0);
    return __shift_mix(__r * __k0 + __vs) * __k2;
  }
};

// cityhash64
template <class _Size>
_Size
__murmur2_or_cityhash<_Size, 64>::operator()(const void* __key, _Size __len)
{
  const char* __s = static_cast<const char*>(__key);
  if (__len <= 32) {
    if (__len <= 16) {
      return __hash_len_0_to_16(__s, __len);
    } else {
      return __hash_len_17_to_32(__s, __len);
    }
  } else if (__len <= 64) {
    return __hash_len_33_to_64(__s, __len);
  }

  // For strings over 64 bytes we hash the end first, and then as we
  // loop we keep 56 bytes of state: v, w, x, y, and z.
  _Size __x = __loadword<_Size>(__s + __len - 40);
  _Size __y = __loadword<_Size>(__s + __len - 16) +
              __loadword<_Size>(__s + __len - 56);
  _Size __z = __hash_len_16(__loadword<_Size>(__s + __len - 48) + __len,
                          __loadword<_Size>(__s + __len - 24));
  pair<_Size, _Size> __v = __weak_hash_len_32_with_seeds(__s + __len - 64, __len, __z);
  pair<_Size, _Size> __w = __weak_hash_len_32_with_seeds(__s + __len - 32, __y + __k1, __x);
  __x = __x * __k1 + __loadword<_Size>(__s);

  // Decrease len to the nearest multiple of 64, and operate on 64-byte chunks.
  __len = (__len - 1) & ~static_cast<_Size>(63);
  do {
    __x = __rotate(__x + __y + __v.first + __loadword<_Size>(__s + 8), 37) * __k1;
    __y = __rotate(__y + __v.second + __loadword<_Size>(__s + 48), 42) * __k1;
    __x ^= __w.second;
    __y += __v.first + __loadword<_Size>(__s + 40);
    __z = __rotate(__z + __w.first, 33) * __k1;
    __v = __weak_hash_len_32_with_seeds(__s, __v.second * __k1, __x + __w.first);
    __w = __weak_hash_len_32_with_seeds(__s + 32, __z + __w.second,
                                        __y + __loadword<_Size>(__s + 16));
    std::swap(__z, __x);
    __s += 64;
    __len -= 64;
  } while (__len != 0);
  return __hash_len_16(
      __hash_len_16(__v.first, __w.first) + __shift_mix(__y) * __k1 + __z,
      __hash_len_16(__v.second, __w.second) + __x);
}

template <class _Tp, size_t = sizeof(_Tp) / sizeof(size_t)>
struct __scalar_hash;

template <class _Tp>
struct __scalar_hash<_Tp, 0>
    : public unary_function<_Tp, size_t>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_t operator()(_Tp __v) const throw()
    {
        union
        {
            _Tp __t;
            size_t __a;
        } __u;
        __u.__a = 0;
        __u.__t = __v;
        return __u.__a;
    }
};

template <class _Tp>
struct __scalar_hash<_Tp, 1>
    : public unary_function<_Tp, size_t>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_t operator()(_Tp __v) const throw()
    {
        union
        {
            _Tp __t;
            size_t __a;
        } __u;
        __u.__t = __v;
        return __u.__a;
    }
};

template <class _Tp>
struct __scalar_hash<_Tp, 2>
    : public unary_function<_Tp, size_t>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_t operator()(_Tp __v) const throw()
    {
        union
        {
            _Tp __t;
            struct
            {
                size_t __a;
                size_t __b;
            };
        } __u;
        __u.__t = __v;
        return __murmur2_or_cityhash<size_t>()(&__u, sizeof(__u));
    }
};

template <class _Tp>
struct __scalar_hash<_Tp, 3>
    : public unary_function<_Tp, size_t>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_t operator()(_Tp __v) const throw()
    {
        union
        {
            _Tp __t;
            struct
            {
                size_t __a;
                size_t __b;
                size_t __c;
            };
        } __u;
        __u.__t = __v;
        return __murmur2_or_cityhash<size_t>()(&__u, sizeof(__u));
    }
};

template <class _Tp>
struct __scalar_hash<_Tp, 4>
    : public unary_function<_Tp, size_t>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_t operator()(_Tp __v) const throw()
    {
        union
        {
            _Tp __t;
            struct
            {
                size_t __a;
                size_t __b;
                size_t __c;
                size_t __d;
            };
        } __u;
        __u.__t = __v;
        return __murmur2_or_cityhash<size_t>()(&__u, sizeof(__u));
    }
};

template<class _Tp>
struct __attribute__ ((__type_visibility__("default"))) hash<_Tp*>
    : public unary_function<_Tp*, size_t>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_t operator()(_Tp* __v) const throw()
    {
        union
        {
            _Tp* __t;
            size_t __a;
        } __u;
        __u.__t = __v;
        return __murmur2_or_cityhash<size_t>()(&__u, sizeof(__u));
    }
};

template <class _Tp, class _Dp>
struct __attribute__ ((__type_visibility__("default"))) hash<unique_ptr<_Tp, _Dp> >
{
    typedef unique_ptr<_Tp, _Dp> argument_type;
    typedef size_t result_type;
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    result_type operator()(const argument_type& __ptr) const throw()
    {
        typedef typename argument_type::pointer pointer;
        return hash<pointer>()(__ptr.get());
    }
};

struct __destruct_n
{
private:
    size_t size;

    template <class _Tp>
    __attribute__ ((__visibility__("hidden"), __always_inline__)) void __process(_Tp* __p, false_type) throw()
        {for (size_t __i = 0; __i < size; ++__i, ++__p) __p->~_Tp();}

    template <class _Tp>
    __attribute__ ((__visibility__("hidden"), __always_inline__)) void __process(_Tp*, true_type) throw()
        {}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) void __incr(false_type) throw()
        {++size;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) void __incr(true_type) throw()
        {}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) void __set(size_t __s, false_type) throw()
        {size = __s;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) void __set(size_t, true_type) throw()
        {}
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit __destruct_n(size_t __s) throw()
        : size(__s) {}

    template <class _Tp>
    __attribute__ ((__visibility__("hidden"), __always_inline__)) void __incr(_Tp*) throw()
        {__incr(integral_constant<bool, is_trivially_destructible<_Tp>::value>());}

    template <class _Tp>
    __attribute__ ((__visibility__("hidden"), __always_inline__)) void __set(size_t __s, _Tp*) throw()
        {__set(__s, integral_constant<bool, is_trivially_destructible<_Tp>::value>());}

    template <class _Tp>
    __attribute__ ((__visibility__("hidden"), __always_inline__)) void operator()(_Tp* __p) throw()
        {__process(__p, integral_constant<bool, is_trivially_destructible<_Tp>::value>());}
};

template <class _Alloc>
class __allocator_destructor
{
    typedef allocator_traits<_Alloc> __alloc_traits;
public:
    typedef typename __alloc_traits::pointer pointer;
    typedef typename __alloc_traits::size_type size_type;
private:
    _Alloc& __alloc_;
    size_type __s_;
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) __allocator_destructor(_Alloc& __a, size_type __s)
             throw()
        : __alloc_(__a), __s_(__s) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void operator()(pointer __p) throw()
        {__alloc_traits::deallocate(__alloc_, __p, __s_);}
};

template <class _InputIterator, class _ForwardIterator>
_ForwardIterator
uninitialized_copy(_InputIterator __f, _InputIterator __l, _ForwardIterator __r)
{
    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;

    _ForwardIterator __s = __r;
    try
    {

        for (; __f != __l; ++__f, ++__r)
            ::new(&*__r) value_type(*__f);

    }
    catch (...)
    {
        for (; __s != __r; ++__s)
            __s->~value_type();
        throw;
    }

    return __r;
}

template <class _InputIterator, class _Size, class _ForwardIterator>
_ForwardIterator
uninitialized_copy_n(_InputIterator __f, _Size __n, _ForwardIterator __r)
{
    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;

    _ForwardIterator __s = __r;
    try
    {

        for (; __n > 0; ++__f, ++__r, --__n)
            ::new(&*__r) value_type(*__f);

    }
    catch (...)
    {
        for (; __s != __r; ++__s)
            __s->~value_type();
        throw;
    }

    return __r;
}

template <class _ForwardIterator, class _Tp>
void
uninitialized_fill(_ForwardIterator __f, _ForwardIterator __l, const _Tp& __x)
{
    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;

    _ForwardIterator __s = __f;
    try
    {

        for (; __f != __l; ++__f)
            ::new(&*__f) value_type(__x);

    }
    catch (...)
    {
        for (; __s != __f; ++__s)
            __s->~value_type();
        throw;
    }

}

template <class _ForwardIterator, class _Size, class _Tp>
_ForwardIterator
uninitialized_fill_n(_ForwardIterator __f, _Size __n, const _Tp& __x)
{
    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;

    _ForwardIterator __s = __f;
    try
    {

        for (; __n > 0; ++__f, --__n)
            ::new(&*__f) value_type(__x);

    }
    catch (...)
    {
        for (; __s != __f; ++__s)
            __s->~value_type();
        throw;
    }

    return __f;
}

class __attribute__ ((__visibility__("default"))) bad_weak_ptr
    : public std::exception
{
public:
    virtual ~bad_weak_ptr() throw();
    virtual const char* what() const throw();
};

template<class _Tp> class __attribute__ ((__type_visibility__("default"))) weak_ptr;

class __attribute__ ((__type_visibility__("default"))) __shared_count
{
    __shared_count(const __shared_count&);
    __shared_count& operator=(const __shared_count&);

protected:
    long __shared_owners_;
    virtual ~__shared_count();
private:
    virtual void __on_zero_shared() throw() = 0;

public:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit __shared_count(long __refs = 0) throw()
        : __shared_owners_(__refs) {}

    void __add_shared() throw();
    bool __release_shared() throw();
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    long use_count() const throw() {return __shared_owners_ + 1;}
};

class __attribute__ ((__type_visibility__("default"))) __shared_weak_count
    : private __shared_count
{
    long __shared_weak_owners_;

public:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit __shared_weak_count(long __refs = 0) throw()
        : __shared_count(__refs),
          __shared_weak_owners_(__refs) {}
protected:
    virtual ~__shared_weak_count();

public:
    void __add_shared() throw();
    void __add_weak() throw();
    void __release_shared() throw();
    void __release_weak() throw();
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    long use_count() const throw() {return __shared_count::use_count();}
    __shared_weak_count* lock() throw();

    // Define the function out only if we build static libc++ without RTTI.
    // Otherwise we may break clients who need to compile their projects with
    // -fno-rtti and yet link against a libc++.dylib compiled
    // without -fno-rtti.

    virtual const void* __get_deleter(const type_info&) const throw();

private:
    virtual void __on_zero_shared_weak() throw() = 0;
};

template <class _Tp, class _Dp, class _Alloc>
class __shared_ptr_pointer
    : public __shared_weak_count
{
    __compressed_pair<__compressed_pair<_Tp, _Dp>, _Alloc> __data_;
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    __shared_ptr_pointer(_Tp __p, _Dp __d, _Alloc __a)
        : __data_(__compressed_pair<_Tp, _Dp>(__p, std::__1::move(__d)), std::__1::move(__a)) {}


    virtual const void* __get_deleter(const type_info&) const throw();


private:
    virtual void __on_zero_shared() throw();
    virtual void __on_zero_shared_weak() throw();
};



template <class _Tp, class _Dp, class _Alloc>
const void*
__shared_ptr_pointer<_Tp, _Dp, _Alloc>::__get_deleter(const type_info& __t) const throw()
{
    return __t == typeid(_Dp) ? &__data_.first().second() : 0;
}



template <class _Tp, class _Dp, class _Alloc>
void
__shared_ptr_pointer<_Tp, _Dp, _Alloc>::__on_zero_shared() throw()
{
    __data_.first().second()(__data_.first().first());
    __data_.first().second().~_Dp();
}

template <class _Tp, class _Dp, class _Alloc>
void
__shared_ptr_pointer<_Tp, _Dp, _Alloc>::__on_zero_shared_weak() throw()
{
    typename _Alloc::template rebind<__shared_ptr_pointer>::other __a(__data_.second());
    __data_.second().~_Alloc();
    __a.deallocate(this, 1);
}

template <class _Tp, class _Alloc>
class __shared_ptr_emplace
    : public __shared_weak_count
{
    __compressed_pair<_Alloc, _Tp> __data_;
public:
# 3705 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/memory" 3
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    __shared_ptr_emplace(_Alloc __a)
        : __data_(__a) {}

    template <class _A0>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        __shared_ptr_emplace(_Alloc __a, _A0& __a0)
            : __data_(__a, _Tp(__a0)) {}

    template <class _A0, class _A1>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        __shared_ptr_emplace(_Alloc __a, _A0& __a0, _A1& __a1)
            : __data_(__a, _Tp(__a0, __a1)) {}

    template <class _A0, class _A1, class _A2>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        __shared_ptr_emplace(_Alloc __a, _A0& __a0, _A1& __a1, _A2& __a2)
            : __data_(__a, _Tp(__a0, __a1, __a2)) {}



private:
    virtual void __on_zero_shared() throw();
    virtual void __on_zero_shared_weak() throw();
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    _Tp* get() throw() {return &__data_.second();}
};

template <class _Tp, class _Alloc>
void
__shared_ptr_emplace<_Tp, _Alloc>::__on_zero_shared() throw()
{
    __data_.second().~_Tp();
}

template <class _Tp, class _Alloc>
void
__shared_ptr_emplace<_Tp, _Alloc>::__on_zero_shared_weak() throw()
{
    typename _Alloc::template rebind<__shared_ptr_emplace>::other __a(__data_.first());
    __data_.first().~_Alloc();
    __a.deallocate(this, 1);
}

template<class _Tp> class __attribute__ ((__type_visibility__("default"))) enable_shared_from_this;

template<class _Tp>
class __attribute__ ((__type_visibility__("default"))) shared_ptr
{
public:
    typedef _Tp element_type;
private:
    element_type* __ptr_;
    __shared_weak_count* __cntrl_;

    struct __nat {int __for_bool_;};
public:
                      shared_ptr() throw();
                      shared_ptr(nullptr_t) throw();
    template<class _Yp>
        explicit shared_ptr(_Yp* __p,
                            typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type = __nat());
    template<class _Yp, class _Dp>
        shared_ptr(_Yp* __p, _Dp __d,
                   typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type = __nat());
    template<class _Yp, class _Dp, class _Alloc>
        shared_ptr(_Yp* __p, _Dp __d, _Alloc __a,
                   typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type = __nat());
    template <class _Dp> shared_ptr(nullptr_t __p, _Dp __d);
    template <class _Dp, class _Alloc> shared_ptr(nullptr_t __p, _Dp __d, _Alloc __a);
    template<class _Yp> shared_ptr(const shared_ptr<_Yp>& __r, element_type* __p) throw();
    shared_ptr(const shared_ptr& __r) throw();
    template<class _Yp>
        shared_ptr(const shared_ptr<_Yp>& __r,
                   typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat>::type = __nat())
                       throw();






    template<class _Yp> explicit shared_ptr(const weak_ptr<_Yp>& __r,
                   typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat>::type= __nat());





    template<class _Yp>
        shared_ptr(auto_ptr<_Yp> __r,
                   typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type = __nat());
# 3819 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/memory" 3
    template <class _Yp, class _Dp>
        shared_ptr(unique_ptr<_Yp, _Dp>,
                   typename enable_if
                   <
                       !is_lvalue_reference<_Dp>::value &&
                       !is_array<_Yp>::value &&
                       is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,
                       __nat
                   >::type = __nat());
    template <class _Yp, class _Dp>
        shared_ptr(unique_ptr<_Yp, _Dp>,
                   typename enable_if
                   <
                       is_lvalue_reference<_Dp>::value &&
                       !is_array<_Yp>::value &&
                       is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,
                       __nat
                   >::type = __nat());


    ~shared_ptr();

    shared_ptr& operator=(const shared_ptr& __r) throw();
    template<class _Yp>
        typename enable_if
        <
            is_convertible<_Yp*, element_type*>::value,
            shared_ptr&
        >::type
        operator=(const shared_ptr<_Yp>& __r) throw();
# 3867 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/memory" 3
    template<class _Yp>
        typename enable_if
        <
            !is_array<_Yp>::value &&
            is_convertible<_Yp*, element_type*>::value,
            shared_ptr&
        >::type
        operator=(auto_ptr<_Yp> __r);

    template <class _Yp, class _Dp>
        typename enable_if
        <
            !is_array<_Yp>::value &&
            is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,
            shared_ptr&
        >::type



        operator=(unique_ptr<_Yp, _Dp> __r);


    void swap(shared_ptr& __r) throw();
    void reset() throw();
    template<class _Yp>
        typename enable_if
        <
            is_convertible<_Yp*, element_type*>::value,
            void
        >::type
        reset(_Yp* __p);
    template<class _Yp, class _Dp>
        typename enable_if
        <
            is_convertible<_Yp*, element_type*>::value,
            void
        >::type
        reset(_Yp* __p, _Dp __d);
    template<class _Yp, class _Dp, class _Alloc>
        typename enable_if
        <
            is_convertible<_Yp*, element_type*>::value,
            void
        >::type
        reset(_Yp* __p, _Dp __d, _Alloc __a);

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    element_type* get() const throw() {return __ptr_;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    typename add_lvalue_reference<element_type>::type operator*() const throw()
        {return *__ptr_;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    element_type* operator->() const throw() {return __ptr_;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    long use_count() const throw() {return __cntrl_ ? __cntrl_->use_count() : 0;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool unique() const throw() {return use_count() == 1;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
                     operator bool() const throw() {return get() != 0;}
    template <class _Up>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        bool owner_before(shared_ptr<_Up> const& __p) const
        {return __cntrl_ < __p.__cntrl_;}
    template <class _Up>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        bool owner_before(weak_ptr<_Up> const& __p) const
        {return __cntrl_ < __p.__cntrl_;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool
    __owner_equivalent(const shared_ptr& __p) const
        {return __cntrl_ == __p.__cntrl_;}


    template <class _Dp>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        _Dp* __get_deleter() const throw()
            {return (_Dp*)(__cntrl_ ? __cntrl_->__get_deleter(typeid(_Dp)) : 0);}
# 3960 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/memory" 3
    static shared_ptr<_Tp> make_shared();

    template<class _A0>
        static shared_ptr<_Tp> make_shared(_A0&);

    template<class _A0, class _A1>
        static shared_ptr<_Tp> make_shared(_A0&, _A1&);

    template<class _A0, class _A1, class _A2>
        static shared_ptr<_Tp> make_shared(_A0&, _A1&, _A2&);

    template<class _Alloc>
        static shared_ptr<_Tp>
        allocate_shared(const _Alloc& __a);

    template<class _Alloc, class _A0>
        static shared_ptr<_Tp>
        allocate_shared(const _Alloc& __a, _A0& __a0);

    template<class _Alloc, class _A0, class _A1>
        static shared_ptr<_Tp>
        allocate_shared(const _Alloc& __a, _A0& __a0, _A1& __a1);

    template<class _Alloc, class _A0, class _A1, class _A2>
        static shared_ptr<_Tp>
        allocate_shared(const _Alloc& __a, _A0& __a0, _A1& __a1, _A2& __a2);



private:

    template <class _Yp>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        void
        __enable_weak_this(const enable_shared_from_this<_Yp>* __e) throw()
        {
            if (__e)
                __e->__weak_this_ = *this;
        }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void __enable_weak_this(const void*) throw() {}

    template <class _Up> friend class __attribute__ ((__type_visibility__("default"))) shared_ptr;
    template <class _Up> friend class __attribute__ ((__type_visibility__("default"))) weak_ptr;
};

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))

shared_ptr<_Tp>::shared_ptr() throw()
    : __ptr_(0),
      __cntrl_(0)
{
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))

shared_ptr<_Tp>::shared_ptr(nullptr_t) throw()
    : __ptr_(0),
      __cntrl_(0)
{
}

template<class _Tp>
template<class _Yp>
shared_ptr<_Tp>::shared_ptr(_Yp* __p,
                            typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type)
    : __ptr_(__p)
{
    unique_ptr<_Yp> __hold(__p);
    typedef __shared_ptr_pointer<_Yp*, default_delete<_Yp>, allocator<_Yp> > _CntrlBlk;
    __cntrl_ = new _CntrlBlk(__p, default_delete<_Yp>(), allocator<_Yp>());
    __hold.release();
    __enable_weak_this(__p);
}

template<class _Tp>
template<class _Yp, class _Dp>
shared_ptr<_Tp>::shared_ptr(_Yp* __p, _Dp __d,
                            typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type)
    : __ptr_(__p)
{

    try
    {

        typedef __shared_ptr_pointer<_Yp*, _Dp, allocator<_Yp> > _CntrlBlk;
        __cntrl_ = new _CntrlBlk(__p, __d, allocator<_Yp>());
        __enable_weak_this(__p);

    }
    catch (...)
    {
        __d(__p);
        throw;
    }

}

template<class _Tp>
template<class _Dp>
shared_ptr<_Tp>::shared_ptr(nullptr_t __p, _Dp __d)
    : __ptr_(0)
{

    try
    {

        typedef __shared_ptr_pointer<nullptr_t, _Dp, allocator<_Tp> > _CntrlBlk;
        __cntrl_ = new _CntrlBlk(__p, __d, allocator<_Tp>());

    }
    catch (...)
    {
        __d(__p);
        throw;
    }

}

template<class _Tp>
template<class _Yp, class _Dp, class _Alloc>
shared_ptr<_Tp>::shared_ptr(_Yp* __p, _Dp __d, _Alloc __a,
                            typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type)
    : __ptr_(__p)
{

    try
    {

        typedef __shared_ptr_pointer<_Yp*, _Dp, _Alloc> _CntrlBlk;
        typedef typename _Alloc::template rebind<_CntrlBlk>::other _A2;
        typedef __allocator_destructor<_A2> _D2;
        _A2 __a2(__a);
        unique_ptr<_CntrlBlk, _D2> __hold2(__a2.allocate(1), _D2(__a2, 1));
        ::new(__hold2.get()) _CntrlBlk(__p, __d, __a);
        __cntrl_ = __hold2.release();
        __enable_weak_this(__p);

    }
    catch (...)
    {
        __d(__p);
        throw;
    }

}

template<class _Tp>
template<class _Dp, class _Alloc>
shared_ptr<_Tp>::shared_ptr(nullptr_t __p, _Dp __d, _Alloc __a)
    : __ptr_(0)
{

    try
    {

        typedef __shared_ptr_pointer<nullptr_t, _Dp, _Alloc> _CntrlBlk;
        typedef typename _Alloc::template rebind<_CntrlBlk>::other _A2;
        typedef __allocator_destructor<_A2> _D2;
        _A2 __a2(__a);
        unique_ptr<_CntrlBlk, _D2> __hold2(__a2.allocate(1), _D2(__a2, 1));
        ::new(__hold2.get()) _CntrlBlk(__p, __d, __a);
        __cntrl_ = __hold2.release();

    }
    catch (...)
    {
        __d(__p);
        throw;
    }

}

template<class _Tp>
template<class _Yp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
shared_ptr<_Tp>::shared_ptr(const shared_ptr<_Yp>& __r, element_type *__p) throw()
    : __ptr_(__p),
      __cntrl_(__r.__cntrl_)
{
    if (__cntrl_)
        __cntrl_->__add_shared();
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
shared_ptr<_Tp>::shared_ptr(const shared_ptr& __r) throw()
    : __ptr_(__r.__ptr_),
      __cntrl_(__r.__cntrl_)
{
    if (__cntrl_)
        __cntrl_->__add_shared();
}

template<class _Tp>
template<class _Yp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
shared_ptr<_Tp>::shared_ptr(const shared_ptr<_Yp>& __r,
                            typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat>::type)
         throw()
    : __ptr_(__r.__ptr_),
      __cntrl_(__r.__cntrl_)
{
    if (__cntrl_)
        __cntrl_->__add_shared();
}
# 4197 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/memory" 3
template<class _Tp>
template<class _Yp>



shared_ptr<_Tp>::shared_ptr(auto_ptr<_Yp> __r,

                            typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type)
    : __ptr_(__r.get())
{
    typedef __shared_ptr_pointer<_Yp*, default_delete<_Yp>, allocator<_Yp> > _CntrlBlk;
    __cntrl_ = new _CntrlBlk(__r.get(), default_delete<_Yp>(), allocator<_Yp>());
    __enable_weak_this(__r.get());
    __r.release();
}

template<class _Tp>
template <class _Yp, class _Dp>



shared_ptr<_Tp>::shared_ptr(unique_ptr<_Yp, _Dp> __r,

                            typename enable_if
                            <
                                !is_lvalue_reference<_Dp>::value &&
                                !is_array<_Yp>::value &&
                                is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,
                                __nat
                            >::type)
    : __ptr_(__r.get())
{
    typedef __shared_ptr_pointer<_Yp*, _Dp, allocator<_Yp> > _CntrlBlk;
    __cntrl_ = new _CntrlBlk(__r.get(), __r.get_deleter(), allocator<_Yp>());
    __enable_weak_this(__r.get());
    __r.release();
}

template<class _Tp>
template <class _Yp, class _Dp>



shared_ptr<_Tp>::shared_ptr(unique_ptr<_Yp, _Dp> __r,

                            typename enable_if
                            <
                                is_lvalue_reference<_Dp>::value &&
                                !is_array<_Yp>::value &&
                                is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,
                                __nat
                            >::type)
    : __ptr_(__r.get())
{
    typedef __shared_ptr_pointer<_Yp*,
                                 reference_wrapper<typename remove_reference<_Dp>::type>,
                                 allocator<_Yp> > _CntrlBlk;
    __cntrl_ = new _CntrlBlk(__r.get(), ref(__r.get_deleter()), allocator<_Yp>());
    __enable_weak_this(__r.get());
    __r.release();
}
# 4299 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/memory" 3
template<class _Tp>
shared_ptr<_Tp>
shared_ptr<_Tp>::make_shared()
{
    typedef __shared_ptr_emplace<_Tp, allocator<_Tp> > _CntrlBlk;
    typedef allocator<_CntrlBlk> _Alloc2;
    typedef __allocator_destructor<_Alloc2> _D2;
    _Alloc2 __alloc2;
    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));
    ::new(__hold2.get()) _CntrlBlk(__alloc2);
    shared_ptr<_Tp> __r;
    __r.__ptr_ = __hold2.get()->get();
    __r.__cntrl_ = __hold2.release();
    __r.__enable_weak_this(__r.__ptr_);
    return __r;
}

template<class _Tp>
template<class _A0>
shared_ptr<_Tp>
shared_ptr<_Tp>::make_shared(_A0& __a0)
{
    typedef __shared_ptr_emplace<_Tp, allocator<_Tp> > _CntrlBlk;
    typedef allocator<_CntrlBlk> _Alloc2;
    typedef __allocator_destructor<_Alloc2> _D2;
    _Alloc2 __alloc2;
    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));
    ::new(__hold2.get()) _CntrlBlk(__alloc2, __a0);
    shared_ptr<_Tp> __r;
    __r.__ptr_ = __hold2.get()->get();
    __r.__cntrl_ = __hold2.release();
    __r.__enable_weak_this(__r.__ptr_);
    return __r;
}

template<class _Tp>
template<class _A0, class _A1>
shared_ptr<_Tp>
shared_ptr<_Tp>::make_shared(_A0& __a0, _A1& __a1)
{
    typedef __shared_ptr_emplace<_Tp, allocator<_Tp> > _CntrlBlk;
    typedef allocator<_CntrlBlk> _Alloc2;
    typedef __allocator_destructor<_Alloc2> _D2;
    _Alloc2 __alloc2;
    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));
    ::new(__hold2.get()) _CntrlBlk(__alloc2, __a0, __a1);
    shared_ptr<_Tp> __r;
    __r.__ptr_ = __hold2.get()->get();
    __r.__cntrl_ = __hold2.release();
    __r.__enable_weak_this(__r.__ptr_);
    return __r;
}

template<class _Tp>
template<class _A0, class _A1, class _A2>
shared_ptr<_Tp>
shared_ptr<_Tp>::make_shared(_A0& __a0, _A1& __a1, _A2& __a2)
{
    typedef __shared_ptr_emplace<_Tp, allocator<_Tp> > _CntrlBlk;
    typedef allocator<_CntrlBlk> _Alloc2;
    typedef __allocator_destructor<_Alloc2> _D2;
    _Alloc2 __alloc2;
    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));
    ::new(__hold2.get()) _CntrlBlk(__alloc2, __a0, __a1, __a2);
    shared_ptr<_Tp> __r;
    __r.__ptr_ = __hold2.get()->get();
    __r.__cntrl_ = __hold2.release();
    __r.__enable_weak_this(__r.__ptr_);
    return __r;
}

template<class _Tp>
template<class _Alloc>
shared_ptr<_Tp>
shared_ptr<_Tp>::allocate_shared(const _Alloc& __a)
{
    typedef __shared_ptr_emplace<_Tp, _Alloc> _CntrlBlk;
    typedef typename _Alloc::template rebind<_CntrlBlk>::other _Alloc2;
    typedef __allocator_destructor<_Alloc2> _D2;
    _Alloc2 __alloc2(__a);
    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));
    ::new(__hold2.get()) _CntrlBlk(__a);
    shared_ptr<_Tp> __r;
    __r.__ptr_ = __hold2.get()->get();
    __r.__cntrl_ = __hold2.release();
    __r.__enable_weak_this(__r.__ptr_);
    return __r;
}

template<class _Tp>
template<class _Alloc, class _A0>
shared_ptr<_Tp>
shared_ptr<_Tp>::allocate_shared(const _Alloc& __a, _A0& __a0)
{
    typedef __shared_ptr_emplace<_Tp, _Alloc> _CntrlBlk;
    typedef typename _Alloc::template rebind<_CntrlBlk>::other _Alloc2;
    typedef __allocator_destructor<_Alloc2> _D2;
    _Alloc2 __alloc2(__a);
    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));
    ::new(__hold2.get()) _CntrlBlk(__a, __a0);
    shared_ptr<_Tp> __r;
    __r.__ptr_ = __hold2.get()->get();
    __r.__cntrl_ = __hold2.release();
    __r.__enable_weak_this(__r.__ptr_);
    return __r;
}

template<class _Tp>
template<class _Alloc, class _A0, class _A1>
shared_ptr<_Tp>
shared_ptr<_Tp>::allocate_shared(const _Alloc& __a, _A0& __a0, _A1& __a1)
{
    typedef __shared_ptr_emplace<_Tp, _Alloc> _CntrlBlk;
    typedef typename _Alloc::template rebind<_CntrlBlk>::other _Alloc2;
    typedef __allocator_destructor<_Alloc2> _D2;
    _Alloc2 __alloc2(__a);
    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));
    ::new(__hold2.get()) _CntrlBlk(__a, __a0, __a1);
    shared_ptr<_Tp> __r;
    __r.__ptr_ = __hold2.get()->get();
    __r.__cntrl_ = __hold2.release();
    __r.__enable_weak_this(__r.__ptr_);
    return __r;
}

template<class _Tp>
template<class _Alloc, class _A0, class _A1, class _A2>
shared_ptr<_Tp>
shared_ptr<_Tp>::allocate_shared(const _Alloc& __a, _A0& __a0, _A1& __a1, _A2& __a2)
{
    typedef __shared_ptr_emplace<_Tp, _Alloc> _CntrlBlk;
    typedef typename _Alloc::template rebind<_CntrlBlk>::other _Alloc2;
    typedef __allocator_destructor<_Alloc2> _D2;
    _Alloc2 __alloc2(__a);
    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));
    ::new(__hold2.get()) _CntrlBlk(__a, __a0, __a1, __a2);
    shared_ptr<_Tp> __r;
    __r.__ptr_ = __hold2.get()->get();
    __r.__cntrl_ = __hold2.release();
    __r.__enable_weak_this(__r.__ptr_);
    return __r;
}



template<class _Tp>
shared_ptr<_Tp>::~shared_ptr()
{
    if (__cntrl_)
        __cntrl_->__release_shared();
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
shared_ptr<_Tp>&
shared_ptr<_Tp>::operator=(const shared_ptr& __r) throw()
{
    shared_ptr(__r).swap(*this);
    return *this;
}

template<class _Tp>
template<class _Yp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_convertible<_Yp*, _Tp*>::value,
    shared_ptr<_Tp>&
>::type
shared_ptr<_Tp>::operator=(const shared_ptr<_Yp>& __r) throw()
{
    shared_ptr(__r).swap(*this);
    return *this;
}
# 4531 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/memory" 3
template<class _Tp>
template<class _Yp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    !is_array<_Yp>::value &&
    is_convertible<_Yp*, _Tp*>::value,
    shared_ptr<_Tp>&
>::type
shared_ptr<_Tp>::operator=(auto_ptr<_Yp> __r)
{
    shared_ptr(__r).swap(*this);
    return *this;
}

template<class _Tp>
template <class _Yp, class _Dp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    !is_array<_Yp>::value &&
    is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, _Tp*>::value,
    shared_ptr<_Tp>&
>::type
shared_ptr<_Tp>::operator=(unique_ptr<_Yp, _Dp> __r)
{
    shared_ptr(std::__1::move(__r)).swap(*this);
    return *this;
}



template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
shared_ptr<_Tp>::swap(shared_ptr& __r) throw()
{
    std::__1::swap(__ptr_, __r.__ptr_);
    std::__1::swap(__cntrl_, __r.__cntrl_);
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
shared_ptr<_Tp>::reset() throw()
{
    shared_ptr().swap(*this);
}

template<class _Tp>
template<class _Yp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_convertible<_Yp*, _Tp*>::value,
    void
>::type
shared_ptr<_Tp>::reset(_Yp* __p)
{
    shared_ptr(__p).swap(*this);
}

template<class _Tp>
template<class _Yp, class _Dp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_convertible<_Yp*, _Tp*>::value,
    void
>::type
shared_ptr<_Tp>::reset(_Yp* __p, _Dp __d)
{
    shared_ptr(__p, __d).swap(*this);
}

template<class _Tp>
template<class _Yp, class _Dp, class _Alloc>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_convertible<_Yp*, _Tp*>::value,
    void
>::type
shared_ptr<_Tp>::reset(_Yp* __p, _Dp __d, _Alloc __a)
{
    shared_ptr(__p, __d, __a).swap(*this);
}
# 4647 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/memory" 3
template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
shared_ptr<_Tp>
make_shared()
{
    return shared_ptr<_Tp>::make_shared();
}

template<class _Tp, class _A0>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
shared_ptr<_Tp>
make_shared(_A0& __a0)
{
    return shared_ptr<_Tp>::make_shared(__a0);
}

template<class _Tp, class _A0, class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
shared_ptr<_Tp>
make_shared(_A0& __a0, _A1& __a1)
{
    return shared_ptr<_Tp>::make_shared(__a0, __a1);
}

template<class _Tp, class _A0, class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
shared_ptr<_Tp>
make_shared(_A0& __a0, _A1& __a1, _A2& __a2)
{
    return shared_ptr<_Tp>::make_shared(__a0, __a1, __a2);
}

template<class _Tp, class _Alloc>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
shared_ptr<_Tp>
allocate_shared(const _Alloc& __a)
{
    return shared_ptr<_Tp>::allocate_shared(__a);
}

template<class _Tp, class _Alloc, class _A0>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
shared_ptr<_Tp>
allocate_shared(const _Alloc& __a, _A0& __a0)
{
    return shared_ptr<_Tp>::allocate_shared(__a, __a0);
}

template<class _Tp, class _Alloc, class _A0, class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
shared_ptr<_Tp>
allocate_shared(const _Alloc& __a, _A0& __a0, _A1& __a1)
{
    return shared_ptr<_Tp>::allocate_shared(__a, __a0, __a1);
}

template<class _Tp, class _Alloc, class _A0, class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
shared_ptr<_Tp>
allocate_shared(const _Alloc& __a, _A0& __a0, _A1& __a1, _A2& __a2)
{
    return shared_ptr<_Tp>::allocate_shared(__a, __a0, __a1, __a2);
}



template<class _Tp, class _Up>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator==(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) throw()
{
    return __x.get() == __y.get();
}

template<class _Tp, class _Up>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator!=(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) throw()
{
    return !(__x == __y);
}

template<class _Tp, class _Up>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator<(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) throw()
{
    typedef typename common_type<_Tp*, _Up*>::type _V;
    return less<_V>()(__x.get(), __y.get());
}

template<class _Tp, class _Up>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator>(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) throw()
{
    return __y < __x;
}

template<class _Tp, class _Up>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator<=(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) throw()
{
    return !(__y < __x);
}

template<class _Tp, class _Up>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator>=(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) throw()
{
    return !(__x < __y);
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator==(const shared_ptr<_Tp>& __x, nullptr_t) throw()
{
    return !__x;
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator==(nullptr_t, const shared_ptr<_Tp>& __x) throw()
{
    return !__x;
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator!=(const shared_ptr<_Tp>& __x, nullptr_t) throw()
{
    return static_cast<bool>(__x);
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator!=(nullptr_t, const shared_ptr<_Tp>& __x) throw()
{
    return static_cast<bool>(__x);
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator<(const shared_ptr<_Tp>& __x, nullptr_t) throw()
{
    return less<_Tp*>()(__x.get(), std::__1::__get_nullptr_t());
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator<(nullptr_t, const shared_ptr<_Tp>& __x) throw()
{
    return less<_Tp*>()(std::__1::__get_nullptr_t(), __x.get());
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator>(const shared_ptr<_Tp>& __x, nullptr_t) throw()
{
    return std::__1::__get_nullptr_t() < __x;
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator>(nullptr_t, const shared_ptr<_Tp>& __x) throw()
{
    return __x < std::__1::__get_nullptr_t();
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator<=(const shared_ptr<_Tp>& __x, nullptr_t) throw()
{
    return !(std::__1::__get_nullptr_t() < __x);
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator<=(nullptr_t, const shared_ptr<_Tp>& __x) throw()
{
    return !(__x < std::__1::__get_nullptr_t());
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator>=(const shared_ptr<_Tp>& __x, nullptr_t) throw()
{
    return !(__x < std::__1::__get_nullptr_t());
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator>=(nullptr_t, const shared_ptr<_Tp>& __x) throw()
{
    return !(std::__1::__get_nullptr_t() < __x);
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
swap(shared_ptr<_Tp>& __x, shared_ptr<_Tp>& __y) throw()
{
    __x.swap(__y);
}

template<class _Tp, class _Up>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    !is_array<_Tp>::value && !is_array<_Up>::value,
    shared_ptr<_Tp>
>::type
static_pointer_cast(const shared_ptr<_Up>& __r) throw()
{
    return shared_ptr<_Tp>(__r, static_cast<_Tp*>(__r.get()));
}

template<class _Tp, class _Up>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    !is_array<_Tp>::value && !is_array<_Up>::value,
    shared_ptr<_Tp>
>::type
dynamic_pointer_cast(const shared_ptr<_Up>& __r) throw()
{
    _Tp* __p = dynamic_cast<_Tp*>(__r.get());
    return __p ? shared_ptr<_Tp>(__r, __p) : shared_ptr<_Tp>();
}

template<class _Tp, class _Up>
typename enable_if
<
    is_array<_Tp>::value == is_array<_Up>::value,
    shared_ptr<_Tp>
>::type
const_pointer_cast(const shared_ptr<_Up>& __r) throw()
{
    typedef typename remove_extent<_Tp>::type _RTp;
    return shared_ptr<_Tp>(__r, const_cast<_RTp*>(__r.get()));
}



template<class _Dp, class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_Dp*
get_deleter(const shared_ptr<_Tp>& __p) throw()
{
    return __p.template __get_deleter<_Dp>();
}



template<class _Tp>
class __attribute__ ((__type_visibility__("default"))) weak_ptr
{
public:
    typedef _Tp element_type;
private:
    element_type* __ptr_;
    __shared_weak_count* __cntrl_;

public:
                      weak_ptr() throw();
    template<class _Yp> weak_ptr(shared_ptr<_Yp> const& __r,
                   typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type = 0)
                        throw();
    weak_ptr(weak_ptr const& __r) throw();
    template<class _Yp> weak_ptr(weak_ptr<_Yp> const& __r,
                   typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type = 0)
                         throw();







    ~weak_ptr();

    weak_ptr& operator=(weak_ptr const& __r) throw();
    template<class _Yp>
        typename enable_if
        <
            is_convertible<_Yp*, element_type*>::value,
            weak_ptr&
        >::type
        operator=(weak_ptr<_Yp> const& __r) throw();
# 4964 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/memory" 3
    template<class _Yp>
        typename enable_if
        <
            is_convertible<_Yp*, element_type*>::value,
            weak_ptr&
        >::type
        operator=(shared_ptr<_Yp> const& __r) throw();

    void swap(weak_ptr& __r) throw();
    void reset() throw();

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    long use_count() const throw()
        {return __cntrl_ ? __cntrl_->use_count() : 0;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool expired() const throw()
        {return __cntrl_ == 0 || __cntrl_->use_count() == 0;}
    shared_ptr<_Tp> lock() const throw();
    template<class _Up>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        bool owner_before(const shared_ptr<_Up>& __r) const
        {return __cntrl_ < __r.__cntrl_;}
    template<class _Up>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        bool owner_before(const weak_ptr<_Up>& __r) const
        {return __cntrl_ < __r.__cntrl_;}

    template <class _Up> friend class __attribute__ ((__type_visibility__("default"))) weak_ptr;
    template <class _Up> friend class __attribute__ ((__type_visibility__("default"))) shared_ptr;
};

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))

weak_ptr<_Tp>::weak_ptr() throw()
    : __ptr_(0),
      __cntrl_(0)
{
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
weak_ptr<_Tp>::weak_ptr(weak_ptr const& __r) throw()
    : __ptr_(__r.__ptr_),
      __cntrl_(__r.__cntrl_)
{
    if (__cntrl_)
        __cntrl_->__add_weak();
}

template<class _Tp>
template<class _Yp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
weak_ptr<_Tp>::weak_ptr(shared_ptr<_Yp> const& __r,
                        typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type)
                         throw()
    : __ptr_(__r.__ptr_),
      __cntrl_(__r.__cntrl_)
{
    if (__cntrl_)
        __cntrl_->__add_weak();
}

template<class _Tp>
template<class _Yp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
weak_ptr<_Tp>::weak_ptr(weak_ptr<_Yp> const& __r,
                        typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type)
         throw()
    : __ptr_(__r.__ptr_),
      __cntrl_(__r.__cntrl_)
{
    if (__cntrl_)
        __cntrl_->__add_weak();
}
# 5067 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/memory" 3
template<class _Tp>
weak_ptr<_Tp>::~weak_ptr()
{
    if (__cntrl_)
        __cntrl_->__release_weak();
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
weak_ptr<_Tp>&
weak_ptr<_Tp>::operator=(weak_ptr const& __r) throw()
{
    weak_ptr(__r).swap(*this);
    return *this;
}

template<class _Tp>
template<class _Yp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_convertible<_Yp*, _Tp*>::value,
    weak_ptr<_Tp>&
>::type
weak_ptr<_Tp>::operator=(weak_ptr<_Yp> const& __r) throw()
{
    weak_ptr(__r).swap(*this);
    return *this;
}
# 5124 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/memory" 3
template<class _Tp>
template<class _Yp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_convertible<_Yp*, _Tp*>::value,
    weak_ptr<_Tp>&
>::type
weak_ptr<_Tp>::operator=(shared_ptr<_Yp> const& __r) throw()
{
    weak_ptr(__r).swap(*this);
    return *this;
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
weak_ptr<_Tp>::swap(weak_ptr& __r) throw()
{
    std::__1::swap(__ptr_, __r.__ptr_);
    std::__1::swap(__cntrl_, __r.__cntrl_);
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
swap(weak_ptr<_Tp>& __x, weak_ptr<_Tp>& __y) throw()
{
    __x.swap(__y);
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
weak_ptr<_Tp>::reset() throw()
{
    weak_ptr().swap(*this);
}

template<class _Tp>
template<class _Yp>
shared_ptr<_Tp>::shared_ptr(const weak_ptr<_Yp>& __r,
                            typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat>::type)
    : __ptr_(__r.__ptr_),
      __cntrl_(__r.__cntrl_ ? __r.__cntrl_->lock() : __r.__cntrl_)
{
    if (__cntrl_ == 0)

        throw bad_weak_ptr();



}

template<class _Tp>
shared_ptr<_Tp>
weak_ptr<_Tp>::lock() const throw()
{
    shared_ptr<_Tp> __r;
    __r.__cntrl_ = __cntrl_ ? __cntrl_->lock() : __cntrl_;
    if (__r.__cntrl_)
        __r.__ptr_ = __ptr_;
    return __r;
}

template <class _Tp> struct owner_less;

template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) owner_less<shared_ptr<_Tp> >
    : binary_function<shared_ptr<_Tp>, shared_ptr<_Tp>, bool>
{
    typedef bool result_type;
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator()(shared_ptr<_Tp> const& __x, shared_ptr<_Tp> const& __y) const
        {return __x.owner_before(__y);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator()(shared_ptr<_Tp> const& __x, weak_ptr<_Tp> const& __y) const
        {return __x.owner_before(__y);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator()( weak_ptr<_Tp> const& __x, shared_ptr<_Tp> const& __y) const
        {return __x.owner_before(__y);}
};

template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) owner_less<weak_ptr<_Tp> >
    : binary_function<weak_ptr<_Tp>, weak_ptr<_Tp>, bool>
{
    typedef bool result_type;
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator()( weak_ptr<_Tp> const& __x, weak_ptr<_Tp> const& __y) const
        {return __x.owner_before(__y);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator()(shared_ptr<_Tp> const& __x, weak_ptr<_Tp> const& __y) const
        {return __x.owner_before(__y);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator()( weak_ptr<_Tp> const& __x, shared_ptr<_Tp> const& __y) const
        {return __x.owner_before(__y);}
};

template<class _Tp>
class __attribute__ ((__type_visibility__("default"))) enable_shared_from_this
{
    mutable weak_ptr<_Tp> __weak_this_;
protected:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    enable_shared_from_this() throw() {}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    enable_shared_from_this(enable_shared_from_this const&) throw() {}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    enable_shared_from_this& operator=(enable_shared_from_this const&) throw()
        {return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    ~enable_shared_from_this() {}
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    shared_ptr<_Tp> shared_from_this()
        {return shared_ptr<_Tp>(__weak_this_);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    shared_ptr<_Tp const> shared_from_this() const
        {return shared_ptr<const _Tp>(__weak_this_);}

    template <class _Up> friend class shared_ptr;
};

template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) hash<shared_ptr<_Tp> >
{
    typedef shared_ptr<_Tp> argument_type;
    typedef size_t result_type;
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    result_type operator()(const argument_type& __ptr) const throw()
    {
        return hash<_Tp*>()(__ptr.get());
    }
};

template<class _CharT, class _Traits, class _Yp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os, shared_ptr<_Yp> const& __p);
# 5393 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/memory" 3
//enum class
struct __attribute__ ((__type_visibility__("default"))) pointer_safety
{
    enum __lx
    {
        relaxed,
        preferred,
        strict
    };

    __lx __v_;

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    pointer_safety(__lx __v) : __v_(__v) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    operator int() const {return __v_;}
};

__attribute__ ((__visibility__("default"))) void declare_reachable(void* __p);
__attribute__ ((__visibility__("default"))) void declare_no_pointers(char* __p, size_t __n);
__attribute__ ((__visibility__("default"))) void undeclare_no_pointers(char* __p, size_t __n);
__attribute__ ((__visibility__("default"))) pointer_safety get_pointer_safety() throw();
__attribute__ ((__visibility__("default"))) void* __undeclare_reachable(void* __p);

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_Tp*
undeclare_reachable(_Tp* __p)
{
    return static_cast<_Tp*>(__undeclare_reachable(__p));
}

__attribute__ ((__visibility__("default"))) void* align(size_t __align, size_t __sz, void*& __ptr, size_t& __space);

} }
# 629 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/algorithm" 2 3
# 639 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/algorithm" 3
# 1 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/__undef_min_max" 1 3
// -*- C++ -*-
//===----------------------------------------------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is dual licensed under the MIT and the University of Illinois Open
// Source Licenses. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
# 640 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/algorithm" 2 3
# 643 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/algorithm" 3


namespace std {inline namespace __1 {

// I'd like to replace these with _VSTD::equal_to<void>, but can't because:
//   * That only works with C++14 and later, and
//   * We haven't included <functional> here.
template <class _T1, class _T2 = _T1>
struct __equal_to
{
    __attribute__ ((__visibility__("hidden"), __always_inline__)) bool operator()(const _T1& __x, const _T1& __y) const {return __x == __y;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) bool operator()(const _T1& __x, const _T2& __y) const {return __x == __y;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) bool operator()(const _T2& __x, const _T1& __y) const {return __x == __y;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) bool operator()(const _T2& __x, const _T2& __y) const {return __x == __y;}
};

template <class _T1>
struct __equal_to<_T1, _T1>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator()(const _T1& __x, const _T1& __y) const {return __x == __y;}
};

template <class _T1>
struct __equal_to<const _T1, _T1>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator()(const _T1& __x, const _T1& __y) const {return __x == __y;}
};

template <class _T1>
struct __equal_to<_T1, const _T1>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator()(const _T1& __x, const _T1& __y) const {return __x == __y;}
};

template <class _T1, class _T2 = _T1>
struct __less
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator()(const _T1& __x, const _T1& __y) const {return __x < __y;}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator()(const _T1& __x, const _T2& __y) const {return __x < __y;}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator()(const _T2& __x, const _T1& __y) const {return __x < __y;}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator()(const _T2& __x, const _T2& __y) const {return __x < __y;}
};

template <class _T1>
struct __less<_T1, _T1>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator()(const _T1& __x, const _T1& __y) const {return __x < __y;}
};

template <class _T1>
struct __less<const _T1, _T1>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator()(const _T1& __x, const _T1& __y) const {return __x < __y;}
};

template <class _T1>
struct __less<_T1, const _T1>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator()(const _T1& __x, const _T1& __y) const {return __x < __y;}
};

template <class _Predicate>
class __negate
{
private:
    _Predicate __p_;
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) __negate() {}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit __negate(_Predicate __p) : __p_(__p) {}

    template <class _T1>
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator()(const _T1& __x) {return !__p_(__x);}

    template <class _T1, class _T2>
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator()(const _T1& __x, const _T2& __y) {return !__p_(__x, __y);}
};
# 756 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/algorithm" 3
// Precondition:  __x != 0
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
unsigned
__ctz(unsigned __x)
{
    return static_cast<unsigned>(__builtin_ctz(__x));
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
unsigned long
__ctz(unsigned long __x)
{
    return static_cast<unsigned long>(__builtin_ctzl(__x));
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
unsigned long long
__ctz(unsigned long long __x)
{
    return static_cast<unsigned long long>(__builtin_ctzll(__x));
}

// Precondition:  __x != 0
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
unsigned
__clz(unsigned __x)
{
    return static_cast<unsigned>(__builtin_clz(__x));
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
unsigned long
__clz(unsigned long __x)
{
    return static_cast<unsigned long>(__builtin_clzl (__x));
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
unsigned long long
__clz(unsigned long long __x)
{
    return static_cast<unsigned long long>(__builtin_clzll(__x));
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) int __pop_count(unsigned __x) {return __builtin_popcount (__x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) int __pop_count(unsigned long __x) {return __builtin_popcountl (__x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) int __pop_count(unsigned long long __x) {return __builtin_popcountll(__x);}

// all_of

template <class _InputIterator, class _Predicate>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
all_of(_InputIterator __first, _InputIterator __last, _Predicate __pred)
{
    for (; __first != __last; ++__first)
        if (!__pred(*__first))
            return false;
    return true;
}

// any_of

template <class _InputIterator, class _Predicate>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
any_of(_InputIterator __first, _InputIterator __last, _Predicate __pred)
{
    for (; __first != __last; ++__first)
        if (__pred(*__first))
            return true;
    return false;
}

// none_of

template <class _InputIterator, class _Predicate>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
none_of(_InputIterator __first, _InputIterator __last, _Predicate __pred)
{
    for (; __first != __last; ++__first)
        if (__pred(*__first))
            return false;
    return true;
}

// for_each

template <class _InputIterator, class _Function>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_Function
for_each(_InputIterator __first, _InputIterator __last, _Function __f)
{
    for (; __first != __last; ++__first)
        __f(*__first);
    return std::__1::move(__f); // explicitly moved for (emulated) C++03
}

// find

template <class _InputIterator, class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_InputIterator
find(_InputIterator __first, _InputIterator __last, const _Tp& __value_)
{
    for (; __first != __last; ++__first)
        if (*__first == __value_)
            break;
    return __first;
}

// find_if

template <class _InputIterator, class _Predicate>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_InputIterator
find_if(_InputIterator __first, _InputIterator __last, _Predicate __pred)
{
    for (; __first != __last; ++__first)
        if (__pred(*__first))
            break;
    return __first;
}

// find_if_not

template<class _InputIterator, class _Predicate>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_InputIterator
find_if_not(_InputIterator __first, _InputIterator __last, _Predicate __pred)
{
    for (; __first != __last; ++__first)
        if (!__pred(*__first))
            break;
    return __first;
}

// find_end

template <class _BinaryPredicate, class _ForwardIterator1, class _ForwardIterator2>
_ForwardIterator1
__find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
           _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __pred,
           forward_iterator_tag, forward_iterator_tag)
{
    // modeled after search algorithm
    _ForwardIterator1 __r = __last1; // __last1 is the "default" answer
    if (__first2 == __last2)
        return __r;
    while (true)
    {
        while (true)
        {
            if (__first1 == __last1) // if source exhausted return last correct answer
                return __r; //    (or __last1 if never found)
            if (__pred(*__first1, *__first2))
                break;
            ++__first1;
        }
        // *__first1 matches *__first2, now match elements after here
        _ForwardIterator1 __m1 = __first1;
        _ForwardIterator2 __m2 = __first2;
        while (true)
        {
            if (++__m2 == __last2)
            { // Pattern exhaused, record answer and search for another one
                __r = __first1;
                ++__first1;
                break;
            }
            if (++__m1 == __last1) // Source exhausted, return last answer
                return __r;
            if (!__pred(*__m1, *__m2)) // mismatch, restart with a new __first
            {
                ++__first1;
                break;
            } // else there is a match, check next elements
        }
    }
}

template <class _BinaryPredicate, class _BidirectionalIterator1, class _BidirectionalIterator2>
_BidirectionalIterator1
__find_end(_BidirectionalIterator1 __first1, _BidirectionalIterator1 __last1,
           _BidirectionalIterator2 __first2, _BidirectionalIterator2 __last2, _BinaryPredicate __pred,
           bidirectional_iterator_tag, bidirectional_iterator_tag)
{
    // modeled after search algorithm (in reverse)
    if (__first2 == __last2)
        return __last1; // Everything matches an empty sequence
    _BidirectionalIterator1 __l1 = __last1;
    _BidirectionalIterator2 __l2 = __last2;
    --__l2;
    while (true)
    {
        // Find last element in sequence 1 that matchs *(__last2-1), with a mininum of loop checks
        while (true)
        {
            if (__first1 == __l1) // return __last1 if no element matches *__first2
                return __last1;
            if (__pred(*--__l1, *__l2))
                break;
        }
        // *__l1 matches *__l2, now match elements before here
        _BidirectionalIterator1 __m1 = __l1;
        _BidirectionalIterator2 __m2 = __l2;
        while (true)
        {
            if (__m2 == __first2) // If pattern exhausted, __m1 is the answer (works for 1 element pattern)
                return __m1;
            if (__m1 == __first1) // Otherwise if source exhaused, pattern not found
                return __last1;
            if (!__pred(*--__m1, *--__m2)) // if there is a mismatch, restart with a new __l1
            {
                break;
            } // else there is a match, check next elements
        }
    }
}

template <class _BinaryPredicate, class _RandomAccessIterator1, class _RandomAccessIterator2>
                              _RandomAccessIterator1
__find_end(_RandomAccessIterator1 __first1, _RandomAccessIterator1 __last1,
           _RandomAccessIterator2 __first2, _RandomAccessIterator2 __last2, _BinaryPredicate __pred,
           random_access_iterator_tag, random_access_iterator_tag)
{
    // Take advantage of knowing source and pattern lengths.  Stop short when source is smaller than pattern
    typename iterator_traits<_RandomAccessIterator2>::difference_type __len2 = __last2 - __first2;
    if (__len2 == 0)
        return __last1;
    typename iterator_traits<_RandomAccessIterator1>::difference_type __len1 = __last1 - __first1;
    if (__len1 < __len2)
        return __last1;
    const _RandomAccessIterator1 __s = __first1 + (__len2 - 1); // End of pattern match can't go before here
    _RandomAccessIterator1 __l1 = __last1;
    _RandomAccessIterator2 __l2 = __last2;
    --__l2;
    while (true)
    {
        while (true)
        {
            if (__s == __l1)
                return __last1;
            if (__pred(*--__l1, *__l2))
                break;
        }
        _RandomAccessIterator1 __m1 = __l1;
        _RandomAccessIterator2 __m2 = __l2;
        while (true)
        {
            if (__m2 == __first2)
                return __m1;
                                 // no need to check range on __m1 because __s guarantees we have enough source
            if (!__pred(*--__m1, *--__m2))
            {
                break;
            }
        }
    }
}

template <class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_ForwardIterator1
find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
         _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __pred)
{
    return std::__1::__find_end<typename add_lvalue_reference<_BinaryPredicate>::type>
                         (__first1, __last1, __first2, __last2, __pred,
                          typename iterator_traits<_ForwardIterator1>::iterator_category(),
                          typename iterator_traits<_ForwardIterator2>::iterator_category());
}

template <class _ForwardIterator1, class _ForwardIterator2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_ForwardIterator1
find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
         _ForwardIterator2 __first2, _ForwardIterator2 __last2)
{
    typedef typename iterator_traits<_ForwardIterator1>::value_type __v1;
    typedef typename iterator_traits<_ForwardIterator2>::value_type __v2;
    return std::__1::find_end(__first1, __last1, __first2, __last2, __equal_to<__v1, __v2>());
}

// find_first_of

template <class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>
                              _ForwardIterator1
__find_first_of_ce(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
              _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __pred)
{
    for (; __first1 != __last1; ++__first1)
        for (_ForwardIterator2 __j = __first2; __j != __last2; ++__j)
            if (__pred(*__first1, *__j))
                return __first1;
    return __last1;
}


template <class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_ForwardIterator1
find_first_of(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
              _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __pred)
{
    return std::__1::__find_first_of_ce(__first1, __last1, __first2, __last2, __pred);
}

template <class _ForwardIterator1, class _ForwardIterator2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_ForwardIterator1
find_first_of(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
              _ForwardIterator2 __first2, _ForwardIterator2 __last2)
{
    typedef typename iterator_traits<_ForwardIterator1>::value_type __v1;
    typedef typename iterator_traits<_ForwardIterator2>::value_type __v2;
    return std::__1::__find_first_of_ce(__first1, __last1, __first2, __last2, __equal_to<__v1, __v2>());
}

// adjacent_find

template <class _ForwardIterator, class _BinaryPredicate>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_ForwardIterator
adjacent_find(_ForwardIterator __first, _ForwardIterator __last, _BinaryPredicate __pred)
{
    if (__first != __last)
    {
        _ForwardIterator __i = __first;
        while (++__i != __last)
        {
            if (__pred(*__first, *__i))
                return __first;
            __first = __i;
        }
    }
    return __last;
}

template <class _ForwardIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_ForwardIterator
adjacent_find(_ForwardIterator __first, _ForwardIterator __last)
{
    typedef typename iterator_traits<_ForwardIterator>::value_type __v;
    return std::__1::adjacent_find(__first, __last, __equal_to<__v>());
}

// count

template <class _InputIterator, class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename iterator_traits<_InputIterator>::difference_type
count(_InputIterator __first, _InputIterator __last, const _Tp& __value_)
{
    typename iterator_traits<_InputIterator>::difference_type __r(0);
    for (; __first != __last; ++__first)
        if (*__first == __value_)
            ++__r;
    return __r;
}

// count_if

template <class _InputIterator, class _Predicate>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename iterator_traits<_InputIterator>::difference_type
count_if(_InputIterator __first, _InputIterator __last, _Predicate __pred)
{
    typename iterator_traits<_InputIterator>::difference_type __r(0);
    for (; __first != __last; ++__first)
        if (__pred(*__first))
            ++__r;
    return __r;
}

// mismatch

template <class _InputIterator1, class _InputIterator2, class _BinaryPredicate>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
pair<_InputIterator1, _InputIterator2>
mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
         _InputIterator2 __first2, _BinaryPredicate __pred)
{
    for (; __first1 != __last1; ++__first1, ++__first2)
        if (!__pred(*__first1, *__first2))
            break;
    return pair<_InputIterator1, _InputIterator2>(__first1, __first2);
}

template <class _InputIterator1, class _InputIterator2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
pair<_InputIterator1, _InputIterator2>
mismatch(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2)
{
    typedef typename iterator_traits<_InputIterator1>::value_type __v1;
    typedef typename iterator_traits<_InputIterator2>::value_type __v2;
    return std::__1::mismatch(__first1, __last1, __first2, __equal_to<__v1, __v2>());
}
# 1183 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/algorithm" 3
// equal

template <class _InputIterator1, class _InputIterator2, class _BinaryPredicate>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
equal(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _BinaryPredicate __pred)
{
    for (; __first1 != __last1; ++__first1, ++__first2)
        if (!__pred(*__first1, *__first2))
            return false;
    return true;
}

template <class _InputIterator1, class _InputIterator2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
equal(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2)
{
    typedef typename iterator_traits<_InputIterator1>::value_type __v1;
    typedef typename iterator_traits<_InputIterator2>::value_type __v2;
    return std::__1::equal(__first1, __last1, __first2, __equal_to<__v1, __v2>());
}
# 1260 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/algorithm" 3
// is_permutation

template<class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>
bool
is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
               _ForwardIterator2 __first2, _BinaryPredicate __pred)
{
    // shorten sequences as much as possible by lopping of any equal parts
    for (; __first1 != __last1; ++__first1, ++__first2)
        if (!__pred(*__first1, *__first2))
            goto __not_done;
    return true;
__not_done:
    // __first1 != __last1 && *__first1 != *__first2
    typedef typename iterator_traits<_ForwardIterator1>::difference_type _D1;
    _D1 __l1 = std::__1::distance(__first1, __last1);
    if (__l1 == _D1(1))
        return false;
    _ForwardIterator2 __last2 = std::__1::next(__first2, __l1);
    // For each element in [f1, l1) see if there are the same number of
    //    equal elements in [f2, l2)
    for (_ForwardIterator1 __i = __first1; __i != __last1; ++__i)
    {
        // Have we already counted the number of *__i in [f1, l1)?
        for (_ForwardIterator1 __j = __first1; __j != __i; ++__j)
            if (__pred(*__j, *__i))
                goto __next_iter;
        {
            // Count number of *__i in [f2, l2)
            _D1 __c2 = 0;
            for (_ForwardIterator2 __j = __first2; __j != __last2; ++__j)
                if (__pred(*__i, *__j))
                    ++__c2;
            if (__c2 == 0)
                return false;
            // Count number of *__i in [__i, l1) (we can start with 1)
            _D1 __c1 = 1;
            for (_ForwardIterator1 __j = std::__1::next(__i); __j != __last1; ++__j)
                if (__pred(*__i, *__j))
                    ++__c1;
            if (__c1 != __c2)
                return false;
        }
__next_iter:;
    }
    return true;
}

template<class _ForwardIterator1, class _ForwardIterator2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
               _ForwardIterator2 __first2)
{
    typedef typename iterator_traits<_ForwardIterator1>::value_type __v1;
    typedef typename iterator_traits<_ForwardIterator2>::value_type __v2;
    return std::__1::is_permutation(__first1, __last1, __first2, __equal_to<__v1, __v2>());
}
# 1413 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/algorithm" 3
// search

template <class _BinaryPredicate, class _ForwardIterator1, class _ForwardIterator2>
_ForwardIterator1
__search(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
         _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __pred,
         forward_iterator_tag, forward_iterator_tag)
{
    if (__first2 == __last2)
        return __first1; // Everything matches an empty sequence
    while (true)
    {
        // Find first element in sequence 1 that matchs *__first2, with a mininum of loop checks
        while (true)
        {
            if (__first1 == __last1) // return __last1 if no element matches *__first2
                return __last1;
            if (__pred(*__first1, *__first2))
                break;
            ++__first1;
        }
        // *__first1 matches *__first2, now match elements after here
        _ForwardIterator1 __m1 = __first1;
        _ForwardIterator2 __m2 = __first2;
        while (true)
        {
            if (++__m2 == __last2) // If pattern exhausted, __first1 is the answer (works for 1 element pattern)
                return __first1;
            if (++__m1 == __last1) // Otherwise if source exhaused, pattern not found
                return __last1;
            if (!__pred(*__m1, *__m2)) // if there is a mismatch, restart with a new __first1
            {
                ++__first1;
                break;
            } // else there is a match, check next elements
        }
    }
}

template <class _BinaryPredicate, class _RandomAccessIterator1, class _RandomAccessIterator2>
                              _RandomAccessIterator1
__search(_RandomAccessIterator1 __first1, _RandomAccessIterator1 __last1,
           _RandomAccessIterator2 __first2, _RandomAccessIterator2 __last2, _BinaryPredicate __pred,
           random_access_iterator_tag, random_access_iterator_tag)
{
    typedef typename std::iterator_traits<_RandomAccessIterator1>::difference_type _D1;
    typedef typename std::iterator_traits<_RandomAccessIterator2>::difference_type _D2;
    // Take advantage of knowing source and pattern lengths.  Stop short when source is smaller than pattern
    _D2 __len2 = __last2 - __first2;
    if (__len2 == 0)
        return __first1;
    _D1 __len1 = __last1 - __first1;
    if (__len1 < __len2)
        return __last1;
    const _RandomAccessIterator1 __s = __last1 - (__len2 - 1); // Start of pattern match can't go beyond here
    while (true)
    {

        while (true)
        {
            if (__first1 == __s)
                return __last1;
            if (__pred(*__first1, *__first2))
                break;
            ++__first1;
        }
# 1510 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/algorithm" 3
        _RandomAccessIterator1 __m1 = __first1;
        _RandomAccessIterator2 __m2 = __first2;

         while (true)
         {
             if (++__m2 == __last2)
                 return __first1;
             ++__m1; // no need to check range on __m1 because __s guarantees we have enough source
             if (!__pred(*__m1, *__m2))
             {
                 ++__first1;
                 break;
             }
         }
# 1561 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/algorithm" 3
    }
}

template <class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_ForwardIterator1
search(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
       _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __pred)
{
    return std::__1::__search<typename add_lvalue_reference<_BinaryPredicate>::type>
                         (__first1, __last1, __first2, __last2, __pred,
                          typename std::iterator_traits<_ForwardIterator1>::iterator_category(),
                          typename std::iterator_traits<_ForwardIterator2>::iterator_category());
}

template <class _ForwardIterator1, class _ForwardIterator2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_ForwardIterator1
search(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
       _ForwardIterator2 __first2, _ForwardIterator2 __last2)
{
    typedef typename std::iterator_traits<_ForwardIterator1>::value_type __v1;
    typedef typename std::iterator_traits<_ForwardIterator2>::value_type __v2;
    return std::__1::search(__first1, __last1, __first2, __last2, __equal_to<__v1, __v2>());
}

// search_n

template <class _BinaryPredicate, class _ForwardIterator, class _Size, class _Tp>
_ForwardIterator
__search_n(_ForwardIterator __first, _ForwardIterator __last,
           _Size __count, const _Tp& __value_, _BinaryPredicate __pred, forward_iterator_tag)
{
    if (__count <= 0)
        return __first;
    while (true)
    {
        // Find first element in sequence that matchs __value_, with a mininum of loop checks
        while (true)
        {
            if (__first == __last) // return __last if no element matches __value_
                return __last;
            if (__pred(*__first, __value_))
                break;
            ++__first;
        }
        // *__first matches __value_, now match elements after here
        _ForwardIterator __m = __first;
        _Size __c(0);
        while (true)
        {
            if (++__c == __count) // If pattern exhausted, __first is the answer (works for 1 element pattern)
                return __first;
            if (++__m == __last) // Otherwise if source exhaused, pattern not found
                return __last;
            if (!__pred(*__m, __value_)) // if there is a mismatch, restart with a new __first
            {
                __first = __m;
                ++__first;
                break;
            } // else there is a match, check next elements
        }
    }
}

template <class _BinaryPredicate, class _RandomAccessIterator, class _Size, class _Tp>
_RandomAccessIterator
__search_n(_RandomAccessIterator __first, _RandomAccessIterator __last,
           _Size __count, const _Tp& __value_, _BinaryPredicate __pred, random_access_iterator_tag)
{
    if (__count <= 0)
        return __first;
    _Size __len = static_cast<_Size>(__last - __first);
    if (__len < __count)
        return __last;
    const _RandomAccessIterator __s = __last - (__count - 1); // Start of pattern match can't go beyond here
    while (true)
    {
        // Find first element in sequence that matchs __value_, with a mininum of loop checks
        while (true)
        {
            if (__first >= __s) // return __last if no element matches __value_
                return __last;
            if (__pred(*__first, __value_))
                break;
            ++__first;
        }
        // *__first matches __value_, now match elements after here
        _RandomAccessIterator __m = __first;
        _Size __c(0);
        while (true)
        {
            if (++__c == __count) // If pattern exhausted, __first is the answer (works for 1 element pattern)
                return __first;
             ++__m; // no need to check range on __m because __s guarantees we have enough source
            if (!__pred(*__m, __value_)) // if there is a mismatch, restart with a new __first
            {
                __first = __m;
                ++__first;
                break;
            } // else there is a match, check next elements
        }
    }
}

template <class _ForwardIterator, class _Size, class _Tp, class _BinaryPredicate>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_ForwardIterator
search_n(_ForwardIterator __first, _ForwardIterator __last,
         _Size __count, const _Tp& __value_, _BinaryPredicate __pred)
{
    return std::__1::__search_n<typename add_lvalue_reference<_BinaryPredicate>::type>
           (__first, __last, __count, __value_, __pred, typename iterator_traits<_ForwardIterator>::iterator_category());
}

template <class _ForwardIterator, class _Size, class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_ForwardIterator
search_n(_ForwardIterator __first, _ForwardIterator __last, _Size __count, const _Tp& __value_)
{
    typedef typename iterator_traits<_ForwardIterator>::value_type __v;
    return std::__1::search_n(__first, __last, __count, __value_, __equal_to<__v, _Tp>());
}

// copy

template <class _Iter>
struct __libcpp_is_trivial_iterator
{
    static const bool value = is_pointer<_Iter>::value;
};

template <class _Iter>
struct __libcpp_is_trivial_iterator<move_iterator<_Iter> >
{
    static const bool value = is_pointer<_Iter>::value;
};

template <class _Iter>
struct __libcpp_is_trivial_iterator<__wrap_iter<_Iter> >
{
    static const bool value = is_pointer<_Iter>::value;
};

template <class _Iter>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_Iter
__unwrap_iter(_Iter __i)
{
    return __i;
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_trivially_copy_assignable<_Tp>::value,
    _Tp*
>::type
__unwrap_iter(move_iterator<_Tp*> __i)
{
    return __i.base();
}



template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_trivially_copy_assignable<_Tp>::value,
    _Tp*
>::type
__unwrap_iter(__wrap_iter<_Tp*> __i)
{
    return __i.base();
}



template <class _InputIterator, class _OutputIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_OutputIterator
__copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result)
{
    for (; __first != __last; ++__first, ++__result)
        *__result = *__first;
    return __result;
}

template <class _Tp, class _Up>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_same<typename remove_const<_Tp>::type, _Up>::value &&
    is_trivially_copy_assignable<_Up>::value,
    _Up*
>::type
__copy(_Tp* __first, _Tp* __last, _Up* __result)
{
    const size_t __n = static_cast<size_t>(__last - __first);
    std::__1::memmove(__result, __first, __n * sizeof(_Up));
    return __result + __n;
}

template <class _InputIterator, class _OutputIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_OutputIterator
copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result)
{
    return std::__1::__copy(__unwrap_iter(__first), __unwrap_iter(__last), __unwrap_iter(__result));
}

// copy_backward

template <class _BidirectionalIterator, class _OutputIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_OutputIterator
__copy_backward(_BidirectionalIterator __first, _BidirectionalIterator __last, _OutputIterator __result)
{
    while (__first != __last)
        *--__result = *--__last;
    return __result;
}

template <class _Tp, class _Up>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_same<typename remove_const<_Tp>::type, _Up>::value &&
    is_trivially_copy_assignable<_Up>::value,
    _Up*
>::type
__copy_backward(_Tp* __first, _Tp* __last, _Up* __result)
{
    const size_t __n = static_cast<size_t>(__last - __first);
    __result -= __n;
    std::__1::memmove(__result, __first, __n * sizeof(_Up));
    return __result;
}

template <class _BidirectionalIterator1, class _BidirectionalIterator2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_BidirectionalIterator2
copy_backward(_BidirectionalIterator1 __first, _BidirectionalIterator1 __last,
              _BidirectionalIterator2 __result)
{
    return std::__1::__copy_backward(__unwrap_iter(__first), __unwrap_iter(__last), __unwrap_iter(__result));
}

// copy_if

template<class _InputIterator, class _OutputIterator, class _Predicate>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_OutputIterator
copy_if(_InputIterator __first, _InputIterator __last,
        _OutputIterator __result, _Predicate __pred)
{
    for (; __first != __last; ++__first)
    {
        if (__pred(*__first))
        {
            *__result = *__first;
            ++__result;
        }
    }
    return __result;
}

// copy_n

template<class _InputIterator, class _Size, class _OutputIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    __is_input_iterator<_InputIterator>::value &&
   !__is_random_access_iterator<_InputIterator>::value,
    _OutputIterator
>::type
copy_n(_InputIterator __first, _Size __n, _OutputIterator __result)
{
    if (__n > 0)
    {
        *__result = *__first;
        ++__result;
        for (--__n; __n > 0; --__n)
        {
            ++__first;
            *__result = *__first;
            ++__result;
        }
    }
    return __result;
}

template<class _InputIterator, class _Size, class _OutputIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    __is_random_access_iterator<_InputIterator>::value,
    _OutputIterator
>::type
copy_n(_InputIterator __first, _Size __n, _OutputIterator __result)
{
    return std::__1::copy(__first, __first + __n, __result);
}

// move

template <class _InputIterator, class _OutputIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_OutputIterator
__move(_InputIterator __first, _InputIterator __last, _OutputIterator __result)
{
    for (; __first != __last; ++__first, ++__result)
        *__result = std::__1::move(*__first);
    return __result;
}

template <class _Tp, class _Up>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_same<typename remove_const<_Tp>::type, _Up>::value &&
    is_trivially_copy_assignable<_Up>::value,
    _Up*
>::type
__move(_Tp* __first, _Tp* __last, _Up* __result)
{
    const size_t __n = static_cast<size_t>(__last - __first);
    std::__1::memmove(__result, __first, __n * sizeof(_Up));
    return __result + __n;
}

template <class _InputIterator, class _OutputIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_OutputIterator
move(_InputIterator __first, _InputIterator __last, _OutputIterator __result)
{
    return std::__1::__move(__unwrap_iter(__first), __unwrap_iter(__last), __unwrap_iter(__result));
}

// move_backward

template <class _InputIterator, class _OutputIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_OutputIterator
__move_backward(_InputIterator __first, _InputIterator __last, _OutputIterator __result)
{
    while (__first != __last)
        *--__result = std::__1::move(*--__last);
    return __result;
}

template <class _Tp, class _Up>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_same<typename remove_const<_Tp>::type, _Up>::value &&
    is_trivially_copy_assignable<_Up>::value,
    _Up*
>::type
__move_backward(_Tp* __first, _Tp* __last, _Up* __result)
{
    const size_t __n = static_cast<size_t>(__last - __first);
    __result -= __n;
    std::__1::memmove(__result, __first, __n * sizeof(_Up));
    return __result;
}

template <class _BidirectionalIterator1, class _BidirectionalIterator2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_BidirectionalIterator2
move_backward(_BidirectionalIterator1 __first, _BidirectionalIterator1 __last,
              _BidirectionalIterator2 __result)
{
    return std::__1::__move_backward(__unwrap_iter(__first), __unwrap_iter(__last), __unwrap_iter(__result));
}

// iter_swap

// moved to <type_traits> for better swap / noexcept support

// transform

template <class _InputIterator, class _OutputIterator, class _UnaryOperation>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_OutputIterator
transform(_InputIterator __first, _InputIterator __last, _OutputIterator __result, _UnaryOperation __op)
{
    for (; __first != __last; ++__first, ++__result)
        *__result = __op(*__first);
    return __result;
}

template <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _BinaryOperation>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_OutputIterator
transform(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2,
          _OutputIterator __result, _BinaryOperation __binary_op)
{
    for (; __first1 != __last1; ++__first1, ++__first2, ++__result)
        *__result = __binary_op(*__first1, *__first2);
    return __result;
}

// replace

template <class _ForwardIterator, class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
replace(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __old_value, const _Tp& __new_value)
{
    for (; __first != __last; ++__first)
        if (*__first == __old_value)
            *__first = __new_value;
}

// replace_if

template <class _ForwardIterator, class _Predicate, class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
replace_if(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred, const _Tp& __new_value)
{
    for (; __first != __last; ++__first)
        if (__pred(*__first))
            *__first = __new_value;
}

// replace_copy

template <class _InputIterator, class _OutputIterator, class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_OutputIterator
replace_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result,
             const _Tp& __old_value, const _Tp& __new_value)
{
    for (; __first != __last; ++__first, ++__result)
        if (*__first == __old_value)
            *__result = __new_value;
        else
            *__result = *__first;
    return __result;
}

// replace_copy_if

template <class _InputIterator, class _OutputIterator, class _Predicate, class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_OutputIterator
replace_copy_if(_InputIterator __first, _InputIterator __last, _OutputIterator __result,
                _Predicate __pred, const _Tp& __new_value)
{
    for (; __first != __last; ++__first, ++__result)
        if (__pred(*__first))
            *__result = __new_value;
        else
            *__result = *__first;
    return __result;
}

// fill_n

template <class _OutputIterator, class _Size, class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_OutputIterator
__fill_n(_OutputIterator __first, _Size __n, const _Tp& __value_)
{
    for (; __n > 0; ++__first, --__n)
        *__first = __value_;
    return __first;
}

template <class _Tp, class _Size, class _Up>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_integral<_Tp>::value && sizeof(_Tp) == 1 &&
    !is_same<_Tp, bool>::value &&
    is_integral<_Up>::value && sizeof(_Up) == 1,
    _Tp*
>::type
__fill_n(_Tp* __first, _Size __n,_Up __value_)
{
    if (__n > 0)
        std::__1::memset(__first, (unsigned char)__value_, (size_t)(__n));
    return __first + __n;
}

template <class _OutputIterator, class _Size, class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_OutputIterator
fill_n(_OutputIterator __first, _Size __n, const _Tp& __value_)
{
   return std::__1::__fill_n(__first, __n, __value_);
}

// fill

template <class _ForwardIterator, class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
__fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, forward_iterator_tag)
{
    for (; __first != __last; ++__first)
        *__first = __value_;
}

template <class _RandomAccessIterator, class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
__fill(_RandomAccessIterator __first, _RandomAccessIterator __last, const _Tp& __value_, random_access_iterator_tag)
{
    std::__1::fill_n(__first, __last - __first, __value_);
}

template <class _ForwardIterator, class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_)
{
    std::__1::__fill(__first, __last, __value_, typename iterator_traits<_ForwardIterator>::iterator_category());
}

// generate

template <class _ForwardIterator, class _Generator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
generate(_ForwardIterator __first, _ForwardIterator __last, _Generator __gen)
{
    for (; __first != __last; ++__first)
        *__first = __gen();
}

// generate_n

template <class _OutputIterator, class _Size, class _Generator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_OutputIterator
generate_n(_OutputIterator __first, _Size __n, _Generator __gen)
{
    for (; __n > 0; ++__first, --__n)
        *__first = __gen();
    return __first;
}

// remove

template <class _ForwardIterator, class _Tp>
_ForwardIterator
remove(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_)
{
    __first = std::__1::find(__first, __last, __value_);
    if (__first != __last)
    {
        _ForwardIterator __i = __first;
        while (++__i != __last)
        {
            if (!(*__i == __value_))
            {
                *__first = std::__1::move(*__i);
                ++__first;
            }
        }
    }
    return __first;
}

// remove_if

template <class _ForwardIterator, class _Predicate>
_ForwardIterator
remove_if(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred)
{
    __first = std::__1::find_if<_ForwardIterator, typename add_lvalue_reference<_Predicate>::type>
                           (__first, __last, __pred);
    if (__first != __last)
    {
        _ForwardIterator __i = __first;
        while (++__i != __last)
        {
            if (!__pred(*__i))
            {
                *__first = std::__1::move(*__i);
                ++__first;
            }
        }
    }
    return __first;
}

// remove_copy

template <class _InputIterator, class _OutputIterator, class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_OutputIterator
remove_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result, const _Tp& __value_)
{
    for (; __first != __last; ++__first)
    {
        if (!(*__first == __value_))
        {
            *__result = *__first;
            ++__result;
        }
    }
    return __result;
}

// remove_copy_if

template <class _InputIterator, class _OutputIterator, class _Predicate>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_OutputIterator
remove_copy_if(_InputIterator __first, _InputIterator __last, _OutputIterator __result, _Predicate __pred)
{
    for (; __first != __last; ++__first)
    {
        if (!__pred(*__first))
        {
            *__result = *__first;
            ++__result;
        }
    }
    return __result;
}

// unique

template <class _ForwardIterator, class _BinaryPredicate>
_ForwardIterator
unique(_ForwardIterator __first, _ForwardIterator __last, _BinaryPredicate __pred)
{
    __first = std::__1::adjacent_find<_ForwardIterator, typename add_lvalue_reference<_BinaryPredicate>::type>
                                 (__first, __last, __pred);
    if (__first != __last)
    {
        // ...  a  a  ?  ...
        //      f     i
        _ForwardIterator __i = __first;
        for (++__i; ++__i != __last;)
            if (!__pred(*__first, *__i))
                *++__first = std::__1::move(*__i);
        ++__first;
    }
    return __first;
}

template <class _ForwardIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_ForwardIterator
unique(_ForwardIterator __first, _ForwardIterator __last)
{
    typedef typename iterator_traits<_ForwardIterator>::value_type __v;
    return std::__1::unique(__first, __last, __equal_to<__v>());
}

// unique_copy

template <class _BinaryPredicate, class _InputIterator, class _OutputIterator>
_OutputIterator
__unique_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result, _BinaryPredicate __pred,
              input_iterator_tag, output_iterator_tag)
{
    if (__first != __last)
    {
        typename iterator_traits<_InputIterator>::value_type __t(*__first);
        *__result = __t;
        ++__result;
        while (++__first != __last)
        {
            if (!__pred(__t, *__first))
            {
                __t = *__first;
                *__result = __t;
                ++__result;
            }
        }
    }
    return __result;
}

template <class _BinaryPredicate, class _ForwardIterator, class _OutputIterator>
_OutputIterator
__unique_copy(_ForwardIterator __first, _ForwardIterator __last, _OutputIterator __result, _BinaryPredicate __pred,
              forward_iterator_tag, output_iterator_tag)
{
    if (__first != __last)
    {
        _ForwardIterator __i = __first;
        *__result = *__i;
        ++__result;
        while (++__first != __last)
        {
            if (!__pred(*__i, *__first))
            {
                *__result = *__first;
                ++__result;
                __i = __first;
            }
        }
    }
    return __result;
}

template <class _BinaryPredicate, class _InputIterator, class _ForwardIterator>
_ForwardIterator
__unique_copy(_InputIterator __first, _InputIterator __last, _ForwardIterator __result, _BinaryPredicate __pred,
              input_iterator_tag, forward_iterator_tag)
{
    if (__first != __last)
    {
        *__result = *__first;
        while (++__first != __last)
            if (!__pred(*__result, *__first))
                *++__result = *__first;
        ++__result;
    }
    return __result;
}

template <class _InputIterator, class _OutputIterator, class _BinaryPredicate>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_OutputIterator
unique_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result, _BinaryPredicate __pred)
{
    return std::__1::__unique_copy<typename add_lvalue_reference<_BinaryPredicate>::type>
                              (__first, __last, __result, __pred,
                               typename iterator_traits<_InputIterator>::iterator_category(),
                               typename iterator_traits<_OutputIterator>::iterator_category());
}

template <class _InputIterator, class _OutputIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_OutputIterator
unique_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result)
{
    typedef typename iterator_traits<_InputIterator>::value_type __v;
    return std::__1::unique_copy(__first, __last, __result, __equal_to<__v>());
}

// reverse

template <class _BidirectionalIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
__reverse(_BidirectionalIterator __first, _BidirectionalIterator __last, bidirectional_iterator_tag)
{
    while (__first != __last)
    {
        if (__first == --__last)
            break;
        swap(*__first, *__last);
        ++__first;
    }
}

template <class _RandomAccessIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
__reverse(_RandomAccessIterator __first, _RandomAccessIterator __last, random_access_iterator_tag)
{
    if (__first != __last)
        for (; __first < --__last; ++__first)
            swap(*__first, *__last);
}

template <class _BidirectionalIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
reverse(_BidirectionalIterator __first, _BidirectionalIterator __last)
{
    std::__1::__reverse(__first, __last, typename iterator_traits<_BidirectionalIterator>::iterator_category());
}

// reverse_copy

template <class _BidirectionalIterator, class _OutputIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_OutputIterator
reverse_copy(_BidirectionalIterator __first, _BidirectionalIterator __last, _OutputIterator __result)
{
    for (; __first != __last; ++__result)
        *__result = *--__last;
    return __result;
}

// rotate

template <class _ForwardIterator>
_ForwardIterator
__rotate_left(_ForwardIterator __first, _ForwardIterator __last)
{
    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;
    value_type __tmp = std::__1::move(*__first);
    _ForwardIterator __lm1 = std::__1::move(std::__1::next(__first), __last, __first);
    *__lm1 = std::__1::move(__tmp);
    return __lm1;
}

template <class _BidirectionalIterator>
_BidirectionalIterator
__rotate_right(_BidirectionalIterator __first, _BidirectionalIterator __last)
{
    typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;
    _BidirectionalIterator __lm1 = std::__1::prev(__last);
    value_type __tmp = std::__1::move(*__lm1);
    _BidirectionalIterator __fp1 = std::__1::move_backward(__first, __lm1, __last);
    *__first = std::__1::move(__tmp);
    return __fp1;
}

template <class _ForwardIterator>
_ForwardIterator
__rotate_forward(_ForwardIterator __first, _ForwardIterator __middle, _ForwardIterator __last)
{
    _ForwardIterator __i = __middle;
    while (true)
    {
        swap(*__first, *__i);
        ++__first;
        if (++__i == __last)
            break;
        if (__first == __middle)
            __middle = __i;
    }
    _ForwardIterator __r = __first;
    if (__first != __middle)
    {
        __i = __middle;
        while (true)
        {
            swap(*__first, *__i);
            ++__first;
            if (++__i == __last)
            {
                if (__first == __middle)
                    break;
                __i = __middle;
            }
            else if (__first == __middle)
                __middle = __i;
        }
    }
    return __r;
}

template<typename _Integral>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_Integral
__gcd(_Integral __x, _Integral __y)
{
    do
    {
        _Integral __t = __x % __y;
        __x = __y;
        __y = __t;
    } while (__y);
    return __x;
}

template<typename _RandomAccessIterator>
_RandomAccessIterator
__rotate_gcd(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last)
{
    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;

    const difference_type __m1 = __middle - __first;
    const difference_type __m2 = __last - __middle;
    if (__m1 == __m2)
    {
        std::__1::swap_ranges(__first, __middle, __middle);
        return __middle;
    }
    const difference_type __g = std::__1::__gcd(__m1, __m2);
    for (_RandomAccessIterator __p = __first + __g; __p != __first;)
    {
        value_type __t(std::__1::move(*--__p));
        _RandomAccessIterator __p1 = __p;
        _RandomAccessIterator __p2 = __p1 + __m1;
        do
        {
            *__p1 = std::__1::move(*__p2);
            __p1 = __p2;
            const difference_type __d = __last - __p2;
            if (__m1 < __d)
                __p2 += __m1;
            else
                __p2 = __first + (__m1 - __d);
        } while (__p2 != __p);
        *__p1 = std::__1::move(__t);
    }
    return __first + __m2;
}

template <class _ForwardIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_ForwardIterator
__rotate(_ForwardIterator __first, _ForwardIterator __middle, _ForwardIterator __last,
         std::__1::forward_iterator_tag)
{
    typedef typename std::__1::iterator_traits<_ForwardIterator>::value_type value_type;
    if (std::__1::is_trivially_move_assignable<value_type>::value)
    {
        if (std::__1::next(__first) == __middle)
            return std::__1::__rotate_left(__first, __last);
    }
    return std::__1::__rotate_forward(__first, __middle, __last);
}

template <class _BidirectionalIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_BidirectionalIterator
__rotate(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last,
         std::__1::bidirectional_iterator_tag)
{
    typedef typename std::__1::iterator_traits<_BidirectionalIterator>::value_type value_type;
    if (std::__1::is_trivially_move_assignable<value_type>::value)
    {
        if (std::__1::next(__first) == __middle)
            return std::__1::__rotate_left(__first, __last);
        if (std::__1::next(__middle) == __last)
            return std::__1::__rotate_right(__first, __last);
    }
    return std::__1::__rotate_forward(__first, __middle, __last);
}

template <class _RandomAccessIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_RandomAccessIterator
__rotate(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last,
         std::__1::random_access_iterator_tag)
{
    typedef typename std::__1::iterator_traits<_RandomAccessIterator>::value_type value_type;
    if (std::__1::is_trivially_move_assignable<value_type>::value)
    {
        if (std::__1::next(__first) == __middle)
            return std::__1::__rotate_left(__first, __last);
        if (std::__1::next(__middle) == __last)
            return std::__1::__rotate_right(__first, __last);
        return std::__1::__rotate_gcd(__first, __middle, __last);
    }
    return std::__1::__rotate_forward(__first, __middle, __last);
}

template <class _ForwardIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_ForwardIterator
rotate(_ForwardIterator __first, _ForwardIterator __middle, _ForwardIterator __last)
{
    if (__first == __middle)
        return __last;
    if (__middle == __last)
        return __first;
    return std::__1::__rotate(__first, __middle, __last,
                           typename std::__1::iterator_traits<_ForwardIterator>::iterator_category());
}

// rotate_copy

template <class _ForwardIterator, class _OutputIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_OutputIterator
rotate_copy(_ForwardIterator __first, _ForwardIterator __middle, _ForwardIterator __last, _OutputIterator __result)
{
    return std::__1::copy(__first, __middle, std::__1::copy(__middle, __last, __result));
}

// min_element

template <class _ForwardIterator, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_ForwardIterator
__min_element(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)
{
    if (__first != __last)
    {
        _ForwardIterator __i = __first;
        while (++__i != __last)
            if (__comp(*__i, *__first))
                __first = __i;
    }
    return __first;
}

template <class _ForwardIterator, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_ForwardIterator
min_element(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)
{
    return __min_element(__first, __last, __comp);
}

template <class _ForwardIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_ForwardIterator
min_element(_ForwardIterator __first, _ForwardIterator __last)
{
    return __min_element(__first, __last,
              __less<typename iterator_traits<_ForwardIterator>::value_type>());
}

// min

template <class _Tp, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
const _Tp&
min(const _Tp& __a, const _Tp& __b, _Compare __comp)
{
    return __comp(__b, __a) ? __b : __a;
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
const _Tp&
min(const _Tp& __a, const _Tp& __b)
{
    return std::__1::min(__a, __b, __less<_Tp>());
}
# 2604 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/algorithm" 3
// max_element

template <class _ForwardIterator, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_ForwardIterator
__max_element(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)
{
    if (__first != __last)
    {
        _ForwardIterator __i = __first;
        while (++__i != __last)
            if (__comp(*__first, *__i))
                __first = __i;
    }
    return __first;
}


template <class _ForwardIterator, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_ForwardIterator
max_element(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)
{
    return __max_element(__first, __last, __comp);
}

template <class _ForwardIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_ForwardIterator
max_element(_ForwardIterator __first, _ForwardIterator __last)
{
    return __max_element(__first, __last,
              __less<typename iterator_traits<_ForwardIterator>::value_type>());
}

// max

template <class _Tp, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
const _Tp&
max(const _Tp& __a, const _Tp& __b, _Compare __comp)
{
    return __comp(__a, __b) ? __b : __a;
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
const _Tp&
max(const _Tp& __a, const _Tp& __b)
{
    return std::__1::max(__a, __b, __less<_Tp>());
}
# 2677 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/algorithm" 3
// minmax_element

template <class _ForwardIterator, class _Compare>
std::pair<_ForwardIterator, _ForwardIterator>
minmax_element(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)
{
  std::pair<_ForwardIterator, _ForwardIterator> __result(__first, __first);
  if (__first != __last)
  {
      if (++__first != __last)
      {
          if (__comp(*__first, *__result.first))
              __result.first = __first;
          else
              __result.second = __first;
          while (++__first != __last)
          {
              _ForwardIterator __i = __first;
              if (++__first == __last)
              {
                  if (__comp(*__i, *__result.first))
                      __result.first = __i;
                  else if (!__comp(*__i, *__result.second))
                      __result.second = __i;
                  break;
              }
              else
              {
                  if (__comp(*__first, *__i))
                  {
                      if (__comp(*__first, *__result.first))
                          __result.first = __first;
                      if (!__comp(*__i, *__result.second))
                          __result.second = __i;
                  }
                  else
                  {
                      if (__comp(*__i, *__result.first))
                          __result.first = __i;
                      if (!__comp(*__first, *__result.second))
                          __result.second = __first;
                  }
              }
          }
      }
  }
  return __result;
}

template <class _ForwardIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
std::pair<_ForwardIterator, _ForwardIterator>
minmax_element(_ForwardIterator __first, _ForwardIterator __last)
{
    return std::__1::minmax_element(__first, __last,
              __less<typename iterator_traits<_ForwardIterator>::value_type>());
}

// minmax

template<class _Tp, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
pair<const _Tp&, const _Tp&>
minmax(const _Tp& __a, const _Tp& __b, _Compare __comp)
{
    return __comp(__b, __a) ? pair<const _Tp&, const _Tp&>(__b, __a) :
                              pair<const _Tp&, const _Tp&>(__a, __b);
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
pair<const _Tp&, const _Tp&>
minmax(const _Tp& __a, const _Tp& __b)
{
    return std::__1::minmax(__a, __b, __less<_Tp>());
}
# 2803 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/algorithm" 3
// random_shuffle

// __independent_bits_engine

template <unsigned long long _Xp, size_t _Rp>
struct __log2_imp
{
    static const size_t value = _Xp & ((unsigned long long)(1) << _Rp) ? _Rp
                                           : __log2_imp<_Xp, _Rp - 1>::value;
};

template <unsigned long long _Xp>
struct __log2_imp<_Xp, 0>
{
    static const size_t value = 0;
};

template <size_t _Rp>
struct __log2_imp<0, _Rp>
{
    static const size_t value = _Rp + 1;
};

template <class _UI, _UI _Xp>
struct __log2
{
    static const size_t value = __log2_imp<_Xp,
                                         sizeof(_UI) * 8 - 1>::value;
};

template<class _Engine, class _UIntType>
class __independent_bits_engine
{
public:
    // types
    typedef _UIntType result_type;

private:
    typedef typename _Engine::result_type _Engine_result_type;
    typedef typename conditional
        <
            sizeof(_Engine_result_type) <= sizeof(result_type),
                result_type,
                _Engine_result_type
        >::type _Working_result_type;

    _Engine& __e_;
    size_t __w_;
    size_t __w0_;
    size_t __n_;
    size_t __n0_;
    _Working_result_type __y0_;
    _Working_result_type __y1_;
    _Engine_result_type __mask0_;
    _Engine_result_type __mask1_;


    static const _Working_result_type _Rp = _Engine::_Max - _Engine::_Min
                                          + _Working_result_type(1);




    static const size_t __m = __log2<_Working_result_type, _Rp>::value;
    static const size_t _WDt = numeric_limits<_Working_result_type>::digits;
    static const size_t _EDt = numeric_limits<_Engine_result_type>::digits;

public:
    // constructors and seeding functions
    __independent_bits_engine(_Engine& __e, size_t __w);

    // generating functions
    result_type operator()() {return __eval(integral_constant<bool, _Rp != 0>());}

private:
    result_type __eval(false_type);
    result_type __eval(true_type);
};

template<class _Engine, class _UIntType>
__independent_bits_engine<_Engine, _UIntType>
    ::__independent_bits_engine(_Engine& __e, size_t __w)
        : __e_(__e),
          __w_(__w)
{
    __n_ = __w_ / __m + (__w_ % __m != 0);
    __w0_ = __w_ / __n_;
    if (_Rp == 0)
        __y0_ = _Rp;
    else if (__w0_ < _WDt)
        __y0_ = (_Rp >> __w0_) << __w0_;
    else
        __y0_ = 0;
    if (_Rp - __y0_ > __y0_ / __n_)
    {
        ++__n_;
        __w0_ = __w_ / __n_;
        if (__w0_ < _WDt)
            __y0_ = (_Rp >> __w0_) << __w0_;
        else
            __y0_ = 0;
    }
    __n0_ = __n_ - __w_ % __n_;
    if (__w0_ < _WDt - 1)
        __y1_ = (_Rp >> (__w0_ + 1)) << (__w0_ + 1);
    else
        __y1_ = 0;
    __mask0_ = __w0_ > 0 ? _Engine_result_type(~0) >> (_EDt - __w0_) :
                          _Engine_result_type(0);
    __mask1_ = __w0_ < _EDt - 1 ?
                               _Engine_result_type(~0) >> (_EDt - (__w0_ + 1)) :
                               _Engine_result_type(~0);
}

template<class _Engine, class _UIntType>
inline
_UIntType
__independent_bits_engine<_Engine, _UIntType>::__eval(false_type)
{
    return static_cast<result_type>(__e_() & __mask0_);
}

template<class _Engine, class _UIntType>
_UIntType
__independent_bits_engine<_Engine, _UIntType>::__eval(true_type)
{
    result_type _Sp = 0;
    for (size_t __k = 0; __k < __n0_; ++__k)
    {
        _Engine_result_type __u;
        do
        {
            __u = __e_() - _Engine::min();
        } while (__u >= __y0_);
        if (__w0_ < _WDt)
            _Sp <<= __w0_;
        else
            _Sp = 0;
        _Sp += __u & __mask0_;
    }
    for (size_t __k = __n0_; __k < __n_; ++__k)
    {
        _Engine_result_type __u;
        do
        {
            __u = __e_() - _Engine::min();
        } while (__u >= __y1_);
        if (__w0_ < _WDt - 1)
            _Sp <<= __w0_ + 1;
        else
            _Sp = 0;
        _Sp += __u & __mask1_;
    }
    return _Sp;
}

// uniform_int_distribution

template<class _IntType = int>
class uniform_int_distribution
{
public:
    // types
    typedef _IntType result_type;

    class param_type
    {
        result_type __a_;
        result_type __b_;
    public:
        typedef uniform_int_distribution distribution_type;

        explicit param_type(result_type __a = 0,
                            result_type __b = numeric_limits<result_type>::max())
            : __a_(__a), __b_(__b) {}

        result_type a() const {return __a_;}
        result_type b() const {return __b_;}

        friend bool operator==(const param_type& __x, const param_type& __y)
            {return __x.__a_ == __y.__a_ && __x.__b_ == __y.__b_;}
        friend bool operator!=(const param_type& __x, const param_type& __y)
            {return !(__x == __y);}
    };

private:
    param_type __p_;

public:
    // constructors and reset functions
    explicit uniform_int_distribution(result_type __a = 0,
                                      result_type __b = numeric_limits<result_type>::max())
        : __p_(param_type(__a, __b)) {}
    explicit uniform_int_distribution(const param_type& __p) : __p_(__p) {}
    void reset() {}

    // generating functions
    template<class _URNG> result_type operator()(_URNG& __g)
        {return (*this)(__g, __p_);}
    template<class _URNG> result_type operator()(_URNG& __g, const param_type& __p);

    // property functions
    result_type a() const {return __p_.a();}
    result_type b() const {return __p_.b();}

    param_type param() const {return __p_;}
    void param(const param_type& __p) {__p_ = __p;}

    result_type min() const {return a();}
    result_type max() const {return b();}

    friend bool operator==(const uniform_int_distribution& __x,
                           const uniform_int_distribution& __y)
        {return __x.__p_ == __y.__p_;}
    friend bool operator!=(const uniform_int_distribution& __x,
                           const uniform_int_distribution& __y)
            {return !(__x == __y);}
};

template<class _IntType>
template<class _URNG>
typename uniform_int_distribution<_IntType>::result_type
uniform_int_distribution<_IntType>::operator()(_URNG& __g, const param_type& __p)
{
    typedef typename conditional<sizeof(result_type) <= sizeof(uint32_t),
                                            uint32_t, uint64_t>::type _UIntType;
    const _UIntType _Rp = __p.b() - __p.a() + _UIntType(1);
    if (_Rp == 1)
        return __p.a();
    const size_t _Dt = numeric_limits<_UIntType>::digits;
    typedef __independent_bits_engine<_URNG, _UIntType> _Eng;
    if (_Rp == 0)
        return static_cast<result_type>(_Eng(__g, _Dt)());
    size_t __w = _Dt - __clz(_Rp) - 1;
    if ((_Rp & (_UIntType(~0) >> (_Dt - __w))) != 0)
        ++__w;
    _Eng __e(__g, __w);
    _UIntType __u;
    do
    {
        __u = __e();
    } while (__u >= _Rp);
    return static_cast<result_type>(__u + __p.a());
}

class __attribute__ ((__type_visibility__("default"))) __rs_default;

__attribute__ ((__visibility__("default"))) __rs_default __rs_get();

class __attribute__ ((__type_visibility__("default"))) __rs_default
{
    static unsigned __c_;

    __rs_default();
public:
    typedef uint_fast32_t result_type;

    static const result_type _Min = 0;
    static const result_type _Max = 0xFFFFFFFF;

    __rs_default(const __rs_default&);
    ~__rs_default();

    result_type operator()();

    static result_type min() {return _Min;}
    static result_type max() {return _Max;}

    friend __attribute__ ((__visibility__("default"))) __rs_default __rs_get();
};

__attribute__ ((__visibility__("default"))) __rs_default __rs_get();

template <class _RandomAccessIterator>
void
random_shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last)
{
    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
    typedef uniform_int_distribution<ptrdiff_t> _Dp;
    typedef typename _Dp::param_type _Pp;
    difference_type __d = __last - __first;
    if (__d > 1)
    {
        _Dp __uid;
        __rs_default __g = __rs_get();
        for (--__last, --__d; __first < __last; ++__first, --__d)
        {
            difference_type __i = __uid(__g, _Pp(0, __d));
            if (__i != difference_type(0))
                swap(*__first, *(__first + __i));
        }
    }
}

template <class _RandomAccessIterator, class _RandomNumberGenerator>
void
random_shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last,



               _RandomNumberGenerator& __rand)

{
    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
    difference_type __d = __last - __first;
    if (__d > 1)
    {
        for (--__last; __first < __last; ++__first, --__d)
        {
            difference_type __i = __rand(__d);
            swap(*__first, *(__first + __i));
        }
    }
}

template<class _RandomAccessIterator, class _UniformRandomNumberGenerator>
    void shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last,



                 _UniformRandomNumberGenerator& __g)

{
    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
    typedef uniform_int_distribution<ptrdiff_t> _Dp;
    typedef typename _Dp::param_type _Pp;
    difference_type __d = __last - __first;
    if (__d > 1)
    {
        _Dp __uid;
        for (--__last, --__d; __first < __last; ++__first, --__d)
        {
            difference_type __i = __uid(__g, _Pp(0, __d));
            if (__i != difference_type(0))
                swap(*__first, *(__first + __i));
        }
    }
}

template <class _InputIterator, class _Predicate>
bool
is_partitioned(_InputIterator __first, _InputIterator __last, _Predicate __pred)
{
    for (; __first != __last; ++__first)
        if (!__pred(*__first))
            break;
    for (; __first != __last; ++__first)
        if (__pred(*__first))
            return false;
    return true;
}

// partition

template <class _Predicate, class _ForwardIterator>
_ForwardIterator
__partition(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred, forward_iterator_tag)
{
    while (true)
    {
        if (__first == __last)
            return __first;
        if (!__pred(*__first))
            break;
        ++__first;
    }
    for (_ForwardIterator __p = __first; ++__p != __last;)
    {
        if (__pred(*__p))
        {
            swap(*__first, *__p);
            ++__first;
        }
    }
    return __first;
}

template <class _Predicate, class _BidirectionalIterator>
_BidirectionalIterator
__partition(_BidirectionalIterator __first, _BidirectionalIterator __last, _Predicate __pred,
            bidirectional_iterator_tag)
{
    while (true)
    {
        while (true)
        {
            if (__first == __last)
                return __first;
            if (!__pred(*__first))
                break;
            ++__first;
        }
        do
        {
            if (__first == --__last)
                return __first;
        } while (!__pred(*__last));
        swap(*__first, *__last);
        ++__first;
    }
}

template <class _ForwardIterator, class _Predicate>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_ForwardIterator
partition(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred)
{
    return std::__1::__partition<typename add_lvalue_reference<_Predicate>::type>
                            (__first, __last, __pred, typename iterator_traits<_ForwardIterator>::iterator_category());
}

// partition_copy

template <class _InputIterator, class _OutputIterator1,
          class _OutputIterator2, class _Predicate>
pair<_OutputIterator1, _OutputIterator2>
partition_copy(_InputIterator __first, _InputIterator __last,
               _OutputIterator1 __out_true, _OutputIterator2 __out_false,
               _Predicate __pred)
{
    for (; __first != __last; ++__first)
    {
        if (__pred(*__first))
        {
            *__out_true = *__first;
            ++__out_true;
        }
        else
        {
            *__out_false = *__first;
            ++__out_false;
        }
    }
    return pair<_OutputIterator1, _OutputIterator2>(__out_true, __out_false);
}

// partition_point

template<class _ForwardIterator, class _Predicate>
_ForwardIterator
partition_point(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred)
{
    typedef typename iterator_traits<_ForwardIterator>::difference_type difference_type;
    difference_type __len = std::__1::distance(__first, __last);
    while (__len != 0)
    {
        difference_type __l2 = __len / 2;
        _ForwardIterator __m = __first;
        std::__1::advance(__m, __l2);
        if (__pred(*__m))
        {
            __first = ++__m;
            __len -= __l2 + 1;
        }
        else
            __len = __l2;
    }
    return __first;
}

// stable_partition

template <class _Predicate, class _ForwardIterator, class _Distance, class _Pair>
_ForwardIterator
__stable_partition(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred,
                   _Distance __len, _Pair __p, forward_iterator_tag __fit)
{
    // *__first is known to be false
    // __len >= 1
    if (__len == 1)
        return __first;
    if (__len == 2)
    {
        _ForwardIterator __m = __first;
        if (__pred(*++__m))
        {
            swap(*__first, *__m);
            return __m;
        }
        return __first;
    }
    if (__len <= __p.second)
    { // The buffer is big enough to use
        typedef typename iterator_traits<_ForwardIterator>::value_type value_type;
        __destruct_n __d(0);
        unique_ptr<value_type, __destruct_n&> __h(__p.first, __d);
        // Move the falses into the temporary buffer, and the trues to the front of the line
        // Update __first to always point to the end of the trues
        value_type* __t = __p.first;
        ::new(__t) value_type(std::__1::move(*__first));
        __d.__incr((value_type*)0);
        ++__t;
        _ForwardIterator __i = __first;
        while (++__i != __last)
        {
            if (__pred(*__i))
            {
                *__first = std::__1::move(*__i);
                ++__first;
            }
            else
            {
                ::new(__t) value_type(std::__1::move(*__i));
                __d.__incr((value_type*)0);
                ++__t;
            }
        }
        // All trues now at start of range, all falses in buffer
        // Move falses back into range, but don't mess up __first which points to first false
        __i = __first;
        for (value_type* __t2 = __p.first; __t2 < __t; ++__t2, ++__i)
            *__i = std::__1::move(*__t2);
        // __h destructs moved-from values out of the temp buffer, but doesn't deallocate buffer
        return __first;
    }
    // Else not enough buffer, do in place
    // __len >= 3
    _ForwardIterator __m = __first;
    _Distance __len2 = __len / 2; // __len2 >= 2
    std::__1::advance(__m, __len2);
    // recurse on [__first, __m), *__first know to be false
    // F?????????????????
    // f       m         l
    typedef typename add_lvalue_reference<_Predicate>::type _PredRef;
    _ForwardIterator __first_false = __stable_partition<_PredRef>(__first, __m, __pred, __len2, __p, __fit);
    // TTTFFFFF??????????
    // f  ff   m         l
    // recurse on [__m, __last], except increase __m until *(__m) is false, *__last know to be true
    _ForwardIterator __m1 = __m;
    _ForwardIterator __second_false = __last;
    _Distance __len_half = __len - __len2;
    while (__pred(*__m1))
    {
        if (++__m1 == __last)
            goto __second_half_done;
        --__len_half;
    }
    // TTTFFFFFTTTF??????
    // f  ff   m  m1     l
    __second_false = __stable_partition<_PredRef>(__m1, __last, __pred, __len_half, __p, __fit);
__second_half_done:
    // TTTFFFFFTTTTTFFFFF
    // f  ff   m    sf   l
    return std::__1::rotate(__first_false, __m, __second_false);
    // TTTTTTTTFFFFFFFFFF
    //         |
}

struct __return_temporary_buffer
{
    template <class _Tp>
    __attribute__ ((__visibility__("hidden"), __always_inline__)) void operator()(_Tp* __p) const {std::__1::return_temporary_buffer(__p);}
};

template <class _Predicate, class _ForwardIterator>
_ForwardIterator
__stable_partition(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred,
                   forward_iterator_tag)
{
    const unsigned __alloc_limit = 3; // might want to make this a function of trivial assignment
    // Either prove all true and return __first or point to first false
    while (true)
    {
        if (__first == __last)
            return __first;
        if (!__pred(*__first))
            break;
        ++__first;
    }
    // We now have a reduced range [__first, __last)
    // *__first is known to be false
    typedef typename iterator_traits<_ForwardIterator>::difference_type difference_type;
    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;
    difference_type __len = std::__1::distance(__first, __last);
    pair<value_type*, ptrdiff_t> __p(0, 0);
    unique_ptr<value_type, __return_temporary_buffer> __h;
    if (__len >= __alloc_limit)
    {
        __p = std::__1::get_temporary_buffer<value_type>(__len);
        __h.reset(__p.first);
    }
    return __stable_partition<typename add_lvalue_reference<_Predicate>::type>
                             (__first, __last, __pred, __len, __p, forward_iterator_tag());
}

template <class _Predicate, class _BidirectionalIterator, class _Distance, class _Pair>
_BidirectionalIterator
__stable_partition(_BidirectionalIterator __first, _BidirectionalIterator __last, _Predicate __pred,
                   _Distance __len, _Pair __p, bidirectional_iterator_tag __bit)
{
    // *__first is known to be false
    // *__last is known to be true
    // __len >= 2
    if (__len == 2)
    {
        swap(*__first, *__last);
        return __last;
    }
    if (__len == 3)
    {
        _BidirectionalIterator __m = __first;
        if (__pred(*++__m))
        {
            swap(*__first, *__m);
            swap(*__m, *__last);
            return __last;
        }
        swap(*__m, *__last);
        swap(*__first, *__m);
        return __m;
    }
    if (__len <= __p.second)
    { // The buffer is big enough to use
        typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;
        __destruct_n __d(0);
        unique_ptr<value_type, __destruct_n&> __h(__p.first, __d);
        // Move the falses into the temporary buffer, and the trues to the front of the line
        // Update __first to always point to the end of the trues
        value_type* __t = __p.first;
        ::new(__t) value_type(std::__1::move(*__first));
        __d.__incr((value_type*)0);
        ++__t;
        _BidirectionalIterator __i = __first;
        while (++__i != __last)
        {
            if (__pred(*__i))
            {
                *__first = std::__1::move(*__i);
                ++__first;
            }
            else
            {
                ::new(__t) value_type(std::__1::move(*__i));
                __d.__incr((value_type*)0);
                ++__t;
            }
        }
        // move *__last, known to be true
        *__first = std::__1::move(*__i);
        __i = ++__first;
        // All trues now at start of range, all falses in buffer
        // Move falses back into range, but don't mess up __first which points to first false
        for (value_type* __t2 = __p.first; __t2 < __t; ++__t2, ++__i)
            *__i = std::__1::move(*__t2);
        // __h destructs moved-from values out of the temp buffer, but doesn't deallocate buffer
        return __first;
    }
    // Else not enough buffer, do in place
    // __len >= 4
    _BidirectionalIterator __m = __first;
    _Distance __len2 = __len / 2; // __len2 >= 2
    std::__1::advance(__m, __len2);
    // recurse on [__first, __m-1], except reduce __m-1 until *(__m-1) is true, *__first know to be false
    // F????????????????T
    // f       m        l
    _BidirectionalIterator __m1 = __m;
    _BidirectionalIterator __first_false = __first;
    _Distance __len_half = __len2;
    while (!__pred(*--__m1))
    {
        if (__m1 == __first)
            goto __first_half_done;
        --__len_half;
    }
    // F???TFFF?????????T
    // f   m1  m        l
    typedef typename add_lvalue_reference<_Predicate>::type _PredRef;
    __first_false = __stable_partition<_PredRef>(__first, __m1, __pred, __len_half, __p, __bit);
__first_half_done:
    // TTTFFFFF?????????T
    // f  ff   m        l
    // recurse on [__m, __last], except increase __m until *(__m) is false, *__last know to be true
    __m1 = __m;
    _BidirectionalIterator __second_false = __last;
    ++__second_false;
    __len_half = __len - __len2;
    while (__pred(*__m1))
    {
        if (++__m1 == __last)
            goto __second_half_done;
        --__len_half;
    }
    // TTTFFFFFTTTF?????T
    // f  ff   m  m1    l
    __second_false = __stable_partition<_PredRef>(__m1, __last, __pred, __len_half, __p, __bit);
__second_half_done:
    // TTTFFFFFTTTTTFFFFF
    // f  ff   m    sf  l
    return std::__1::rotate(__first_false, __m, __second_false);
    // TTTTTTTTFFFFFFFFFF
    //         |
}

template <class _Predicate, class _BidirectionalIterator>
_BidirectionalIterator
__stable_partition(_BidirectionalIterator __first, _BidirectionalIterator __last, _Predicate __pred,
                   bidirectional_iterator_tag)
{
    typedef typename iterator_traits<_BidirectionalIterator>::difference_type difference_type;
    typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;
    const difference_type __alloc_limit = 4; // might want to make this a function of trivial assignment
    // Either prove all true and return __first or point to first false
    while (true)
    {
        if (__first == __last)
            return __first;
        if (!__pred(*__first))
            break;
        ++__first;
    }
    // __first points to first false, everything prior to __first is already set.
    // Either prove [__first, __last) is all false and return __first, or point __last to last true
    do
    {
        if (__first == --__last)
            return __first;
    } while (!__pred(*__last));
    // We now have a reduced range [__first, __last]
    // *__first is known to be false
    // *__last is known to be true
    // __len >= 2
    difference_type __len = std::__1::distance(__first, __last) + 1;
    pair<value_type*, ptrdiff_t> __p(0, 0);
    unique_ptr<value_type, __return_temporary_buffer> __h;
    if (__len >= __alloc_limit)
    {
        __p = std::__1::get_temporary_buffer<value_type>(__len);
        __h.reset(__p.first);
    }
    return __stable_partition<typename add_lvalue_reference<_Predicate>::type>
                             (__first, __last, __pred, __len, __p, bidirectional_iterator_tag());
}

template <class _ForwardIterator, class _Predicate>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_ForwardIterator
stable_partition(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred)
{
    return __stable_partition<typename add_lvalue_reference<_Predicate>::type>
                             (__first, __last, __pred, typename iterator_traits<_ForwardIterator>::iterator_category());
}

// is_sorted_until

template <class _ForwardIterator, class _Compare>
_ForwardIterator
is_sorted_until(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)
{
    if (__first != __last)
    {
        _ForwardIterator __i = __first;
        while (++__i != __last)
        {
            if (__comp(*__i, *__first))
                return __i;
            __first = __i;
        }
    }
    return __last;
}

template<class _ForwardIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_ForwardIterator
is_sorted_until(_ForwardIterator __first, _ForwardIterator __last)
{
    return std::__1::is_sorted_until(__first, __last, __less<typename iterator_traits<_ForwardIterator>::value_type>());
}

// is_sorted

template <class _ForwardIterator, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
is_sorted(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)
{
    return std::__1::is_sorted_until(__first, __last, __comp) == __last;
}

template<class _ForwardIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
is_sorted(_ForwardIterator __first, _ForwardIterator __last)
{
    return std::__1::is_sorted(__first, __last, __less<typename iterator_traits<_ForwardIterator>::value_type>());
}

// sort

// stable, 2-3 compares, 0-2 swaps

template <class _Compare, class _ForwardIterator>
unsigned
__sort3(_ForwardIterator __x, _ForwardIterator __y, _ForwardIterator __z, _Compare __c)
{
    unsigned __r = 0;
    if (!__c(*__y, *__x)) // if x <= y
    {
        if (!__c(*__z, *__y)) // if y <= z
            return __r; // x <= y && y <= z
                                   // x <= y && y > z
        swap(*__y, *__z); // x <= z && y < z
        __r = 1;
        if (__c(*__y, *__x)) // if x > y
        {
            swap(*__x, *__y); // x < y && y <= z
            __r = 2;
        }
        return __r; // x <= y && y < z
    }
    if (__c(*__z, *__y)) // x > y, if y > z
    {
        swap(*__x, *__z); // x < y && y < z
        __r = 1;
        return __r;
    }
    swap(*__x, *__y); // x > y && y <= z
    __r = 1; // x < y && x <= z
    if (__c(*__z, *__y)) // if y > z
    {
        swap(*__y, *__z); // x <= y && y < z
        __r = 2;
    }
    return __r;
} // x <= y && y <= z

// stable, 3-6 compares, 0-5 swaps

template <class _Compare, class _ForwardIterator>
unsigned
__sort4(_ForwardIterator __x1, _ForwardIterator __x2, _ForwardIterator __x3,
            _ForwardIterator __x4, _Compare __c)
{
    unsigned __r = __sort3<_Compare>(__x1, __x2, __x3, __c);
    if (__c(*__x4, *__x3))
    {
        swap(*__x3, *__x4);
        ++__r;
        if (__c(*__x3, *__x2))
        {
            swap(*__x2, *__x3);
            ++__r;
            if (__c(*__x2, *__x1))
            {
                swap(*__x1, *__x2);
                ++__r;
            }
        }
    }
    return __r;
}

// stable, 4-10 compares, 0-9 swaps

template <class _Compare, class _ForwardIterator>
unsigned
__sort5(_ForwardIterator __x1, _ForwardIterator __x2, _ForwardIterator __x3,
            _ForwardIterator __x4, _ForwardIterator __x5, _Compare __c)
{
    unsigned __r = __sort4<_Compare>(__x1, __x2, __x3, __x4, __c);
    if (__c(*__x5, *__x4))
    {
        swap(*__x4, *__x5);
        ++__r;
        if (__c(*__x4, *__x3))
        {
            swap(*__x3, *__x4);
            ++__r;
            if (__c(*__x3, *__x2))
            {
                swap(*__x2, *__x3);
                ++__r;
                if (__c(*__x2, *__x1))
                {
                    swap(*__x1, *__x2);
                    ++__r;
                }
            }
        }
    }
    return __r;
}

// Assumes size > 0
template <class _Compare, class _BirdirectionalIterator>
void
__selection_sort(_BirdirectionalIterator __first, _BirdirectionalIterator __last, _Compare __comp)
{
    _BirdirectionalIterator __lm1 = __last;
    for (--__lm1; __first != __lm1; ++__first)
    {
        _BirdirectionalIterator __i = std::__1::min_element<_BirdirectionalIterator,
                                                        typename add_lvalue_reference<_Compare>::type>
                                                       (__first, __last, __comp);
        if (__i != __first)
            swap(*__first, *__i);
    }
}

template <class _Compare, class _BirdirectionalIterator>
void
__insertion_sort(_BirdirectionalIterator __first, _BirdirectionalIterator __last, _Compare __comp)
{
    typedef typename iterator_traits<_BirdirectionalIterator>::value_type value_type;
    if (__first != __last)
    {
        _BirdirectionalIterator __i = __first;
        for (++__i; __i != __last; ++__i)
        {
            _BirdirectionalIterator __j = __i;
            value_type __t(std::__1::move(*__j));
            for (_BirdirectionalIterator __k = __i; __k != __first && __comp(__t, *--__k); --__j)
                *__j = std::__1::move(*__k);
            *__j = std::__1::move(__t);
        }
    }
}

template <class _Compare, class _RandomAccessIterator>
void
__insertion_sort_3(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
{
    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;
    _RandomAccessIterator __j = __first+2;
    __sort3<_Compare>(__first, __first+1, __j, __comp);
    for (_RandomAccessIterator __i = __j+1; __i != __last; ++__i)
    {
        if (__comp(*__i, *__j))
        {
            value_type __t(std::__1::move(*__i));
            _RandomAccessIterator __k = __j;
            __j = __i;
            do
            {
                *__j = std::__1::move(*__k);
                __j = __k;
            } while (__j != __first && __comp(__t, *--__k));
            *__j = std::__1::move(__t);
        }
        __j = __i;
    }
}

template <class _Compare, class _RandomAccessIterator>
bool
__insertion_sort_incomplete(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
{
    switch (__last - __first)
    {
    case 0:
    case 1:
        return true;
    case 2:
        if (__comp(*--__last, *__first))
            swap(*__first, *__last);
        return true;
    case 3:
        std::__1::__sort3<_Compare>(__first, __first+1, --__last, __comp);
        return true;
    case 4:
        std::__1::__sort4<_Compare>(__first, __first+1, __first+2, --__last, __comp);
        return true;
    case 5:
        std::__1::__sort5<_Compare>(__first, __first+1, __first+2, __first+3, --__last, __comp);
        return true;
    }
    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;
    _RandomAccessIterator __j = __first+2;
    __sort3<_Compare>(__first, __first+1, __j, __comp);
    const unsigned __limit = 8;
    unsigned __count = 0;
    for (_RandomAccessIterator __i = __j+1; __i != __last; ++__i)
    {
        if (__comp(*__i, *__j))
        {
            value_type __t(std::__1::move(*__i));
            _RandomAccessIterator __k = __j;
            __j = __i;
            do
            {
                *__j = std::__1::move(*__k);
                __j = __k;
            } while (__j != __first && __comp(__t, *--__k));
            *__j = std::__1::move(__t);
            if (++__count == __limit)
                return ++__i == __last;
        }
        __j = __i;
    }
    return true;
}

template <class _Compare, class _BirdirectionalIterator>
void
__insertion_sort_move(_BirdirectionalIterator __first1, _BirdirectionalIterator __last1,
                      typename iterator_traits<_BirdirectionalIterator>::value_type* __first2, _Compare __comp)
{
    typedef typename iterator_traits<_BirdirectionalIterator>::value_type value_type;
    if (__first1 != __last1)
    {
        __destruct_n __d(0);
        unique_ptr<value_type, __destruct_n&> __h(__first2, __d);
        value_type* __last2 = __first2;
        ::new(__last2) value_type(std::__1::move(*__first1));
        __d.__incr((value_type*)0);
        for (++__last2; ++__first1 != __last1; ++__last2)
        {
            value_type* __j2 = __last2;
            value_type* __i2 = __j2;
            if (__comp(*__first1, *--__i2))
            {
                ::new(__j2) value_type(std::__1::move(*__i2));
                __d.__incr((value_type*)0);
                for (--__j2; __i2 != __first2 && __comp(*__first1, *--__i2); --__j2)
                    *__j2 = std::__1::move(*__i2);
                *__j2 = std::__1::move(*__first1);
            }
            else
            {
                ::new(__j2) value_type(std::__1::move(*__first1));
                __d.__incr((value_type*)0);
            }
        }
        __h.release();
    }
}

template <class _Compare, class _RandomAccessIterator>
void
__sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
{
    // _Compare is known to be a reference type
    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;
    const difference_type __limit = is_trivially_copy_constructible<value_type>::value &&
                                    is_trivially_copy_assignable<value_type>::value ? 30 : 6;
    while (true)
    {
    __restart:
        difference_type __len = __last - __first;
        switch (__len)
        {
        case 0:
        case 1:
            return;
        case 2:
            if (__comp(*--__last, *__first))
                swap(*__first, *__last);
            return;
        case 3:
            std::__1::__sort3<_Compare>(__first, __first+1, --__last, __comp);
            return;
        case 4:
            std::__1::__sort4<_Compare>(__first, __first+1, __first+2, --__last, __comp);
            return;
        case 5:
            std::__1::__sort5<_Compare>(__first, __first+1, __first+2, __first+3, --__last, __comp);
            return;
        }
        if (__len <= __limit)
        {
            std::__1::__insertion_sort_3<_Compare>(__first, __last, __comp);
            return;
        }
        // __len > 5
        _RandomAccessIterator __m = __first;
        _RandomAccessIterator __lm1 = __last;
        --__lm1;
        unsigned __n_swaps;
        {
        difference_type __delta;
        if (__len >= 1000)
        {
            __delta = __len/2;
            __m += __delta;
            __delta /= 2;
            __n_swaps = std::__1::__sort5<_Compare>(__first, __first + __delta, __m, __m+__delta, __lm1, __comp);
        }
        else
        {
            __delta = __len/2;
            __m += __delta;
            __n_swaps = std::__1::__sort3<_Compare>(__first, __m, __lm1, __comp);
        }
        }
        // *__m is median
        // partition [__first, __m) < *__m and *__m <= [__m, __last)
        // (this inhibits tossing elements equivalent to __m around unnecessarily)
        _RandomAccessIterator __i = __first;
        _RandomAccessIterator __j = __lm1;
        // j points beyond range to be tested, *__m is known to be <= *__lm1
        // The search going up is known to be guarded but the search coming down isn't.
        // Prime the downward search with a guard.
        if (!__comp(*__i, *__m)) // if *__first == *__m
        {
            // *__first == *__m, *__first doesn't go in first part
            // manually guard downward moving __j against __i
            while (true)
            {
                if (__i == --__j)
                {
                    // *__first == *__m, *__m <= all other elements
                    // Parition instead into [__first, __i) == *__first and *__first < [__i, __last)
                    ++__i; // __first + 1
                    __j = __last;
                    if (!__comp(*__first, *--__j)) // we need a guard if *__first == *(__last-1)
                    {
                        while (true)
                        {
                            if (__i == __j)
                                return; // [__first, __last) all equivalent elements
                            if (__comp(*__first, *__i))
                            {
                                swap(*__i, *__j);
                                ++__n_swaps;
                                ++__i;
                                break;
                            }
                            ++__i;
                        }
                    }
                    // [__first, __i) == *__first and *__first < [__j, __last) and __j == __last - 1
                    if (__i == __j)
                        return;
                    while (true)
                    {
                        while (!__comp(*__first, *__i))
                            ++__i;
                        while (__comp(*__first, *--__j))
                            ;
                        if (__i >= __j)
                            break;
                        swap(*__i, *__j);
                        ++__n_swaps;
                        ++__i;
                    }
                    // [__first, __i) == *__first and *__first < [__i, __last)
                    // The first part is sorted, sort the secod part
                    // _VSTD::__sort<_Compare>(__i, __last, __comp);
                    __first = __i;
                    goto __restart;
                }
                if (__comp(*__j, *__m))
                {
                    swap(*__i, *__j);
                    ++__n_swaps;
                    break; // found guard for downward moving __j, now use unguarded partition
                }
            }
        }
        // It is known that *__i < *__m
        ++__i;
        // j points beyond range to be tested, *__m is known to be <= *__lm1
        // if not yet partitioned...
        if (__i < __j)
        {
            // known that *(__i - 1) < *__m
            // known that __i <= __m
            while (true)
            {
                // __m still guards upward moving __i
                while (__comp(*__i, *__m))
                    ++__i;
                // It is now known that a guard exists for downward moving __j
                while (!__comp(*--__j, *__m))
                    ;
                if (__i > __j)
                    break;
                swap(*__i, *__j);
                ++__n_swaps;
                // It is known that __m != __j
                // If __m just moved, follow it
                if (__m == __i)
                    __m = __j;
                ++__i;
            }
        }
        // [__first, __i) < *__m and *__m <= [__i, __last)
        if (__i != __m && __comp(*__m, *__i))
        {
            swap(*__i, *__m);
            ++__n_swaps;
        }
        // [__first, __i) < *__i and *__i <= [__i+1, __last)
        // If we were given a perfect partition, see if insertion sort is quick...
        if (__n_swaps == 0)
        {
            bool __fs = std::__1::__insertion_sort_incomplete<_Compare>(__first, __i, __comp);
            if (std::__1::__insertion_sort_incomplete<_Compare>(__i+1, __last, __comp))
            {
                if (__fs)
                    return;
                __last = __i;
                continue;
            }
            else
            {
                if (__fs)
                {
                    __first = ++__i;
                    continue;
                }
            }
        }
        // sort smaller range with recursive call and larger with tail recursion elimination
        if (__i - __first < __last - __i)
        {
            std::__1::__sort<_Compare>(__first, __i, __comp);
            // _VSTD::__sort<_Compare>(__i+1, __last, __comp);
            __first = ++__i;
        }
        else
        {
            std::__1::__sort<_Compare>(__i+1, __last, __comp);
            // _VSTD::__sort<_Compare>(__first, __i, __comp);
            __last = __i;
        }
    }
}

// This forwarder keeps the top call and the recursive calls using the same instantiation, forcing a reference _Compare
template <class _RandomAccessIterator, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
{





    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
    __sort<_Comp_ref>(__first, __last, __comp);

}

template <class _RandomAccessIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
sort(_RandomAccessIterator __first, _RandomAccessIterator __last)
{
    std::__1::sort(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
sort(_Tp** __first, _Tp** __last)
{
    std::__1::sort((size_t*)__first, (size_t*)__last, __less<size_t>());
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
sort(__wrap_iter<_Tp*> __first, __wrap_iter<_Tp*> __last)
{
    std::__1::sort(__first.base(), __last.base());
}

template <class _Tp, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
sort(__wrap_iter<_Tp*> __first, __wrap_iter<_Tp*> __last, _Compare __comp)
{
    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
    std::__1::sort<_Tp*, _Comp_ref>(__first.base(), __last.base(), __comp);
}
# 4113 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/algorithm" 3
// lower_bound

template <class _Compare, class _ForwardIterator, class _Tp>
_ForwardIterator
__lower_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)
{
    typedef typename iterator_traits<_ForwardIterator>::difference_type difference_type;
    difference_type __len = std::__1::distance(__first, __last);
    while (__len != 0)
    {
        difference_type __l2 = __len / 2;
        _ForwardIterator __m = __first;
        std::__1::advance(__m, __l2);
        if (__comp(*__m, __value_))
        {
            __first = ++__m;
            __len -= __l2 + 1;
        }
        else
            __len = __l2;
    }
    return __first;
}

template <class _ForwardIterator, class _Tp, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_ForwardIterator
lower_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)
{





    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
    return __lower_bound<_Comp_ref>(__first, __last, __value_, __comp);

}

template <class _ForwardIterator, class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_ForwardIterator
lower_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_)
{
    return std::__1::lower_bound(__first, __last, __value_,
                             __less<typename iterator_traits<_ForwardIterator>::value_type, _Tp>());
}

// upper_bound

template <class _Compare, class _ForwardIterator, class _Tp>
_ForwardIterator
__upper_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)
{
    typedef typename iterator_traits<_ForwardIterator>::difference_type difference_type;
    difference_type __len = std::__1::distance(__first, __last);
    while (__len != 0)
    {
        difference_type __l2 = __len / 2;
        _ForwardIterator __m = __first;
        std::__1::advance(__m, __l2);
        if (__comp(__value_, *__m))
            __len = __l2;
        else
        {
            __first = ++__m;
            __len -= __l2 + 1;
        }
    }
    return __first;
}

template <class _ForwardIterator, class _Tp, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_ForwardIterator
upper_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)
{





    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
    return __upper_bound<_Comp_ref>(__first, __last, __value_, __comp);

}

template <class _ForwardIterator, class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_ForwardIterator
upper_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_)
{
    return std::__1::upper_bound(__first, __last, __value_,
                             __less<_Tp, typename iterator_traits<_ForwardIterator>::value_type>());
}

// equal_range

template <class _Compare, class _ForwardIterator, class _Tp>
pair<_ForwardIterator, _ForwardIterator>
__equal_range(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)
{
    typedef typename iterator_traits<_ForwardIterator>::difference_type difference_type;
    difference_type __len = std::__1::distance(__first, __last);
    while (__len != 0)
    {
        difference_type __l2 = __len / 2;
        _ForwardIterator __m = __first;
        std::__1::advance(__m, __l2);
        if (__comp(*__m, __value_))
        {
            __first = ++__m;
            __len -= __l2 + 1;
        }
        else if (__comp(__value_, *__m))
        {
            __last = __m;
            __len = __l2;
        }
        else
        {
            _ForwardIterator __mp1 = __m;
            return pair<_ForwardIterator, _ForwardIterator>
                   (
                      __lower_bound<_Compare>(__first, __m, __value_, __comp),
                      __upper_bound<_Compare>(++__mp1, __last, __value_, __comp)
                   );
        }
    }
    return pair<_ForwardIterator, _ForwardIterator>(__first, __first);
}

template <class _ForwardIterator, class _Tp, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
pair<_ForwardIterator, _ForwardIterator>
equal_range(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)
{





    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
    return __equal_range<_Comp_ref>(__first, __last, __value_, __comp);

}

template <class _ForwardIterator, class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
pair<_ForwardIterator, _ForwardIterator>
equal_range(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_)
{
    return std::__1::equal_range(__first, __last, __value_,
                             __less<typename iterator_traits<_ForwardIterator>::value_type, _Tp>());
}

// binary_search

template <class _Compare, class _ForwardIterator, class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
__binary_search(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)
{
    __first = __lower_bound<_Compare>(__first, __last, __value_, __comp);
    return __first != __last && !__comp(__value_, *__first);
}

template <class _ForwardIterator, class _Tp, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
binary_search(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)
{





    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
    return __binary_search<_Comp_ref>(__first, __last, __value_, __comp);

}

template <class _ForwardIterator, class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
binary_search(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_)
{
    return std::__1::binary_search(__first, __last, __value_,
                             __less<typename iterator_traits<_ForwardIterator>::value_type, _Tp>());
}

// merge

template <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator>
_OutputIterator
__merge(_InputIterator1 __first1, _InputIterator1 __last1,
        _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)
{
    for (; __first1 != __last1; ++__result)
    {
        if (__first2 == __last2)
            return std::__1::copy(__first1, __last1, __result);
        if (__comp(*__first2, *__first1))
        {
            *__result = *__first2;
            ++__first2;
        }
        else
        {
            *__result = *__first1;
            ++__first1;
        }
    }
    return std::__1::copy(__first2, __last2, __result);
}

template <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_OutputIterator
merge(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)
{





    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
    return std::__1::__merge<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __comp);

}

template <class _InputIterator1, class _InputIterator2, class _OutputIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_OutputIterator
merge(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)
{
    typedef typename iterator_traits<_InputIterator1>::value_type __v1;
    typedef typename iterator_traits<_InputIterator2>::value_type __v2;
    return merge(__first1, __last1, __first2, __last2, __result, __less<__v1, __v2>());
}

// inplace_merge

template <class _Compare, class _BidirectionalIterator>
void
__buffered_inplace_merge(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last,
                _Compare __comp, typename iterator_traits<_BidirectionalIterator>::difference_type __len1,
                                 typename iterator_traits<_BidirectionalIterator>::difference_type __len2,
                typename iterator_traits<_BidirectionalIterator>::value_type* __buff)
{
    typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;
    typedef typename iterator_traits<_BidirectionalIterator>::difference_type difference_type;
    typedef typename iterator_traits<_BidirectionalIterator>::pointer pointer;
    __destruct_n __d(0);
    unique_ptr<value_type, __destruct_n&> __h2(__buff, __d);
    if (__len1 <= __len2)
    {
        value_type* __p = __buff;
        for (_BidirectionalIterator __i = __first; __i != __middle; __d.__incr((value_type*)0), ++__i, ++__p)
            ::new(__p) value_type(std::__1::move(*__i));
        __merge<_Compare>(move_iterator<value_type*>(__buff),
                          move_iterator<value_type*>(__p),
                          move_iterator<_BidirectionalIterator>(__middle),
                          move_iterator<_BidirectionalIterator>(__last),
                          __first, __comp);
    }
    else
    {
        value_type* __p = __buff;
        for (_BidirectionalIterator __i = __middle; __i != __last; __d.__incr((value_type*)0), ++__i, ++__p)
            ::new(__p) value_type(std::__1::move(*__i));
        typedef reverse_iterator<_BidirectionalIterator> _RBi;
        typedef reverse_iterator<value_type*> _Rv;
        __merge(move_iterator<_RBi>(_RBi(__middle)), move_iterator<_RBi>(_RBi(__first)),
                move_iterator<_Rv>(_Rv(__p)), move_iterator<_Rv>(_Rv(__buff)),
                _RBi(__last), __negate<_Compare>(__comp));
    }
}

template <class _Compare, class _BidirectionalIterator>
void
__inplace_merge(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last,
                _Compare __comp, typename iterator_traits<_BidirectionalIterator>::difference_type __len1,
                                 typename iterator_traits<_BidirectionalIterator>::difference_type __len2,
                typename iterator_traits<_BidirectionalIterator>::value_type* __buff, ptrdiff_t __buff_size)
{
    typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;
    typedef typename iterator_traits<_BidirectionalIterator>::difference_type difference_type;
    while (true)
    {
        // if __middle == __last, we're done
        if (__len2 == 0)
            return;
        // shrink [__first, __middle) as much as possible (with no moves), returning if it shrinks to 0
        for (; true; ++__first, --__len1)
        {
            if (__len1 == 0)
                return;
            if (__comp(*__middle, *__first))
                break;
        }
        if (__len1 <= __buff_size || __len2 <= __buff_size)
        {
            __buffered_inplace_merge<_Compare>(__first, __middle, __last, __comp, __len1, __len2, __buff);
            return;
        }
        // __first < __middle < __last
        // *__first > *__middle
        // partition [__first, __m1) [__m1, __middle) [__middle, __m2) [__m2, __last) such that
        //     all elements in:
        //         [__first, __m1)  <= [__middle, __m2)
        //         [__middle, __m2) <  [__m1, __middle)
        //         [__m1, __middle) <= [__m2, __last)
        //     and __m1 or __m2 is in the middle of its range
        _BidirectionalIterator __m1; // "median" of [__first, __middle)
        _BidirectionalIterator __m2; // "median" of [__middle, __last)
        difference_type __len11; // distance(__first, __m1)
        difference_type __len21; // distance(__middle, __m2)
        // binary search smaller range
        if (__len1 < __len2)
        { // __len >= 1, __len2 >= 2
            __len21 = __len2 / 2;
            __m2 = __middle;
            std::__1::advance(__m2, __len21);
            __m1 = __upper_bound<_Compare>(__first, __middle, *__m2, __comp);
            __len11 = std::__1::distance(__first, __m1);
        }
        else
        {
            if (__len1 == 1)
            { // __len1 >= __len2 && __len2 > 0, therefore __len2 == 1
                // It is known *__first > *__middle
                swap(*__first, *__middle);
                return;
            }
            // __len1 >= 2, __len2 >= 1
            __len11 = __len1 / 2;
            __m1 = __first;
            std::__1::advance(__m1, __len11);
            __m2 = __lower_bound<_Compare>(__middle, __last, *__m1, __comp);
            __len21 = std::__1::distance(__middle, __m2);
        }
        difference_type __len12 = __len1 - __len11; // distance(__m1, __middle)
        difference_type __len22 = __len2 - __len21; // distance(__m2, __last)
        // [__first, __m1) [__m1, __middle) [__middle, __m2) [__m2, __last)
        // swap middle two partitions
        __middle = std::__1::rotate(__m1, __middle, __m2);
        // __len12 and __len21 now have swapped meanings
        // merge smaller range with recurisve call and larger with tail recursion elimination
        if (__len11 + __len21 < __len12 + __len22)
        {
            __inplace_merge<_Compare>(__first, __m1, __middle, __comp, __len11, __len21, __buff, __buff_size);
//          __inplace_merge<_Compare>(__middle, __m2, __last, __comp, __len12, __len22, __buff, __buff_size);
            __first = __middle;
            __middle = __m2;
            __len1 = __len12;
            __len2 = __len22;
        }
        else
        {
            __inplace_merge<_Compare>(__middle, __m2, __last, __comp, __len12, __len22, __buff, __buff_size);
//          __inplace_merge<_Compare>(__first, __m1, __middle, __comp, __len11, __len21, __buff, __buff_size);
            __last = __middle;
            __middle = __m1;
            __len1 = __len11;
            __len2 = __len21;
        }
    }
}

template <class _Tp>
struct __inplace_merge_switch
{
    static const unsigned value = is_trivially_copy_assignable<_Tp>::value;
};

template <class _BidirectionalIterator, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
inplace_merge(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last,
              _Compare __comp)
{
    typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;
    typedef typename iterator_traits<_BidirectionalIterator>::difference_type difference_type;
    difference_type __len1 = std::__1::distance(__first, __middle);
    difference_type __len2 = std::__1::distance(__middle, __last);
    difference_type __buf_size = std::__1::min(__len1, __len2);
    pair<value_type*, ptrdiff_t> __buf(0, 0);
    unique_ptr<value_type, __return_temporary_buffer> __h;
    if (__inplace_merge_switch<value_type>::value && __buf_size > 8)
    {
        __buf = std::__1::get_temporary_buffer<value_type>(__buf_size);
        __h.reset(__buf.first);
    }






    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
    return std::__1::__inplace_merge<_Comp_ref>(__first, __middle, __last, __comp, __len1, __len2,
                                            __buf.first, __buf.second);

}

template <class _BidirectionalIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
inplace_merge(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last)
{
    std::__1::inplace_merge(__first, __middle, __last,
                        __less<typename iterator_traits<_BidirectionalIterator>::value_type>());
}

// stable_sort

template <class _Compare, class _InputIterator1, class _InputIterator2>
void
__merge_move_construct(_InputIterator1 __first1, _InputIterator1 __last1,
        _InputIterator2 __first2, _InputIterator2 __last2,
        typename iterator_traits<_InputIterator1>::value_type* __result, _Compare __comp)
{
    typedef typename iterator_traits<_InputIterator1>::value_type value_type;
    __destruct_n __d(0);
    unique_ptr<value_type, __destruct_n&> __h(__result, __d);
    for (; true; ++__result)
    {
        if (__first1 == __last1)
        {
            for (; __first2 != __last2; ++__first2, ++__result, __d.__incr((value_type*)0))
                ::new (__result) value_type(std::__1::move(*__first2));
            __h.release();
            return;
        }
        if (__first2 == __last2)
        {
            for (; __first1 != __last1; ++__first1, ++__result, __d.__incr((value_type*)0))
                ::new (__result) value_type(std::__1::move(*__first1));
            __h.release();
            return;
        }
        if (__comp(*__first2, *__first1))
        {
            ::new (__result) value_type(std::__1::move(*__first2));
            __d.__incr((value_type*)0);
            ++__first2;
        }
        else
        {
            ::new (__result) value_type(std::__1::move(*__first1));
            __d.__incr((value_type*)0);
            ++__first1;
        }
    }
}

template <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator>
void
__merge_move_assign(_InputIterator1 __first1, _InputIterator1 __last1,
        _InputIterator2 __first2, _InputIterator2 __last2,
        _OutputIterator __result, _Compare __comp)
{
    for (; __first1 != __last1; ++__result)
    {
        if (__first2 == __last2)
        {
            for (; __first1 != __last1; ++__first1, ++__result)
                *__result = std::__1::move(*__first1);
            return;
        }
        if (__comp(*__first2, *__first1))
        {
            *__result = std::__1::move(*__first2);
            ++__first2;
        }
        else
        {
            *__result = std::__1::move(*__first1);
            ++__first1;
        }
    }
    for (; __first2 != __last2; ++__first2, ++__result)
        *__result = std::__1::move(*__first2);
}

template <class _Compare, class _RandomAccessIterator>
void
__stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp,
              typename iterator_traits<_RandomAccessIterator>::difference_type __len,
              typename iterator_traits<_RandomAccessIterator>::value_type* __buff, ptrdiff_t __buff_size);

template <class _Compare, class _RandomAccessIterator>
void
__stable_sort_move(_RandomAccessIterator __first1, _RandomAccessIterator __last1, _Compare __comp,
                   typename iterator_traits<_RandomAccessIterator>::difference_type __len,
                   typename iterator_traits<_RandomAccessIterator>::value_type* __first2)
{
    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;
    switch (__len)
    {
    case 0:
        return;
    case 1:
        ::new(__first2) value_type(std::__1::move(*__first1));
        return;
    case 2:
       __destruct_n __d(0);
        unique_ptr<value_type, __destruct_n&> __h2(__first2, __d);
         if (__comp(*--__last1, *__first1))
        {
            ::new(__first2) value_type(std::__1::move(*__last1));
            __d.__incr((value_type*)0);
            ++__first2;
            ::new(__first2) value_type(std::__1::move(*__first1));
        }
        else
        {
            ::new(__first2) value_type(std::__1::move(*__first1));
            __d.__incr((value_type*)0);
            ++__first2;
            ::new(__first2) value_type(std::__1::move(*__last1));
        }
        __h2.release();
        return;
    }
    if (__len <= 8)
    {
        __insertion_sort_move<_Compare>(__first1, __last1, __first2, __comp);
        return;
    }
    typename iterator_traits<_RandomAccessIterator>::difference_type __l2 = __len / 2;
    _RandomAccessIterator __m = __first1 + __l2;
    __stable_sort<_Compare>(__first1, __m, __comp, __l2, __first2, __l2);
    __stable_sort<_Compare>(__m, __last1, __comp, __len - __l2, __first2 + __l2, __len - __l2);
    __merge_move_construct<_Compare>(__first1, __m, __m, __last1, __first2, __comp);
}

template <class _Tp>
struct __stable_sort_switch
{
    static const unsigned value = 128*is_trivially_copy_assignable<_Tp>::value;
};

template <class _Compare, class _RandomAccessIterator>
void
__stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp,
              typename iterator_traits<_RandomAccessIterator>::difference_type __len,
              typename iterator_traits<_RandomAccessIterator>::value_type* __buff, ptrdiff_t __buff_size)
{
    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;
    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
    switch (__len)
    {
    case 0:
    case 1:
        return;
    case 2:
        if (__comp(*--__last, *__first))
            swap(*__first, *__last);
        return;
    }
    if (__len <= static_cast<difference_type>(__stable_sort_switch<value_type>::value))
    {
        __insertion_sort<_Compare>(__first, __last, __comp);
        return;
    }
    typename iterator_traits<_RandomAccessIterator>::difference_type __l2 = __len / 2;
    _RandomAccessIterator __m = __first + __l2;
    if (__len <= __buff_size)
    {
        __destruct_n __d(0);
        unique_ptr<value_type, __destruct_n&> __h2(__buff, __d);
        __stable_sort_move<_Compare>(__first, __m, __comp, __l2, __buff);
        __d.__set(__l2, (value_type*)0);
        __stable_sort_move<_Compare>(__m, __last, __comp, __len - __l2, __buff + __l2);
        __d.__set(__len, (value_type*)0);
        __merge_move_assign<_Compare>(__buff, __buff + __l2, __buff + __l2, __buff + __len, __first, __comp);
//         __merge<_Compare>(move_iterator<value_type*>(__buff),
//                           move_iterator<value_type*>(__buff + __l2),
//                           move_iterator<_RandomAccessIterator>(__buff + __l2),
//                           move_iterator<_RandomAccessIterator>(__buff + __len),
//                           __first, __comp);
        return;
    }
    __stable_sort<_Compare>(__first, __m, __comp, __l2, __buff, __buff_size);
    __stable_sort<_Compare>(__m, __last, __comp, __len - __l2, __buff, __buff_size);
    __inplace_merge<_Compare>(__first, __m, __last, __comp, __l2, __len - __l2, __buff, __buff_size);
}

template <class _RandomAccessIterator, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
{
    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;
    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
    difference_type __len = __last - __first;
    pair<value_type*, ptrdiff_t> __buf(0, 0);
    unique_ptr<value_type, __return_temporary_buffer> __h;
    if (__len > static_cast<difference_type>(__stable_sort_switch<value_type>::value))
    {
        __buf = std::__1::get_temporary_buffer<value_type>(__len);
        __h.reset(__buf.first);
    }





    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
    __stable_sort<_Comp_ref>(__first, __last, __comp, __len, __buf.first, __buf.second);

}

template <class _RandomAccessIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last)
{
    std::__1::stable_sort(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
}

// is_heap_until

template <class _RandomAccessIterator, class _Compare>
_RandomAccessIterator
is_heap_until(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
{
    typedef typename std::__1::iterator_traits<_RandomAccessIterator>::difference_type difference_type;
    difference_type __len = __last - __first;
    difference_type __p = 0;
    difference_type __c = 1;
    _RandomAccessIterator __pp = __first;
    while (__c < __len)
    {
        _RandomAccessIterator __cp = __first + __c;
        if (__comp(*__pp, *__cp))
            return __cp;
        ++__c;
        ++__cp;
        if (__c == __len)
            return __last;
        if (__comp(*__pp, *__cp))
            return __cp;
        ++__p;
        ++__pp;
        __c = 2 * __p + 1;
    }
    return __last;
}

template<class _RandomAccessIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_RandomAccessIterator
is_heap_until(_RandomAccessIterator __first, _RandomAccessIterator __last)
{
    return std::__1::is_heap_until(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
}

// is_heap

template <class _RandomAccessIterator, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
is_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
{
    return std::__1::is_heap_until(__first, __last, __comp) == __last;
}

template<class _RandomAccessIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
is_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
{
    return std::__1::is_heap(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
}

// push_heap

template <class _Compare, class _RandomAccessIterator>
void
__push_heap_front(_RandomAccessIterator __first, _RandomAccessIterator, _Compare __comp,
                  typename iterator_traits<_RandomAccessIterator>::difference_type __len)
{
    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;
    if (__len > 1)
    {
        difference_type __p = 0;
        _RandomAccessIterator __pp = __first;
        difference_type __c = 2;
        _RandomAccessIterator __cp = __first + __c;
        if (__c == __len || __comp(*__cp, *(__cp - 1)))
        {
            --__c;
            --__cp;
        }
        if (__comp(*__pp, *__cp))
        {
            value_type __t(std::__1::move(*__pp));
            do
            {
                *__pp = std::__1::move(*__cp);
                __pp = __cp;
                __p = __c;
                __c = (__p + 1) * 2;
                if (__c > __len)
                    break;
                __cp = __first + __c;
                if (__c == __len || __comp(*__cp, *(__cp - 1)))
                {
                    --__c;
                    --__cp;
                }
            } while (__comp(__t, *__cp));
            *__pp = std::__1::move(__t);
        }
    }
}

template <class _Compare, class _RandomAccessIterator>
void
__push_heap_back(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp,
                 typename iterator_traits<_RandomAccessIterator>::difference_type __len)
{
    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;
    if (__len > 1)
    {
        __len = (__len - 2) / 2;
        _RandomAccessIterator __ptr = __first + __len;
        if (__comp(*__ptr, *--__last))
        {
            value_type __t(std::__1::move(*__last));
            do
            {
                *__last = std::__1::move(*__ptr);
                __last = __ptr;
                if (__len == 0)
                    break;
                __len = (__len - 1) / 2;
                __ptr = __first + __len;
            } while (__comp(*__ptr, __t));
            *__last = std::__1::move(__t);
        }
    }
}

template <class _RandomAccessIterator, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
push_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
{





    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
    __push_heap_back<_Comp_ref>(__first, __last, __comp, __last - __first);

}

template <class _RandomAccessIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
push_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
{
    std::__1::push_heap(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
}

// pop_heap

template <class _Compare, class _RandomAccessIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
__pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp,
           typename iterator_traits<_RandomAccessIterator>::difference_type __len)
{
    if (__len > 1)
    {
        swap(*__first, *--__last);
        __push_heap_front<_Compare>(__first, __last, __comp, __len-1);
    }
}

template <class _RandomAccessIterator, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
{





    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
    __pop_heap<_Comp_ref>(__first, __last, __comp, __last - __first);

}

template <class _RandomAccessIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
{
    std::__1::pop_heap(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
}

// make_heap

template <class _Compare, class _RandomAccessIterator>
void
__make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
{
    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
    difference_type __n = __last - __first;
    if (__n > 1)
    {
        __last = __first;
        ++__last;
        for (difference_type __i = 1; __i < __n;)
            __push_heap_back<_Compare>(__first, ++__last, __comp, ++__i);
    }
}

template <class _RandomAccessIterator, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
{





    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
    __make_heap<_Comp_ref>(__first, __last, __comp);

}

template <class _RandomAccessIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
{
    std::__1::make_heap(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
}

// sort_heap

template <class _Compare, class _RandomAccessIterator>
void
__sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
{
    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
    for (difference_type __n = __last - __first; __n > 1; --__last, --__n)
        __pop_heap<_Compare>(__first, __last, __comp, __n);
}

template <class _RandomAccessIterator, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
{





    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
    __sort_heap<_Comp_ref>(__first, __last, __comp);

}

template <class _RandomAccessIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
{
    std::__1::sort_heap(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
}

// partial_sort

template <class _Compare, class _RandomAccessIterator>
void
__partial_sort(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last,
             _Compare __comp)
{
    __make_heap<_Compare>(__first, __middle, __comp);
    typename iterator_traits<_RandomAccessIterator>::difference_type __len = __middle - __first;
    for (_RandomAccessIterator __i = __middle; __i != __last; ++__i)
    {
        if (__comp(*__i, *__first))
        {
            swap(*__i, *__first);
            __push_heap_front<_Compare>(__first, __middle, __comp, __len);
        }
    }
    __sort_heap<_Compare>(__first, __middle, __comp);
}

template <class _RandomAccessIterator, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
partial_sort(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last,
             _Compare __comp)
{





    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
    __partial_sort<_Comp_ref>(__first, __middle, __last, __comp);

}

template <class _RandomAccessIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
partial_sort(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last)
{
    std::__1::partial_sort(__first, __middle, __last,
                       __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
}

// partial_sort_copy

template <class _Compare, class _InputIterator, class _RandomAccessIterator>
_RandomAccessIterator
__partial_sort_copy(_InputIterator __first, _InputIterator __last,
                    _RandomAccessIterator __result_first, _RandomAccessIterator __result_last, _Compare __comp)
{
    _RandomAccessIterator __r = __result_first;
    if (__r != __result_last)
    {
        typename iterator_traits<_RandomAccessIterator>::difference_type __len = 0;
        for (; __first != __last && __r != __result_last; ++__first, ++__r, ++__len)
            *__r = *__first;
        __make_heap<_Compare>(__result_first, __r, __comp);
        for (; __first != __last; ++__first)
            if (__comp(*__first, *__result_first))
            {
                *__result_first = *__first;
                __push_heap_front<_Compare>(__result_first, __r, __comp, __len);
            }
        __sort_heap<_Compare>(__result_first, __r, __comp);
    }
    return __r;
}

template <class _InputIterator, class _RandomAccessIterator, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_RandomAccessIterator
partial_sort_copy(_InputIterator __first, _InputIterator __last,
                  _RandomAccessIterator __result_first, _RandomAccessIterator __result_last, _Compare __comp)
{





    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
    return __partial_sort_copy<_Comp_ref>(__first, __last, __result_first, __result_last, __comp);

}

template <class _InputIterator, class _RandomAccessIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_RandomAccessIterator
partial_sort_copy(_InputIterator __first, _InputIterator __last,
                  _RandomAccessIterator __result_first, _RandomAccessIterator __result_last)
{
    return std::__1::partial_sort_copy(__first, __last, __result_first, __result_last,
                                   __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
}

// nth_element

template <class _Compare, class _RandomAccessIterator>
void
__nth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth, _RandomAccessIterator __last, _Compare __comp)
{
    // _Compare is known to be a reference type
    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
    const difference_type __limit = 7;
    while (true)
    {
    __restart:
        if (__nth == __last)
            return;
        difference_type __len = __last - __first;
        switch (__len)
        {
        case 0:
        case 1:
            return;
        case 2:
            if (__comp(*--__last, *__first))
                swap(*__first, *__last);
            return;
        case 3:
            {
            _RandomAccessIterator __m = __first;
            std::__1::__sort3<_Compare>(__first, ++__m, --__last, __comp);
            return;
            }
        }
        if (__len <= __limit)
        {
            __selection_sort<_Compare>(__first, __last, __comp);
            return;
        }
        // __len > __limit >= 3
        _RandomAccessIterator __m = __first + __len/2;
        _RandomAccessIterator __lm1 = __last;
        unsigned __n_swaps = std::__1::__sort3<_Compare>(__first, __m, --__lm1, __comp);
        // *__m is median
        // partition [__first, __m) < *__m and *__m <= [__m, __last)
        // (this inhibits tossing elements equivalent to __m around unnecessarily)
        _RandomAccessIterator __i = __first;
        _RandomAccessIterator __j = __lm1;
        // j points beyond range to be tested, *__lm1 is known to be <= *__m
        // The search going up is known to be guarded but the search coming down isn't.
        // Prime the downward search with a guard.
        if (!__comp(*__i, *__m)) // if *__first == *__m
        {
            // *__first == *__m, *__first doesn't go in first part
            // manually guard downward moving __j against __i
            while (true)
            {
                if (__i == --__j)
                {
                    // *__first == *__m, *__m <= all other elements
                    // Parition instead into [__first, __i) == *__first and *__first < [__i, __last)
                    ++__i; // __first + 1
                    __j = __last;
                    if (!__comp(*__first, *--__j)) // we need a guard if *__first == *(__last-1)
                    {
                        while (true)
                        {
                            if (__i == __j)
                                return; // [__first, __last) all equivalent elements
                            if (__comp(*__first, *__i))
                            {
                                swap(*__i, *__j);
                                ++__n_swaps;
                                ++__i;
                                break;
                            }
                            ++__i;
                        }
                    }
                    // [__first, __i) == *__first and *__first < [__j, __last) and __j == __last - 1
                    if (__i == __j)
                        return;
                    while (true)
                    {
                        while (!__comp(*__first, *__i))
                            ++__i;
                        while (__comp(*__first, *--__j))
                            ;
                        if (__i >= __j)
                            break;
                        swap(*__i, *__j);
                        ++__n_swaps;
                        ++__i;
                    }
                    // [__first, __i) == *__first and *__first < [__i, __last)
                    // The first part is sorted,
                    if (__nth < __i)
                        return;
                    // __nth_element the secod part
                    // __nth_element<_Compare>(__i, __nth, __last, __comp);
                    __first = __i;
                    goto __restart;
                }
                if (__comp(*__j, *__m))
                {
                    swap(*__i, *__j);
                    ++__n_swaps;
                    break; // found guard for downward moving __j, now use unguarded partition
                }
            }
        }
        ++__i;
        // j points beyond range to be tested, *__lm1 is known to be <= *__m
        // if not yet partitioned...
        if (__i < __j)
        {
            // known that *(__i - 1) < *__m
            while (true)
            {
                // __m still guards upward moving __i
                while (__comp(*__i, *__m))
                    ++__i;
                // It is now known that a guard exists for downward moving __j
                while (!__comp(*--__j, *__m))
                    ;
                if (__i >= __j)
                    break;
                swap(*__i, *__j);
                ++__n_swaps;
                // It is known that __m != __j
                // If __m just moved, follow it
                if (__m == __i)
                    __m = __j;
                ++__i;
            }
        }
        // [__first, __i) < *__m and *__m <= [__i, __last)
        if (__i != __m && __comp(*__m, *__i))
        {
            swap(*__i, *__m);
            ++__n_swaps;
        }
        // [__first, __i) < *__i and *__i <= [__i+1, __last)
        if (__nth == __i)
            return;
        if (__n_swaps == 0)
        {
            // We were given a perfectly partitioned sequence.  Coincidence?
            if (__nth < __i)
            {
                // Check for [__first, __i) already sorted
                __j = __m = __first;
                while (++__j != __i)
                {
                    if (__comp(*__j, *__m))
                        // not yet sorted, so sort
                        goto not_sorted;
                    __m = __j;
                }
                // [__first, __i) sorted
                return;
            }
            else
            {
                // Check for [__i, __last) already sorted
                __j = __m = __i;
                while (++__j != __last)
                {
                    if (__comp(*__j, *__m))
                        // not yet sorted, so sort
                        goto not_sorted;
                    __m = __j;
                }
                // [__i, __last) sorted
                return;
            }
        }
not_sorted:
        // __nth_element on range containing __nth
        if (__nth < __i)
        {
            // __nth_element<_Compare>(__first, __nth, __i, __comp);
            __last = __i;
        }
        else
        {
            // __nth_element<_Compare>(__i+1, __nth, __last, __comp);
            __first = ++__i;
        }
    }
}

template <class _RandomAccessIterator, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
nth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth, _RandomAccessIterator __last, _Compare __comp)
{





    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
    __nth_element<_Comp_ref>(__first, __nth, __last, __comp);

}

template <class _RandomAccessIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
nth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth, _RandomAccessIterator __last)
{
    std::__1::nth_element(__first, __nth, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
}

// includes

template <class _Compare, class _InputIterator1, class _InputIterator2>
bool
__includes(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2,
           _Compare __comp)
{
    for (; __first2 != __last2; ++__first1)
    {
        if (__first1 == __last1 || __comp(*__first2, *__first1))
            return false;
        if (!__comp(*__first1, *__first2))
            ++__first2;
    }
    return true;
}

template <class _InputIterator1, class _InputIterator2, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
includes(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2,
         _Compare __comp)
{





    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
    return __includes<_Comp_ref>(__first1, __last1, __first2, __last2, __comp);

}

template <class _InputIterator1, class _InputIterator2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
includes(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2)
{
    return std::__1::includes(__first1, __last1, __first2, __last2,
                          __less<typename iterator_traits<_InputIterator1>::value_type,
                                 typename iterator_traits<_InputIterator2>::value_type>());
}

// set_union

template <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator>
_OutputIterator
__set_union(_InputIterator1 __first1, _InputIterator1 __last1,
            _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)
{
    for (; __first1 != __last1; ++__result)
    {
        if (__first2 == __last2)
            return std::__1::copy(__first1, __last1, __result);
        if (__comp(*__first2, *__first1))
        {
            *__result = *__first2;
            ++__first2;
        }
        else
        {
            *__result = *__first1;
            if (!__comp(*__first1, *__first2))
                ++__first2;
            ++__first1;
        }
    }
    return std::__1::copy(__first2, __last2, __result);
}

template <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_OutputIterator
set_union(_InputIterator1 __first1, _InputIterator1 __last1,
          _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)
{





    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
    return __set_union<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __comp);

}

template <class _InputIterator1, class _InputIterator2, class _OutputIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_OutputIterator
set_union(_InputIterator1 __first1, _InputIterator1 __last1,
          _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)
{
    return std::__1::set_union(__first1, __last1, __first2, __last2, __result,
                          __less<typename iterator_traits<_InputIterator1>::value_type,
                                 typename iterator_traits<_InputIterator2>::value_type>());
}

// set_intersection

template <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator>
_OutputIterator
__set_intersection(_InputIterator1 __first1, _InputIterator1 __last1,
                   _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)
{
    while (__first1 != __last1 && __first2 != __last2)
    {
        if (__comp(*__first1, *__first2))
            ++__first1;
        else
        {
            if (!__comp(*__first2, *__first1))
            {
                *__result = *__first1;
                ++__result;
                ++__first1;
            }
            ++__first2;
        }
    }
    return __result;
}

template <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_OutputIterator
set_intersection(_InputIterator1 __first1, _InputIterator1 __last1,
                 _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)
{





    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
    return __set_intersection<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __comp);

}

template <class _InputIterator1, class _InputIterator2, class _OutputIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_OutputIterator
set_intersection(_InputIterator1 __first1, _InputIterator1 __last1,
                 _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)
{
    return std::__1::set_intersection(__first1, __last1, __first2, __last2, __result,
                                  __less<typename iterator_traits<_InputIterator1>::value_type,
                                         typename iterator_traits<_InputIterator2>::value_type>());
}

// set_difference

template <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator>
_OutputIterator
__set_difference(_InputIterator1 __first1, _InputIterator1 __last1,
                 _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)
{
    while (__first1 != __last1)
    {
        if (__first2 == __last2)
            return std::__1::copy(__first1, __last1, __result);
        if (__comp(*__first1, *__first2))
        {
            *__result = *__first1;
            ++__result;
            ++__first1;
        }
        else
        {
            if (!__comp(*__first2, *__first1))
                ++__first1;
            ++__first2;
        }
    }
    return __result;
}

template <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_OutputIterator
set_difference(_InputIterator1 __first1, _InputIterator1 __last1,
               _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)
{





    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
    return __set_difference<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __comp);

}

template <class _InputIterator1, class _InputIterator2, class _OutputIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_OutputIterator
set_difference(_InputIterator1 __first1, _InputIterator1 __last1,
               _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)
{
    return std::__1::set_difference(__first1, __last1, __first2, __last2, __result,
                                __less<typename iterator_traits<_InputIterator1>::value_type,
                                       typename iterator_traits<_InputIterator2>::value_type>());
}

// set_symmetric_difference

template <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator>
_OutputIterator
__set_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1,
                           _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)
{
    while (__first1 != __last1)
    {
        if (__first2 == __last2)
            return std::__1::copy(__first1, __last1, __result);
        if (__comp(*__first1, *__first2))
        {
            *__result = *__first1;
            ++__result;
            ++__first1;
        }
        else
        {
            if (__comp(*__first2, *__first1))
            {
                *__result = *__first2;
                ++__result;
            }
            else
                ++__first1;
            ++__first2;
        }
    }
    return std::__1::copy(__first2, __last2, __result);
}

template <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_OutputIterator
set_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1,
                         _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)
{





    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
    return __set_symmetric_difference<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __comp);

}

template <class _InputIterator1, class _InputIterator2, class _OutputIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_OutputIterator
set_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1,
                         _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)
{
    return std::__1::set_symmetric_difference(__first1, __last1, __first2, __last2, __result,
                                          __less<typename iterator_traits<_InputIterator1>::value_type,
                                                 typename iterator_traits<_InputIterator2>::value_type>());
}

// lexicographical_compare

template <class _Compare, class _InputIterator1, class _InputIterator2>
bool
__lexicographical_compare(_InputIterator1 __first1, _InputIterator1 __last1,
                          _InputIterator2 __first2, _InputIterator2 __last2, _Compare __comp)
{
    for (; __first2 != __last2; ++__first1, ++__first2)
    {
        if (__first1 == __last1 || __comp(*__first1, *__first2))
            return true;
        if (__comp(*__first2, *__first1))
            return false;
    }
    return false;
}

template <class _InputIterator1, class _InputIterator2, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
lexicographical_compare(_InputIterator1 __first1, _InputIterator1 __last1,
                        _InputIterator2 __first2, _InputIterator2 __last2, _Compare __comp)
{





    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
    return __lexicographical_compare<_Comp_ref>(__first1, __last1, __first2, __last2, __comp);

}

template <class _InputIterator1, class _InputIterator2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
lexicographical_compare(_InputIterator1 __first1, _InputIterator1 __last1,
                        _InputIterator2 __first2, _InputIterator2 __last2)
{
    return std::__1::lexicographical_compare(__first1, __last1, __first2, __last2,
                                         __less<typename iterator_traits<_InputIterator1>::value_type,
                                                typename iterator_traits<_InputIterator2>::value_type>());
}

// next_permutation

template <class _Compare, class _BidirectionalIterator>
bool
__next_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last, _Compare __comp)
{
    _BidirectionalIterator __i = __last;
    if (__first == __last || __first == --__i)
        return false;
    while (true)
    {
        _BidirectionalIterator __ip1 = __i;
        if (__comp(*--__i, *__ip1))
        {
            _BidirectionalIterator __j = __last;
            while (!__comp(*__i, *--__j))
                ;
            swap(*__i, *__j);
            std::__1::reverse(__ip1, __last);
            return true;
        }
        if (__i == __first)
        {
            std::__1::reverse(__first, __last);
            return false;
        }
    }
}

template <class _BidirectionalIterator, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
next_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last, _Compare __comp)
{





    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
    return __next_permutation<_Comp_ref>(__first, __last, __comp);

}

template <class _BidirectionalIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
next_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last)
{
    return std::__1::next_permutation(__first, __last,
                                  __less<typename iterator_traits<_BidirectionalIterator>::value_type>());
}

// prev_permutation

template <class _Compare, class _BidirectionalIterator>
bool
__prev_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last, _Compare __comp)
{
    _BidirectionalIterator __i = __last;
    if (__first == __last || __first == --__i)
        return false;
    while (true)
    {
        _BidirectionalIterator __ip1 = __i;
        if (__comp(*__ip1, *--__i))
        {
            _BidirectionalIterator __j = __last;
            while (!__comp(*--__j, *__i))
                ;
            swap(*__i, *__j);
            std::__1::reverse(__ip1, __last);
            return true;
        }
        if (__i == __first)
        {
            std::__1::reverse(__first, __last);
            return false;
        }
    }
}

template <class _BidirectionalIterator, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
prev_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last, _Compare __comp)
{





    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
    return __prev_permutation<_Comp_ref>(__first, __last, __comp);

}

template <class _BidirectionalIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
prev_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last)
{
    return std::__1::prev_permutation(__first, __last,
                                  __less<typename iterator_traits<_BidirectionalIterator>::value_type>());
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_integral<_Tp>::value,
    _Tp
>::type
__rotate_left(_Tp __t, _Tp __n = 1)
{
    const unsigned __bits = static_cast<unsigned>(sizeof(_Tp) * 8 - 1);
    __n &= __bits;
    return static_cast<_Tp>((__t << __n) | (static_cast<typename make_unsigned<_Tp>::type>(__t) >> (__bits - __n)));
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_integral<_Tp>::value,
    _Tp
>::type
__rotate_right(_Tp __t, _Tp __n = 1)
{
    const unsigned __bits = static_cast<unsigned>(sizeof(_Tp) * 8 - 1);
    __n &= __bits;
    return static_cast<_Tp>((__t << (__bits - __n)) | (static_cast<typename make_unsigned<_Tp>::type>(__t) >> __n));
}

} }
# 440 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/string" 2 3



# 1 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/stdexcept" 1 3
// -*- C++ -*-
//===--------------------------- stdexcept --------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is dual licensed under the MIT and the University of Illinois Open
// Source Licenses. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//




/*
    stdexcept synopsis

namespace std
{

class logic_error;
    class domain_error;
    class invalid_argument;
    class length_error;
    class out_of_range;
class runtime_error;
    class range_error;
    class overflow_error;
    class underflow_error;

for each class xxx_error:

class xxx_error : public exception // at least indirectly
{
public:
    explicit xxx_error(const string& what_arg);
    explicit xxx_error(const char*   what_arg);

    virtual const char* what() const noexcept // returns what_arg
};

}  // std

*/
# 51 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/stdexcept" 3



namespace std {inline namespace __1 {
class __attribute__ ((__visibility__("hidden"))) __libcpp_refstring {
    const char *__imp_;
};
} }


namespace std // purposefully not using versioning namespace
{

class __attribute__ ((__visibility__("default"))) logic_error
    : public exception
{
private:
    std::__1::__libcpp_refstring __imp_;
public:
    explicit logic_error(const string&);
    explicit logic_error(const char*);

    logic_error(const logic_error&) throw();
    logic_error& operator=(const logic_error&) throw();

    virtual ~logic_error() throw();

    virtual const char* what() const throw();
};

class __attribute__ ((__visibility__("default"))) runtime_error
    : public exception
{
private:
    std::__1::__libcpp_refstring __imp_;
public:
    explicit runtime_error(const string&);
    explicit runtime_error(const char*);

    runtime_error(const runtime_error&) throw();
    runtime_error& operator=(const runtime_error&) throw();

    virtual ~runtime_error() throw();

    virtual const char* what() const throw();
};

class __attribute__ ((__visibility__("default"))) domain_error
    : public logic_error
{
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit domain_error(const string& __s) : logic_error(__s) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit domain_error(const char* __s) : logic_error(__s) {}

    virtual ~domain_error() throw();
};

class __attribute__ ((__visibility__("default"))) invalid_argument
    : public logic_error
{
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit invalid_argument(const string& __s) : logic_error(__s) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit invalid_argument(const char* __s) : logic_error(__s) {}

    virtual ~invalid_argument() throw();
};

class __attribute__ ((__visibility__("default"))) length_error
    : public logic_error
{
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit length_error(const string& __s) : logic_error(__s) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit length_error(const char* __s) : logic_error(__s) {}

    virtual ~length_error() throw();
};

class __attribute__ ((__visibility__("default"))) out_of_range
    : public logic_error
{
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit out_of_range(const string& __s) : logic_error(__s) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit out_of_range(const char* __s) : logic_error(__s) {}

    virtual ~out_of_range() throw();
};

class __attribute__ ((__visibility__("default"))) range_error
    : public runtime_error
{
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit range_error(const string& __s) : runtime_error(__s) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit range_error(const char* __s) : runtime_error(__s) {}

    virtual ~range_error() throw();
};

class __attribute__ ((__visibility__("default"))) overflow_error
    : public runtime_error
{
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit overflow_error(const string& __s) : runtime_error(__s) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit overflow_error(const char* __s) : runtime_error(__s) {}

    virtual ~overflow_error() throw();
};

class __attribute__ ((__visibility__("default"))) underflow_error
    : public runtime_error
{
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit underflow_error(const string& __s) : runtime_error(__s) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit underflow_error(const char* __s) : runtime_error(__s) {}

    virtual ~underflow_error() throw();
};

} // std
# 444 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/string" 2 3
# 454 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/string" 3
# 1 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/__undef_min_max" 1 3
// -*- C++ -*-
//===----------------------------------------------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is dual licensed under the MIT and the University of Illinois Open
// Source Licenses. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
# 455 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/string" 2 3
# 458 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/string" 3


namespace std {inline namespace __1 {

// fpos

template <class _StateT>
class __attribute__ ((__type_visibility__("default"))) fpos
{
private:
    _StateT __st_;
    streamoff __off_;
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) fpos(streamoff __off = streamoff()) : __st_(), __off_(__off) {}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) operator streamoff() const {return __off_;}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) _StateT state() const {return __st_;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) void state(_StateT __st) {__st_ = __st;}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) fpos& operator+=(streamoff __off) {__off_ += __off; return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) fpos operator+ (streamoff __off) const {fpos __t(*this); __t += __off; return __t;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) fpos& operator-=(streamoff __off) {__off_ -= __off; return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) fpos operator- (streamoff __off) const {fpos __t(*this); __t -= __off; return __t;}
};

template <class _StateT>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
streamoff operator-(const fpos<_StateT>& __x, const fpos<_StateT>& __y)
    {return streamoff(__x) - streamoff(__y);}

template <class _StateT>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool operator==(const fpos<_StateT>& __x, const fpos<_StateT>& __y)
    {return streamoff(__x) == streamoff(__y);}

template <class _StateT>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool operator!=(const fpos<_StateT>& __x, const fpos<_StateT>& __y)
    {return streamoff(__x) != streamoff(__y);}

// char_traits

template <class _CharT>
struct __attribute__ ((__type_visibility__("default"))) char_traits
{
    typedef _CharT char_type;
    typedef int int_type;
    typedef streamoff off_type;
    typedef streampos pos_type;
    typedef mbstate_t state_type;

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static void assign(char_type& __c1, const char_type& __c2) throw()
        {__c1 = __c2;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static bool eq(char_type __c1, char_type __c2) throw()
        {return __c1 == __c2;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static bool lt(char_type __c1, char_type __c2) throw()
        {return __c1 < __c2;}

    static int compare(const char_type* __s1, const char_type* __s2, size_t __n);
    static size_t length(const char_type* __s);
    static const char_type* find(const char_type* __s, size_t __n, const char_type& __a);
    static char_type* move(char_type* __s1, const char_type* __s2, size_t __n);
    static char_type* copy(char_type* __s1, const char_type* __s2, size_t __n);
    static char_type* assign(char_type* __s, size_t __n, char_type __a);

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static int_type not_eof(int_type __c) throw()
        {return eq_int_type(__c, eof()) ? ~eof() : __c;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static char_type to_char_type(int_type __c) throw()
        {return char_type(__c);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static int_type to_int_type(char_type __c) throw()
        {return int_type(__c);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static bool eq_int_type(int_type __c1, int_type __c2) throw()
        {return __c1 == __c2;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static int_type eof() throw()
        {return int_type((-1));}
};

template <class _CharT>
int
char_traits<_CharT>::compare(const char_type* __s1, const char_type* __s2, size_t __n)
{
    for (; __n; --__n, ++__s1, ++__s2)
    {
        if (lt(*__s1, *__s2))
            return -1;
        if (lt(*__s2, *__s1))
            return 1;
    }
    return 0;
}

template <class _CharT>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
size_t
char_traits<_CharT>::length(const char_type* __s)
{
    size_t __len = 0;
    for (; !eq(*__s, char_type(0)); ++__s)
        ++__len;
    return __len;
}

template <class _CharT>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
const _CharT*
char_traits<_CharT>::find(const char_type* __s, size_t __n, const char_type& __a)
{
    for (; __n; --__n)
    {
        if (eq(*__s, __a))
            return __s;
        ++__s;
    }
    return 0;
}

template <class _CharT>
_CharT*
char_traits<_CharT>::move(char_type* __s1, const char_type* __s2, size_t __n)
{
    char_type* __r = __s1;
    if (__s1 < __s2)
    {
        for (; __n; --__n, ++__s1, ++__s2)
            assign(*__s1, *__s2);
    }
    else if (__s2 < __s1)
    {
        __s1 += __n;
        __s2 += __n;
        for (; __n; --__n)
            assign(*--__s1, *--__s2);
    }
    return __r;
}

template <class _CharT>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_CharT*
char_traits<_CharT>::copy(char_type* __s1, const char_type* __s2, size_t __n)
{
    ((void)0);
    char_type* __r = __s1;
    for (; __n; --__n, ++__s1, ++__s2)
        assign(*__s1, *__s2);
    return __r;
}

template <class _CharT>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_CharT*
char_traits<_CharT>::assign(char_type* __s, size_t __n, char_type __a)
{
    char_type* __r = __s;
    for (; __n; --__n, ++__s)
        assign(*__s, __a);
    return __r;
}

// char_traits<char>

template <>
struct __attribute__ ((__type_visibility__("default"))) char_traits<char>
{
    typedef char char_type;
    typedef int int_type;
    typedef streamoff off_type;
    typedef streampos pos_type;
    typedef mbstate_t state_type;

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static void assign(char_type& __c1, const char_type& __c2) throw()
        {__c1 = __c2;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static bool eq(char_type __c1, char_type __c2) throw()
            {return __c1 == __c2;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static bool lt(char_type __c1, char_type __c2) throw()
        {return (unsigned char)__c1 < (unsigned char)__c2;}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static int compare(const char_type* __s1, const char_type* __s2, size_t __n)
        {return memcmp(__s1, __s2, __n);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static size_t length(const char_type* __s) {return strlen(__s);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static const char_type* find(const char_type* __s, size_t __n, const char_type& __a)
        {return (const char_type*)memchr(__s, to_int_type(__a), __n);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static char_type* move(char_type* __s1, const char_type* __s2, size_t __n)
        {return (char_type*)memmove(__s1, __s2, __n);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static char_type* copy(char_type* __s1, const char_type* __s2, size_t __n)
        {
            ((void)0);
            return (char_type*)memcpy(__s1, __s2, __n);
        }
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static char_type* assign(char_type* __s, size_t __n, char_type __a)
        {return (char_type*)memset(__s, to_int_type(__a), __n);}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static int_type not_eof(int_type __c) throw()
        {return eq_int_type(__c, eof()) ? ~eof() : __c;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static char_type to_char_type(int_type __c) throw()
        {return char_type(__c);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static int_type to_int_type(char_type __c) throw()
        {return int_type((unsigned char)__c);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static bool eq_int_type(int_type __c1, int_type __c2) throw()
        {return __c1 == __c2;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static int_type eof() throw()
        {return int_type((-1));}
};

// char_traits<wchar_t>

template <>
struct __attribute__ ((__type_visibility__("default"))) char_traits<wchar_t>
{
    typedef wchar_t char_type;
    typedef wint_t int_type;
    typedef streamoff off_type;
    typedef streampos pos_type;
    typedef mbstate_t state_type;

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static void assign(char_type& __c1, const char_type& __c2) throw()
        {__c1 = __c2;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static bool eq(char_type __c1, char_type __c2) throw()
        {return __c1 == __c2;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static bool lt(char_type __c1, char_type __c2) throw()
        {return __c1 < __c2;}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static int compare(const char_type* __s1, const char_type* __s2, size_t __n)
        {return wmemcmp(__s1, __s2, __n);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static size_t length(const char_type* __s)
        {return wcslen(__s);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static const char_type* find(const char_type* __s, size_t __n, const char_type& __a)
        {return (const char_type*)wmemchr(__s, __a, __n);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static char_type* move(char_type* __s1, const char_type* __s2, size_t __n)
        {return (char_type*)wmemmove(__s1, __s2, __n);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static char_type* copy(char_type* __s1, const char_type* __s2, size_t __n)
        {
            ((void)0);
            return (char_type*)wmemcpy(__s1, __s2, __n);
        }
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static char_type* assign(char_type* __s, size_t __n, char_type __a)
        {return (char_type*)wmemset(__s, __a, __n);}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static int_type not_eof(int_type __c) throw()
        {return eq_int_type(__c, eof()) ? ~eof() : __c;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static char_type to_char_type(int_type __c) throw()
        {return char_type(__c);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static int_type to_int_type(char_type __c) throw()
        {return int_type(__c);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static bool eq_int_type(int_type __c1, int_type __c2) throw()
        {return __c1 == __c2;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static int_type eof() throw()
        {return int_type(((__darwin_wint_t)-1));}
};



template <>
struct __attribute__ ((__type_visibility__("default"))) char_traits<char16_t>
{
    typedef char16_t char_type;
    typedef uint_least16_t int_type;
    typedef streamoff off_type;
    typedef u16streampos pos_type;
    typedef mbstate_t state_type;

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static void assign(char_type& __c1, const char_type& __c2) throw()
        {__c1 = __c2;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static bool eq(char_type __c1, char_type __c2) throw()
        {return __c1 == __c2;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static bool lt(char_type __c1, char_type __c2) throw()
        {return __c1 < __c2;}

    static int compare(const char_type* __s1, const char_type* __s2, size_t __n);
    static size_t length(const char_type* __s);
    static const char_type* find(const char_type* __s, size_t __n, const char_type& __a);
    static char_type* move(char_type* __s1, const char_type* __s2, size_t __n);
    static char_type* copy(char_type* __s1, const char_type* __s2, size_t __n);
    static char_type* assign(char_type* __s, size_t __n, char_type __a);

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static int_type not_eof(int_type __c) throw()
        {return eq_int_type(__c, eof()) ? ~eof() : __c;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static char_type to_char_type(int_type __c) throw()
        {return char_type(__c);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static int_type to_int_type(char_type __c) throw()
        {return int_type(__c);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static bool eq_int_type(int_type __c1, int_type __c2) throw()
        {return __c1 == __c2;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static int_type eof() throw()
        {return int_type(0xDFFF);}
};

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
int
char_traits<char16_t>::compare(const char_type* __s1, const char_type* __s2, size_t __n)
{
    for (; __n; --__n, ++__s1, ++__s2)
    {
        if (lt(*__s1, *__s2))
            return -1;
        if (lt(*__s2, *__s1))
            return 1;
    }
    return 0;
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
size_t
char_traits<char16_t>::length(const char_type* __s)
{
    size_t __len = 0;
    for (; !eq(*__s, char_type(0)); ++__s)
        ++__len;
    return __len;
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
const char16_t*
char_traits<char16_t>::find(const char_type* __s, size_t __n, const char_type& __a)
{
    for (; __n; --__n)
    {
        if (eq(*__s, __a))
            return __s;
        ++__s;
    }
    return 0;
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
char16_t*
char_traits<char16_t>::move(char_type* __s1, const char_type* __s2, size_t __n)
{
    char_type* __r = __s1;
    if (__s1 < __s2)
    {
        for (; __n; --__n, ++__s1, ++__s2)
            assign(*__s1, *__s2);
    }
    else if (__s2 < __s1)
    {
        __s1 += __n;
        __s2 += __n;
        for (; __n; --__n)
            assign(*--__s1, *--__s2);
    }
    return __r;
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
char16_t*
char_traits<char16_t>::copy(char_type* __s1, const char_type* __s2, size_t __n)
{
    ((void)0);
    char_type* __r = __s1;
    for (; __n; --__n, ++__s1, ++__s2)
        assign(*__s1, *__s2);
    return __r;
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
char16_t*
char_traits<char16_t>::assign(char_type* __s, size_t __n, char_type __a)
{
    char_type* __r = __s;
    for (; __n; --__n, ++__s)
        assign(*__s, __a);
    return __r;
}

template <>
struct __attribute__ ((__type_visibility__("default"))) char_traits<char32_t>
{
    typedef char32_t char_type;
    typedef uint_least32_t int_type;
    typedef streamoff off_type;
    typedef u32streampos pos_type;
    typedef mbstate_t state_type;

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static void assign(char_type& __c1, const char_type& __c2) throw()
        {__c1 = __c2;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static bool eq(char_type __c1, char_type __c2) throw()
        {return __c1 == __c2;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static bool lt(char_type __c1, char_type __c2) throw()
        {return __c1 < __c2;}

    static int compare(const char_type* __s1, const char_type* __s2, size_t __n);
    static size_t length(const char_type* __s);
    static const char_type* find(const char_type* __s, size_t __n, const char_type& __a);
    static char_type* move(char_type* __s1, const char_type* __s2, size_t __n);
    static char_type* copy(char_type* __s1, const char_type* __s2, size_t __n);
    static char_type* assign(char_type* __s, size_t __n, char_type __a);

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static int_type not_eof(int_type __c) throw()
        {return eq_int_type(__c, eof()) ? ~eof() : __c;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static char_type to_char_type(int_type __c) throw()
        {return char_type(__c);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static int_type to_int_type(char_type __c) throw()
        {return int_type(__c);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static bool eq_int_type(int_type __c1, int_type __c2) throw()
        {return __c1 == __c2;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static int_type eof() throw()
        {return int_type(0xFFFFFFFF);}
};

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
int
char_traits<char32_t>::compare(const char_type* __s1, const char_type* __s2, size_t __n)
{
    for (; __n; --__n, ++__s1, ++__s2)
    {
        if (lt(*__s1, *__s2))
            return -1;
        if (lt(*__s2, *__s1))
            return 1;
    }
    return 0;
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
size_t
char_traits<char32_t>::length(const char_type* __s)
{
    size_t __len = 0;
    for (; !eq(*__s, char_type(0)); ++__s)
        ++__len;
    return __len;
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
const char32_t*
char_traits<char32_t>::find(const char_type* __s, size_t __n, const char_type& __a)
{
    for (; __n; --__n)
    {
        if (eq(*__s, __a))
            return __s;
        ++__s;
    }
    return 0;
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
char32_t*
char_traits<char32_t>::move(char_type* __s1, const char_type* __s2, size_t __n)
{
    char_type* __r = __s1;
    if (__s1 < __s2)
    {
        for (; __n; --__n, ++__s1, ++__s2)
            assign(*__s1, *__s2);
    }
    else if (__s2 < __s1)
    {
        __s1 += __n;
        __s2 += __n;
        for (; __n; --__n)
            assign(*--__s1, *--__s2);
    }
    return __r;
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
char32_t*
char_traits<char32_t>::copy(char_type* __s1, const char_type* __s2, size_t __n)
{
    ((void)0);
    char_type* __r = __s1;
    for (; __n; --__n, ++__s1, ++__s2)
        assign(*__s1, *__s2);
    return __r;
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
char32_t*
char_traits<char32_t>::assign(char_type* __s, size_t __n, char_type __a)
{
    char_type* __r = __s;
    for (; __n; --__n, ++__s)
        assign(*__s, __a);
    return __r;
}



// helper fns for basic_string

// __str_find
template<class _CharT, class _SizeT, class _Traits, _SizeT __npos>
_SizeT __attribute__ ((__visibility__("hidden"), __always_inline__))
__str_find(const _CharT *__p, _SizeT __sz,
             _CharT __c, _SizeT __pos) throw()
{
    if (__pos >= __sz)
        return __npos;
    const _CharT* __r = _Traits::find(__p + __pos, __sz - __pos, __c);
    if (__r == 0)
        return __npos;
    return static_cast<_SizeT>(__r - __p);
}

template<class _CharT, class _SizeT, class _Traits, _SizeT __npos>
_SizeT __attribute__ ((__visibility__("hidden"), __always_inline__))
__str_find(const _CharT *__p, _SizeT __sz,
       const _CharT* __s, _SizeT __pos, _SizeT __n) throw()
{
    if (__pos > __sz || __sz - __pos < __n)
        return __npos;
    if (__n == 0)
        return __pos;
    const _CharT* __r =
        std::__1::__search(__p + __pos, __p + __sz,
                        __s, __s + __n, _Traits::eq,
                        random_access_iterator_tag(), random_access_iterator_tag());
    if (__r == __p + __sz)
        return __npos;
    return static_cast<_SizeT>(__r - __p);
}


// __str_rfind

template<class _CharT, class _SizeT, class _Traits, _SizeT __npos>
_SizeT __attribute__ ((__visibility__("hidden"), __always_inline__))
__str_rfind(const _CharT *__p, _SizeT __sz,
              _CharT __c, _SizeT __pos) throw()
{
    if (__sz < 1)
        return __npos;
    if (__pos < __sz)
        ++__pos;
    else
        __pos = __sz;
    for (const _CharT* __ps = __p + __pos; __ps != __p;)
    {
        if (_Traits::eq(*--__ps, __c))
            return static_cast<_SizeT>(__ps - __p);
    }
    return __npos;
}

template<class _CharT, class _SizeT, class _Traits, _SizeT __npos>
_SizeT __attribute__ ((__visibility__("hidden"), __always_inline__))
__str_rfind(const _CharT *__p, _SizeT __sz,
        const _CharT* __s, _SizeT __pos, _SizeT __n) throw()
{
    __pos = std::__1::min(__pos, __sz);
    if (__n < __sz - __pos)
        __pos += __n;
    else
        __pos = __sz;
    const _CharT* __r = std::__1::__find_end(
                  __p, __p + __pos, __s, __s + __n, _Traits::eq,
                        random_access_iterator_tag(), random_access_iterator_tag());
    if (__n > 0 && __r == __p + __pos)
        return __npos;
    return static_cast<_SizeT>(__r - __p);
}

// __str_find_first_of
template<class _CharT, class _SizeT, class _Traits, _SizeT __npos>
_SizeT __attribute__ ((__visibility__("hidden"), __always_inline__))
__str_find_first_of(const _CharT *__p, _SizeT __sz,
                const _CharT* __s, _SizeT __pos, _SizeT __n) throw()
{
    if (__pos >= __sz || __n == 0)
        return __npos;
    const _CharT* __r = std::__1::__find_first_of_ce
        (__p + __pos, __p + __sz, __s, __s + __n, _Traits::eq );
    if (__r == __p + __sz)
        return __npos;
    return static_cast<_SizeT>(__r - __p);
}


// __str_find_last_of
template<class _CharT, class _SizeT, class _Traits, _SizeT __npos>
_SizeT __attribute__ ((__visibility__("hidden"), __always_inline__))
__str_find_last_of(const _CharT *__p, _SizeT __sz,
               const _CharT* __s, _SizeT __pos, _SizeT __n) throw()
    {
    if (__n != 0)
    {
        if (__pos < __sz)
            ++__pos;
        else
            __pos = __sz;
        for (const _CharT* __ps = __p + __pos; __ps != __p;)
        {
            const _CharT* __r = _Traits::find(__s, __n, *--__ps);
            if (__r)
                return static_cast<_SizeT>(__ps - __p);
        }
    }
    return __npos;
}


// __str_find_first_not_of
template<class _CharT, class _SizeT, class _Traits, _SizeT __npos>
_SizeT __attribute__ ((__visibility__("hidden"), __always_inline__))
__str_find_first_not_of(const _CharT *__p, _SizeT __sz,
                    const _CharT* __s, _SizeT __pos, _SizeT __n) throw()
{
    if (__pos < __sz)
    {
        const _CharT* __pe = __p + __sz;
        for (const _CharT* __ps = __p + __pos; __ps != __pe; ++__ps)
            if (_Traits::find(__s, __n, *__ps) == 0)
                return static_cast<_SizeT>(__ps - __p);
    }
    return __npos;
}


template<class _CharT, class _SizeT, class _Traits, _SizeT __npos>
_SizeT __attribute__ ((__visibility__("hidden"), __always_inline__))
__str_find_first_not_of(const _CharT *__p, _SizeT __sz,
                          _CharT __c, _SizeT __pos) throw()
{
    if (__pos < __sz)
    {
        const _CharT* __pe = __p + __sz;
        for (const _CharT* __ps = __p + __pos; __ps != __pe; ++__ps)
            if (!_Traits::eq(*__ps, __c))
                return static_cast<_SizeT>(__ps - __p);
    }
    return __npos;
}


// __str_find_last_not_of
template<class _CharT, class _SizeT, class _Traits, _SizeT __npos>
_SizeT __attribute__ ((__visibility__("hidden"), __always_inline__))
__str_find_last_not_of(const _CharT *__p, _SizeT __sz,
                   const _CharT* __s, _SizeT __pos, _SizeT __n) throw()
{
    if (__pos < __sz)
        ++__pos;
    else
        __pos = __sz;
    for (const _CharT* __ps = __p + __pos; __ps != __p;)
        if (_Traits::find(__s, __n, *--__ps) == 0)
            return static_cast<_SizeT>(__ps - __p);
    return __npos;
}


template<class _CharT, class _SizeT, class _Traits, _SizeT __npos>
_SizeT __attribute__ ((__visibility__("hidden"), __always_inline__))
__str_find_last_not_of(const _CharT *__p, _SizeT __sz,
                         _CharT __c, _SizeT __pos) throw()
{
    if (__pos < __sz)
        ++__pos;
    else
        __pos = __sz;
    for (const _CharT* __ps = __p + __pos; __ps != __p;)
        if (!_Traits::eq(*--__ps, __c))
            return static_cast<_SizeT>(__ps - __p);
    return __npos;
}

template<class _Ptr>
size_t __attribute__ ((__visibility__("hidden"), __always_inline__)) __do_string_hash(_Ptr __p, _Ptr __e)
{
    typedef typename iterator_traits<_Ptr>::value_type value_type;
    return __murmur2_or_cityhash<size_t>()(__p, (__e-__p)*sizeof(value_type));
}

// basic_string

template<class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>
operator+(const basic_string<_CharT, _Traits, _Allocator>& __x,
          const basic_string<_CharT, _Traits, _Allocator>& __y);

template<class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>
operator+(const _CharT* __x, const basic_string<_CharT,_Traits,_Allocator>& __y);

template<class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>
operator+(_CharT __x, const basic_string<_CharT,_Traits,_Allocator>& __y);

template<class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>
operator+(const basic_string<_CharT, _Traits, _Allocator>& __x, const _CharT* __y);

template<class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>
operator+(const basic_string<_CharT, _Traits, _Allocator>& __x, _CharT __y);

template <bool>
class __attribute__ ((__type_visibility__("default"))) __basic_string_common
{
protected:
    void __throw_length_error() const;
    void __throw_out_of_range() const;
};

template <bool __b>
void
__basic_string_common<__b>::__throw_length_error() const
{

    throw length_error("basic_string");



}

template <bool __b>
void
__basic_string_common<__b>::__throw_out_of_range() const
{

    throw out_of_range("basic_string");



}
# 1253 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/string" 3
template<class _CharT, class _Traits, class _Allocator>
class __attribute__ ((__type_visibility__("default"))) basic_string
    : private __basic_string_common<true>
{
public:
    typedef basic_string __self;
    typedef _Traits traits_type;
    typedef typename traits_type::char_type value_type;
    typedef _Allocator allocator_type;
    typedef allocator_traits<allocator_type> __alloc_traits;
    typedef typename __alloc_traits::size_type size_type;
    typedef typename __alloc_traits::difference_type difference_type;
    typedef value_type& reference;
    typedef const value_type& const_reference;
    typedef typename __alloc_traits::pointer pointer;
    typedef typename __alloc_traits::const_pointer const_pointer;

    typedef __static_assert_check<sizeof(__static_assert_test<(is_pod<value_type>::value)>)> __t1270;
    typedef __static_assert_check<sizeof(__static_assert_test<((is_same<_CharT, value_type>::value))>)> __t1272;

    typedef __static_assert_check<sizeof(__static_assert_test<((is_same<typename allocator_type::value_type, value_type>::value))>)> __t1274;





    typedef __wrap_iter<pointer> iterator;
    typedef __wrap_iter<const_pointer> const_iterator;

    typedef std::__1::reverse_iterator<iterator> reverse_iterator;
    typedef std::__1::reverse_iterator<const_iterator> const_reverse_iterator;

private:
# 1319 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/string" 3
    struct __long
    {
        size_type __cap_;
        size_type __size_;
        pointer __data_;
    };





    enum {__short_mask = 0x01};
    enum {__long_mask = 0x1ul};


    enum {__min_cap = (sizeof(__long) - 1)/sizeof(value_type) > 2 ?
                      (sizeof(__long) - 1)/sizeof(value_type) : 2};

    struct __short
    {
        union
        {
            unsigned char __size_;
            value_type __lx;
        };
        value_type __data_[__min_cap];
    };



    union __ulx{__long __lx; __short __lxx;};

    enum {__n_words = sizeof(__ulx) / sizeof(size_type)};

    struct __raw
    {
        size_type __words[__n_words];
    };

    struct __rep
    {
        union
        {
            __long __l;
            __short __s;
            __raw __r;
        };
    };

    __compressed_pair<__rep, allocator_type> __r_;

public:
    static const size_type npos = -1;

    __attribute__ ((__visibility__("hidden"), __always_inline__)) basic_string()
                                                                           ;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit basic_string(const allocator_type& __a);
    basic_string(const basic_string& __str);
    basic_string(const basic_string& __str, const allocator_type& __a);







    __attribute__ ((__visibility__("hidden"), __always_inline__)) basic_string(const value_type* __s);
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    basic_string(const value_type* __s, const allocator_type& __a);
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    basic_string(const value_type* __s, size_type __n);
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    basic_string(const value_type* __s, size_type __n, const allocator_type& __a);
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    basic_string(size_type __n, value_type __c);
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    basic_string(size_type __n, value_type __c, const allocator_type& __a);
    basic_string(const basic_string& __str, size_type __pos, size_type __n = npos,
                 const allocator_type& __a = allocator_type());
    template<class _InputIterator>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        basic_string(_InputIterator __first, _InputIterator __last);
    template<class _InputIterator>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        basic_string(_InputIterator __first, _InputIterator __last, const allocator_type& __a);







    ~basic_string();

    basic_string& operator=(const basic_string& __str);






    __attribute__ ((__visibility__("hidden"), __always_inline__)) basic_string& operator=(const value_type* __s) {return assign(__s);}
    basic_string& operator=(value_type __c);
# 1441 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/string" 3
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iterator begin() throw()
        {return iterator(__get_pointer());}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const_iterator begin() const throw()
        {return const_iterator(__get_pointer());}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iterator end() throw()
        {return iterator(__get_pointer() + size());}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const_iterator end() const throw()
        {return const_iterator(__get_pointer() + size());}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    reverse_iterator rbegin() throw()
        {return reverse_iterator(end());}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const_reverse_iterator rbegin() const throw()
        {return const_reverse_iterator(end());}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    reverse_iterator rend() throw()
        {return reverse_iterator(begin());}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const_reverse_iterator rend() const throw()
        {return const_reverse_iterator(begin());}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const_iterator cbegin() const throw()
        {return begin();}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const_iterator cend() const throw()
        {return end();}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const_reverse_iterator crbegin() const throw()
        {return rbegin();}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const_reverse_iterator crend() const throw()
        {return rend();}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) size_type size() const throw()
        {return __is_long() ? __get_long_size() : __get_short_size();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) size_type length() const throw() {return size();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) size_type max_size() const throw();
    __attribute__ ((__visibility__("hidden"), __always_inline__)) size_type capacity() const throw()
        {return (__is_long() ? __get_long_cap() : __min_cap) - 1;}

    void resize(size_type __n, value_type __c);
    __attribute__ ((__visibility__("hidden"), __always_inline__)) void resize(size_type __n) {resize(__n, value_type());}

    void reserve(size_type res_arg = 0);
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void shrink_to_fit() throw() {reserve();}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void clear() throw();
    __attribute__ ((__visibility__("hidden"), __always_inline__)) bool empty() const throw() {return size() == 0;}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) const_reference operator[](size_type __pos) const;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) reference operator[](size_type __pos);

    const_reference at(size_type __n) const;
    reference at(size_type __n);

    __attribute__ ((__visibility__("hidden"), __always_inline__)) basic_string& operator+=(const basic_string& __str) {return append(__str);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) basic_string& operator+=(const value_type* __s) {return append(__s);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) basic_string& operator+=(value_type __c) {push_back(__c); return *this;}




    __attribute__ ((__visibility__("hidden"), __always_inline__))
    basic_string& append(const basic_string& __str);
    basic_string& append(const basic_string& __str, size_type __pos, size_type __n=npos);
    basic_string& append(const value_type* __s, size_type __n);
    basic_string& append(const value_type* __s);
    basic_string& append(size_type __n, value_type __c);
    template<class _InputIterator>
        typename enable_if
        <
             __is_input_iterator <_InputIterator>::value &&
            !__is_forward_iterator<_InputIterator>::value,
            basic_string&
        >::type
        append(_InputIterator __first, _InputIterator __last);
    template<class _ForwardIterator>
        typename enable_if
        <
            __is_forward_iterator<_ForwardIterator>::value,
            basic_string&
        >::type
        append(_ForwardIterator __first, _ForwardIterator __last);





    void push_back(value_type __c);
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void pop_back();
    __attribute__ ((__visibility__("hidden"), __always_inline__)) reference front();
    __attribute__ ((__visibility__("hidden"), __always_inline__)) const_reference front() const;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) reference back();
    __attribute__ ((__visibility__("hidden"), __always_inline__)) const_reference back() const;

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    basic_string& assign(const basic_string& __str);





    basic_string& assign(const basic_string& __str, size_type __pos, size_type __n=npos);
    basic_string& assign(const value_type* __s, size_type __n);
    basic_string& assign(const value_type* __s);
    basic_string& assign(size_type __n, value_type __c);
    template<class _InputIterator>
        typename enable_if
        <
             __is_input_iterator <_InputIterator>::value &&
            !__is_forward_iterator<_InputIterator>::value,
            basic_string&
        >::type
        assign(_InputIterator __first, _InputIterator __last);
    template<class _ForwardIterator>
        typename enable_if
        <
            __is_forward_iterator<_ForwardIterator>::value,
            basic_string&
        >::type
        assign(_ForwardIterator __first, _ForwardIterator __last);





    __attribute__ ((__visibility__("hidden"), __always_inline__))
    basic_string& insert(size_type __pos1, const basic_string& __str);
    basic_string& insert(size_type __pos1, const basic_string& __str, size_type __pos2, size_type __n=npos);
    basic_string& insert(size_type __pos, const value_type* __s, size_type __n);
    basic_string& insert(size_type __pos, const value_type* __s);
    basic_string& insert(size_type __pos, size_type __n, value_type __c);
    iterator insert(const_iterator __pos, value_type __c);
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iterator insert(const_iterator __pos, size_type __n, value_type __c);
    template<class _InputIterator>
        typename enable_if
        <
             __is_input_iterator <_InputIterator>::value &&
            !__is_forward_iterator<_InputIterator>::value,
            iterator
        >::type
        insert(const_iterator __pos, _InputIterator __first, _InputIterator __last);
    template<class _ForwardIterator>
        typename enable_if
        <
            __is_forward_iterator<_ForwardIterator>::value,
            iterator
        >::type
        insert(const_iterator __pos, _ForwardIterator __first, _ForwardIterator __last);






    basic_string& erase(size_type __pos = 0, size_type __n = npos);
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iterator erase(const_iterator __pos);
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iterator erase(const_iterator __first, const_iterator __last);

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    basic_string& replace(size_type __pos1, size_type __n1, const basic_string& __str);
    basic_string& replace(size_type __pos1, size_type __n1, const basic_string& __str, size_type __pos2, size_type __n2=npos);
    basic_string& replace(size_type __pos, size_type __n1, const value_type* __s, size_type __n2);
    basic_string& replace(size_type __pos, size_type __n1, const value_type* __s);
    basic_string& replace(size_type __pos, size_type __n1, size_type __n2, value_type __c);
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    basic_string& replace(const_iterator __i1, const_iterator __i2, const basic_string& __str);
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    basic_string& replace(const_iterator __i1, const_iterator __i2, const value_type* __s, size_type __n);
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    basic_string& replace(const_iterator __i1, const_iterator __i2, const value_type* __s);
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    basic_string& replace(const_iterator __i1, const_iterator __i2, size_type __n, value_type __c);
    template<class _InputIterator>
        typename enable_if
        <
            __is_input_iterator<_InputIterator>::value,
            basic_string&
        >::type
        replace(const_iterator __i1, const_iterator __i2, _InputIterator __j1, _InputIterator __j2);






    size_type copy(value_type* __s, size_type __n, size_type __pos = 0) const;
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    basic_string substr(size_type __pos = 0, size_type __n = npos) const;

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void swap(basic_string& __str)

                                                                 ;

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const value_type* c_str() const throw() {return data();}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const value_type* data() const throw() {return std::__1::__to_raw_pointer(__get_pointer());}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    allocator_type get_allocator() const throw() {return __alloc();}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_type find(const basic_string& __str, size_type __pos = 0) const throw();
    size_type find(const value_type* __s, size_type __pos, size_type __n) const throw();
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_type find(const value_type* __s, size_type __pos = 0) const throw();
    size_type find(value_type __c, size_type __pos = 0) const throw();

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_type rfind(const basic_string& __str, size_type __pos = npos) const throw();
    size_type rfind(const value_type* __s, size_type __pos, size_type __n) const throw();
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_type rfind(const value_type* __s, size_type __pos = npos) const throw();
    size_type rfind(value_type __c, size_type __pos = npos) const throw();

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_type find_first_of(const basic_string& __str, size_type __pos = 0) const throw();
    size_type find_first_of(const value_type* __s, size_type __pos, size_type __n) const throw();
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_type find_first_of(const value_type* __s, size_type __pos = 0) const throw();
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_type find_first_of(value_type __c, size_type __pos = 0) const throw();

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_type find_last_of(const basic_string& __str, size_type __pos = npos) const throw();
    size_type find_last_of(const value_type* __s, size_type __pos, size_type __n) const throw();
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_type find_last_of(const value_type* __s, size_type __pos = npos) const throw();
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_type find_last_of(value_type __c, size_type __pos = npos) const throw();

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_type find_first_not_of(const basic_string& __str, size_type __pos = 0) const throw();
    size_type find_first_not_of(const value_type* __s, size_type __pos, size_type __n) const throw();
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_type find_first_not_of(const value_type* __s, size_type __pos = 0) const throw();
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_type find_first_not_of(value_type __c, size_type __pos = 0) const throw();

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_type find_last_not_of(const basic_string& __str, size_type __pos = npos) const throw();
    size_type find_last_not_of(const value_type* __s, size_type __pos, size_type __n) const throw();
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_type find_last_not_of(const value_type* __s, size_type __pos = npos) const throw();
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_type find_last_not_of(value_type __c, size_type __pos = npos) const throw();

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    int compare(const basic_string& __str) const throw();
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    int compare(size_type __pos1, size_type __n1, const basic_string& __str) const;
    int compare(size_type __pos1, size_type __n1, const basic_string& __str, size_type __pos2, size_type __n2=npos) const;
    int compare(const value_type* __s) const throw();
    int compare(size_type __pos1, size_type __n1, const value_type* __s) const;
    int compare(size_type __pos1, size_type __n1, const value_type* __s, size_type __n2) const;

    __attribute__ ((__visibility__("hidden"), __always_inline__)) bool __invariants() const;

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool __is_long() const throw()
        {return bool(__r_.first().__s.__size_ & __short_mask);}
# 1725 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/string" 3
private:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    allocator_type& __alloc() throw()
        {return __r_.second();}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const allocator_type& __alloc() const throw()
        {return __r_.second();}
# 1753 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/string" 3
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void __set_short_size(size_type __s) throw()



        {__r_.first().__s.__size_ = (unsigned char)(__s << 1);}


    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_type __get_short_size() const throw()



        {return __r_.first().__s.__size_ >> 1;}




    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void __set_long_size(size_type __s) throw()
        {__r_.first().__l.__size_ = __s;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_type __get_long_size() const throw()
        {return __r_.first().__l.__size_;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void __set_size(size_type __s) throw()
        {if (__is_long()) __set_long_size(__s); else __set_short_size(__s);}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void __set_long_cap(size_type __s) throw()
        {__r_.first().__l.__cap_ = __long_mask | __s;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_type __get_long_cap() const throw()
        {return __r_.first().__l.__cap_ & size_type(~__long_mask);}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void __set_long_pointer(pointer __p) throw()
        {__r_.first().__l.__data_ = __p;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    pointer __get_long_pointer() throw()
        {return __r_.first().__l.__data_;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const_pointer __get_long_pointer() const throw()
        {return __r_.first().__l.__data_;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    pointer __get_short_pointer() throw()
        {return pointer_traits<pointer>::pointer_to(__r_.first().__s.__data_[0]);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const_pointer __get_short_pointer() const throw()
        {return pointer_traits<const_pointer>::pointer_to(__r_.first().__s.__data_[0]);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    pointer __get_pointer() throw()
        {return __is_long() ? __get_long_pointer() : __get_short_pointer();}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const_pointer __get_pointer() const throw()
        {return __is_long() ? __get_long_pointer() : __get_short_pointer();}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void __zero() throw()
        {
            size_type (&__a)[__n_words] = __r_.first().__r.__words;
            for (unsigned __i = 0; __i < __n_words; ++__i)
                __a[__i] = 0;
        }

    template <size_type __a> static
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        size_type __align_it(size_type __s) throw()
            {return __s + (__a-1) & ~(__a-1);}
    enum {__alignment = 16};
    static __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_type __recommend(size_type __s) throw()
        {return (__s < __min_cap ? __min_cap :
                 __align_it<sizeof(value_type) < __alignment ?
                            __alignment/sizeof(value_type) : 1 > (__s+1)) - 1;}

    void __init(const value_type* __s, size_type __sz, size_type __reserve);
    void __init(const value_type* __s, size_type __sz);
    void __init(size_type __n, value_type __c);

    template <class _InputIterator>
    typename enable_if
    <
         __is_input_iterator <_InputIterator>::value &&
        !__is_forward_iterator<_InputIterator>::value,
        void
    >::type
    __init(_InputIterator __first, _InputIterator __last);

    template <class _ForwardIterator>
    typename enable_if
    <
        __is_forward_iterator<_ForwardIterator>::value,
        void
    >::type
    __init(_ForwardIterator __first, _ForwardIterator __last);

    void __grow_by(size_type __old_cap, size_type __delta_cap, size_type __old_sz,
                   size_type __n_copy, size_type __n_del, size_type __n_add = 0);
    void __grow_by_and_replace(size_type __old_cap, size_type __delta_cap, size_type __old_sz,
                               size_type __n_copy, size_type __n_del,
                               size_type __n_add, const value_type* __p_new_stuff);

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void __erase_to_end(size_type __pos);

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void __copy_assign_alloc(const basic_string& __str)
        {__copy_assign_alloc(__str, integral_constant<bool,
                      __alloc_traits::propagate_on_container_copy_assignment::value>());}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void __copy_assign_alloc(const basic_string& __str, true_type)
        {
            if (__alloc() != __str.__alloc())
            {
                clear();
                shrink_to_fit();
            }
            __alloc() = __str.__alloc();
        }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void __copy_assign_alloc(const basic_string&, false_type) throw()
        {}
# 1887 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/string" 3
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void
    __move_assign_alloc(basic_string& __str)



    {__move_assign_alloc(__str, integral_constant<bool,
                      __alloc_traits::propagate_on_container_move_assignment::value>());}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void __move_assign_alloc(basic_string& __c, true_type)

        {
            __alloc() = std::__1::move(__c.__alloc());
        }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void __move_assign_alloc(basic_string&, false_type)
        throw()
        {}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static void __swap_alloc(allocator_type& __x, allocator_type& __y)


        {__swap_alloc(__x, __y, integral_constant<bool,
                      __alloc_traits::propagate_on_container_swap::value>());}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static void __swap_alloc(allocator_type& __x, allocator_type& __y, true_type)

        {
            using std::__1::swap;
            swap(__x, __y);
        }
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static void __swap_alloc(allocator_type&, allocator_type&, false_type) throw()
        {}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) void __invalidate_all_iterators();
    __attribute__ ((__visibility__("hidden"), __always_inline__)) void __invalidate_iterators_past(size_type);

    friend basic_string operator+<>(const basic_string&, const basic_string&);
    friend basic_string operator+<>(const value_type*, const basic_string&);
    friend basic_string operator+<>(value_type, const basic_string&);
    friend basic_string operator+<>(const basic_string&, const value_type*);
    friend basic_string operator+<>(const basic_string&, value_type);
};

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
basic_string<_CharT, _Traits, _Allocator>::__invalidate_all_iterators()
{



}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
basic_string<_CharT, _Traits, _Allocator>::__invalidate_iterators_past(size_type



                                                                      )
{
# 1974 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/string" 3
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_string<_CharT, _Traits, _Allocator>::basic_string()

{



    __zero();
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_string<_CharT, _Traits, _Allocator>::basic_string(const allocator_type& __a)
    : __r_(__a)
{



    __zero();
}

template <class _CharT, class _Traits, class _Allocator>
void
basic_string<_CharT, _Traits, _Allocator>::__init(const value_type* __s, size_type __sz, size_type __reserve)
{
    if (__reserve > max_size())
        this->__throw_length_error();
    pointer __p;
    if (__reserve < __min_cap)
    {
        __set_short_size(__sz);
        __p = __get_short_pointer();
    }
    else
    {
        size_type __cap = __recommend(__reserve);
        __p = __alloc_traits::allocate(__alloc(), __cap+1);
        __set_long_pointer(__p);
        __set_long_cap(__cap+1);
        __set_long_size(__sz);
    }
    traits_type::copy(std::__1::__to_raw_pointer(__p), __s, __sz);
    traits_type::assign(__p[__sz], value_type());
}

template <class _CharT, class _Traits, class _Allocator>
void
basic_string<_CharT, _Traits, _Allocator>::__init(const value_type* __s, size_type __sz)
{
    if (__sz > max_size())
        this->__throw_length_error();
    pointer __p;
    if (__sz < __min_cap)
    {
        __set_short_size(__sz);
        __p = __get_short_pointer();
    }
    else
    {
        size_type __cap = __recommend(__sz);
        __p = __alloc_traits::allocate(__alloc(), __cap+1);
        __set_long_pointer(__p);
        __set_long_cap(__cap+1);
        __set_long_size(__sz);
    }
    traits_type::copy(std::__1::__to_raw_pointer(__p), __s, __sz);
    traits_type::assign(__p[__sz], value_type());
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_string<_CharT, _Traits, _Allocator>::basic_string(const value_type* __s)
{
    ((void)0);
    __init(__s, traits_type::length(__s));



}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_string<_CharT, _Traits, _Allocator>::basic_string(const value_type* __s, const allocator_type& __a)
    : __r_(__a)
{
    ((void)0);
    __init(__s, traits_type::length(__s));



}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_string<_CharT, _Traits, _Allocator>::basic_string(const value_type* __s, size_type __n)
{
    ((void)0);
    __init(__s, __n);



}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_string<_CharT, _Traits, _Allocator>::basic_string(const value_type* __s, size_type __n, const allocator_type& __a)
    : __r_(__a)
{
    ((void)0);
    __init(__s, __n);



}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>::basic_string(const basic_string& __str)
    : __r_(__alloc_traits::select_on_container_copy_construction(__str.__alloc()))
{
    if (!__str.__is_long())
        __r_.first().__r = __str.__r_.first().__r;
    else
        __init(std::__1::__to_raw_pointer(__str.__get_long_pointer()), __str.__get_long_size());



}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>::basic_string(const basic_string& __str, const allocator_type& __a)
    : __r_(__a)
{
    if (!__str.__is_long())
        __r_.first().__r = __str.__r_.first().__r;
    else
        __init(std::__1::__to_raw_pointer(__str.__get_long_pointer()), __str.__get_long_size());



}
# 2155 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/string" 3
template <class _CharT, class _Traits, class _Allocator>
void
basic_string<_CharT, _Traits, _Allocator>::__init(size_type __n, value_type __c)
{
    if (__n > max_size())
        this->__throw_length_error();
    pointer __p;
    if (__n < __min_cap)
    {
        __set_short_size(__n);
        __p = __get_short_pointer();
    }
    else
    {
        size_type __cap = __recommend(__n);
        __p = __alloc_traits::allocate(__alloc(), __cap+1);
        __set_long_pointer(__p);
        __set_long_cap(__cap+1);
        __set_long_size(__n);
    }
    traits_type::assign(std::__1::__to_raw_pointer(__p), __n, __c);
    traits_type::assign(__p[__n], value_type());
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_string<_CharT, _Traits, _Allocator>::basic_string(size_type __n, value_type __c)
{
    __init(__n, __c);



}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_string<_CharT, _Traits, _Allocator>::basic_string(size_type __n, value_type __c, const allocator_type& __a)
    : __r_(__a)
{
    __init(__n, __c);



}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>::basic_string(const basic_string& __str, size_type __pos, size_type __n,
                                                        const allocator_type& __a)
    : __r_(__a)
{
    size_type __str_sz = __str.size();
    if (__pos > __str_sz)
        this->__throw_out_of_range();
    __init(__str.data() + __pos, std::__1::min(__n, __str_sz - __pos));



}

template <class _CharT, class _Traits, class _Allocator>
template <class _InputIterator>
typename enable_if
<
     __is_input_iterator <_InputIterator>::value &&
    !__is_forward_iterator<_InputIterator>::value,
    void
>::type
basic_string<_CharT, _Traits, _Allocator>::__init(_InputIterator __first, _InputIterator __last)
{
    __zero();

    try
    {

    for (; __first != __last; ++__first)
        push_back(*__first);

    }
    catch (...)
    {
        if (__is_long())
            __alloc_traits::deallocate(__alloc(), __get_long_pointer(), __get_long_cap());
        throw;
    }

}

template <class _CharT, class _Traits, class _Allocator>
template <class _ForwardIterator>
typename enable_if
<
    __is_forward_iterator<_ForwardIterator>::value,
    void
>::type
basic_string<_CharT, _Traits, _Allocator>::__init(_ForwardIterator __first, _ForwardIterator __last)
{
    size_type __sz = static_cast<size_type>(std::__1::distance(__first, __last));
    if (__sz > max_size())
        this->__throw_length_error();
    pointer __p;
    if (__sz < __min_cap)
    {
        __set_short_size(__sz);
        __p = __get_short_pointer();
    }
    else
    {
        size_type __cap = __recommend(__sz);
        __p = __alloc_traits::allocate(__alloc(), __cap+1);
        __set_long_pointer(__p);
        __set_long_cap(__cap+1);
        __set_long_size(__sz);
    }
    for (; __first != __last; ++__first, ++__p)
        traits_type::assign(*__p, *__first);
    traits_type::assign(*__p, value_type());
}

template <class _CharT, class _Traits, class _Allocator>
template<class _InputIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_string<_CharT, _Traits, _Allocator>::basic_string(_InputIterator __first, _InputIterator __last)
{
    __init(__first, __last);



}

template <class _CharT, class _Traits, class _Allocator>
template<class _InputIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_string<_CharT, _Traits, _Allocator>::basic_string(_InputIterator __first, _InputIterator __last,
                                                        const allocator_type& __a)
    : __r_(__a)
{
    __init(__first, __last);



}
# 2322 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/string" 3
template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>::~basic_string()
{



    if (__is_long())
        __alloc_traits::deallocate(__alloc(), __get_long_pointer(), __get_long_cap());
}

template <class _CharT, class _Traits, class _Allocator>
void
basic_string<_CharT, _Traits, _Allocator>::__grow_by_and_replace
    (size_type __old_cap, size_type __delta_cap, size_type __old_sz,
     size_type __n_copy, size_type __n_del, size_type __n_add, const value_type* __p_new_stuff)
{
    size_type __ms = max_size();
    if (__delta_cap > __ms - __old_cap - 1)
        this->__throw_length_error();
    pointer __old_p = __get_pointer();
    size_type __cap = __old_cap < __ms / 2 - __alignment ?
                          __recommend(std::__1::max(__old_cap + __delta_cap, 2 * __old_cap)) :
                          __ms - 1;
    pointer __p = __alloc_traits::allocate(__alloc(), __cap+1);
    __invalidate_all_iterators();
    if (__n_copy != 0)
        traits_type::copy(std::__1::__to_raw_pointer(__p),
                          std::__1::__to_raw_pointer(__old_p), __n_copy);
    if (__n_add != 0)
        traits_type::copy(std::__1::__to_raw_pointer(__p) + __n_copy, __p_new_stuff, __n_add);
    size_type __sec_cp_sz = __old_sz - __n_del - __n_copy;
    if (__sec_cp_sz != 0)
        traits_type::copy(std::__1::__to_raw_pointer(__p) + __n_copy + __n_add,
                          std::__1::__to_raw_pointer(__old_p) + __n_copy + __n_del, __sec_cp_sz);
    if (__old_cap+1 != __min_cap)
        __alloc_traits::deallocate(__alloc(), __old_p, __old_cap+1);
    __set_long_pointer(__p);
    __set_long_cap(__cap+1);
    __old_sz = __n_copy + __n_add + __sec_cp_sz;
    __set_long_size(__old_sz);
    traits_type::assign(__p[__old_sz], value_type());
}

template <class _CharT, class _Traits, class _Allocator>
void
basic_string<_CharT, _Traits, _Allocator>::__grow_by(size_type __old_cap, size_type __delta_cap, size_type __old_sz,
                                                     size_type __n_copy, size_type __n_del, size_type __n_add)
{
    size_type __ms = max_size();
    if (__delta_cap > __ms - __old_cap)
        this->__throw_length_error();
    pointer __old_p = __get_pointer();
    size_type __cap = __old_cap < __ms / 2 - __alignment ?
                          __recommend(std::__1::max(__old_cap + __delta_cap, 2 * __old_cap)) :
                          __ms - 1;
    pointer __p = __alloc_traits::allocate(__alloc(), __cap+1);
    __invalidate_all_iterators();
    if (__n_copy != 0)
        traits_type::copy(std::__1::__to_raw_pointer(__p),
                          std::__1::__to_raw_pointer(__old_p), __n_copy);
    size_type __sec_cp_sz = __old_sz - __n_del - __n_copy;
    if (__sec_cp_sz != 0)
        traits_type::copy(std::__1::__to_raw_pointer(__p) + __n_copy + __n_add,
                          std::__1::__to_raw_pointer(__old_p) + __n_copy + __n_del,
                          __sec_cp_sz);
    if (__old_cap+1 != __min_cap)
        __alloc_traits::deallocate(__alloc(), __old_p, __old_cap+1);
    __set_long_pointer(__p);
    __set_long_cap(__cap+1);
}

// assign

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::assign(const value_type* __s, size_type __n)
{
    ((void)0);
    size_type __cap = capacity();
    if (__cap >= __n)
    {
        value_type* __p = std::__1::__to_raw_pointer(__get_pointer());
        traits_type::move(__p, __s, __n);
        traits_type::assign(__p[__n], value_type());
        __set_size(__n);
        __invalidate_iterators_past(__n);
    }
    else
    {
        size_type __sz = size();
        __grow_by_and_replace(__cap, __n - __cap, __sz, 0, __sz, __n, __s);
    }
    return *this;
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::assign(size_type __n, value_type __c)
{
    size_type __cap = capacity();
    if (__cap < __n)
    {
        size_type __sz = size();
        __grow_by(__cap, __n - __cap, __sz, 0, __sz);
    }
    else
        __invalidate_iterators_past(__n);
    value_type* __p = std::__1::__to_raw_pointer(__get_pointer());
    traits_type::assign(__p, __n, __c);
    traits_type::assign(__p[__n], value_type());
    __set_size(__n);
    return *this;
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::operator=(value_type __c)
{
    pointer __p;
    if (__is_long())
    {
        __p = __get_long_pointer();
        __set_long_size(1);
    }
    else
    {
        __p = __get_short_pointer();
        __set_short_size(1);
    }
    traits_type::assign(*__p, __c);
    traits_type::assign(*++__p, value_type());
    __invalidate_iterators_past(1);
    return *this;
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::operator=(const basic_string& __str)
{
    if (this != &__str)
    {
        __copy_assign_alloc(__str);
        assign(__str);
    }
    return *this;
}
# 2509 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/string" 3
template <class _CharT, class _Traits, class _Allocator>
template<class _InputIterator>
typename enable_if
<
     __is_input_iterator <_InputIterator>::value &&
    !__is_forward_iterator<_InputIterator>::value,
    basic_string<_CharT, _Traits, _Allocator>&
>::type
basic_string<_CharT, _Traits, _Allocator>::assign(_InputIterator __first, _InputIterator __last)
{
    clear();
    for (; __first != __last; ++__first)
        push_back(*__first);
    return *this;
}

template <class _CharT, class _Traits, class _Allocator>
template<class _ForwardIterator>
typename enable_if
<
    __is_forward_iterator<_ForwardIterator>::value,
    basic_string<_CharT, _Traits, _Allocator>&
>::type
basic_string<_CharT, _Traits, _Allocator>::assign(_ForwardIterator __first, _ForwardIterator __last)
{
    size_type __n = static_cast<size_type>(std::__1::distance(__first, __last));
    size_type __cap = capacity();
    if (__cap < __n)
    {
        size_type __sz = size();
        __grow_by(__cap, __n - __cap, __sz, 0, __sz);
    }
    else
        __invalidate_iterators_past(__n);
    pointer __p = __get_pointer();
    for (; __first != __last; ++__first, ++__p)
        traits_type::assign(*__p, *__first);
    traits_type::assign(*__p, value_type());
    __set_size(__n);
    return *this;
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::assign(const basic_string& __str)
{
    return assign(__str.data(), __str.size());
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::assign(const basic_string& __str, size_type __pos, size_type __n)
{
    size_type __sz = __str.size();
    if (__pos > __sz)
        this->__throw_out_of_range();
    return assign(__str.data() + __pos, std::__1::min(__n, __sz - __pos));
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::assign(const value_type* __s)
{
    ((void)0);
    return assign(__s, traits_type::length(__s));
}

// append

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::append(const value_type* __s, size_type __n)
{
    ((void)0);
    size_type __cap = capacity();
    size_type __sz = size();
    if (__cap - __sz >= __n)
    {
        if (__n)
        {
            value_type* __p = std::__1::__to_raw_pointer(__get_pointer());
            traits_type::copy(__p + __sz, __s, __n);
            __sz += __n;
            __set_size(__sz);
            traits_type::assign(__p[__sz], value_type());
        }
    }
    else
        __grow_by_and_replace(__cap, __sz + __n - __cap, __sz, __sz, 0, __n, __s);
    return *this;
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::append(size_type __n, value_type __c)
{
    if (__n)
    {
        size_type __cap = capacity();
        size_type __sz = size();
        if (__cap - __sz < __n)
            __grow_by(__cap, __sz + __n - __cap, __sz, __sz, 0);
        pointer __p = __get_pointer();
        traits_type::assign(std::__1::__to_raw_pointer(__p) + __sz, __n, __c);
        __sz += __n;
        __set_size(__sz);
        traits_type::assign(__p[__sz], value_type());
    }
    return *this;
}

template <class _CharT, class _Traits, class _Allocator>
void
basic_string<_CharT, _Traits, _Allocator>::push_back(value_type __c)
{
    bool __is_short = !__is_long();
    size_type __cap;
    size_type __sz;
    if (__is_short)
    {
        __cap = __min_cap - 1;
        __sz = __get_short_size();
    }
    else
    {
        __cap = __get_long_cap() - 1;
        __sz = __get_long_size();
    }
    if (__sz == __cap)
    {
        __grow_by(__cap, 1, __sz, __sz, 0);
        __is_short = !__is_long();
    }
    pointer __p;
    if (__is_short)
    {
        __p = __get_short_pointer() + __sz;
        __set_short_size(__sz+1);
    }
    else
    {
        __p = __get_long_pointer() + __sz;
        __set_long_size(__sz+1);
    }
    traits_type::assign(*__p, __c);
    traits_type::assign(*++__p, value_type());
}

template <class _CharT, class _Traits, class _Allocator>
template<class _InputIterator>
typename enable_if
<
     __is_input_iterator <_InputIterator>::value &&
    !__is_forward_iterator<_InputIterator>::value,
    basic_string<_CharT, _Traits, _Allocator>&
>::type
basic_string<_CharT, _Traits, _Allocator>::append(_InputIterator __first, _InputIterator __last)
{
    for (; __first != __last; ++__first)
        push_back(*__first);
    return *this;
}

template <class _CharT, class _Traits, class _Allocator>
template<class _ForwardIterator>
typename enable_if
<
    __is_forward_iterator<_ForwardIterator>::value,
    basic_string<_CharT, _Traits, _Allocator>&
>::type
basic_string<_CharT, _Traits, _Allocator>::append(_ForwardIterator __first, _ForwardIterator __last)
{
    size_type __sz = size();
    size_type __cap = capacity();
    size_type __n = static_cast<size_type>(std::__1::distance(__first, __last));
    if (__n)
    {
        if (__cap - __sz < __n)
            __grow_by(__cap, __sz + __n - __cap, __sz, __sz, 0);
        pointer __p = __get_pointer() + __sz;
        for (; __first != __last; ++__p, ++__first)
            traits_type::assign(*__p, *__first);
        traits_type::assign(*__p, value_type());
        __set_size(__sz + __n);
    }
    return *this;
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::append(const basic_string& __str)
{
    return append(__str.data(), __str.size());
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::append(const basic_string& __str, size_type __pos, size_type __n)
{
    size_type __sz = __str.size();
    if (__pos > __sz)
        this->__throw_out_of_range();
    return append(__str.data() + __pos, std::__1::min(__n, __sz - __pos));
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::append(const value_type* __s)
{
    ((void)0);
    return append(__s, traits_type::length(__s));
}

// insert

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos, const value_type* __s, size_type __n)
{
    ((void)0);
    size_type __sz = size();
    if (__pos > __sz)
        this->__throw_out_of_range();
    size_type __cap = capacity();
    if (__cap - __sz >= __n)
    {
        if (__n)
        {
            value_type* __p = std::__1::__to_raw_pointer(__get_pointer());
            size_type __n_move = __sz - __pos;
            if (__n_move != 0)
            {
                if (__p + __pos <= __s && __s < __p + __sz)
                    __s += __n;
                traits_type::move(__p + __pos + __n, __p + __pos, __n_move);
            }
            traits_type::move(__p + __pos, __s, __n);
            __sz += __n;
            __set_size(__sz);
            traits_type::assign(__p[__sz], value_type());
        }
    }
    else
        __grow_by_and_replace(__cap, __sz + __n - __cap, __sz, __pos, 0, __n, __s);
    return *this;
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos, size_type __n, value_type __c)
{
    size_type __sz = size();
    if (__pos > __sz)
        this->__throw_out_of_range();
    if (__n)
    {
        size_type __cap = capacity();
        value_type* __p;
        if (__cap - __sz >= __n)
        {
            __p = std::__1::__to_raw_pointer(__get_pointer());
            size_type __n_move = __sz - __pos;
            if (__n_move != 0)
                traits_type::move(__p + __pos + __n, __p + __pos, __n_move);
        }
        else
        {
            __grow_by(__cap, __sz + __n - __cap, __sz, __pos, 0, __n);
            __p = std::__1::__to_raw_pointer(__get_long_pointer());
        }
        traits_type::assign(__p + __pos, __n, __c);
        __sz += __n;
        __set_size(__sz);
        traits_type::assign(__p[__sz], value_type());
    }
    return *this;
}

template <class _CharT, class _Traits, class _Allocator>
template<class _InputIterator>
typename enable_if
<
     __is_input_iterator <_InputIterator>::value &&
    !__is_forward_iterator<_InputIterator>::value,
    typename basic_string<_CharT, _Traits, _Allocator>::iterator
>::type
basic_string<_CharT, _Traits, _Allocator>::insert(const_iterator __pos, _InputIterator __first, _InputIterator __last)
{





    size_type __old_sz = size();
    difference_type __ip = __pos - begin();
    for (; __first != __last; ++__first)
        push_back(*__first);
    pointer __p = __get_pointer();
    std::__1::rotate(__p + __ip, __p + __old_sz, __p + size());



    return iterator(__p + __ip);

}

template <class _CharT, class _Traits, class _Allocator>
template<class _ForwardIterator>
typename enable_if
<
    __is_forward_iterator<_ForwardIterator>::value,
    typename basic_string<_CharT, _Traits, _Allocator>::iterator
>::type
basic_string<_CharT, _Traits, _Allocator>::insert(const_iterator __pos, _ForwardIterator __first, _ForwardIterator __last)
{





    size_type __ip = static_cast<size_type>(__pos - begin());
    size_type __sz = size();
    size_type __cap = capacity();
    size_type __n = static_cast<size_type>(std::__1::distance(__first, __last));
    if (__n)
    {
        value_type* __p;
        if (__cap - __sz >= __n)
        {
            __p = std::__1::__to_raw_pointer(__get_pointer());
            size_type __n_move = __sz - __ip;
            if (__n_move != 0)
                traits_type::move(__p + __ip + __n, __p + __ip, __n_move);
        }
        else
        {
            __grow_by(__cap, __sz + __n - __cap, __sz, __ip, 0, __n);
            __p = std::__1::__to_raw_pointer(__get_long_pointer());
        }
        __sz += __n;
        __set_size(__sz);
        traits_type::assign(__p[__sz], value_type());
        for (__p += __ip; __first != __last; ++__p, ++__first)
            traits_type::assign(*__p, *__first);
    }
    return begin() + __ip;
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos1, const basic_string& __str)
{
    return insert(__pos1, __str.data(), __str.size());
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos1, const basic_string& __str,
                                                  size_type __pos2, size_type __n)
{
    size_type __str_sz = __str.size();
    if (__pos2 > __str_sz)
        this->__throw_out_of_range();
    return insert(__pos1, __str.data() + __pos2, std::__1::min(__n, __str_sz - __pos2));
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos, const value_type* __s)
{
    ((void)0);
    return insert(__pos, __s, traits_type::length(__s));
}

template <class _CharT, class _Traits, class _Allocator>
typename basic_string<_CharT, _Traits, _Allocator>::iterator
basic_string<_CharT, _Traits, _Allocator>::insert(const_iterator __pos, value_type __c)
{
    size_type __ip = static_cast<size_type>(__pos - begin());
    size_type __sz = size();
    size_type __cap = capacity();
    value_type* __p;
    if (__cap == __sz)
    {
        __grow_by(__cap, 1, __sz, __ip, 0, 1);
        __p = std::__1::__to_raw_pointer(__get_long_pointer());
    }
    else
    {
        __p = std::__1::__to_raw_pointer(__get_pointer());
        size_type __n_move = __sz - __ip;
        if (__n_move != 0)
            traits_type::move(__p + __ip + 1, __p + __ip, __n_move);
    }
    traits_type::assign(__p[__ip], __c);
    traits_type::assign(__p[++__sz], value_type());
    __set_size(__sz);
    return begin() + static_cast<difference_type>(__ip);
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename basic_string<_CharT, _Traits, _Allocator>::iterator
basic_string<_CharT, _Traits, _Allocator>::insert(const_iterator __pos, size_type __n, value_type __c)
{





    difference_type __p = __pos - begin();
    insert(static_cast<size_type>(__p), __n, __c);
    return begin() + __p;
}

// replace

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos, size_type __n1, const value_type* __s, size_type __n2)
{
    ((void)0);
    size_type __sz = size();
    if (__pos > __sz)
        this->__throw_out_of_range();
    __n1 = std::__1::min(__n1, __sz - __pos);
    size_type __cap = capacity();
    if (__cap - __sz + __n1 >= __n2)
    {
        value_type* __p = std::__1::__to_raw_pointer(__get_pointer());
        if (__n1 != __n2)
        {
            size_type __n_move = __sz - __pos - __n1;
            if (__n_move != 0)
            {
                if (__n1 > __n2)
                {
                    traits_type::move(__p + __pos, __s, __n2);
                    traits_type::move(__p + __pos + __n2, __p + __pos + __n1, __n_move);
                    goto __finish;
                }
                if (__p + __pos < __s && __s < __p + __sz)
                {
                    if (__p + __pos + __n1 <= __s)
                        __s += __n2 - __n1;
                    else // __p + __pos < __s < __p + __pos + __n1
                    {
                        traits_type::move(__p + __pos, __s, __n1);
                        __pos += __n1;
                        __s += __n2;
                        __n2 -= __n1;
                        __n1 = 0;
                    }
                }
                traits_type::move(__p + __pos + __n2, __p + __pos + __n1, __n_move);
            }
        }
        traits_type::move(__p + __pos, __s, __n2);
__finish:
        __sz += __n2 - __n1;
        __set_size(__sz);
        __invalidate_iterators_past(__sz);
        traits_type::assign(__p[__sz], value_type());
    }
    else
        __grow_by_and_replace(__cap, __sz - __n1 + __n2 - __cap, __sz, __pos, __n1, __n2, __s);
    return *this;
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos, size_type __n1, size_type __n2, value_type __c)
{
    size_type __sz = size();
    if (__pos > __sz)
        this->__throw_out_of_range();
    __n1 = std::__1::min(__n1, __sz - __pos);
    size_type __cap = capacity();
    value_type* __p;
    if (__cap - __sz + __n1 >= __n2)
    {
        __p = std::__1::__to_raw_pointer(__get_pointer());
        if (__n1 != __n2)
        {
            size_type __n_move = __sz - __pos - __n1;
            if (__n_move != 0)
                traits_type::move(__p + __pos + __n2, __p + __pos + __n1, __n_move);
        }
    }
    else
    {
        __grow_by(__cap, __sz - __n1 + __n2 - __cap, __sz, __pos, __n1, __n2);
        __p = std::__1::__to_raw_pointer(__get_long_pointer());
    }
    traits_type::assign(__p + __pos, __n2, __c);
    __sz += __n2 - __n1;
    __set_size(__sz);
    __invalidate_iterators_past(__sz);
    traits_type::assign(__p[__sz], value_type());
    return *this;
}

template <class _CharT, class _Traits, class _Allocator>
template<class _InputIterator>
typename enable_if
<
    __is_input_iterator<_InputIterator>::value,
    basic_string<_CharT, _Traits, _Allocator>&
>::type
basic_string<_CharT, _Traits, _Allocator>::replace(const_iterator __i1, const_iterator __i2,
                                                   _InputIterator __j1, _InputIterator __j2)
{
    for (; true; ++__i1, ++__j1)
    {
        if (__i1 == __i2)
        {
            if (__j1 != __j2)
                insert(__i1, __j1, __j2);
            break;
        }
        if (__j1 == __j2)
        {
            erase(__i1, __i2);
            break;
        }
        traits_type::assign(const_cast<value_type&>(*__i1), *__j1);
    }
    return *this;
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos1, size_type __n1, const basic_string& __str)
{
    return replace(__pos1, __n1, __str.data(), __str.size());
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos1, size_type __n1, const basic_string& __str,
                                                   size_type __pos2, size_type __n2)
{
    size_type __str_sz = __str.size();
    if (__pos2 > __str_sz)
        this->__throw_out_of_range();
    return replace(__pos1, __n1, __str.data() + __pos2, std::__1::min(__n2, __str_sz - __pos2));
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos, size_type __n1, const value_type* __s)
{
    ((void)0);
    return replace(__pos, __n1, __s, traits_type::length(__s));
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::replace(const_iterator __i1, const_iterator __i2, const basic_string& __str)
{
    return replace(static_cast<size_type>(__i1 - begin()), static_cast<size_type>(__i2 - __i1),
                   __str.data(), __str.size());
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::replace(const_iterator __i1, const_iterator __i2, const value_type* __s, size_type __n)
{
    return replace(static_cast<size_type>(__i1 - begin()), static_cast<size_type>(__i2 - __i1), __s, __n);
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::replace(const_iterator __i1, const_iterator __i2, const value_type* __s)
{
    return replace(static_cast<size_type>(__i1 - begin()), static_cast<size_type>(__i2 - __i1), __s);
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::replace(const_iterator __i1, const_iterator __i2, size_type __n, value_type __c)
{
    return replace(static_cast<size_type>(__i1 - begin()), static_cast<size_type>(__i2 - __i1), __n, __c);
}

// erase

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::erase(size_type __pos, size_type __n)
{
    size_type __sz = size();
    if (__pos > __sz)
        this->__throw_out_of_range();
    if (__n)
    {
        value_type* __p = std::__1::__to_raw_pointer(__get_pointer());
        __n = std::__1::min(__n, __sz - __pos);
        size_type __n_move = __sz - __pos - __n;
        if (__n_move != 0)
            traits_type::move(__p + __pos, __p + __pos + __n, __n_move);
        __sz -= __n;
        __set_size(__sz);
        __invalidate_iterators_past(__sz);
        traits_type::assign(__p[__sz], value_type());
    }
    return *this;
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename basic_string<_CharT, _Traits, _Allocator>::iterator
basic_string<_CharT, _Traits, _Allocator>::erase(const_iterator __pos)
{





    ((void)0);

    iterator __b = begin();
    size_type __r = static_cast<size_type>(__pos - __b);
    erase(__r, 1);
    return __b + static_cast<difference_type>(__r);
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename basic_string<_CharT, _Traits, _Allocator>::iterator
basic_string<_CharT, _Traits, _Allocator>::erase(const_iterator __first, const_iterator __last)
{





    ((void)0);
    iterator __b = begin();
    size_type __r = static_cast<size_type>(__first - __b);
    erase(__r, static_cast<size_type>(__last - __first));
    return __b + static_cast<difference_type>(__r);
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
basic_string<_CharT, _Traits, _Allocator>::pop_back()
{
    ((void)0);
    size_type __sz;
    if (__is_long())
    {
        __sz = __get_long_size() - 1;
        __set_long_size(__sz);
        traits_type::assign(*(__get_long_pointer() + __sz), value_type());
    }
    else
    {
        __sz = __get_short_size() - 1;
        __set_short_size(__sz);
        traits_type::assign(*(__get_short_pointer() + __sz), value_type());
    }
    __invalidate_iterators_past(__sz);
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
basic_string<_CharT, _Traits, _Allocator>::clear() throw()
{
    __invalidate_all_iterators();
    if (__is_long())
    {
        traits_type::assign(*__get_long_pointer(), value_type());
        __set_long_size(0);
    }
    else
    {
        traits_type::assign(*__get_short_pointer(), value_type());
        __set_short_size(0);
    }
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
basic_string<_CharT, _Traits, _Allocator>::__erase_to_end(size_type __pos)
{
    if (__is_long())
    {
        traits_type::assign(*(__get_long_pointer() + __pos), value_type());
        __set_long_size(__pos);
    }
    else
    {
        traits_type::assign(*(__get_short_pointer() + __pos), value_type());
        __set_short_size(__pos);
    }
    __invalidate_iterators_past(__pos);
}

template <class _CharT, class _Traits, class _Allocator>
void
basic_string<_CharT, _Traits, _Allocator>::resize(size_type __n, value_type __c)
{
    size_type __sz = size();
    if (__n > __sz)
        append(__n - __sz, __c);
    else
        __erase_to_end(__n);
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::max_size() const throw()
{
    size_type __m = __alloc_traits::max_size(__alloc());



    return __m - __alignment;

}

template <class _CharT, class _Traits, class _Allocator>
void
basic_string<_CharT, _Traits, _Allocator>::reserve(size_type __res_arg)
{
    if (__res_arg > max_size())
        this->__throw_length_error();
    size_type __cap = capacity();
    size_type __sz = size();
    __res_arg = std::__1::max(__res_arg, __sz);
    __res_arg = __recommend(__res_arg);
    if (__res_arg != __cap)
    {
        pointer __new_data, __p;
        bool __was_long, __now_long;
        if (__res_arg == __min_cap - 1)
        {
            __was_long = true;
            __now_long = false;
            __new_data = __get_short_pointer();
            __p = __get_long_pointer();
        }
        else
        {
            if (__res_arg > __cap)
                __new_data = __alloc_traits::allocate(__alloc(), __res_arg+1);
            else
            {

                try
                {

                    __new_data = __alloc_traits::allocate(__alloc(), __res_arg+1);

                }
                catch (...)
                {
                    return;
                }




            }
            __now_long = true;
            __was_long = __is_long();
            __p = __get_pointer();
        }
        traits_type::copy(std::__1::__to_raw_pointer(__new_data),
                          std::__1::__to_raw_pointer(__p), size()+1);
        if (__was_long)
            __alloc_traits::deallocate(__alloc(), __p, __cap+1);
        if (__now_long)
        {
            __set_long_cap(__res_arg+1);
            __set_long_size(__sz);
            __set_long_pointer(__new_data);
        }
        else
            __set_short_size(__sz);
        __invalidate_all_iterators();
    }
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename basic_string<_CharT, _Traits, _Allocator>::const_reference
basic_string<_CharT, _Traits, _Allocator>::operator[](size_type __pos) const
{
    ((void)0);
    return *(data() + __pos);
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename basic_string<_CharT, _Traits, _Allocator>::reference
basic_string<_CharT, _Traits, _Allocator>::operator[](size_type __pos)
{
    ((void)0);
    return *(__get_pointer() + __pos);
}

template <class _CharT, class _Traits, class _Allocator>
typename basic_string<_CharT, _Traits, _Allocator>::const_reference
basic_string<_CharT, _Traits, _Allocator>::at(size_type __n) const
{
    if (__n >= size())
        this->__throw_out_of_range();
    return (*this)[__n];
}

template <class _CharT, class _Traits, class _Allocator>
typename basic_string<_CharT, _Traits, _Allocator>::reference
basic_string<_CharT, _Traits, _Allocator>::at(size_type __n)
{
    if (__n >= size())
        this->__throw_out_of_range();
    return (*this)[__n];
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename basic_string<_CharT, _Traits, _Allocator>::reference
basic_string<_CharT, _Traits, _Allocator>::front()
{
    ((void)0);
    return *__get_pointer();
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename basic_string<_CharT, _Traits, _Allocator>::const_reference
basic_string<_CharT, _Traits, _Allocator>::front() const
{
    ((void)0);
    return *data();
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename basic_string<_CharT, _Traits, _Allocator>::reference
basic_string<_CharT, _Traits, _Allocator>::back()
{
    ((void)0);
    return *(__get_pointer() + size() - 1);
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename basic_string<_CharT, _Traits, _Allocator>::const_reference
basic_string<_CharT, _Traits, _Allocator>::back() const
{
    ((void)0);
    return *(data() + size() - 1);
}

template <class _CharT, class _Traits, class _Allocator>
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::copy(value_type* __s, size_type __n, size_type __pos) const
{
    size_type __sz = size();
    if (__pos > __sz)
        this->__throw_out_of_range();
    size_type __rlen = std::__1::min(__n, __sz - __pos);
    traits_type::copy(__s, data() + __pos, __rlen);
    return __rlen;
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_string<_CharT, _Traits, _Allocator>
basic_string<_CharT, _Traits, _Allocator>::substr(size_type __pos, size_type __n) const
{
    return basic_string(*this, __pos, __n, __alloc());
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
basic_string<_CharT, _Traits, _Allocator>::swap(basic_string& __str)


{







    std::__1::swap(__r_.first(), __str.__r_.first());
    __swap_alloc(__alloc(), __str.__alloc());
}

// find

template <class _Traits>
struct __attribute__ ((__visibility__("hidden"))) __traits_eq
{
    typedef typename _Traits::char_type char_type;
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator()(const char_type& __x, const char_type& __y) throw()
        {return _Traits::eq(__x, __y);}
};

template<class _CharT, class _Traits, class _Allocator>
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find(const value_type* __s,
                                                size_type __pos,
                                                size_type __n) const throw()
{
    ((void)0);
    return std::__1::__str_find<value_type, size_type, traits_type, npos>
        (data(), size(), __s, __pos, __n);
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find(const basic_string& __str,
                                                size_type __pos) const throw()
{
    return std::__1::__str_find<value_type, size_type, traits_type, npos>
        (data(), size(), __str.data(), __pos, __str.size());
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find(const value_type* __s,
                                                size_type __pos) const throw()
{
    ((void)0);
    return std::__1::__str_find<value_type, size_type, traits_type, npos>
        (data(), size(), __s, __pos, traits_type::length(__s));
}

template<class _CharT, class _Traits, class _Allocator>
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find(value_type __c,
                                                size_type __pos) const throw()
{
    return std::__1::__str_find<value_type, size_type, traits_type, npos>
        (data(), size(), __c, __pos);
}

// rfind

template<class _CharT, class _Traits, class _Allocator>
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::rfind(const value_type* __s,
                                                 size_type __pos,
                                                 size_type __n) const throw()
{
    ((void)0);
    return std::__1::__str_rfind<value_type, size_type, traits_type, npos>
        (data(), size(), __s, __pos, __n);
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::rfind(const basic_string& __str,
                                                 size_type __pos) const throw()
{
    return std::__1::__str_rfind<value_type, size_type, traits_type, npos>
        (data(), size(), __str.data(), __pos, __str.size());
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::rfind(const value_type* __s,
                                                 size_type __pos) const throw()
{
    ((void)0);
    return std::__1::__str_rfind<value_type, size_type, traits_type, npos>
        (data(), size(), __s, __pos, traits_type::length(__s));
}

template<class _CharT, class _Traits, class _Allocator>
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::rfind(value_type __c,
                                                 size_type __pos) const throw()
{
    return std::__1::__str_rfind<value_type, size_type, traits_type, npos>
        (data(), size(), __c, __pos);
}

// find_first_of

template<class _CharT, class _Traits, class _Allocator>
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_first_of(const value_type* __s,
                                                         size_type __pos,
                                                         size_type __n) const throw()
{
    ((void)0);
    return std::__1::__str_find_first_of<value_type, size_type, traits_type, npos>
        (data(), size(), __s, __pos, __n);
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_first_of(const basic_string& __str,
                                                         size_type __pos) const throw()
{
    return std::__1::__str_find_first_of<value_type, size_type, traits_type, npos>
        (data(), size(), __str.data(), __pos, __str.size());
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_first_of(const value_type* __s,
                                                         size_type __pos) const throw()
{
    ((void)0);
    return std::__1::__str_find_first_of<value_type, size_type, traits_type, npos>
        (data(), size(), __s, __pos, traits_type::length(__s));
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_first_of(value_type __c,
                                                         size_type __pos) const throw()
{
    return find(__c, __pos);
}

// find_last_of

template<class _CharT, class _Traits, class _Allocator>
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_last_of(const value_type* __s,
                                                        size_type __pos,
                                                        size_type __n) const throw()
{
    ((void)0);
    return std::__1::__str_find_last_of<value_type, size_type, traits_type, npos>
        (data(), size(), __s, __pos, __n);
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_last_of(const basic_string& __str,
                                                        size_type __pos) const throw()
{
    return std::__1::__str_find_last_of<value_type, size_type, traits_type, npos>
        (data(), size(), __str.data(), __pos, __str.size());
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_last_of(const value_type* __s,
                                                        size_type __pos) const throw()
{
    ((void)0);
    return std::__1::__str_find_last_of<value_type, size_type, traits_type, npos>
        (data(), size(), __s, __pos, traits_type::length(__s));
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_last_of(value_type __c,
                                                        size_type __pos) const throw()
{
    return rfind(__c, __pos);
}

// find_first_not_of

template<class _CharT, class _Traits, class _Allocator>
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_first_not_of(const value_type* __s,
                                                             size_type __pos,
                                                             size_type __n) const throw()
{
    ((void)0);
    return std::__1::__str_find_first_not_of<value_type, size_type, traits_type, npos>
        (data(), size(), __s, __pos, __n);
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_first_not_of(const basic_string& __str,
                                                             size_type __pos) const throw()
{
    return std::__1::__str_find_first_not_of<value_type, size_type, traits_type, npos>
        (data(), size(), __str.data(), __pos, __str.size());
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_first_not_of(const value_type* __s,
                                                             size_type __pos) const throw()
{
    ((void)0);
    return std::__1::__str_find_first_not_of<value_type, size_type, traits_type, npos>
        (data(), size(), __s, __pos, traits_type::length(__s));
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_first_not_of(value_type __c,
                                                             size_type __pos) const throw()
{
    return std::__1::__str_find_first_not_of<value_type, size_type, traits_type, npos>
        (data(), size(), __c, __pos);
}

// find_last_not_of

template<class _CharT, class _Traits, class _Allocator>
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_last_not_of(const value_type* __s,
                                                            size_type __pos,
                                                            size_type __n) const throw()
{
    ((void)0);
    return std::__1::__str_find_last_not_of<value_type, size_type, traits_type, npos>
        (data(), size(), __s, __pos, __n);
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_last_not_of(const basic_string& __str,
                                                            size_type __pos) const throw()
{
    return std::__1::__str_find_last_not_of<value_type, size_type, traits_type, npos>
        (data(), size(), __str.data(), __pos, __str.size());
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_last_not_of(const value_type* __s,
                                                            size_type __pos) const throw()
{
    ((void)0);
    return std::__1::__str_find_last_not_of<value_type, size_type, traits_type, npos>
        (data(), size(), __s, __pos, traits_type::length(__s));
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_last_not_of(value_type __c,
                                                            size_type __pos) const throw()
{
    return std::__1::__str_find_last_not_of<value_type, size_type, traits_type, npos>
        (data(), size(), __c, __pos);
}

// compare

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
int
basic_string<_CharT, _Traits, _Allocator>::compare(const basic_string& __str) const throw()
{
    size_t __lhs_sz = size();
    size_t __rhs_sz = __str.size();
    int __result = traits_type::compare(data(), __str.data(),
                                        std::__1::min(__lhs_sz, __rhs_sz));
    if (__result != 0)
        return __result;
    if (__lhs_sz < __rhs_sz)
        return -1;
    if (__lhs_sz > __rhs_sz)
        return 1;
    return 0;
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
int
basic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1,
                                                   size_type __n1,
                                                   const basic_string& __str) const
{
    return compare(__pos1, __n1, __str.data(), __str.size());
}

template <class _CharT, class _Traits, class _Allocator>
int
basic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1,
                                                   size_type __n1,
                                                   const basic_string& __str,
                                                   size_type __pos2,
                                                   size_type __n2) const
{
    size_type __sz = __str.size();
    if (__pos2 > __sz)
        this->__throw_out_of_range();
    return compare(__pos1, __n1, __str.data() + __pos2, std::__1::min(__n2,
                                                                  __sz - __pos2));
}

template <class _CharT, class _Traits, class _Allocator>
int
basic_string<_CharT, _Traits, _Allocator>::compare(const value_type* __s) const throw()
{
    ((void)0);
    return compare(0, npos, __s, traits_type::length(__s));
}

template <class _CharT, class _Traits, class _Allocator>
int
basic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1,
                                                   size_type __n1,
                                                   const value_type* __s) const
{
    ((void)0);
    return compare(__pos1, __n1, __s, traits_type::length(__s));
}

template <class _CharT, class _Traits, class _Allocator>
int
basic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1,
                                                   size_type __n1,
                                                   const value_type* __s,
                                                   size_type __n2) const
{
    ((void)0);
    size_type __sz = size();
    if (__pos1 > __sz || __n2 == npos)
        this->__throw_out_of_range();
    size_type __rlen = std::__1::min(__n1, __sz - __pos1);
    int __r = traits_type::compare(data() + __pos1, __s, std::__1::min(__rlen, __n2));
    if (__r == 0)
    {
        if (__rlen < __n2)
            __r = -1;
        else if (__rlen > __n2)
            __r = 1;
    }
    return __r;
}

// __invariants

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
basic_string<_CharT, _Traits, _Allocator>::__invariants() const
{
    if (size() > capacity())
        return false;
    if (capacity() < __min_cap - 1)
        return false;
    if (data() == 0)
        return false;
    if (data()[size()] != value_type(0))
        return false;
    return true;
}

// operator==

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator==(const basic_string<_CharT, _Traits, _Allocator>& __lhs,
           const basic_string<_CharT, _Traits, _Allocator>& __rhs) throw()
{
    size_t __lhs_sz = __lhs.size();
    return __lhs_sz == __rhs.size() && _Traits::compare(__lhs.data(),
                                                        __rhs.data(),
                                                        __lhs_sz) == 0;
}

template<class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator==(const basic_string<char, char_traits<char>, _Allocator>& __lhs,
           const basic_string<char, char_traits<char>, _Allocator>& __rhs) throw()
{
    size_t __lhs_sz = __lhs.size();
    if (__lhs_sz != __rhs.size())
        return false;
    const char* __lp = __lhs.data();
    const char* __rp = __rhs.data();
    if (__lhs.__is_long())
        return char_traits<char>::compare(__lp, __rp, __lhs_sz) == 0;
    for (; __lhs_sz != 0; --__lhs_sz, ++__lp, ++__rp)
        if (*__lp != *__rp)
            return false;
    return true;
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator==(const _CharT* __lhs,
           const basic_string<_CharT, _Traits, _Allocator>& __rhs) throw()
{
    return __rhs.compare(__lhs) == 0;
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator==(const basic_string<_CharT,_Traits,_Allocator>& __lhs,
           const _CharT* __rhs) throw()
{
    return __lhs.compare(__rhs) == 0;
}

// operator!=

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator!=(const basic_string<_CharT,_Traits,_Allocator>& __lhs,
           const basic_string<_CharT, _Traits, _Allocator>& __rhs) throw()
{
    return !(__lhs == __rhs);
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator!=(const _CharT* __lhs,
           const basic_string<_CharT, _Traits, _Allocator>& __rhs) throw()
{
    return !(__lhs == __rhs);
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator!=(const basic_string<_CharT, _Traits, _Allocator>& __lhs,
           const _CharT* __rhs) throw()
{
    return !(__lhs == __rhs);
}

// operator<

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator< (const basic_string<_CharT, _Traits, _Allocator>& __lhs,
           const basic_string<_CharT, _Traits, _Allocator>& __rhs) throw()
{
    return __lhs.compare(__rhs) < 0;
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator< (const basic_string<_CharT, _Traits, _Allocator>& __lhs,
           const _CharT* __rhs) throw()
{
    return __lhs.compare(__rhs) < 0;
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator< (const _CharT* __lhs,
           const basic_string<_CharT, _Traits, _Allocator>& __rhs) throw()
{
    return __rhs.compare(__lhs) > 0;
}

// operator>

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator> (const basic_string<_CharT, _Traits, _Allocator>& __lhs,
           const basic_string<_CharT, _Traits, _Allocator>& __rhs) throw()
{
    return __rhs < __lhs;
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator> (const basic_string<_CharT, _Traits, _Allocator>& __lhs,
           const _CharT* __rhs) throw()
{
    return __rhs < __lhs;
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator> (const _CharT* __lhs,
           const basic_string<_CharT, _Traits, _Allocator>& __rhs) throw()
{
    return __rhs < __lhs;
}

// operator<=

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator<=(const basic_string<_CharT, _Traits, _Allocator>& __lhs,
           const basic_string<_CharT, _Traits, _Allocator>& __rhs) throw()
{
    return !(__rhs < __lhs);
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator<=(const basic_string<_CharT, _Traits, _Allocator>& __lhs,
           const _CharT* __rhs) throw()
{
    return !(__rhs < __lhs);
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator<=(const _CharT* __lhs,
           const basic_string<_CharT, _Traits, _Allocator>& __rhs) throw()
{
    return !(__rhs < __lhs);
}

// operator>=

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator>=(const basic_string<_CharT, _Traits, _Allocator>& __lhs,
           const basic_string<_CharT, _Traits, _Allocator>& __rhs) throw()
{
    return !(__lhs < __rhs);
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator>=(const basic_string<_CharT, _Traits, _Allocator>& __lhs,
           const _CharT* __rhs) throw()
{
    return !(__lhs < __rhs);
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator>=(const _CharT* __lhs,
           const basic_string<_CharT, _Traits, _Allocator>& __rhs) throw()
{
    return !(__lhs < __rhs);
}

// operator +

template<class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>
operator+(const basic_string<_CharT, _Traits, _Allocator>& __lhs,
          const basic_string<_CharT, _Traits, _Allocator>& __rhs)
{
    basic_string<_CharT, _Traits, _Allocator> __r(__lhs.get_allocator());
    typename basic_string<_CharT, _Traits, _Allocator>::size_type __lhs_sz = __lhs.size();
    typename basic_string<_CharT, _Traits, _Allocator>::size_type __rhs_sz = __rhs.size();
    __r.__init(__lhs.data(), __lhs_sz, __lhs_sz + __rhs_sz);
    __r.append(__rhs.data(), __rhs_sz);
    return __r;
}

template<class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>
operator+(const _CharT* __lhs , const basic_string<_CharT,_Traits,_Allocator>& __rhs)
{
    basic_string<_CharT, _Traits, _Allocator> __r(__rhs.get_allocator());
    typename basic_string<_CharT, _Traits, _Allocator>::size_type __lhs_sz = _Traits::length(__lhs);
    typename basic_string<_CharT, _Traits, _Allocator>::size_type __rhs_sz = __rhs.size();
    __r.__init(__lhs, __lhs_sz, __lhs_sz + __rhs_sz);
    __r.append(__rhs.data(), __rhs_sz);
    return __r;
}

template<class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>
operator+(_CharT __lhs, const basic_string<_CharT,_Traits,_Allocator>& __rhs)
{
    basic_string<_CharT, _Traits, _Allocator> __r(__rhs.get_allocator());
    typename basic_string<_CharT, _Traits, _Allocator>::size_type __rhs_sz = __rhs.size();
    __r.__init(&__lhs, 1, 1 + __rhs_sz);
    __r.append(__rhs.data(), __rhs_sz);
    return __r;
}

template<class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>
operator+(const basic_string<_CharT, _Traits, _Allocator>& __lhs, const _CharT* __rhs)
{
    basic_string<_CharT, _Traits, _Allocator> __r(__lhs.get_allocator());
    typename basic_string<_CharT, _Traits, _Allocator>::size_type __lhs_sz = __lhs.size();
    typename basic_string<_CharT, _Traits, _Allocator>::size_type __rhs_sz = _Traits::length(__rhs);
    __r.__init(__lhs.data(), __lhs_sz, __lhs_sz + __rhs_sz);
    __r.append(__rhs, __rhs_sz);
    return __r;
}

template<class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>
operator+(const basic_string<_CharT, _Traits, _Allocator>& __lhs, _CharT __rhs)
{
    basic_string<_CharT, _Traits, _Allocator> __r(__lhs.get_allocator());
    typename basic_string<_CharT, _Traits, _Allocator>::size_type __lhs_sz = __lhs.size();
    __r.__init(__lhs.data(), __lhs_sz, __lhs_sz + 1);
    __r.push_back(__rhs);
    return __r;
}
# 4108 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/string" 3
// swap

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
swap(basic_string<_CharT, _Traits, _Allocator>& __lhs,
     basic_string<_CharT, _Traits, _Allocator>& __rhs)

{
    __lhs.swap(__rhs);
}



typedef basic_string<char16_t> u16string;
typedef basic_string<char32_t> u32string;



__attribute__ ((__visibility__("default"))) int stoi (const string& __str, size_t* __idx = 0, int __base = 10);
__attribute__ ((__visibility__("default"))) long stol (const string& __str, size_t* __idx = 0, int __base = 10);
__attribute__ ((__visibility__("default"))) unsigned long stoul (const string& __str, size_t* __idx = 0, int __base = 10);
__attribute__ ((__visibility__("default"))) long long stoll (const string& __str, size_t* __idx = 0, int __base = 10);
__attribute__ ((__visibility__("default"))) unsigned long long stoull(const string& __str, size_t* __idx = 0, int __base = 10);

__attribute__ ((__visibility__("default"))) float stof (const string& __str, size_t* __idx = 0);
__attribute__ ((__visibility__("default"))) double stod (const string& __str, size_t* __idx = 0);
__attribute__ ((__visibility__("default"))) long double stold(const string& __str, size_t* __idx = 0);

__attribute__ ((__visibility__("default"))) string to_string(int __val);
__attribute__ ((__visibility__("default"))) string to_string(unsigned __val);
__attribute__ ((__visibility__("default"))) string to_string(long __val);
__attribute__ ((__visibility__("default"))) string to_string(unsigned long __val);
__attribute__ ((__visibility__("default"))) string to_string(long long __val);
__attribute__ ((__visibility__("default"))) string to_string(unsigned long long __val);
__attribute__ ((__visibility__("default"))) string to_string(float __val);
__attribute__ ((__visibility__("default"))) string to_string(double __val);
__attribute__ ((__visibility__("default"))) string to_string(long double __val);

__attribute__ ((__visibility__("default"))) int stoi (const wstring& __str, size_t* __idx = 0, int __base = 10);
__attribute__ ((__visibility__("default"))) long stol (const wstring& __str, size_t* __idx = 0, int __base = 10);
__attribute__ ((__visibility__("default"))) unsigned long stoul (const wstring& __str, size_t* __idx = 0, int __base = 10);
__attribute__ ((__visibility__("default"))) long long stoll (const wstring& __str, size_t* __idx = 0, int __base = 10);
__attribute__ ((__visibility__("default"))) unsigned long long stoull(const wstring& __str, size_t* __idx = 0, int __base = 10);

__attribute__ ((__visibility__("default"))) float stof (const wstring& __str, size_t* __idx = 0);
__attribute__ ((__visibility__("default"))) double stod (const wstring& __str, size_t* __idx = 0);
__attribute__ ((__visibility__("default"))) long double stold(const wstring& __str, size_t* __idx = 0);

__attribute__ ((__visibility__("default"))) wstring to_wstring(int __val);
__attribute__ ((__visibility__("default"))) wstring to_wstring(unsigned __val);
__attribute__ ((__visibility__("default"))) wstring to_wstring(long __val);
__attribute__ ((__visibility__("default"))) wstring to_wstring(unsigned long __val);
__attribute__ ((__visibility__("default"))) wstring to_wstring(long long __val);
__attribute__ ((__visibility__("default"))) wstring to_wstring(unsigned long long __val);
__attribute__ ((__visibility__("default"))) wstring to_wstring(float __val);
__attribute__ ((__visibility__("default"))) wstring to_wstring(double __val);
__attribute__ ((__visibility__("default"))) wstring to_wstring(long double __val);

template<class _CharT, class _Traits, class _Allocator>
    const typename basic_string<_CharT, _Traits, _Allocator>::size_type
                   basic_string<_CharT, _Traits, _Allocator>::npos;

template<class _CharT, class _Traits, class _Allocator>
struct __attribute__ ((__type_visibility__("default"))) hash<basic_string<_CharT, _Traits, _Allocator> >
    : public unary_function<basic_string<_CharT, _Traits, _Allocator>, size_t>
{
    size_t
        operator()(const basic_string<_CharT, _Traits, _Allocator>& __val) const throw();
};

template<class _CharT, class _Traits, class _Allocator>
size_t
hash<basic_string<_CharT, _Traits, _Allocator> >::operator()(
        const basic_string<_CharT, _Traits, _Allocator>& __val) const throw()
{
    return __do_string_hash(__val.data(), __val.data() + __val.size());
}

template<class _CharT, class _Traits, class _Allocator>
basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os,
           const basic_string<_CharT, _Traits, _Allocator>& __str);

template<class _CharT, class _Traits, class _Allocator>
basic_istream<_CharT, _Traits>&
operator>>(basic_istream<_CharT, _Traits>& __is,
           basic_string<_CharT, _Traits, _Allocator>& __str);

template<class _CharT, class _Traits, class _Allocator>
basic_istream<_CharT, _Traits>&
getline(basic_istream<_CharT, _Traits>& __is,
        basic_string<_CharT, _Traits, _Allocator>& __str, _CharT __dlm);

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_istream<_CharT, _Traits>&
getline(basic_istream<_CharT, _Traits>& __is,
        basic_string<_CharT, _Traits, _Allocator>& __str);
# 4297 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/string" 3
} }
# 16 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/__locale" 2 3


# 1 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/mutex" 1 3
// -*- C++ -*-
//===--------------------------- mutex ------------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is dual licensed under the MIT and the University of Illinois Open
// Source Licenses. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//




/*
    mutex synopsis

namespace std
{

class mutex
{
public:
     constexpr mutex() noexcept;
     ~mutex();

    mutex(const mutex&) = delete;
    mutex& operator=(const mutex&) = delete;

    void lock();
    bool try_lock();
    void unlock();

    typedef pthread_mutex_t* native_handle_type;
    native_handle_type native_handle();
};

class recursive_mutex
{
public:
     recursive_mutex();
     ~recursive_mutex();

    recursive_mutex(const recursive_mutex&) = delete;
    recursive_mutex& operator=(const recursive_mutex&) = delete;

    void lock();
    bool try_lock() noexcept;
    void unlock();

    typedef pthread_mutex_t* native_handle_type;
    native_handle_type native_handle();
};

class timed_mutex
{
public:
     timed_mutex();
     ~timed_mutex();

    timed_mutex(const timed_mutex&) = delete;
    timed_mutex& operator=(const timed_mutex&) = delete;

    void lock();
    bool try_lock();
    template <class Rep, class Period>
        bool try_lock_for(const chrono::duration<Rep, Period>& rel_time);
    template <class Clock, class Duration>
        bool try_lock_until(const chrono::time_point<Clock, Duration>& abs_time);
    void unlock();
};

class recursive_timed_mutex
{
public:
     recursive_timed_mutex();
     ~recursive_timed_mutex();

    recursive_timed_mutex(const recursive_timed_mutex&) = delete;
    recursive_timed_mutex& operator=(const recursive_timed_mutex&) = delete;

    void lock();
    bool try_lock() noexcept;
    template <class Rep, class Period>
        bool try_lock_for(const chrono::duration<Rep, Period>& rel_time);
    template <class Clock, class Duration>
        bool try_lock_until(const chrono::time_point<Clock, Duration>& abs_time);
    void unlock();
};

struct defer_lock_t {};
struct try_to_lock_t {};
struct adopt_lock_t {};

constexpr defer_lock_t  defer_lock{};
constexpr try_to_lock_t try_to_lock{};
constexpr adopt_lock_t  adopt_lock{};

template <class Mutex>
class lock_guard
{
public:
    typedef Mutex mutex_type;

    explicit lock_guard(mutex_type& m);
    lock_guard(mutex_type& m, adopt_lock_t);
    ~lock_guard();

    lock_guard(lock_guard const&) = delete;
    lock_guard& operator=(lock_guard const&) = delete;
};

template <class Mutex>
class unique_lock
{
public:
    typedef Mutex mutex_type;
    unique_lock() noexcept;
    explicit unique_lock(mutex_type& m);
    unique_lock(mutex_type& m, defer_lock_t) noexcept;
    unique_lock(mutex_type& m, try_to_lock_t);
    unique_lock(mutex_type& m, adopt_lock_t);
    template <class Clock, class Duration>
        unique_lock(mutex_type& m, const chrono::time_point<Clock, Duration>& abs_time);
    template <class Rep, class Period>
        unique_lock(mutex_type& m, const chrono::duration<Rep, Period>& rel_time);
    ~unique_lock();

    unique_lock(unique_lock const&) = delete;
    unique_lock& operator=(unique_lock const&) = delete;

    unique_lock(unique_lock&& u) noexcept;
    unique_lock& operator=(unique_lock&& u) noexcept;

    void lock();
    bool try_lock();

    template <class Rep, class Period>
        bool try_lock_for(const chrono::duration<Rep, Period>& rel_time);
    template <class Clock, class Duration>
        bool try_lock_until(const chrono::time_point<Clock, Duration>& abs_time);

    void unlock();

    void swap(unique_lock& u) noexcept;
    mutex_type* release() noexcept;

    bool owns_lock() const noexcept;
    explicit operator bool () const noexcept;
    mutex_type* mutex() const noexcept;
};

template <class Mutex>
  void swap(unique_lock<Mutex>& x, unique_lock<Mutex>& y) noexcept;

template <class L1, class L2, class... L3>
  int try_lock(L1&, L2&, L3&...);
template <class L1, class L2, class... L3>
  void lock(L1&, L2&, L3&...);

struct once_flag
{
    constexpr once_flag() noexcept;

    once_flag(const once_flag&) = delete;
    once_flag& operator=(const once_flag&) = delete;
};

template<class Callable, class ...Args>
  void call_once(once_flag& flag, Callable&& func, Args&&... args);

}  // std

*/



# 1 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/__mutex_base" 1 3
// -*- C++ -*-
//===----------------------------------------------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is dual licensed under the MIT and the University of Illinois Open
// Source Licenses. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//






# 1 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/chrono" 1 3
// -*- C++ -*-
//===---------------------------- chrono ----------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is dual licensed under the MIT and the University of Illinois Open
// Source Licenses. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//




/*
    chrono synopsis

namespace std
{
namespace chrono
{

template <class ToDuration, class Rep, class Period>
constexpr
ToDuration
duration_cast(const duration<Rep, Period>& fd);

template <class Rep> struct treat_as_floating_point : is_floating_point<Rep> {};

template <class Rep>
struct duration_values
{
public:
    static constexpr Rep zero();
    static constexpr Rep max();
    static constexpr Rep min();
};

// duration

template <class Rep, class Period = ratio<1>>
class duration
{
    static_assert(!__is_duration<Rep>::value, "A duration representation can not be a duration");
    static_assert(__is_ratio<Period>::value, "Second template parameter of duration must be a std::ratio");
    static_assert(Period::num > 0, "duration period must be positive");
public:
    typedef Rep rep;
    typedef Period period;

    constexpr duration() = default;
    template <class Rep2>
        constexpr explicit duration(const Rep2& r,
            typename enable_if
            <
               is_convertible<Rep2, rep>::value &&
               (treat_as_floating_point<rep>::value ||
               !treat_as_floating_point<rep>::value && !treat_as_floating_point<Rep2>::value)
            >::type* = 0);

    // conversions
    template <class Rep2, class Period2>
        constexpr duration(const duration<Rep2, Period2>& d,
            typename enable_if
            <
                treat_as_floating_point<rep>::value ||
                ratio_divide<Period2, period>::type::den == 1
            >::type* = 0);

    // observer

    constexpr rep count() const;

    // arithmetic

    constexpr duration  operator+() const;
    constexpr duration  operator-() const;
    duration& operator++();
    duration  operator++(int);
    duration& operator--();
    duration  operator--(int);

    duration& operator+=(const duration& d);
    duration& operator-=(const duration& d);

    duration& operator*=(const rep& rhs);
    duration& operator/=(const rep& rhs);

    // special values

    static constexpr duration zero();
    static constexpr duration min();
    static constexpr duration max();
};

typedef duration<long long,         nano> nanoseconds;
typedef duration<long long,        micro> microseconds;
typedef duration<long long,        milli> milliseconds;
typedef duration<long long              > seconds;
typedef duration<     long, ratio<  60> > minutes;
typedef duration<     long, ratio<3600> > hours;

template <class Clock, class Duration = typename Clock::duration>
class time_point
{
public:
    typedef Clock                     clock;
    typedef Duration                  duration;
    typedef typename duration::rep    rep;
    typedef typename duration::period period;
private:
    duration d_;  // exposition only

public:
    time_point();  // has value "epoch" // constexpr in C++14
    explicit time_point(const duration& d);  // same as time_point() + d // constexpr in C++14

    // conversions
    template <class Duration2>
       time_point(const time_point<clock, Duration2>& t); // constexpr in C++14

    // observer

    duration time_since_epoch() const; // constexpr in C++14

    // arithmetic

    time_point& operator+=(const duration& d);
    time_point& operator-=(const duration& d);

    // special values

    static constexpr time_point min();
    static constexpr time_point max();
};

} // chrono

// common_type traits
template <class Rep1, class Period1, class Rep2, class Period2>
  struct common_type<chrono::duration<Rep1, Period1>, chrono::duration<Rep2, Period2>>;

template <class Clock, class Duration1, class Duration2>
  struct common_type<chrono::time_point<Clock, Duration1>, chrono::time_point<Clock, Duration2>>;

namespace chrono {

// duration arithmetic
template <class Rep1, class Period1, class Rep2, class Period2>
  constexpr
  typename common_type<duration<Rep1, Period1>, duration<Rep2, Period2>>::type
  operator+(const duration<Rep1, Period1>& lhs, const duration<Rep2, Period2>& rhs);
template <class Rep1, class Period1, class Rep2, class Period2>
  constexpr
  typename common_type<duration<Rep1, Period1>, duration<Rep2, Period2>>::type
  operator-(const duration<Rep1, Period1>& lhs, const duration<Rep2, Period2>& rhs);
template <class Rep1, class Period, class Rep2>
  constexpr
  duration<typename common_type<Rep1, Rep2>::type, Period>
  operator*(const duration<Rep1, Period>& d, const Rep2& s);
template <class Rep1, class Period, class Rep2>
  constexpr
  duration<typename common_type<Rep1, Rep2>::type, Period>
  operator*(const Rep1& s, const duration<Rep2, Period>& d);
template <class Rep1, class Period, class Rep2>
  constexpr
  duration<typename common_type<Rep1, Rep2>::type, Period>
  operator/(const duration<Rep1, Period>& d, const Rep2& s);
template <class Rep1, class Period1, class Rep2, class Period2>
  constexpr
  typename common_type<Rep1, Rep2>::type
  operator/(const duration<Rep1, Period1>& lhs, const duration<Rep2, Period2>& rhs);

// duration comparisons
template <class Rep1, class Period1, class Rep2, class Period2>
   constexpr
   bool operator==(const duration<Rep1, Period1>& lhs, const duration<Rep2, Period2>& rhs);
template <class Rep1, class Period1, class Rep2, class Period2>
   constexpr
   bool operator!=(const duration<Rep1, Period1>& lhs, const duration<Rep2, Period2>& rhs);
template <class Rep1, class Period1, class Rep2, class Period2>
   constexpr
   bool operator< (const duration<Rep1, Period1>& lhs, const duration<Rep2, Period2>& rhs);
template <class Rep1, class Period1, class Rep2, class Period2>
   constexpr
   bool operator<=(const duration<Rep1, Period1>& lhs, const duration<Rep2, Period2>& rhs);
template <class Rep1, class Period1, class Rep2, class Period2>
   constexpr
   bool operator> (const duration<Rep1, Period1>& lhs, const duration<Rep2, Period2>& rhs);
template <class Rep1, class Period1, class Rep2, class Period2>
   constexpr
   bool operator>=(const duration<Rep1, Period1>& lhs, const duration<Rep2, Period2>& rhs);

// duration_cast
template <class ToDuration, class Rep, class Period>
  ToDuration duration_cast(const duration<Rep, Period>& d);

// time_point arithmetic (all constexpr in C++14)
template <class Clock, class Duration1, class Rep2, class Period2>
  time_point<Clock, typename common_type<Duration1, duration<Rep2, Period2>>::type>
  operator+(const time_point<Clock, Duration1>& lhs, const duration<Rep2, Period2>& rhs);
template <class Rep1, class Period1, class Clock, class Duration2>
  time_point<Clock, typename common_type<duration<Rep1, Period1>, Duration2>::type>
  operator+(const duration<Rep1, Period1>& lhs, const time_point<Clock, Duration2>& rhs);
template <class Clock, class Duration1, class Rep2, class Period2>
  time_point<Clock, typename common_type<Duration1, duration<Rep2, Period2>>::type>
  operator-(const time_point<Clock, Duration1>& lhs, const duration<Rep2, Period2>& rhs);
template <class Clock, class Duration1, class Duration2>
  typename common_type<Duration1, Duration2>::type
  operator-(const time_point<Clock, Duration1>& lhs, const time_point<Clock, Duration2>& rhs);

// time_point comparisons (all constexpr in C++14)
template <class Clock, class Duration1, class Duration2>
   bool operator==(const time_point<Clock, Duration1>& lhs, const time_point<Clock, Duration2>& rhs);
template <class Clock, class Duration1, class Duration2>
   bool operator!=(const time_point<Clock, Duration1>& lhs, const time_point<Clock, Duration2>& rhs);
template <class Clock, class Duration1, class Duration2>
   bool operator< (const time_point<Clock, Duration1>& lhs, const time_point<Clock, Duration2>& rhs);
template <class Clock, class Duration1, class Duration2>
   bool operator<=(const time_point<Clock, Duration1>& lhs, const time_point<Clock, Duration2>& rhs);
template <class Clock, class Duration1, class Duration2>
   bool operator> (const time_point<Clock, Duration1>& lhs, const time_point<Clock, Duration2>& rhs);
template <class Clock, class Duration1, class Duration2>
   bool operator>=(const time_point<Clock, Duration1>& lhs, const time_point<Clock, Duration2>& rhs);

// time_point_cast (constexpr in C++14)

template <class ToDuration, class Clock, class Duration>
  time_point<Clock, ToDuration> time_point_cast(const time_point<Clock, Duration>& t);

// Clocks

class system_clock
{
public:
    typedef microseconds                     duration;
    typedef duration::rep                    rep;
    typedef duration::period                 period;
    typedef chrono::time_point<system_clock> time_point;
    static const bool is_steady =            false; // constexpr in C++14

    static time_point now() noexcept;
    static time_t     to_time_t  (const time_point& __t) noexcept;
    static time_point from_time_t(time_t __t) noexcept;
};

class steady_clock
{
public:
    typedef nanoseconds                                   duration;
    typedef duration::rep                                 rep;
    typedef duration::period                              period;
    typedef chrono::time_point<steady_clock, duration>    time_point;
    static const bool is_steady =                         true; // constexpr in C++14

    static time_point now() noexcept;
};

typedef steady_clock high_resolution_clock;

}  // chrono

constexpr chrono::hours                                 operator "" h(unsigned long long); // C++14
constexpr chrono::duration<unspecified , ratio<3600,1>> operator "" h(long double); // C++14
constexpr chrono::minutes                               operator "" min(unsigned long long); // C++14
constexpr chrono::duration<unspecified , ratio<60,1>>   operator "" min(long double); // C++14
constexpr chrono::seconds                               operator "" s(unsigned long long); // C++14
constexpr chrono::duration<unspecified >                operator "" s(long double); // C++14
constexpr chrono::milliseconds                          operator "" ms(unsigned long long); // C++14
constexpr chrono::duration<unspecified , milli>         operator "" ms(long double); // C++14
constexpr chrono::microseconds                          operator "" us(unsigned long long); // C++14
constexpr chrono::duration<unspecified , micro>         operator "" us(long double); // C++14
constexpr chrono::nanoseconds                           operator "" ns(unsigned long long); // C++14
constexpr chrono::duration<unspecified , nano>          operator "" ns(long double); // C++14

}  // std
*/



# 1 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/ctime" 1 3
// -*- C++ -*-
//===---------------------------- ctime -----------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is dual licensed under the MIT and the University of Illinois Open
// Source Licenses. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//




/*
    ctime synopsis

Macros:

    NULL
    CLOCKS_PER_SEC

namespace std
{

Types:

    clock_t
    size_t
    time_t
    tm

clock_t clock();
double difftime(time_t time1, time_t time0);
time_t mktime(tm* timeptr);
time_t time(time_t* timer);
char* asctime(const tm* timeptr);
char* ctime(const time_t* timer);
tm*    gmtime(const time_t* timer);
tm* localtime(const time_t* timer);
size_t strftime(char* restrict s, size_t maxsize, const char* restrict format,
                const tm* restrict timeptr);

}  // std

*/
# 52 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/ctime" 3


namespace std {inline namespace __1 {

using ::clock_t;
using ::size_t;
using ::time_t;
using ::tm;
using ::clock;
using ::difftime;
using ::mktime;
using ::time;
using ::asctime;
using ::ctime;
using ::gmtime;
using ::localtime;
using ::strftime;

} }
# 280 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/chrono" 2 3

# 1 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/ratio" 1 3
// -*- C++ -*-
//===---------------------------- ratio -----------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is dual licensed under the MIT and the University of Illinois Open
// Source Licenses. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//




/*
    ratio synopsis

namespace std
{

template <intmax_t N, intmax_t D = 1>
class ratio
{
public:
    static const intmax_t num;
    static const intmax_t den;
    typedef ratio<num, den> type;
};

// ratio arithmetic
template <class R1, class R2> using ratio_add = ...;
template <class R1, class R2> using ratio_subtract = ...;
template <class R1, class R2> using ratio_multiply = ...;
template <class R1, class R2> using ratio_divide = ...;

// ratio comparison
template <class R1, class R2> struct ratio_equal;
template <class R1, class R2> struct ratio_not_equal;
template <class R1, class R2> struct ratio_less;
template <class R1, class R2> struct ratio_less_equal;
template <class R1, class R2> struct ratio_greater;
template <class R1, class R2> struct ratio_greater_equal;

// convenience SI typedefs
typedef ratio<1, 1000000000000000000000000> yocto;  // not supported
typedef ratio<1,    1000000000000000000000> zepto;  // not supported
typedef ratio<1,       1000000000000000000> atto;
typedef ratio<1,          1000000000000000> femto;
typedef ratio<1,             1000000000000> pico;
typedef ratio<1,                1000000000> nano;
typedef ratio<1,                   1000000> micro;
typedef ratio<1,                      1000> milli;
typedef ratio<1,                       100> centi;
typedef ratio<1,                        10> deci;
typedef ratio<                       10, 1> deca;
typedef ratio<                      100, 1> hecto;
typedef ratio<                     1000, 1> kilo;
typedef ratio<                  1000000, 1> mega;
typedef ratio<               1000000000, 1> giga;
typedef ratio<            1000000000000, 1> tera;
typedef ratio<         1000000000000000, 1> peta;
typedef ratio<      1000000000000000000, 1> exa;
typedef ratio<   1000000000000000000000, 1> zetta;  // not supported
typedef ratio<1000000000000000000000000, 1> yotta;  // not supported

}
*/




# 1 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/climits" 1 3
// -*- C++ -*-
//===--------------------------- climits ----------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is dual licensed under the MIT and the University of Illinois Open
// Source Licenses. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//




/*
    climits synopsis

Macros:

    CHAR_BIT
    SCHAR_MIN
    SCHAR_MAX
    UCHAR_MAX
    CHAR_MIN
    CHAR_MAX
    MB_LEN_MAX
    SHRT_MIN
    SHRT_MAX
    USHRT_MAX
    INT_MIN
    INT_MAX
    UINT_MAX
    LONG_MIN
    LONG_MAX
    ULONG_MAX
    LLONG_MIN   // C99
    LLONG_MAX   // C99
    ULLONG_MAX  // C99

*/



# 1 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../lib/clang/3.5.0/include/limits.h" 1 3 4
/*===---- limits.h - Standard header for integer sizes --------------------===*\
 *
 * Copyright (c) 2009 Chris Lattner
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
\*===----------------------------------------------------------------------===*/




/* The system's limits.h may, in turn, try to #include_next GCC's limits.h.
   Avert this #include_next madness. */




/* System headers include a number of constants from POSIX in <limits.h>.
   Include it if we're hosted. */


# 1 "/usr/include/limits.h" 1 3 4
/*
 * Copyright (c) 2000, 2004-2007, 2009 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
/*	$NetBSD: limits.h,v 1.8 1996/10/21 05:10:50 jtc Exp $	*/

/*
 * Copyright (c) 1988, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)limits.h	8.2 (Berkeley) 1/4/94
 */






# 1 "/usr/include/machine/limits.h" 1 3 4
/* This is the `system' limits.h, independent of any particular
   compiler.  GCC provides its own limits.h which can be found in
   /usr/lib/gcc, although it is not very informative.  
   This file is public domain.  */


# 1 "/usr/include/i386/limits.h" 1 3 4
/*
 * Copyright (c) 1988, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)limits.h	8.3 (Berkeley) 1/4/94
 */






# 1 "/usr/include/i386/_limits.h" 1 3 4
/*
 * Copyright (c) 2004 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * The contents of this file constitute Original Code as defined in and
 * are subject to the Apple Public Source License Version 1.1 (the
 * "License").  You may not use this file except in compliance with the
 * License.  Please obtain a copy of the License at
 * http://www.apple.com/publicsource and read it before using this file.
 * 
 * This Original Code and all software distributed under the License are
 * distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT.  Please see the
 * License for the specific language governing rights and limitations
 * under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
# 41 "/usr/include/i386/limits.h" 2 3 4








/*
 * According to ANSI (section 2.2.4.2), the values below must be usable by
 * #if preprocessing directives.  Additionally, the expression must have the
 * same type as would an expression that is an object of the corresponding
 * type converted according to the integral promotions.  The subtraction for
 * INT_MIN and LONG_MIN is so the value is not unsigned; 2147483648 is an
 * unsigned int for 32-bit two's complement ANSI compilers (section 3.1.3.2).
 * These numbers work for pcc as well.  The UINT_MAX and ULONG_MAX values
 * are written as hex so that GCC will be quiet about large integer constants.
 */
# 7 "/usr/include/machine/limits.h" 2 3 4
# 65 "/usr/include/limits.h" 2 3 4
# 1 "/usr/include/sys/syslimits.h" 1 3 4
/*
 * Copyright (c) 2000 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
/*	$NetBSD: syslimits.h,v 1.15 1997/06/25 00:48:09 lukem Exp $	*/

/*
 * Copyright (c) 1988, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)syslimits.h	8.1 (Berkeley) 6/2/93
 */







/*
 * Note: CHILD_MAX *must* be less than hard_maxproc, which is set at
 * compile time; you *cannot* set it higher than the hard limit!!
 */
# 107 "/usr/include/sys/syslimits.h" 3 4
     /* = ((PRIO_MAX - PRIO_MIN) / 2) + 1 */
     /* range: 0 - 39 [(2 * NZERO) - 1] */
     /* 0 is not actually used */
# 66 "/usr/include/limits.h" 2 3 4
# 137 "/usr/include/limits.h" 3 4
/* Actually for XSI Visible */


/* Removed in Issue 6 */
# 159 "/usr/include/limits.h" 3 4
/* NZERO to be defined here. TBD. See also sys/param.h  */
# 38 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../lib/clang/3.5.0/include/limits.h" 2 3 4


/* Many system headers try to "help us out" by defining these.  No really, we
   know how big each datatype is. */
# 59 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../lib/clang/3.5.0/include/limits.h" 3 4
/* C90/99 5.2.4.2.1 */
# 89 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../lib/clang/3.5.0/include/limits.h" 3 4
/* C99 5.2.4.2.1: Added long long.
   C++11 18.3.3.2: same contents as the Standard C Library header <limits.h>.
 */
# 103 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../lib/clang/3.5.0/include/limits.h" 3 4
/* LONG_LONG_MIN/LONG_LONG_MAX/ULONG_LONG_MAX are a GNU extension.  It's too bad
   that we don't have something like #pragma poison that could be used to
   deprecate a macro - the code should just use LLONG_MAX and friends.
 */
# 43 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/climits" 2 3
# 46 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/climits" 3
# 71 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/ratio" 2 3


# 1 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/__undef_min_max" 1 3
// -*- C++ -*-
//===----------------------------------------------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is dual licensed under the MIT and the University of Illinois Open
// Source Licenses. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
# 74 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/ratio" 2 3
# 77 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/ratio" 3


namespace std {inline namespace __1 {

// __static_gcd

template <intmax_t _Xp, intmax_t _Yp>
struct __static_gcd
{
    static const intmax_t value = __static_gcd<_Yp, _Xp % _Yp>::value;
};

template <intmax_t _Xp>
struct __static_gcd<_Xp, 0>
{
    static const intmax_t value = _Xp;
};

template <>
struct __static_gcd<0, 0>
{
    static const intmax_t value = 1;
};

// __static_lcm

template <intmax_t _Xp, intmax_t _Yp>
struct __static_lcm
{
    static const intmax_t value = _Xp / __static_gcd<_Xp, _Yp>::value * _Yp;
};

template <intmax_t _Xp>
struct __static_abs
{
    static const intmax_t value = _Xp < 0 ? -_Xp : _Xp;
};

template <intmax_t _Xp>
struct __static_sign
{
    static const intmax_t value = _Xp == 0 ? 0 : (_Xp < 0 ? -1 : 1);
};

template <intmax_t _Xp, intmax_t _Yp, intmax_t = __static_sign<_Yp>::value>
class __ll_add;

template <intmax_t _Xp, intmax_t _Yp>
class __ll_add<_Xp, _Yp, 1>
{
    static const intmax_t min = (1LL << (sizeof(intmax_t) * 8 - 1)) + 1;
    static const intmax_t max = -min;

    typedef __static_assert_check<sizeof(__static_assert_test<(_Xp <= max - _Yp)>)> __t130;
public:
    static const intmax_t value = _Xp + _Yp;
};

template <intmax_t _Xp, intmax_t _Yp>
class __ll_add<_Xp, _Yp, 0>
{
public:
    static const intmax_t value = _Xp;
};

template <intmax_t _Xp, intmax_t _Yp>
class __ll_add<_Xp, _Yp, -1>
{
    static const intmax_t min = (1LL << (sizeof(intmax_t) * 8 - 1)) + 1;
    static const intmax_t max = -min;

    typedef __static_assert_check<sizeof(__static_assert_test<(min - _Yp <= _Xp)>)> __t148;
public:
    static const intmax_t value = _Xp + _Yp;
};

template <intmax_t _Xp, intmax_t _Yp, intmax_t = __static_sign<_Yp>::value>
class __ll_sub;

template <intmax_t _Xp, intmax_t _Yp>
class __ll_sub<_Xp, _Yp, 1>
{
    static const intmax_t min = (1LL << (sizeof(intmax_t) * 8 - 1)) + 1;
    static const intmax_t max = -min;

    typedef __static_assert_check<sizeof(__static_assert_test<(min + _Yp <= _Xp)>)> __t162;
public:
    static const intmax_t value = _Xp - _Yp;
};

template <intmax_t _Xp, intmax_t _Yp>
class __ll_sub<_Xp, _Yp, 0>
{
public:
    static const intmax_t value = _Xp;
};

template <intmax_t _Xp, intmax_t _Yp>
class __ll_sub<_Xp, _Yp, -1>
{
    static const intmax_t min = (1LL << (sizeof(intmax_t) * 8 - 1)) + 1;
    static const intmax_t max = -min;

    typedef __static_assert_check<sizeof(__static_assert_test<(_Xp <= max + _Yp)>)> __t180;
public:
    static const intmax_t value = _Xp - _Yp;
};

template <intmax_t _Xp, intmax_t _Yp>
class __ll_mul
{
    static const intmax_t nan = (1LL << (sizeof(intmax_t) * 8 - 1));
    static const intmax_t min = nan + 1;
    static const intmax_t max = -min;
    static const intmax_t __a_x = __static_abs<_Xp>::value;
    static const intmax_t __a_y = __static_abs<_Yp>::value;

    typedef __static_assert_check<sizeof(__static_assert_test<(_Xp != nan && _Yp != nan && __a_x <= max / __a_y)>)> __t194;
public:
    static const intmax_t value = _Xp * _Yp;
};

template <intmax_t _Yp>
class __ll_mul<0, _Yp>
{
public:
    static const intmax_t value = 0;
};

template <intmax_t _Xp>
class __ll_mul<_Xp, 0>
{
public:
    static const intmax_t value = 0;
};

template <>
class __ll_mul<0, 0>
{
public:
    static const intmax_t value = 0;
};

// Not actually used but left here in case needed in future maintenance
template <intmax_t _Xp, intmax_t _Yp>
class __ll_div
{
    static const intmax_t nan = (1LL << (sizeof(intmax_t) * 8 - 1));
    static const intmax_t min = nan + 1;
    static const intmax_t max = -min;

    typedef __static_assert_check<sizeof(__static_assert_test<(_Xp != nan && _Yp != nan && _Yp != 0)>)> __t228;
public:
    static const intmax_t value = _Xp / _Yp;
};

template <intmax_t _Num, intmax_t _Den = 1>
class __attribute__ ((__type_visibility__("default"))) ratio
{
    typedef __static_assert_check<sizeof(__static_assert_test<(__static_abs<_Num>::value >= 0)>)> __t236;
    typedef __static_assert_check<sizeof(__static_assert_test<(_Den != 0)>)> __t237;
    typedef __static_assert_check<sizeof(__static_assert_test<(__static_abs<_Den>::value > 0)>)> __t238;
    static const intmax_t __na = __static_abs<_Num>::value;
    static const intmax_t __da = __static_abs<_Den>::value;
    static const intmax_t __s = __static_sign<_Num>::value * __static_sign<_Den>::value;
    static const intmax_t __gcd = __static_gcd<__na, __da>::value;
public:
    static const intmax_t num = __s * __na / __gcd;
    static const intmax_t den = __da / __gcd;

    typedef ratio<num, den> type;
};

template <intmax_t _Num, intmax_t _Den> const intmax_t ratio<_Num, _Den>::num;
template <intmax_t _Num, intmax_t _Den> const intmax_t ratio<_Num, _Den>::den;

template <class _Tp> struct __is_ratio : false_type {};
template <intmax_t _Num, intmax_t _Den> struct __is_ratio<ratio<_Num, _Den> > : true_type {};

typedef ratio<1LL, 1000000000000000000LL> atto;
typedef ratio<1LL, 1000000000000000LL> femto;
typedef ratio<1LL, 1000000000000LL> pico;
typedef ratio<1LL, 1000000000LL> nano;
typedef ratio<1LL, 1000000LL> micro;
typedef ratio<1LL, 1000LL> milli;
typedef ratio<1LL, 100LL> centi;
typedef ratio<1LL, 10LL> deci;
typedef ratio< 10LL, 1LL> deca;
typedef ratio< 100LL, 1LL> hecto;
typedef ratio< 1000LL, 1LL> kilo;
typedef ratio< 1000000LL, 1LL> mega;
typedef ratio< 1000000000LL, 1LL> giga;
typedef ratio< 1000000000000LL, 1LL> tera;
typedef ratio< 1000000000000000LL, 1LL> peta;
typedef ratio<1000000000000000000LL, 1LL> exa;

template <class _R1, class _R2>
struct __ratio_multiply
{
private:
    static const intmax_t __gcd_n1_d2 = __static_gcd<_R1::num, _R2::den>::value;
    static const intmax_t __gcd_d1_n2 = __static_gcd<_R1::den, _R2::num>::value;
public:
    typedef typename ratio
        <
            __ll_mul<_R1::num / __gcd_n1_d2, _R2::num / __gcd_d1_n2>::value,
            __ll_mul<_R2::den / __gcd_n1_d2, _R1::den / __gcd_d1_n2>::value
        >::type type;
};
# 294 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/ratio" 3
template <class _R1, class _R2>
struct __attribute__ ((__type_visibility__("default"))) ratio_multiply
    : public __ratio_multiply<_R1, _R2>::type {};



template <class _R1, class _R2>
struct __ratio_divide
{
private:
    static const intmax_t __gcd_n1_n2 = __static_gcd<_R1::num, _R2::num>::value;
    static const intmax_t __gcd_d1_d2 = __static_gcd<_R1::den, _R2::den>::value;
public:
    typedef typename ratio
        <
            __ll_mul<_R1::num / __gcd_n1_n2, _R2::den / __gcd_d1_d2>::value,
            __ll_mul<_R2::num / __gcd_n1_n2, _R1::den / __gcd_d1_d2>::value
        >::type type;
};
# 321 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/ratio" 3
template <class _R1, class _R2>
struct __attribute__ ((__type_visibility__("default"))) ratio_divide
    : public __ratio_divide<_R1, _R2>::type {};



template <class _R1, class _R2>
struct __ratio_add
{
private:
    static const intmax_t __gcd_n1_n2 = __static_gcd<_R1::num, _R2::num>::value;
    static const intmax_t __gcd_d1_d2 = __static_gcd<_R1::den, _R2::den>::value;
public:
    typedef typename ratio_multiply
        <
            ratio<__gcd_n1_n2, _R1::den / __gcd_d1_d2>,
            ratio
            <
                __ll_add
                <
                    __ll_mul<_R1::num / __gcd_n1_n2, _R2::den / __gcd_d1_d2>::value,
                    __ll_mul<_R2::num / __gcd_n1_n2, _R1::den / __gcd_d1_d2>::value
                >::value,
                _R2::den
            >
        >::type type;
};
# 356 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/ratio" 3
template <class _R1, class _R2>
struct __attribute__ ((__type_visibility__("default"))) ratio_add
    : public __ratio_add<_R1, _R2>::type {};



template <class _R1, class _R2>
struct __ratio_subtract
{
private:
    static const intmax_t __gcd_n1_n2 = __static_gcd<_R1::num, _R2::num>::value;
    static const intmax_t __gcd_d1_d2 = __static_gcd<_R1::den, _R2::den>::value;
public:
    typedef typename ratio_multiply
        <
            ratio<__gcd_n1_n2, _R1::den / __gcd_d1_d2>,
            ratio
            <
                __ll_sub
                <
                    __ll_mul<_R1::num / __gcd_n1_n2, _R2::den / __gcd_d1_d2>::value,
                    __ll_mul<_R2::num / __gcd_n1_n2, _R1::den / __gcd_d1_d2>::value
                >::value,
                _R2::den
            >
        >::type type;
};
# 391 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/ratio" 3
template <class _R1, class _R2>
struct __attribute__ ((__type_visibility__("default"))) ratio_subtract
    : public __ratio_subtract<_R1, _R2>::type {};



// ratio_equal

template <class _R1, class _R2>
struct __attribute__ ((__type_visibility__("default"))) ratio_equal
    : public integral_constant<bool, _R1::num == _R2::num && _R1::den == _R2::den> {};

template <class _R1, class _R2>
struct __attribute__ ((__type_visibility__("default"))) ratio_not_equal
    : public integral_constant<bool, !ratio_equal<_R1, _R2>::value> {};

// ratio_less

template <class _R1, class _R2, bool _Odd = false,
          intmax_t _Q1 = _R1::num / _R1::den, intmax_t _M1 = _R1::num % _R1::den,
          intmax_t _Q2 = _R2::num / _R2::den, intmax_t _M2 = _R2::num % _R2::den>
struct __ratio_less1
{
    static const bool value = _Odd ? _Q2 < _Q1 : _Q1 < _Q2;
};

template <class _R1, class _R2, bool _Odd, intmax_t _Qp>
struct __ratio_less1<_R1, _R2, _Odd, _Qp, 0, _Qp, 0>
{
    static const bool value = false;
};

template <class _R1, class _R2, bool _Odd, intmax_t _Qp, intmax_t _M2>
struct __ratio_less1<_R1, _R2, _Odd, _Qp, 0, _Qp, _M2>
{
    static const bool value = !_Odd;
};

template <class _R1, class _R2, bool _Odd, intmax_t _Qp, intmax_t _M1>
struct __ratio_less1<_R1, _R2, _Odd, _Qp, _M1, _Qp, 0>
{
    static const bool value = _Odd;
};

template <class _R1, class _R2, bool _Odd, intmax_t _Qp, intmax_t _M1,
                                                        intmax_t _M2>
struct __ratio_less1<_R1, _R2, _Odd, _Qp, _M1, _Qp, _M2>
{
    static const bool value = __ratio_less1<ratio<_R1::den, _M1>,
                                            ratio<_R2::den, _M2>, !_Odd>::value;
};

template <class _R1, class _R2, intmax_t _S1 = __static_sign<_R1::num>::value,
                                intmax_t _S2 = __static_sign<_R2::num>::value>
struct __ratio_less
{
    static const bool value = _S1 < _S2;
};

template <class _R1, class _R2>
struct __ratio_less<_R1, _R2, 1LL, 1LL>
{
    static const bool value = __ratio_less1<_R1, _R2>::value;
};

template <class _R1, class _R2>
struct __ratio_less<_R1, _R2, -1LL, -1LL>
{
    static const bool value = __ratio_less1<ratio<-_R2::num, _R2::den>, ratio<-_R1::num, _R1::den> >::value;
};

template <class _R1, class _R2>
struct __attribute__ ((__type_visibility__("default"))) ratio_less
    : public integral_constant<bool, __ratio_less<_R1, _R2>::value> {};

template <class _R1, class _R2>
struct __attribute__ ((__type_visibility__("default"))) ratio_less_equal
    : public integral_constant<bool, !ratio_less<_R2, _R1>::value> {};

template <class _R1, class _R2>
struct __attribute__ ((__type_visibility__("default"))) ratio_greater
    : public integral_constant<bool, ratio_less<_R2, _R1>::value> {};

template <class _R1, class _R2>
struct __attribute__ ((__type_visibility__("default"))) ratio_greater_equal
    : public integral_constant<bool, !ratio_less<_R1, _R2>::value> {};

template <class _R1, class _R2>
struct __ratio_gcd
{
    typedef ratio<__static_gcd<_R1::num, _R2::num>::value,
                  __static_lcm<_R1::den, _R2::den>::value> type;
};

} }
# 282 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/chrono" 2 3


# 1 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/__undef_min_max" 1 3
// -*- C++ -*-
//===----------------------------------------------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is dual licensed under the MIT and the University of Illinois Open
// Source Licenses. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
# 285 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/chrono" 2 3
# 288 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/chrono" 3


namespace std {inline namespace __1 {

namespace chrono
{

template <class _Rep, class _Period = ratio<1> > class __attribute__ ((__type_visibility__("default"))) duration;

template <class _Tp>
struct __is_duration : false_type {};

template <class _Rep, class _Period>
struct __is_duration<duration<_Rep, _Period> > : true_type {};

template <class _Rep, class _Period>
struct __is_duration<const duration<_Rep, _Period> > : true_type {};

template <class _Rep, class _Period>
struct __is_duration<volatile duration<_Rep, _Period> > : true_type {};

template <class _Rep, class _Period>
struct __is_duration<const volatile duration<_Rep, _Period> > : true_type {};

} // chrono

template <class _Rep1, class _Period1, class _Rep2, class _Period2>
struct __attribute__ ((__type_visibility__("default"))) common_type<chrono::duration<_Rep1, _Period1>,
                                         chrono::duration<_Rep2, _Period2> >
{
    typedef chrono::duration<typename common_type<_Rep1, _Rep2>::type,
                             typename __ratio_gcd<_Period1, _Period2>::type> type;
};

namespace chrono {

// duration_cast

template <class _FromDuration, class _ToDuration,
          class _Period = typename ratio_divide<typename _FromDuration::period, typename _ToDuration::period>::type,
          bool = _Period::num == 1,
          bool = _Period::den == 1>
struct __duration_cast;

template <class _FromDuration, class _ToDuration, class _Period>
struct __duration_cast<_FromDuration, _ToDuration, _Period, true, true>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    _ToDuration operator()(const _FromDuration& __fd) const
    {
        return _ToDuration(static_cast<typename _ToDuration::rep>(__fd.count()));
    }
};

template <class _FromDuration, class _ToDuration, class _Period>
struct __duration_cast<_FromDuration, _ToDuration, _Period, true, false>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    _ToDuration operator()(const _FromDuration& __fd) const
    {
        typedef typename common_type<typename _ToDuration::rep, typename _FromDuration::rep, intmax_t>::type _Ct;
        return _ToDuration(static_cast<typename _ToDuration::rep>(
                           static_cast<_Ct>(__fd.count()) / static_cast<_Ct>(_Period::den)));
    }
};

template <class _FromDuration, class _ToDuration, class _Period>
struct __duration_cast<_FromDuration, _ToDuration, _Period, false, true>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    _ToDuration operator()(const _FromDuration& __fd) const
    {
        typedef typename common_type<typename _ToDuration::rep, typename _FromDuration::rep, intmax_t>::type _Ct;
        return _ToDuration(static_cast<typename _ToDuration::rep>(
                           static_cast<_Ct>(__fd.count()) * static_cast<_Ct>(_Period::num)));
    }
};

template <class _FromDuration, class _ToDuration, class _Period>
struct __duration_cast<_FromDuration, _ToDuration, _Period, false, false>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    _ToDuration operator()(const _FromDuration& __fd) const
    {
        typedef typename common_type<typename _ToDuration::rep, typename _FromDuration::rep, intmax_t>::type _Ct;
        return _ToDuration(static_cast<typename _ToDuration::rep>(
                           static_cast<_Ct>(__fd.count()) * static_cast<_Ct>(_Period::num)
                                                          / static_cast<_Ct>(_Period::den)));
    }
};

template <class _ToDuration, class _Rep, class _Period>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))

typename enable_if
<
    __is_duration<_ToDuration>::value,
    _ToDuration
>::type
duration_cast(const duration<_Rep, _Period>& __fd)
{
    return __duration_cast<duration<_Rep, _Period>, _ToDuration>()(__fd);
}

template <class _Rep>
struct __attribute__ ((__type_visibility__("default"))) treat_as_floating_point : is_floating_point<_Rep> {};

template <class _Rep>
struct __attribute__ ((__type_visibility__("default"))) duration_values
{
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static _Rep zero() {return _Rep(0);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static _Rep max() {return numeric_limits<_Rep>::max();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static _Rep min() {return numeric_limits<_Rep>::lowest();}
};

// duration

template <class _Rep, class _Period>
class __attribute__ ((__type_visibility__("default"))) duration
{
    typedef __static_assert_check<sizeof(__static_assert_test<(!__is_duration<_Rep>::value)>)> __t409;
    typedef __static_assert_check<sizeof(__static_assert_test<(__is_ratio<_Period>::value)>)> __t410;
    typedef __static_assert_check<sizeof(__static_assert_test<(_Period::num > 0)>)> __t411;

    template <class _R1, class _R2>
    struct __no_overflow
    {
    private:
        static const intmax_t __gcd_n1_n2 = __static_gcd<_R1::num, _R2::num>::value;
        static const intmax_t __gcd_d1_d2 = __static_gcd<_R1::den, _R2::den>::value;
        static const intmax_t __n1 = _R1::num / __gcd_n1_n2;
        static const intmax_t __d1 = _R1::den / __gcd_d1_d2;
        static const intmax_t __n2 = _R2::num / __gcd_n1_n2;
        static const intmax_t __d2 = _R2::den / __gcd_d1_d2;
        static const intmax_t max = -((intmax_t(1) << (sizeof(intmax_t) * 8 - 1)) + 1);

        template <intmax_t _Xp, intmax_t _Yp, bool __overflow>
        struct __mul // __overflow == false
        {
            static const intmax_t value = _Xp * _Yp;
        };

        template <intmax_t _Xp, intmax_t _Yp>
        struct __mul<_Xp, _Yp, true>
        {
            static const intmax_t value = 1;
        };

    public:
        static const bool value = (__n1 <= max / __d2) && (__n2 <= max / __d1);
        typedef ratio<__mul<__n1, __d2, !value>::value,
                      __mul<__n2, __d1, !value>::value> type;
    };

public:
    typedef _Rep rep;
    typedef _Period period;
private:
    rep __rep_;
public:

    __attribute__ ((__visibility__("hidden"), __always_inline__))



        duration() {}


    template <class _Rep2>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        explicit duration(const _Rep2& __r,
            typename enable_if
            <
               is_convertible<_Rep2, rep>::value &&
               (treat_as_floating_point<rep>::value ||
               !treat_as_floating_point<_Rep2>::value)
            >::type* = 0)
                : __rep_(__r) {}

    // conversions
    template <class _Rep2, class _Period2>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        duration(const duration<_Rep2, _Period2>& __d,
            typename enable_if
            <
                __no_overflow<_Period2, period>::value && (
                treat_as_floating_point<rep>::value ||
                (__no_overflow<_Period2, period>::type::den == 1 &&
                 !treat_as_floating_point<_Rep2>::value))
            >::type* = 0)
                : __rep_(std::__1::chrono::duration_cast<duration>(__d).count()) {}

    // observer

    __attribute__ ((__visibility__("hidden"), __always_inline__)) rep count() const {return __rep_;}

    // arithmetic

    __attribute__ ((__visibility__("hidden"), __always_inline__)) duration operator+() const {return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) duration operator-() const {return duration(-__rep_);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) duration& operator++() {++__rep_; return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) duration operator++(int) {return duration(__rep_++);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) duration& operator--() {--__rep_; return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) duration operator--(int) {return duration(__rep_--);}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) duration& operator+=(const duration& __d) {__rep_ += __d.count(); return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) duration& operator-=(const duration& __d) {__rep_ -= __d.count(); return *this;}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) duration& operator*=(const rep& rhs) {__rep_ *= rhs; return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) duration& operator/=(const rep& rhs) {__rep_ /= rhs; return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) duration& operator%=(const rep& rhs) {__rep_ %= rhs; return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) duration& operator%=(const duration& rhs) {__rep_ %= rhs.count(); return *this;}

    // special values

    __attribute__ ((__visibility__("hidden"), __always_inline__)) static duration zero() {return duration(duration_values<rep>::zero());}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static duration min() {return duration(duration_values<rep>::min());}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static duration max() {return duration(duration_values<rep>::max());}
};

typedef duration<long long, nano> nanoseconds;
typedef duration<long long, micro> microseconds;
typedef duration<long long, milli> milliseconds;
typedef duration<long long > seconds;
typedef duration< long, ratio< 60> > minutes;
typedef duration< long, ratio<3600> > hours;

// Duration ==

template <class _LhsDuration, class _RhsDuration>
struct __duration_eq
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator()(const _LhsDuration& __lhs, const _RhsDuration& __rhs) const
        {
            typedef typename common_type<_LhsDuration, _RhsDuration>::type _Ct;
            return _Ct(__lhs).count() == _Ct(__rhs).count();
        }
};

template <class _LhsDuration>
struct __duration_eq<_LhsDuration, _LhsDuration>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator()(const _LhsDuration& __lhs, const _LhsDuration& __rhs) const
        {return __lhs.count() == __rhs.count();}
};

template <class _Rep1, class _Period1, class _Rep2, class _Period2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))

bool
operator==(const duration<_Rep1, _Period1>& __lhs, const duration<_Rep2, _Period2>& __rhs)
{
    return __duration_eq<duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >()(__lhs, __rhs);
}

// Duration !=

template <class _Rep1, class _Period1, class _Rep2, class _Period2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))

bool
operator!=(const duration<_Rep1, _Period1>& __lhs, const duration<_Rep2, _Period2>& __rhs)
{
    return !(__lhs == __rhs);
}

// Duration <

template <class _LhsDuration, class _RhsDuration>
struct __duration_lt
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator()(const _LhsDuration& __lhs, const _RhsDuration& __rhs) const
        {
            typedef typename common_type<_LhsDuration, _RhsDuration>::type _Ct;
            return _Ct(__lhs).count() < _Ct(__rhs).count();
        }
};

template <class _LhsDuration>
struct __duration_lt<_LhsDuration, _LhsDuration>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator()(const _LhsDuration& __lhs, const _LhsDuration& __rhs) const
        {return __lhs.count() < __rhs.count();}
};

template <class _Rep1, class _Period1, class _Rep2, class _Period2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))

bool
operator< (const duration<_Rep1, _Period1>& __lhs, const duration<_Rep2, _Period2>& __rhs)
{
    return __duration_lt<duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >()(__lhs, __rhs);
}

// Duration >

template <class _Rep1, class _Period1, class _Rep2, class _Period2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))

bool
operator> (const duration<_Rep1, _Period1>& __lhs, const duration<_Rep2, _Period2>& __rhs)
{
    return __rhs < __lhs;
}

// Duration <=

template <class _Rep1, class _Period1, class _Rep2, class _Period2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))

bool
operator<=(const duration<_Rep1, _Period1>& __lhs, const duration<_Rep2, _Period2>& __rhs)
{
    return !(__rhs < __lhs);
}

// Duration >=

template <class _Rep1, class _Period1, class _Rep2, class _Period2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))

bool
operator>=(const duration<_Rep1, _Period1>& __lhs, const duration<_Rep2, _Period2>& __rhs)
{
    return !(__lhs < __rhs);
}

// Duration +

template <class _Rep1, class _Period1, class _Rep2, class _Period2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))

typename common_type<duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type
operator+(const duration<_Rep1, _Period1>& __lhs, const duration<_Rep2, _Period2>& __rhs)
{
    typedef typename common_type<duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _Cd;
    return _Cd(_Cd(__lhs).count() + _Cd(__rhs).count());
}

// Duration -

template <class _Rep1, class _Period1, class _Rep2, class _Period2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))

typename common_type<duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type
operator-(const duration<_Rep1, _Period1>& __lhs, const duration<_Rep2, _Period2>& __rhs)
{
    typedef typename common_type<duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _Cd;
    return _Cd(_Cd(__lhs).count() - _Cd(__rhs).count());
}

// Duration *

template <class _Rep1, class _Period, class _Rep2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))

typename enable_if
<
    is_convertible<_Rep2, typename common_type<_Rep1, _Rep2>::type>::value,
    duration<typename common_type<_Rep1, _Rep2>::type, _Period>
>::type
operator*(const duration<_Rep1, _Period>& __d, const _Rep2& __s)
{
    typedef typename common_type<_Rep1, _Rep2>::type _Cr;
    typedef duration<_Cr, _Period> _Cd;
    return _Cd(_Cd(__d).count() * static_cast<_Cr>(__s));
}

template <class _Rep1, class _Period, class _Rep2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))

typename enable_if
<
    is_convertible<_Rep1, typename common_type<_Rep1, _Rep2>::type>::value,
    duration<typename common_type<_Rep1, _Rep2>::type, _Period>
>::type
operator*(const _Rep1& __s, const duration<_Rep2, _Period>& __d)
{
    return __d * __s;
}

// Duration /

template <class _Duration, class _Rep, bool = __is_duration<_Rep>::value>
struct __duration_divide_result
{
};

template <class _Duration, class _Rep2,
    bool = is_convertible<_Rep2,
                          typename common_type<typename _Duration::rep, _Rep2>::type>::value>
struct __duration_divide_imp
{
};

template <class _Rep1, class _Period, class _Rep2>
struct __duration_divide_imp<duration<_Rep1, _Period>, _Rep2, true>
{
    typedef duration<typename common_type<_Rep1, _Rep2>::type, _Period> type;
};

template <class _Rep1, class _Period, class _Rep2>
struct __duration_divide_result<duration<_Rep1, _Period>, _Rep2, false>
    : __duration_divide_imp<duration<_Rep1, _Period>, _Rep2>
{
};

template <class _Rep1, class _Period, class _Rep2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))

typename __duration_divide_result<duration<_Rep1, _Period>, _Rep2>::type
operator/(const duration<_Rep1, _Period>& __d, const _Rep2& __s)
{
    typedef typename common_type<_Rep1, _Rep2>::type _Cr;
    typedef duration<_Cr, _Period> _Cd;
    return _Cd(_Cd(__d).count() / static_cast<_Cr>(__s));
}

template <class _Rep1, class _Period1, class _Rep2, class _Period2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))

typename common_type<_Rep1, _Rep2>::type
operator/(const duration<_Rep1, _Period1>& __lhs, const duration<_Rep2, _Period2>& __rhs)
{
    typedef typename common_type<duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _Ct;
    return _Ct(__lhs).count() / _Ct(__rhs).count();
}

// Duration %

template <class _Rep1, class _Period, class _Rep2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))

typename __duration_divide_result<duration<_Rep1, _Period>, _Rep2>::type
operator%(const duration<_Rep1, _Period>& __d, const _Rep2& __s)
{
    typedef typename common_type<_Rep1, _Rep2>::type _Cr;
    typedef duration<_Cr, _Period> _Cd;
    return _Cd(_Cd(__d).count() % static_cast<_Cr>(__s));
}

template <class _Rep1, class _Period1, class _Rep2, class _Period2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))

typename common_type<duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type
operator%(const duration<_Rep1, _Period1>& __lhs, const duration<_Rep2, _Period2>& __rhs)
{
    typedef typename common_type<_Rep1, _Rep2>::type _Cr;
    typedef typename common_type<duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _Cd;
    return _Cd(static_cast<_Cr>(_Cd(__lhs).count()) % static_cast<_Cr>(_Cd(__rhs).count()));
}

//////////////////////////////////////////////////////////
///////////////////// time_point /////////////////////////
//////////////////////////////////////////////////////////

template <class _Clock, class _Duration = typename _Clock::duration>
class __attribute__ ((__type_visibility__("default"))) time_point
{
    typedef __static_assert_check<sizeof(__static_assert_test<(__is_duration<_Duration>::value)>)> __t753;

public:
    typedef _Clock clock;
    typedef _Duration duration;
    typedef typename duration::rep rep;
    typedef typename duration::period period;
private:
    duration __d_;

public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) time_point() : __d_(duration::zero()) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit time_point(const duration& __d) : __d_(__d) {}

    // conversions
    template <class _Duration2>
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    time_point(const time_point<clock, _Duration2>& t,
        typename enable_if
        <
            is_convertible<_Duration2, duration>::value
        >::type* = 0)
            : __d_(t.time_since_epoch()) {}

    // observer

    __attribute__ ((__visibility__("hidden"), __always_inline__)) duration time_since_epoch() const {return __d_;}

    // arithmetic

    __attribute__ ((__visibility__("hidden"), __always_inline__)) time_point& operator+=(const duration& __d) {__d_ += __d; return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) time_point& operator-=(const duration& __d) {__d_ -= __d; return *this;}

    // special values

    __attribute__ ((__visibility__("hidden"), __always_inline__)) static time_point min() {return time_point(duration::min());}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static time_point max() {return time_point(duration::max());}
};

} // chrono

template <class _Clock, class _Duration1, class _Duration2>
struct __attribute__ ((__type_visibility__("default"))) common_type<chrono::time_point<_Clock, _Duration1>,
                                         chrono::time_point<_Clock, _Duration2> >
{
    typedef chrono::time_point<_Clock, typename common_type<_Duration1, _Duration2>::type> type;
};

namespace chrono {

template <class _ToDuration, class _Clock, class _Duration>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
time_point<_Clock, _ToDuration>
time_point_cast(const time_point<_Clock, _Duration>& __t)
{
    return time_point<_Clock, _ToDuration>(std::__1::chrono::duration_cast<_ToDuration>(__t.time_since_epoch()));
}

// time_point ==

template <class _Clock, class _Duration1, class _Duration2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator==(const time_point<_Clock, _Duration1>& __lhs, const time_point<_Clock, _Duration2>& __rhs)
{
    return __lhs.time_since_epoch() == __rhs.time_since_epoch();
}

// time_point !=

template <class _Clock, class _Duration1, class _Duration2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator!=(const time_point<_Clock, _Duration1>& __lhs, const time_point<_Clock, _Duration2>& __rhs)
{
    return !(__lhs == __rhs);
}

// time_point <

template <class _Clock, class _Duration1, class _Duration2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator<(const time_point<_Clock, _Duration1>& __lhs, const time_point<_Clock, _Duration2>& __rhs)
{
    return __lhs.time_since_epoch() < __rhs.time_since_epoch();
}

// time_point >

template <class _Clock, class _Duration1, class _Duration2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator>(const time_point<_Clock, _Duration1>& __lhs, const time_point<_Clock, _Duration2>& __rhs)
{
    return __rhs < __lhs;
}

// time_point <=

template <class _Clock, class _Duration1, class _Duration2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator<=(const time_point<_Clock, _Duration1>& __lhs, const time_point<_Clock, _Duration2>& __rhs)
{
    return !(__rhs < __lhs);
}

// time_point >=

template <class _Clock, class _Duration1, class _Duration2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator>=(const time_point<_Clock, _Duration1>& __lhs, const time_point<_Clock, _Duration2>& __rhs)
{
    return !(__lhs < __rhs);
}

// time_point operator+(time_point x, duration y);

template <class _Clock, class _Duration1, class _Rep2, class _Period2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
time_point<_Clock, typename common_type<_Duration1, duration<_Rep2, _Period2> >::type>
operator+(const time_point<_Clock, _Duration1>& __lhs, const duration<_Rep2, _Period2>& __rhs)
{
    typedef time_point<_Clock, typename common_type<_Duration1, duration<_Rep2, _Period2> >::type> _Tr;
    return _Tr (__lhs.time_since_epoch() + __rhs);
}

// time_point operator+(duration x, time_point y);

template <class _Rep1, class _Period1, class _Clock, class _Duration2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
time_point<_Clock, typename common_type<duration<_Rep1, _Period1>, _Duration2>::type>
operator+(const duration<_Rep1, _Period1>& __lhs, const time_point<_Clock, _Duration2>& __rhs)
{
    return __rhs + __lhs;
}

// time_point operator-(time_point x, duration y);

template <class _Clock, class _Duration1, class _Rep2, class _Period2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
time_point<_Clock, typename common_type<_Duration1, duration<_Rep2, _Period2> >::type>
operator-(const time_point<_Clock, _Duration1>& __lhs, const duration<_Rep2, _Period2>& __rhs)
{
    return __lhs + (-__rhs);
}

// duration operator-(time_point x, time_point y);

template <class _Clock, class _Duration1, class _Duration2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename common_type<_Duration1, _Duration2>::type
operator-(const time_point<_Clock, _Duration1>& __lhs, const time_point<_Clock, _Duration2>& __rhs)
{
    return __lhs.time_since_epoch() - __rhs.time_since_epoch();
}

//////////////////////////////////////////////////////////
/////////////////////// clocks ///////////////////////////
//////////////////////////////////////////////////////////

class __attribute__ ((__type_visibility__("default"))) system_clock
{
public:
    typedef microseconds duration;
    typedef duration::rep rep;
    typedef duration::period period;
    typedef chrono::time_point<system_clock> time_point;
    static const bool is_steady = false;

    static time_point now() throw();
    static time_t to_time_t (const time_point& __t) throw();
    static time_point from_time_t(time_t __t) throw();
};

class __attribute__ ((__type_visibility__("default"))) steady_clock
{
public:
    typedef nanoseconds duration;
    typedef duration::rep rep;
    typedef duration::period period;
    typedef chrono::time_point<steady_clock, duration> time_point;
    static const bool is_steady = true;

    static time_point now() throw();
};

typedef steady_clock high_resolution_clock;

} // chrono
# 1025 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/chrono" 3
} }
# 16 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/__mutex_base" 2 3
# 1 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/system_error" 1 3
// -*- C++ -*-
//===---------------------------- system_error ----------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is dual licensed under the MIT and the University of Illinois Open
// Source Licenses. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//




/*
    system_error synopsis

namespace std
{

class error_category
{
public:
    virtual ~error_category() noexcept;

    constexpr error_category();
    error_category(const error_category&) = delete;
    error_category& operator=(const error_category&) = delete;

    virtual const char* name() const noexcept = 0;
    virtual error_condition default_error_condition(int ev) const noexcept;
    virtual bool equivalent(int code, const error_condition& condition) const noexcept;
    virtual bool equivalent(const error_code& code, int condition) const noexcept;
    virtual string message(int ev) const = 0;

    bool operator==(const error_category& rhs) const noexcept;
    bool operator!=(const error_category& rhs) const noexcept;
    bool operator<(const error_category& rhs) const noexcept;
};

const error_category& generic_category() noexcept;
const error_category& system_category() noexcept;

template <class T> struct is_error_code_enum
    : public false_type {};

template <class T> struct is_error_condition_enum
    : public false_type {};

class error_code
{
public:
    // constructors:
    error_code() noexcept;
    error_code(int val, const error_category& cat) noexcept;
    template <class ErrorCodeEnum>
        error_code(ErrorCodeEnum e) noexcept;

    // modifiers:
    void assign(int val, const error_category& cat) noexcept;
    template <class ErrorCodeEnum>
        error_code& operator=(ErrorCodeEnum e) noexcept;
    void clear() noexcept;

    // observers:
    int value() const noexcept;
    const error_category& category() const noexcept;
    error_condition default_error_condition() const noexcept;
    string message() const;
    explicit operator bool() const noexcept;
};

// non-member functions:
bool operator<(const error_code& lhs, const error_code& rhs) noexcept;
template <class charT, class traits>
    basic_ostream<charT,traits>&
    operator<<(basic_ostream<charT,traits>& os, const error_code& ec);

class error_condition
{
public:
    // constructors:
    error_condition() noexcept;
    error_condition(int val, const error_category& cat) noexcept;
    template <class ErrorConditionEnum>
        error_condition(ErrorConditionEnum e) noexcept;

    // modifiers:
    void assign(int val, const error_category& cat) noexcept;
    template <class ErrorConditionEnum>
        error_condition& operator=(ErrorConditionEnum e) noexcept;
    void clear() noexcept;

    // observers:
    int value() const noexcept;
    const error_category& category() const noexcept;
    string message() const noexcept;
    explicit operator bool() const noexcept;
};

bool operator<(const error_condition& lhs, const error_condition& rhs) noexcept;

class system_error
    : public runtime_error
{
public:
    system_error(error_code ec, const string& what_arg);
    system_error(error_code ec, const char* what_arg);
    system_error(error_code ec);
    system_error(int ev, const error_category& ecat, const string& what_arg);
    system_error(int ev, const error_category& ecat, const char* what_arg);
    system_error(int ev, const error_category& ecat);

    const error_code& code() const noexcept;
    const char* what() const noexcept;
};

enum class errc
{
    address_family_not_supported,       // EAFNOSUPPORT
    address_in_use,                     // EADDRINUSE
    address_not_available,              // EADDRNOTAVAIL
    already_connected,                  // EISCONN
    argument_list_too_long,             // E2BIG
    argument_out_of_domain,             // EDOM
    bad_address,                        // EFAULT
    bad_file_descriptor,                // EBADF
    bad_message,                        // EBADMSG
    broken_pipe,                        // EPIPE
    connection_aborted,                 // ECONNABORTED
    connection_already_in_progress,     // EALREADY
    connection_refused,                 // ECONNREFUSED
    connection_reset,                   // ECONNRESET
    cross_device_link,                  // EXDEV
    destination_address_required,       // EDESTADDRREQ
    device_or_resource_busy,            // EBUSY
    directory_not_empty,                // ENOTEMPTY
    executable_format_error,            // ENOEXEC
    file_exists,                        // EEXIST
    file_too_large,                     // EFBIG
    filename_too_long,                  // ENAMETOOLONG
    function_not_supported,             // ENOSYS
    host_unreachable,                   // EHOSTUNREACH
    identifier_removed,                 // EIDRM
    illegal_byte_sequence,              // EILSEQ
    inappropriate_io_control_operation, // ENOTTY
    interrupted,                        // EINTR
    invalid_argument,                   // EINVAL
    invalid_seek,                       // ESPIPE
    io_error,                           // EIO
    is_a_directory,                     // EISDIR
    message_size,                       // EMSGSIZE
    network_down,                       // ENETDOWN
    network_reset,                      // ENETRESET
    network_unreachable,                // ENETUNREACH
    no_buffer_space,                    // ENOBUFS
    no_child_process,                   // ECHILD
    no_link,                            // ENOLINK
    no_lock_available,                  // ENOLCK
    no_message_available,               // ENODATA
    no_message,                         // ENOMSG
    no_protocol_option,                 // ENOPROTOOPT
    no_space_on_device,                 // ENOSPC
    no_stream_resources,                // ENOSR
    no_such_device_or_address,          // ENXIO
    no_such_device,                     // ENODEV
    no_such_file_or_directory,          // ENOENT
    no_such_process,                    // ESRCH
    not_a_directory,                    // ENOTDIR
    not_a_socket,                       // ENOTSOCK
    not_a_stream,                       // ENOSTR
    not_connected,                      // ENOTCONN
    not_enough_memory,                  // ENOMEM
    not_supported,                      // ENOTSUP
    operation_canceled,                 // ECANCELED
    operation_in_progress,              // EINPROGRESS
    operation_not_permitted,            // EPERM
    operation_not_supported,            // EOPNOTSUPP
    operation_would_block,              // EWOULDBLOCK
    owner_dead,                         // EOWNERDEAD
    permission_denied,                  // EACCES
    protocol_error,                     // EPROTO
    protocol_not_supported,             // EPROTONOSUPPORT
    read_only_file_system,              // EROFS
    resource_deadlock_would_occur,      // EDEADLK
    resource_unavailable_try_again,     // EAGAIN
    result_out_of_range,                // ERANGE
    state_not_recoverable,              // ENOTRECOVERABLE
    stream_timeout,                     // ETIME
    text_file_busy,                     // ETXTBSY
    timed_out,                          // ETIMEDOUT
    too_many_files_open_in_system,      // ENFILE
    too_many_files_open,                // EMFILE
    too_many_links,                     // EMLINK
    too_many_symbolic_link_levels,      // ELOOP
    value_too_large,                    // EOVERFLOW
    wrong_protocol_type                 // EPROTOTYPE
};

template <> struct is_error_condition_enum<errc>
    : true_type { }

error_code make_error_code(errc e) noexcept;
error_condition make_error_condition(errc e) noexcept;

// Comparison operators:
bool operator==(const error_code& lhs, const error_code& rhs) noexcept;
bool operator==(const error_code& lhs, const error_condition& rhs) noexcept;
bool operator==(const error_condition& lhs, const error_code& rhs) noexcept;
bool operator==(const error_condition& lhs, const error_condition& rhs) noexcept;
bool operator!=(const error_code& lhs, const error_code& rhs) noexcept;
bool operator!=(const error_code& lhs, const error_condition& rhs) noexcept;
bool operator!=(const error_condition& lhs, const error_code& rhs) noexcept;
bool operator!=(const error_condition& lhs, const error_condition& rhs) noexcept;

template <> struct hash<std::error_code>;

}  // std

*/



# 1 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/cerrno" 1 3
// -*- C++ -*-
//===-------------------------- cerrno ------------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is dual licensed under the MIT and the University of Illinois Open
// Source Licenses. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//




/*
    cerrno synopsis

Macros:

    EDOM
    EILSEQ  // C99
    ERANGE
    errno

*/



# 1 "/usr/include/errno.h" 1 3 4
/*
 * Copyright (c) 2000 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

# 1 "/usr/include/sys/errno.h" 1 3 4
/*
 * Copyright (c) 2000-2012 Apple, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
/* Copyright (c) 1995 NeXT Computer, Inc. All Rights Reserved */
/*
 * Copyright (c) 1982, 1986, 1989, 1993
 *	The Regents of the University of California.  All rights reserved.
 * (c) UNIX System Laboratories, Inc.
 * All or some portions of this file are derived from material licensed
 * to the University of California by American Telephone and Telegraph
 * Co. or Unix System Laboratories, Inc. and are reproduced herein with
 * the permission of UNIX System Laboratories, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)errno.h	8.5 (Berkeley) 1/21/94
 */
# 79 "/usr/include/sys/errno.h" 3 4
extern "C" {
extern int * __error(void);

}

/*
 * Error codes
 */
# 99 "/usr/include/sys/errno.h" 3 4
     /* 11 was EAGAIN */
# 124 "/usr/include/sys/errno.h" 3 4
/* math software */



/* non-blocking and interrupt i/o */





/* ipc/network software -- argument errors */
# 164 "/usr/include/sys/errno.h" 3 4
/* ipc/network software -- operational errors */
# 183 "/usr/include/sys/errno.h" 3 4
/* should be rearranged */






/* quotas & mush */






/* Network File System */
# 216 "/usr/include/sys/errno.h" 3 4
/* Intelligent device errors */






/* Program loading errors */
# 250 "/usr/include/sys/errno.h" 3 4
/* This value is only discrete when compiling __DARWIN_UNIX03, or KERNEL */
# 24 "/usr/include/errno.h" 2 3 4
# 28 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/cerrno" 2 3
# 31 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/cerrno" 3
# 77 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/cerrno" 3
//  supply errno values likely to be missing, particularly on Windows
# 255 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/cerrno" 3
//  Windows Mobile doesn't appear to define these:
# 223 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/system_error" 2 3
# 229 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/system_error" 3


namespace std {inline namespace __1 {

// is_error_code_enum

template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_error_code_enum
    : public false_type {};

// is_error_condition_enum

template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_error_condition_enum
    : public false_type {};

// Some error codes are not present on all platforms, so we provide equivalents
// for them:

//enum class errc
struct __attribute__ ((__type_visibility__("default"))) errc { enum __lx
{
    address_family_not_supported = 47,
    address_in_use = 48,
    address_not_available = 49,
    already_connected = 56,
    argument_list_too_long = 7,
    argument_out_of_domain = 33,
    bad_address = 14,
    bad_file_descriptor = 9,
    bad_message = 94,
    broken_pipe = 32,
    connection_aborted = 53,
    connection_already_in_progress = 37,
    connection_refused = 61,
    connection_reset = 54,
    cross_device_link = 18,
    destination_address_required = 39,
    device_or_resource_busy = 16,
    directory_not_empty = 66,
    executable_format_error = 8,
    file_exists = 17,
    file_too_large = 27,
    filename_too_long = 63,
    function_not_supported = 78,
    host_unreachable = 65,
    identifier_removed = 90,
    illegal_byte_sequence = 92,
    inappropriate_io_control_operation = 25,
    interrupted = 4,
    invalid_argument = 22,
    invalid_seek = 29,
    io_error = 5,
    is_a_directory = 21,
    message_size = 40,
    network_down = 50,
    network_reset = 52,
    network_unreachable = 51,
    no_buffer_space = 55,
    no_child_process = 10,
    no_link = 97,
    no_lock_available = 77,

    no_message_available = 96,



    no_message = 91,
    no_protocol_option = 42,
    no_space_on_device = 28,

    no_stream_resources = 98,



    no_such_device_or_address = 6,
    no_such_device = 19,
    no_such_file_or_directory = 2,
    no_such_process = 3,
    not_a_directory = 20,
    not_a_socket = 38,

    not_a_stream = 99,



    not_connected = 57,
    not_enough_memory = 12,
    not_supported = 45,
    operation_canceled = 89,
    operation_in_progress = 36,
    operation_not_permitted = 1,
    operation_not_supported = 102,
    operation_would_block = 35,
    owner_dead = 105,
    permission_denied = 13,
    protocol_error = 100,
    protocol_not_supported = 43,
    read_only_file_system = 30,
    resource_deadlock_would_occur = 11,
    resource_unavailable_try_again = 35,
    result_out_of_range = 34,
    state_not_recoverable = 104,

    stream_timeout = 101,



    text_file_busy = 26,
    timed_out = 60,
    too_many_files_open_in_system = 23,
    too_many_files_open = 24,
    too_many_links = 31,
    too_many_symbolic_link_levels = 62,
    value_too_large = 84,
    wrong_protocol_type = 41
};
__lx __v_; __attribute__ ((__visibility__("hidden"), __always_inline__)) errc(__lx __v) : __v_(__v) {} __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit errc(int __v) : __v_(static_cast<__lx>(__v)) {} __attribute__ ((__visibility__("hidden"), __always_inline__)) operator int() const {return __v_;} };

template <>
struct __attribute__ ((__type_visibility__("default"))) is_error_condition_enum<errc>
    : true_type { };


template <>
struct __attribute__ ((__type_visibility__("default"))) is_error_condition_enum<errc::__lx>
    : true_type { };


class __attribute__ ((__type_visibility__("default"))) error_condition;
class __attribute__ ((__type_visibility__("default"))) error_code;

// class error_category

class __attribute__ ((__visibility__("hidden"))) __do_message;

class __attribute__ ((__type_visibility__("default"))) error_category
{
public:
    virtual ~error_category() throw();




    __attribute__ ((__visibility__("hidden"), __always_inline__))
                                  error_category() throw() {};

private:
    error_category(const error_category&);// = delete;
    error_category& operator=(const error_category&);// = delete;

public:
    virtual const char* name() const throw() = 0;
    virtual error_condition default_error_condition(int __ev) const throw();
    virtual bool equivalent(int __code, const error_condition& __condition) const throw();
    virtual bool equivalent(const error_code& __code, int __condition) const throw();
    virtual string message(int __ev) const = 0;

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator==(const error_category& __rhs) const throw() {return this == &__rhs;}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator!=(const error_category& __rhs) const throw() {return !(*this == __rhs);}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator< (const error_category& __rhs) const throw() {return this < &__rhs;}

    friend class __attribute__ ((__visibility__("hidden"))) __do_message;
};

class __attribute__ ((__visibility__("hidden"))) __do_message
    : public error_category
{
public:
    virtual string message(int ev) const;
};

__attribute__ ((__visibility__("default"))) const error_category& generic_category() throw();
__attribute__ ((__visibility__("default"))) const error_category& system_category() throw();

class __attribute__ ((__type_visibility__("default"))) error_condition
{
    int __val_;
    const error_category* __cat_;
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    error_condition() throw() : __val_(0), __cat_(&generic_category()) {}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    error_condition(int __val, const error_category& __cat) throw()
        : __val_(__val), __cat_(&__cat) {}

    template <class _Ep>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        error_condition(_Ep __e,
              typename enable_if<is_error_condition_enum<_Ep>::value>::type* = 0
                                                                     ) throw()
            {*this = make_error_condition(__e);}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void assign(int __val, const error_category& __cat) throw()
    {
        __val_ = __val;
        __cat_ = &__cat;
    }

    template <class _Ep>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        typename enable_if
        <
            is_error_condition_enum<_Ep>::value,
            error_condition&
        >::type
        operator=(_Ep __e) throw()
            {*this = make_error_condition(__e); return *this;}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void clear() throw()
    {
        __val_ = 0;
        __cat_ = &generic_category();
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    int value() const throw() {return __val_;}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const error_category& category() const throw() {return *__cat_;}
    string message() const;

    __attribute__ ((__visibility__("hidden"), __always_inline__))

        operator bool() const throw() {return __val_ != 0;}
};

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
error_condition
make_error_condition(errc __e) throw()
{
    return error_condition(static_cast<int>(__e), generic_category());
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator<(const error_condition& __x, const error_condition& __y) throw()
{
    return __x.category() < __y.category()
        || (__x.category() == __y.category() && __x.value() < __y.value());
}

// error_code

class __attribute__ ((__type_visibility__("default"))) error_code
{
    int __val_;
    const error_category* __cat_;
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    error_code() throw() : __val_(0), __cat_(&system_category()) {}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    error_code(int __val, const error_category& __cat) throw()
        : __val_(__val), __cat_(&__cat) {}

    template <class _Ep>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        error_code(_Ep __e,
                   typename enable_if<is_error_code_enum<_Ep>::value>::type* = 0
                                                                     ) throw()
            {*this = make_error_code(__e);}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void assign(int __val, const error_category& __cat) throw()
    {
        __val_ = __val;
        __cat_ = &__cat;
    }

    template <class _Ep>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        typename enable_if
        <
            is_error_code_enum<_Ep>::value,
            error_code&
        >::type
        operator=(_Ep __e) throw()
            {*this = make_error_code(__e); return *this;}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void clear() throw()
    {
        __val_ = 0;
        __cat_ = &system_category();
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    int value() const throw() {return __val_;}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const error_category& category() const throw() {return *__cat_;}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    error_condition default_error_condition() const throw()
        {return __cat_->default_error_condition(__val_);}

    string message() const;

    __attribute__ ((__visibility__("hidden"), __always_inline__))

        operator bool() const throw() {return __val_ != 0;}
};

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
error_code
make_error_code(errc __e) throw()
{
    return error_code(static_cast<int>(__e), generic_category());
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator<(const error_code& __x, const error_code& __y) throw()
{
    return __x.category() < __y.category()
        || (__x.category() == __y.category() && __x.value() < __y.value());
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator==(const error_code& __x, const error_code& __y) throw()
{
    return __x.category() == __y.category() && __x.value() == __y.value();
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator==(const error_code& __x, const error_condition& __y) throw()
{
    return __x.category().equivalent(__x.value(), __y)
        || __y.category().equivalent(__x, __y.value());
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator==(const error_condition& __x, const error_code& __y) throw()
{
    return __y == __x;
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator==(const error_condition& __x, const error_condition& __y) throw()
{
    return __x.category() == __y.category() && __x.value() == __y.value();
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator!=(const error_code& __x, const error_code& __y) throw()
{return !(__x == __y);}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator!=(const error_code& __x, const error_condition& __y) throw()
{return !(__x == __y);}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator!=(const error_condition& __x, const error_code& __y) throw()
{return !(__x == __y);}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator!=(const error_condition& __x, const error_condition& __y) throw()
{return !(__x == __y);}

template <>
struct __attribute__ ((__type_visibility__("default"))) hash<error_code>
    : public unary_function<error_code, size_t>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_t operator()(const error_code& __ec) const throw()
    {
        return static_cast<size_t>(__ec.value());
    }
};

// system_error

class __attribute__ ((__type_visibility__("default"))) system_error
    : public runtime_error
{
    error_code __ec_;
public:
    system_error(error_code __ec, const string& __what_arg);
    system_error(error_code __ec, const char* __what_arg);
    system_error(error_code __ec);
    system_error(int __ev, const error_category& __ecat, const string& __what_arg);
    system_error(int __ev, const error_category& __ecat, const char* __what_arg);
    system_error(int __ev, const error_category& __ecat);
    ~system_error() throw();

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const error_code& code() const throw() {return __ec_;}

private:
    static string __init(const error_code&, string);
};

__attribute__ ((__visibility__("default"))) void __throw_system_error(int ev, const char* what_arg);

} }
# 17 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/__mutex_base" 2 3
# 1 "/usr/include/pthread.h" 1 3 4
/*
 * Copyright (c) 2000-2012 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_LICENSE_HEADER_END@
 */
/*
 * Copyright 1996 1995 by Open Software Foundation, Inc. 1997 1996 1995 1994 1993 1992 1991
 *              All Rights Reserved
 *
 * Permission to use, copy, modify, and distribute this software and
 * its documentation for any purpose and without fee is hereby granted,
 * provided that the above copyright notice appears in all copies and
 * that both the copyright notice and this permission notice appear in
 * supporting documentation.
 *
 * OSF DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE.
 *
 * IN NO EVENT SHALL OSF BE LIABLE FOR ANY SPECIAL, INDIRECT, OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
 * LOSS OF USE, DATA OR PROFITS, WHETHER IN ACTION OF CONTRACT,
 * NEGLIGENCE, OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION
 * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 */
/*
 * MkLinux
 */

/*
 * POSIX Threads - IEEE 1003.1c
 */







# 1 "/usr/include/pthread/pthread_impl.h" 1 3 4
/*
 * Copyright (c) 2000-2003 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */



/*
 * Internal implementation details
 */

/* This whole header file will disappear, so don't depend on it... */



/*
 * [Internal] data structure signatures
 */
# 47 "/usr/include/pthread/pthread_impl.h" 3 4
/*
 * POSIX scheduling policies
 */
# 58 "/usr/include/pthread.h" 2 3 4

# 1 "/usr/include/pthread/sched.h" 1 3 4
/*
 * Copyright (c) 2000-2003 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */







extern "C" {
/*
 * Scheduling paramters
 */

struct sched_param { int sched_priority; char __opaque[4]; };


extern int sched_yield(void);
extern int sched_get_priority_min(int);
extern int sched_get_priority_max(int);
}
# 60 "/usr/include/pthread.h" 2 3 4



# 1 "/usr/include/sys/_pthread/_pthread_cond_t.h" 1 3 4
/*
 * Copyright (c) 2003-2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */


typedef __darwin_pthread_cond_t pthread_cond_t;
# 64 "/usr/include/pthread.h" 2 3 4
# 1 "/usr/include/sys/_pthread/_pthread_condattr_t.h" 1 3 4
/*
 * Copyright (c) 2003-2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */


typedef __darwin_pthread_condattr_t pthread_condattr_t;
# 65 "/usr/include/pthread.h" 2 3 4
# 1 "/usr/include/sys/_pthread/_pthread_key_t.h" 1 3 4
/*
 * Copyright (c) 2003-2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */


typedef __darwin_pthread_key_t pthread_key_t;
# 66 "/usr/include/pthread.h" 2 3 4
# 1 "/usr/include/sys/_pthread/_pthread_mutex_t.h" 1 3 4
/*
 * Copyright (c) 2003-2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */


typedef __darwin_pthread_mutex_t pthread_mutex_t;
# 67 "/usr/include/pthread.h" 2 3 4
# 1 "/usr/include/sys/_pthread/_pthread_mutexattr_t.h" 1 3 4
/*
 * Copyright (c) 2003-2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */


typedef __darwin_pthread_mutexattr_t pthread_mutexattr_t;
# 68 "/usr/include/pthread.h" 2 3 4
# 1 "/usr/include/sys/_pthread/_pthread_once_t.h" 1 3 4
/*
 * Copyright (c) 2003-2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */


typedef __darwin_pthread_once_t pthread_once_t;
# 69 "/usr/include/pthread.h" 2 3 4
# 1 "/usr/include/sys/_pthread/_pthread_rwlock_t.h" 1 3 4
/*
 * Copyright (c) 2003-2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */


typedef __darwin_pthread_rwlock_t pthread_rwlock_t;
# 70 "/usr/include/pthread.h" 2 3 4
# 1 "/usr/include/sys/_pthread/_pthread_rwlockattr_t.h" 1 3 4
/*
 * Copyright (c) 2003-2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */


typedef __darwin_pthread_rwlockattr_t pthread_rwlockattr_t;
# 71 "/usr/include/pthread.h" 2 3 4
# 1 "/usr/include/sys/_pthread/_pthread_t.h" 1 3 4
/*
 * Copyright (c) 2003-2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */


typedef __darwin_pthread_t pthread_t;
# 72 "/usr/include/pthread.h" 2 3 4

# 1 "/usr/include/pthread/qos.h" 1 3 4
/*
 * Copyright (c) 2013-2014 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_LICENSE_HEADER_END@
 */
# 32 "/usr/include/pthread/qos.h" 3 4
# 1 "/usr/include/sys/qos.h" 1 3 4
/*
 * Copyright (c) 2013-2014 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_LICENSE_HEADER_END@
 */







/*!
 * @typedef qos_class_t
 *
 * @abstract
 * An abstract thread quality of service (QOS) classification.
 *
 * @discussion
 * Thread quality of service (QOS) classes are ordered abstract representations
 * of the nature of work that is expected to be performed by a pthread, dispatch
 * queue, or NSOperation. Each class specifies a maximum thread scheduling
 * priority for that band (which may be used in combination with a relative
 * priority offset within the band), as well as quality of service
 * characteristics for timer latency, CPU throughput, I/O throughput, network
 * socket traffic management behavior and more.
 *
 * A best effort is made to allocate available system resources to every QOS
 * class. Quality of service degredation only occurs during system resource
 * contention, proportionally to the QOS class. That said, QOS classes
 * representing user-initiated work attempt to achieve peak throughput while
 * QOS classes for other work attempt to achieve peak energy and thermal
 * efficiency, even in the absence of contention. Finally, the use of QOS
 * classes does not allow threads to supersede any limits that may be applied
 * to the overall process.
 */

/*!
 * @constant QOS_CLASS_USER_INTERACTIVE
 * @abstract A QOS class which indicates work performed by this thread
 * is interactive with the user.
 * @discussion Such work is requested to run at high priority relative to other
 * work on the system. Specifying this QOS class is a request to run with
 * nearly all available system CPU and I/O bandwidth even under contention.
 * This is not an energy-efficient QOS class to use for large tasks. The use of
 * this QOS class should be limited to critical interaction with the user such
 * as handling events on the main event loop, view drawing, animation, etc.
 *
 * @constant QOS_CLASS_USER_INITIATED
 * @abstract A QOS class which indicates work performed by this thread
 * was initiated by the user and that the user is likely waiting for the
 * results.
 * @discussion Such work is requested to run at a priority below critical user-
 * interactive work, but relatively higher than other work on the system. This
 * is not an energy-efficient QOS class to use for large tasks and the use of
 * this QOS class should be limited to operations where the user is immediately
 * waiting for the results.
 *
 * @constant QOS_CLASS_DEFAULT
 * @abstract A default QOS class used by the system in cases where more specific
 * QOS class information is not available.
 * @discussion Such work is requested to run at a priority below critical user-
 * interactive and user-initiated work, but relatively higher than utility and
 * background tasks. Threads created by pthread_create() without an attribute
 * specifying a QOS class will default to QOS_CLASS_DEFAULT. This QOS class
 * value is not intended to be used as a work classification, it should only be
 * set when propagating or restoring QOS class values provided by the system.
 *
 * @constant QOS_CLASS_UTILITY
 * @abstract A QOS class which indicates work performed by this thread
 * may or may not be initiated by the user and that the user is unlikely to be
 * immediately waiting for the results.
 * @discussion Such work is requested to run at a priority below critical user-
 * interactive and user-initiated work, but relatively higher than low-level
 * system maintenance tasks. The use of this QOS class indicates the work should
 * be run in an energy and thermally-efficient manner.
 *
 * @constant QOS_CLASS_BACKGROUND
 * @abstract A QOS class which indicates work performed by this thread was not
 * initiated by the user and that the user may be unaware of the results.
 * @discussion Such work is requested to run at a priority below other work.
 * The use of this QOS class indicates the work should be run in the most energy
 * and thermally-efficient manner.
 *
 * @constant QOS_CLASS_UNSPECIFIED
 * @abstract A QOS class value which indicates the absence or removal of QOS
 * class information.
 * @discussion As an API return value, may indicate that threads or pthread
 * attributes were configured with legacy API incompatible or in conflict with
 * the QOS class system.
 */
# 124 "/usr/include/sys/qos.h" 3 4
enum { QOS_CLASS_USER_INTERACTIVE __attribute__((availability(macosx,introduced=10.10))) = 0x21, QOS_CLASS_USER_INITIATED __attribute__((availability(macosx,introduced=10.10))) = 0x19, QOS_CLASS_DEFAULT __attribute__((availability(macosx,introduced=10.10))) = 0x15, QOS_CLASS_UTILITY __attribute__((availability(macosx,introduced=10.10))) = 0x11, QOS_CLASS_BACKGROUND __attribute__((availability(macosx,introduced=10.10))) = 0x09, QOS_CLASS_UNSPECIFIED __attribute__((availability(macosx,introduced=10.10))) = 0x00, }; typedef unsigned int qos_class_t;
# 141 "/usr/include/sys/qos.h" 3 4
/*!
 * @constant QOS_MIN_RELATIVE_PRIORITY
 * @abstract The minimum relative priority that may be specified within a
 * QOS class. These priorities are relative only within a given QOS class
 * and meaningful only for the current process.
 */


/* Userspace (only) definitions */



extern "C" {

/*!
 * @function qos_class_self
 *
 * @abstract
 * Returns the requested QOS class of the current thread.
 *
 * @return
 * One of the QOS class values in qos_class_t.
 */
__attribute__((availability(macosx,introduced=10.10)))
qos_class_t
qos_class_self(void);

/*!
 * @function qos_class_main
 *
 * @abstract
 * Returns the initial requested QOS class of the main thread.
 *
 * @discussion
 * The QOS class that the main thread of a process is created with depends on
 * the type of process (e.g. application or daemon) and on how it has been
 * launched.
 *
 * This function returns that initial requested QOS class value chosen by the
 * system to enable propagation of that classification to matching work not
 * executing on the main thread.
 *
 * @return
 * One of the QOS class values in qos_class_t.
 */
__attribute__((availability(macosx,introduced=10.10)))
qos_class_t
qos_class_main(void);

}
# 33 "/usr/include/pthread/qos.h" 2 3 4



extern "C" {

/*!
 * @function pthread_attr_set_qos_class_np
 *
 * @abstract
 * Sets the QOS class and relative priority of a pthread attribute structure
 * which may be used to specify the requested QOS class of newly created
 * threads.
 *
 * @discussion
 * The QOS class and relative priority represent an overall combination of
 * system quality of service attributes on a thread.
 *
 * Subsequent calls to interfaces such as pthread_attr_setschedparam() that are
 * incompatible or in conflict with the QOS class system will unset the QOS
 * class requested with this interface and pthread_attr_get_qos_class_np() will
 * return QOS_CLASS_UNSPECIFIED.
 *
 * @param __attr
 * The pthread attribute structure to modify.
 *
 * @param __qos_class
 * A QOS class value:
 *	- QOS_CLASS_USER_INTERACTIVE
 *	- QOS_CLASS_USER_INITIATED
 *	- QOS_CLASS_DEFAULT
 *	- QOS_CLASS_UTILITY
 *	- QOS_CLASS_BACKGROUND
 * EINVAL will be returned if any other value is provided.
 *
 * @param __relative_priority
 * A relative priority within the QOS class. This value is a negative offset
 * from the maximum supported scheduler priority for the given class.
 * EINVAL will be returned if the value is greater than zero or less than
 * QOS_MIN_RELATIVE_PRIORITY.
 *
 * @return
 * Zero if successful, otherwise an errno value.
 */
__attribute__((availability(macosx,introduced=10.10)))
int
pthread_attr_set_qos_class_np(pthread_attr_t *__attr,
  qos_class_t __qos_class, int __relative_priority);

/*!
 * @function pthread_attr_get_qos_class_np
 *
 * @abstract
 * Gets the QOS class and relative priority of a pthread attribute structure.
 *
 * @param __attr
 * The pthread attribute structure to inspect.
 *
 * @param __qos_class
 * On output, a QOS class value:
 *	- QOS_CLASS_USER_INTERACTIVE
 *	- QOS_CLASS_USER_INITIATED
 *	- QOS_CLASS_DEFAULT
 *	- QOS_CLASS_UTILITY
 *	- QOS_CLASS_BACKGROUND
 *	- QOS_CLASS_UNSPECIFIED
 * This value may be NULL in which case no value is returned.
 *
 * @param __relative_priority
 * On output, a relative priority offset within the QOS class.
 * This value may be NULL in which case no value is returned.
 *
 * @return
 * Zero if successful, otherwise an errno value.
 */
__attribute__((availability(macosx,introduced=10.10)))
int
pthread_attr_get_qos_class_np(pthread_attr_t * __attr,
  qos_class_t * __qos_class,
  int * __relative_priority);

/*!
 * @function pthread_set_qos_class_self_np
 *
 * @abstract
 * Sets the requested QOS class and relative priority of the current thread.
 *
 * @discussion
 * The QOS class and relative priority represent an overall combination of
 * system quality of service attributes on a thread.
 *
 * Subsequent calls to interfaces such as pthread_setschedparam() that are
 * incompatible or in conflict with the QOS class system will unset the QOS
 * class requested with this interface and pthread_get_qos_class_np() will
 * return QOS_CLASS_UNSPECIFIED thereafter. A thread so modified is permanently
 * opted-out of the QOS class system and calls to this function to request a QOS
 * class for such a thread will fail and return EPERM.
 *
 * @param __qos_class
 * A QOS class value:
 *	- QOS_CLASS_USER_INTERACTIVE
 *	- QOS_CLASS_USER_INITIATED
 *	- QOS_CLASS_DEFAULT
 *	- QOS_CLASS_UTILITY
 *	- QOS_CLASS_BACKGROUND
 * EINVAL will be returned if any other value is provided.
 *
 * @param __relative_priority
 * A relative priority within the QOS class. This value is a negative offset
 * from the maximum supported scheduler priority for the given class.
 * EINVAL will be returned if the value is greater than zero or less than
 * QOS_MIN_RELATIVE_PRIORITY.
 *
 * @return
 * Zero if successful, otherwise an errno value.
 */
__attribute__((availability(macosx,introduced=10.10)))
int
pthread_set_qos_class_self_np(qos_class_t __qos_class,
  int __relative_priority);

/*!
 * @function pthread_get_qos_class_np
 *
 * @abstract
 * Gets the requested QOS class and relative priority of a thread.
 *
 * @param __pthread
 * The target thread to inspect.
 *
 * @param __qos_class
 * On output, a QOS class value:
 *	- QOS_CLASS_USER_INTERACTIVE
 *	- QOS_CLASS_USER_INITIATED
 *	- QOS_CLASS_DEFAULT
 *	- QOS_CLASS_UTILITY
 *	- QOS_CLASS_BACKGROUND
 *	- QOS_CLASS_UNSPECIFIED
 * This value may be NULL in which case no value is returned.
 *
 * @param __relative_priority
 * On output, a relative priority offset within the QOS class.
 * This value may be NULL in which case no value is returned.
 *
 * @return
 * Zero if successful, otherwise an errno value.
 */
__attribute__((availability(macosx,introduced=10.10)))
int
pthread_get_qos_class_np(pthread_t __pthread,
  qos_class_t * __qos_class,
  int * __relative_priority);

/*!
 * @typedef pthread_override_t
 *
 * @abstract
 * An opaque object representing a QOS class override of a thread.
 *
 * @discussion
 * A QOS class override of a target thread expresses that an item of pending
 * work classified with a specific QOS class and relative priority depends on
 * the completion of the work currently being executed by the thread (e.g. due
 * to ordering requirements).
 *
 * While overrides are in effect, the target thread will execute at the maximum
 * QOS class and relative priority of all overrides and of the QOS class
 * requested by the thread itself.
 *
 * A QOS class override does not modify the target thread's requested QOS class
 * value and the effect of an override is not visible to the qos_class_self()
 * and pthread_get_qos_class_np() interfaces.
 */

typedef struct pthread_override_s* pthread_override_t;

/*!
 * @function pthread_override_qos_class_start_np
 *
 * @abstract
 * Starts a QOS class override of the specified target thread.
 *
 * @discussion
 * Starting a QOS class override of the specified target thread expresses that
 * an item of pending work classified with the specified QOS class and relative
 * priority depends on the completion of the work currently being executed by
 * the thread (e.g. due to ordering requirements).
 *
 * While overrides are in effect, the specified target thread will execute at
 * the maximum QOS class and relative priority of all overrides and of the QOS
 * class requested by the thread itself.
 *
 * Starting a QOS class override does not modify the target thread's requested
 * QOS class value and the effect of an override is not visible to the
 * qos_class_self() and pthread_get_qos_class_np() interfaces.
 *
 * The returned newly allocated override object is intended to be associated
 * with the item of pending work in question. Once the dependency has been
 * satisfied and enabled that work to begin executing, the QOS class override
 * must be ended by passing the associated override object to
 * pthread_override_qos_class_end_np(). Failure to do so will result in the
 * associated resources to be leaked and the target thread to be permanently
 * executed at an inappropriately elevated QOS class.
 *
 * @param __pthread
 * The target thread to modify.
 *
 * @param __qos_class
 * A QOS class value:
 *	- QOS_CLASS_USER_INTERACTIVE
 *	- QOS_CLASS_USER_INITIATED
 *	- QOS_CLASS_DEFAULT
 *	- QOS_CLASS_UTILITY
 *	- QOS_CLASS_BACKGROUND
 * NULL will be returned if any other value is provided.
 *
 * @param __relative_priority
 * A relative priority within the QOS class. This value is a negative offset
 * from the maximum supported scheduler priority for the given class.
 * NULL will be returned if the value is greater than zero or less than
 * QOS_MIN_RELATIVE_PRIORITY.
 *
 * @return
 * A newly allocated override object if successful, or NULL if the override
 * could not be started.
 */
__attribute__((availability(macosx,introduced=10.10)))
pthread_override_t
pthread_override_qos_class_start_np(pthread_t __pthread,
  qos_class_t __qos_class, int __relative_priority);

/*!
 * @function pthread_override_qos_class_end_np
 *
 * @abstract
 * Ends a QOS class override.
 *
 * @discussion
 * Passing an override object returned by pthread_override_qos_class_start_np()
 * ends the QOS class override started by that call and deallocates all
 * associated resources as well as the override object itself.
 *
 * The thread starting and the thread ending a QOS class override need not be
 * identical. If the thread ending the override is the the target thread of the
 * override itself, it should take care to elevate its requested QOS class
 * appropriately with pthread_set_qos_class_self_np() before ending the
 * override.
 *
 * @param __override
 * An override object returned by pthread_override_qos_class_start_np().
 *
 * @return
 * Zero if successful, otherwise an errno value.
 */
__attribute__((availability(macosx,introduced=10.10)))
int
pthread_override_qos_class_end_np(pthread_override_t __override);

}
# 74 "/usr/include/pthread.h" 2 3 4



# 1 "/usr/include/sys/_types/_mach_port_t.h" 1 3 4
/*
 * Copyright (c) 2003-2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */

/* 
 *	mach_port_t - a named port right
 *
 *	In user-space, "rights" are represented by the name of the
 *	right in the Mach port namespace.  Even so, this type is
 *	presented as a unique one to more clearly denote the presence
 *	of a right coming along with the name. 
 *
 *	Often, various rights for a port held in a single name space
 *	will coalesce and are, therefore, be identified by a single name
 *	[this is the case for send and receive rights].  But not
 *	always [send-once rights currently get a unique name for
 *	each right].      
 *
 *	This definition of mach_port_t is only for user-space.
 *
 */



typedef __darwin_mach_port_t mach_port_t;
# 78 "/usr/include/pthread.h" 2 3 4




/*
 * These symbols indicate which [optional] features are available
 * They can be tested at compile time via '#ifdef XXX'
 * The way to check for pthreads is like so:

 * #include <unistd.h>
 * #ifdef _POSIX_THREADS
 * #include <pthread.h>
 * #endif

 */

/* These will be moved to unistd.h */

/*
 * Note: These data structures are meant to be opaque.  Only enough
 * structure is exposed to support initializers.
 * All of the typedefs will be moved to <sys/types.h>
 */




extern "C" {
/*
 * Threads
 */


/*
 * Cancel cleanup handler management.  Note, since these are implemented as macros,
 * they *MUST* occur in matched pairs!
 */
# 131 "/usr/include/pthread.h" 3 4
/*
 * Thread attributes
 */
# 146 "/usr/include/pthread.h" 3 4
/* Value returned from pthread_join() when a thread is canceled */


/* We only support PTHREAD_SCOPE_SYSTEM */



/* We only support PTHREAD_PROCESS_PRIVATE */



/*
 * Mutex protocol attributes
 */




/*
 * Mutex type attributes
 */





/*
 * RWLock variables
 */


/*
 * Mutex variables
 */


/* <rdar://problem/10854763> */







/*
 * Condition variable attributes
 */

/*
 * Condition variables
 */



/*
 * Initialization control (once) variables
 */



/*
 * Prototypes for all PTHREAD interfaces
 */
__attribute__((availability(macosx,introduced=10.4)))
int pthread_atfork(void (*)(void), void (*)(void), void (*)(void));

__attribute__((availability(macosx,introduced=10.4)))
int pthread_attr_destroy(pthread_attr_t *);

__attribute__((availability(macosx,introduced=10.4)))
int pthread_attr_getdetachstate(const pthread_attr_t *, int *);

__attribute__((availability(macosx,introduced=10.4)))
int pthread_attr_getguardsize(const pthread_attr_t * , size_t * );

__attribute__((availability(macosx,introduced=10.4)))
int pthread_attr_getinheritsched(const pthread_attr_t * , int * );

__attribute__((availability(macosx,introduced=10.4)))
int pthread_attr_getschedparam(const pthread_attr_t * ,
  struct sched_param * );

__attribute__((availability(macosx,introduced=10.4)))
int pthread_attr_getschedpolicy(const pthread_attr_t * , int * );

__attribute__((availability(macosx,introduced=10.4)))
int pthread_attr_getscope(const pthread_attr_t * , int * );

__attribute__((availability(macosx,introduced=10.4)))
int pthread_attr_getstack(const pthread_attr_t * , void ** ,
  size_t * );

__attribute__((availability(macosx,introduced=10.4)))
int pthread_attr_getstackaddr(const pthread_attr_t * , void ** );

__attribute__((availability(macosx,introduced=10.4)))
int pthread_attr_getstacksize(const pthread_attr_t * , size_t * );

__attribute__((availability(macosx,introduced=10.4)))
int pthread_attr_init(pthread_attr_t *);

__attribute__((availability(macosx,introduced=10.4)))
int pthread_attr_setdetachstate(pthread_attr_t *, int);

__attribute__((availability(macosx,introduced=10.4)))
int pthread_attr_setguardsize(pthread_attr_t *, size_t);

__attribute__((availability(macosx,introduced=10.4)))
int pthread_attr_setinheritsched(pthread_attr_t *, int);

__attribute__((availability(macosx,introduced=10.4)))
int pthread_attr_setschedparam(pthread_attr_t * ,
  const struct sched_param * );

__attribute__((availability(macosx,introduced=10.4)))
int pthread_attr_setschedpolicy(pthread_attr_t *, int);

__attribute__((availability(macosx,introduced=10.4)))
int pthread_attr_setscope(pthread_attr_t *, int);

__attribute__((availability(macosx,introduced=10.4)))
int pthread_attr_setstack(pthread_attr_t *, void *, size_t);

__attribute__((availability(macosx,introduced=10.4)))
int pthread_attr_setstackaddr(pthread_attr_t *, void *);

__attribute__((availability(macosx,introduced=10.4)))
int pthread_attr_setstacksize(pthread_attr_t *, size_t);

__attribute__((availability(macosx,introduced=10.4)))
int pthread_cancel(pthread_t) __asm("_" "pthread_cancel" );

__attribute__((availability(macosx,introduced=10.4)))
int pthread_cond_broadcast(pthread_cond_t *);

__attribute__((availability(macosx,introduced=10.4)))
int pthread_cond_destroy(pthread_cond_t *);

__attribute__((availability(macosx,introduced=10.4)))
int pthread_cond_init(pthread_cond_t * ,
  const pthread_condattr_t * ) __asm("_" "pthread_cond_init" );

__attribute__((availability(macosx,introduced=10.4)))
int pthread_cond_signal(pthread_cond_t *);

__attribute__((availability(macosx,introduced=10.4)))
int pthread_cond_timedwait(pthread_cond_t * , pthread_mutex_t * ,
  const struct timespec * ) __asm("_" "pthread_cond_timedwait" );

__attribute__((availability(macosx,introduced=10.4)))
int pthread_cond_wait(pthread_cond_t * ,
  pthread_mutex_t * ) __asm("_" "pthread_cond_wait" );

__attribute__((availability(macosx,introduced=10.4)))
int pthread_condattr_destroy(pthread_condattr_t *);

__attribute__((availability(macosx,introduced=10.4)))
int pthread_condattr_init(pthread_condattr_t *);

__attribute__((availability(macosx,introduced=10.4)))
int pthread_condattr_getpshared(const pthread_condattr_t * ,
  int * );

__attribute__((availability(macosx,introduced=10.4)))
int pthread_condattr_setpshared(pthread_condattr_t *, int);

__attribute__((availability(macosx,introduced=10.4)))
int pthread_create(pthread_t * , const pthread_attr_t * ,
  void *(*)(void *), void * );

__attribute__((availability(macosx,introduced=10.4)))
int pthread_detach(pthread_t);

__attribute__((availability(macosx,introduced=10.4)))
int pthread_equal(pthread_t, pthread_t);

__attribute__((availability(macosx,introduced=10.4)))
void pthread_exit(void *) __attribute__((noreturn));

__attribute__((availability(macosx,introduced=10.4)))
int pthread_getconcurrency(void);

__attribute__((availability(macosx,introduced=10.4)))
int pthread_getschedparam(pthread_t , int * ,
  struct sched_param * );

__attribute__((availability(macosx,introduced=10.4)))
void* pthread_getspecific(pthread_key_t);

__attribute__((availability(macosx,introduced=10.4)))
int pthread_join(pthread_t , void **) __asm("_" "pthread_join" );

__attribute__((availability(macosx,introduced=10.4)))
int pthread_key_create(pthread_key_t *, void (*)(void *));

__attribute__((availability(macosx,introduced=10.4)))
int pthread_key_delete(pthread_key_t);

__attribute__((availability(macosx,introduced=10.4)))
int pthread_mutex_destroy(pthread_mutex_t *);

__attribute__((availability(macosx,introduced=10.4)))
int pthread_mutex_getprioceiling(const pthread_mutex_t * ,
  int * );

__attribute__((availability(macosx,introduced=10.4)))
int pthread_mutex_init(pthread_mutex_t * ,
  const pthread_mutexattr_t * );

__attribute__((availability(macosx,introduced=10.4)))
int pthread_mutex_lock(pthread_mutex_t *);

__attribute__((availability(macosx,introduced=10.4)))
int pthread_mutex_setprioceiling(pthread_mutex_t * , int,
  int * );

__attribute__((availability(macosx,introduced=10.4)))
int pthread_mutex_trylock(pthread_mutex_t *);

__attribute__((availability(macosx,introduced=10.4)))
int pthread_mutex_unlock(pthread_mutex_t *);

__attribute__((availability(macosx,introduced=10.4)))
int pthread_mutexattr_destroy(pthread_mutexattr_t *) __asm("_" "pthread_mutexattr_destroy" );

__attribute__((availability(macosx,introduced=10.4)))
int pthread_mutexattr_getprioceiling(const pthread_mutexattr_t * ,
  int * );

__attribute__((availability(macosx,introduced=10.4)))
int pthread_mutexattr_getprotocol(const pthread_mutexattr_t * ,
  int * );

__attribute__((availability(macosx,introduced=10.4)))
int pthread_mutexattr_getpshared(const pthread_mutexattr_t * ,
  int * );

__attribute__((availability(macosx,introduced=10.4)))
int pthread_mutexattr_gettype(const pthread_mutexattr_t * ,
  int * );

__attribute__((availability(macosx,introduced=10.4)))
int pthread_mutexattr_init(pthread_mutexattr_t *);

__attribute__((availability(macosx,introduced=10.4)))
int pthread_mutexattr_setprioceiling(pthread_mutexattr_t *, int);

__attribute__((availability(macosx,introduced=10.4)))
int pthread_mutexattr_setprotocol(pthread_mutexattr_t *, int);

__attribute__((availability(macosx,introduced=10.4)))
int pthread_mutexattr_setpshared(pthread_mutexattr_t *, int);

__attribute__((availability(macosx,introduced=10.4)))
int pthread_mutexattr_settype(pthread_mutexattr_t *, int);

__attribute__((availability(macosx,introduced=10.4)))
int pthread_once(pthread_once_t *, void (*)(void));

__attribute__((availability(macosx,introduced=10.4)))
int pthread_rwlock_destroy(pthread_rwlock_t * ) __asm("_" "pthread_rwlock_destroy" );

__attribute__((availability(macosx,introduced=10.4)))
int pthread_rwlock_init(pthread_rwlock_t * ,
  const pthread_rwlockattr_t * ) __asm("_" "pthread_rwlock_init" );

__attribute__((availability(macosx,introduced=10.4)))
int pthread_rwlock_rdlock(pthread_rwlock_t *) __asm("_" "pthread_rwlock_rdlock" );

__attribute__((availability(macosx,introduced=10.4)))
int pthread_rwlock_tryrdlock(pthread_rwlock_t *) __asm("_" "pthread_rwlock_tryrdlock" );

__attribute__((availability(macosx,introduced=10.4)))
int pthread_rwlock_trywrlock(pthread_rwlock_t *) __asm("_" "pthread_rwlock_trywrlock" );

__attribute__((availability(macosx,introduced=10.4)))
int pthread_rwlock_wrlock(pthread_rwlock_t *) __asm("_" "pthread_rwlock_wrlock" );

__attribute__((availability(macosx,introduced=10.4)))
int pthread_rwlock_unlock(pthread_rwlock_t *) __asm("_" "pthread_rwlock_unlock" );

__attribute__((availability(macosx,introduced=10.4)))
int pthread_rwlockattr_destroy(pthread_rwlockattr_t *);

__attribute__((availability(macosx,introduced=10.4)))
int pthread_rwlockattr_getpshared(const pthread_rwlockattr_t * ,
  int * );

__attribute__((availability(macosx,introduced=10.4)))
int pthread_rwlockattr_init(pthread_rwlockattr_t *);

__attribute__((availability(macosx,introduced=10.4)))
int pthread_rwlockattr_setpshared(pthread_rwlockattr_t *, int);

__attribute__((availability(macosx,introduced=10.4)))
pthread_t pthread_self(void);

__attribute__((availability(macosx,introduced=10.4)))
int pthread_setcancelstate(int , int *) __asm("_" "pthread_setcancelstate" );

__attribute__((availability(macosx,introduced=10.4)))
int pthread_setcanceltype(int , int *) __asm("_" "pthread_setcanceltype" );

__attribute__((availability(macosx,introduced=10.4)))
int pthread_setconcurrency(int);

__attribute__((availability(macosx,introduced=10.4)))
int pthread_setschedparam(pthread_t, int, const struct sched_param *);

__attribute__((availability(macosx,introduced=10.4)))
int pthread_setspecific(pthread_key_t , const void *);

__attribute__((availability(macosx,introduced=10.4)))
void pthread_testcancel(void) __asm("_" "pthread_testcancel" );



/* returns non-zero if pthread_create or cthread_fork have been called */
__attribute__((availability(macosx,introduced=10.4)))
int pthread_is_threaded_np(void);

__attribute__((availability(macosx,introduced=10.6)))
int pthread_threadid_np(pthread_t,__uint64_t*);

/*SPI to set and get pthread name*/
__attribute__((availability(macosx,introduced=10.6)))
int pthread_getname_np(pthread_t,char*,size_t);

__attribute__((availability(macosx,introduced=10.6)))
int pthread_setname_np(const char*);

/* returns non-zero if the current thread is the main thread */
__attribute__((availability(macosx,introduced=10.4)))
int pthread_main_np(void);

/* return the mach thread bound to the pthread */
__attribute__((availability(macosx,introduced=10.4)))
mach_port_t pthread_mach_thread_np(pthread_t);

__attribute__((availability(macosx,introduced=10.4)))
size_t pthread_get_stacksize_np(pthread_t);

__attribute__((availability(macosx,introduced=10.4)))
void* pthread_get_stackaddr_np(pthread_t);

/* Like pthread_cond_signal(), but only wake up the specified pthread */
__attribute__((availability(macosx,introduced=10.4)))
int pthread_cond_signal_thread_np(pthread_cond_t *, pthread_t);

/* Like pthread_cond_timedwait, but use a relative timeout */
__attribute__((availability(macosx,introduced=10.4)))
int pthread_cond_timedwait_relative_np(pthread_cond_t *, pthread_mutex_t *,
  const struct timespec *);

/* Like pthread_create(), but leaves the thread suspended */
__attribute__((availability(macosx,introduced=10.4)))
int pthread_create_suspended_np(pthread_t *, const pthread_attr_t *,
  void *(*)(void *), void *);

__attribute__((availability(macosx,introduced=10.4)))
int pthread_kill(pthread_t, int);

__attribute__((availability(macosx,introduced=10.5)))
pthread_t pthread_from_mach_thread_np(mach_port_t);

__attribute__((availability(macosx,introduced=10.4)))
int pthread_sigmask(int, const sigset_t *, sigset_t *) __asm("_" "pthread_sigmask" );

__attribute__((availability(macosx,introduced=10.4)))
void pthread_yield_np(void);


}
# 18 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/__mutex_base" 2 3
# 21 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/__mutex_base" 3


namespace std {inline namespace __1 {

class __attribute__ ((__type_visibility__("default"))) mutex
{
    pthread_mutex_t __m_;

public:
    __attribute__ ((__visibility__("hidden"), __always_inline__))



     mutex() throw() {__m_ = (pthread_mutex_t){0x32AAABA7, {0}};}

     ~mutex();

private:
    mutex(const mutex&);// = delete;
    mutex& operator=(const mutex&);// = delete;

public:
    void lock();
    bool try_lock() throw();
    void unlock() throw();

    typedef pthread_mutex_t* native_handle_type;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) native_handle_type native_handle() {return &__m_;}
};

struct __attribute__ ((__type_visibility__("default"))) defer_lock_t {};
struct __attribute__ ((__type_visibility__("default"))) try_to_lock_t {};
struct __attribute__ ((__type_visibility__("default"))) adopt_lock_t {};



extern const defer_lock_t defer_lock;
extern const try_to_lock_t try_to_lock;
extern const adopt_lock_t adopt_lock;
# 69 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/__mutex_base" 3
template <class _Mutex>
class __attribute__ ((__type_visibility__("default"))) lock_guard
{
public:
    typedef _Mutex mutex_type;

private:
    mutex_type& __m_;
public:

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit lock_guard(mutex_type& __m)
        : __m_(__m) {__m_.lock();}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    lock_guard(mutex_type& __m, adopt_lock_t)
        : __m_(__m) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    ~lock_guard() {__m_.unlock();}

private:
    lock_guard(lock_guard const&);// = delete;
    lock_guard& operator=(lock_guard const&);// = delete;
};

template <class _Mutex>
class __attribute__ ((__type_visibility__("default"))) unique_lock
{
public:
    typedef _Mutex mutex_type;

private:
    mutex_type* __m_;
    bool __owns_;

public:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    unique_lock() throw() : __m_(std::__1::__get_nullptr_t()), __owns_(false) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit unique_lock(mutex_type& __m)
        : __m_(&__m), __owns_(true) {__m_->lock();}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    unique_lock(mutex_type& __m, defer_lock_t) throw()
        : __m_(&__m), __owns_(false) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    unique_lock(mutex_type& __m, try_to_lock_t)
        : __m_(&__m), __owns_(__m.try_lock()) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    unique_lock(mutex_type& __m, adopt_lock_t)
        : __m_(&__m), __owns_(true) {}
    template <class _Clock, class _Duration>
    __attribute__ ((__visibility__("hidden"), __always_inline__))
        unique_lock(mutex_type& __m, const chrono::time_point<_Clock, _Duration>& __t)
            : __m_(&__m), __owns_(__m.try_lock_until(__t)) {}
    template <class _Rep, class _Period>
    __attribute__ ((__visibility__("hidden"), __always_inline__))
        unique_lock(mutex_type& __m, const chrono::duration<_Rep, _Period>& __d)
            : __m_(&__m), __owns_(__m.try_lock_for(__d)) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    ~unique_lock()
    {
        if (__owns_)
            __m_->unlock();
    }

private:
    unique_lock(unique_lock const&); // = delete;
    unique_lock& operator=(unique_lock const&); // = delete;

public:
# 157 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/__mutex_base" 3
    void lock();
    bool try_lock();

    template <class _Rep, class _Period>
        bool try_lock_for(const chrono::duration<_Rep, _Period>& __d);
    template <class _Clock, class _Duration>
        bool try_lock_until(const chrono::time_point<_Clock, _Duration>& __t);

    void unlock();

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void swap(unique_lock& __u) throw()
    {
        std::__1::swap(__m_, __u.__m_);
        std::__1::swap(__owns_, __u.__owns_);
    }
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    mutex_type* release() throw()
    {
        mutex_type* __m = __m_;
        __m_ = std::__1::__get_nullptr_t();
        __owns_ = false;
        return __m;
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool owns_lock() const throw() {return __owns_;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))

        operator bool () const throw() {return __owns_;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    mutex_type* mutex() const throw() {return __m_;}
};

template <class _Mutex>
void
unique_lock<_Mutex>::lock()
{
    if (__m_ == std::__1::__get_nullptr_t())
        __throw_system_error(1, "unique_lock::lock: references null mutex");
    if (__owns_)
        __throw_system_error(11, "unique_lock::lock: already locked");
    __m_->lock();
    __owns_ = true;
}

template <class _Mutex>
bool
unique_lock<_Mutex>::try_lock()
{
    if (__m_ == std::__1::__get_nullptr_t())
        __throw_system_error(1, "unique_lock::try_lock: references null mutex");
    if (__owns_)
        __throw_system_error(11, "unique_lock::try_lock: already locked");
    __owns_ = __m_->try_lock();
    return __owns_;
}

template <class _Mutex>
template <class _Rep, class _Period>
bool
unique_lock<_Mutex>::try_lock_for(const chrono::duration<_Rep, _Period>& __d)
{
    if (__m_ == std::__1::__get_nullptr_t())
        __throw_system_error(1, "unique_lock::try_lock_for: references null mutex");
    if (__owns_)
        __throw_system_error(11, "unique_lock::try_lock_for: already locked");
    __owns_ = __m_->try_lock_for(__d);
    return __owns_;
}

template <class _Mutex>
template <class _Clock, class _Duration>
bool
unique_lock<_Mutex>::try_lock_until(const chrono::time_point<_Clock, _Duration>& __t)
{
    if (__m_ == std::__1::__get_nullptr_t())
        __throw_system_error(1, "unique_lock::try_lock_until: references null mutex");
    if (__owns_)
        __throw_system_error(11, "unique_lock::try_lock_until: already locked");
    __owns_ = __m_->try_lock_until(__t);
    return __owns_;
}

template <class _Mutex>
void
unique_lock<_Mutex>::unlock()
{
    if (!__owns_)
        __throw_system_error(1, "unique_lock::unlock: not locked");
    __m_->unlock();
    __owns_ = false;
}

template <class _Mutex>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
swap(unique_lock<_Mutex>& __x, unique_lock<_Mutex>& __y) throw()
    {__x.swap(__y);}

//enum class cv_status
struct __attribute__ ((__type_visibility__("default"))) cv_status { enum __lx
{
    no_timeout,
    timeout
};
__lx __v_; __attribute__ ((__visibility__("hidden"), __always_inline__)) cv_status(__lx __v) : __v_(__v) {} __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit cv_status(int __v) : __v_(static_cast<__lx>(__v)) {} __attribute__ ((__visibility__("hidden"), __always_inline__)) operator int() const {return __v_;} };

class __attribute__ ((__type_visibility__("default"))) condition_variable
{
    pthread_cond_t __cv_;
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__))



    condition_variable() {__cv_ = (pthread_cond_t){0x3CB0B1BB, {0}};}

    ~condition_variable();

private:
    condition_variable(const condition_variable&); // = delete;
    condition_variable& operator=(const condition_variable&); // = delete;

public:
    void notify_one() throw();
    void notify_all() throw();

    void wait(unique_lock<mutex>& __lk) throw();
    template <class _Predicate>
        void wait(unique_lock<mutex>& __lk, _Predicate __pred);

    template <class _Clock, class _Duration>
        cv_status
        wait_until(unique_lock<mutex>& __lk,
                   const chrono::time_point<_Clock, _Duration>& __t);

    template <class _Clock, class _Duration, class _Predicate>
        bool
        wait_until(unique_lock<mutex>& __lk,
                   const chrono::time_point<_Clock, _Duration>& __t,
                   _Predicate __pred);

    template <class _Rep, class _Period>
        cv_status
        wait_for(unique_lock<mutex>& __lk,
                 const chrono::duration<_Rep, _Period>& __d);

    template <class _Rep, class _Period, class _Predicate>
        bool
        wait_for(unique_lock<mutex>& __lk,
                 const chrono::duration<_Rep, _Period>& __d,
                 _Predicate __pred);

    typedef pthread_cond_t* native_handle_type;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) native_handle_type native_handle() {return &__cv_;}

private:
    void __do_timed_wait(unique_lock<mutex>& __lk,
       chrono::time_point<chrono::system_clock, chrono::nanoseconds>) throw();
};

template <class _To, class _Rep, class _Period>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    chrono::__is_duration<_To>::value,
    _To
>::type
__ceil(chrono::duration<_Rep, _Period> __d)
{
    using namespace chrono;
    _To __r = duration_cast<_To>(__d);
    if (__r < __d)
        ++__r;
    return __r;
}

template <class _Predicate>
void
condition_variable::wait(unique_lock<mutex>& __lk, _Predicate __pred)
{
    while (!__pred())
        wait(__lk);
}

template <class _Clock, class _Duration>
cv_status
condition_variable::wait_until(unique_lock<mutex>& __lk,
                               const chrono::time_point<_Clock, _Duration>& __t)
{
    using namespace chrono;
    wait_for(__lk, __t - _Clock::now());
    return _Clock::now() < __t ? cv_status::no_timeout : cv_status::timeout;
}

template <class _Clock, class _Duration, class _Predicate>
bool
condition_variable::wait_until(unique_lock<mutex>& __lk,
                   const chrono::time_point<_Clock, _Duration>& __t,
                   _Predicate __pred)
{
    while (!__pred())
    {
        if (wait_until(__lk, __t) == cv_status::timeout)
            return __pred();
    }
    return true;
}

template <class _Rep, class _Period>
cv_status
condition_variable::wait_for(unique_lock<mutex>& __lk,
                             const chrono::duration<_Rep, _Period>& __d)
{
    using namespace chrono;
    if (__d <= __d.zero())
        return cv_status::timeout;
    typedef time_point<system_clock, duration<long double, nano> > __sys_tpf;
    typedef time_point<system_clock, nanoseconds> __sys_tpi;
    __sys_tpf _Max = __sys_tpi::max();
    system_clock::time_point __s_now = system_clock::now();
    steady_clock::time_point __c_now = steady_clock::now();
    if (_Max - __d > __s_now)
        __do_timed_wait(__lk, __s_now + __ceil<nanoseconds>(__d));
    else
        __do_timed_wait(__lk, __sys_tpi::max());
    return steady_clock::now() - __c_now < __d ? cv_status::no_timeout :
                                                 cv_status::timeout;
}

template <class _Rep, class _Period, class _Predicate>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
condition_variable::wait_for(unique_lock<mutex>& __lk,
                             const chrono::duration<_Rep, _Period>& __d,
                             _Predicate __pred)
{
    return wait_until(__lk, chrono::steady_clock::now() + __d,
                      std::__1::move(__pred));
}

} }
# 177 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/mutex" 2 3
# 1 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/functional" 1 3
// -*- C++ -*-
//===------------------------ functional ----------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is dual licensed under the MIT and the University of Illinois Open
// Source Licenses. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//




/*
    functional synopsis

namespace std
{

template <class Arg, class Result>
struct unary_function
{
    typedef Arg    argument_type;
    typedef Result result_type;
};

template <class Arg1, class Arg2, class Result>
struct binary_function
{
    typedef Arg1   first_argument_type;
    typedef Arg2   second_argument_type;
    typedef Result result_type;
};

template <class T>
class reference_wrapper
    : public unary_function<T1, R> // if wrapping a unary functor
    : public binary_function<T1, T2, R> // if wraping a binary functor
{
public:
    // types
    typedef T type;
    typedef see below result_type; // Not always defined

    // construct/copy/destroy
    reference_wrapper(T&) noexcept;
    reference_wrapper(T&&) = delete; // do not bind to temps
    reference_wrapper(const reference_wrapper<T>& x) noexcept;

    // assignment
    reference_wrapper& operator=(const reference_wrapper<T>& x) noexcept;

    // access
    operator T& () const noexcept;
    T& get() const noexcept;

    // invoke
    template <class... ArgTypes>
      typename result_of<T&(ArgTypes&&...)>::type
          operator() (ArgTypes&&...) const;
};

template <class T> reference_wrapper<T> ref(T& t) noexcept;
template <class T> void ref(const T&& t) = delete;
template <class T> reference_wrapper<T> ref(reference_wrapper<T>t) noexcept;

template <class T> reference_wrapper<const T> cref(const T& t) noexcept;
template <class T> void cref(const T&& t) = delete;
template <class T> reference_wrapper<const T> cref(reference_wrapper<T> t) noexcept;

template <class T> // <class T=void> in C++14
struct plus : binary_function<T, T, T>
{
    T operator()(const T& x, const T& y) const;
};

template <class T> // <class T=void> in C++14
struct minus : binary_function<T, T, T>
{
    T operator()(const T& x, const T& y) const;
};

template <class T> // <class T=void> in C++14
struct multiplies : binary_function<T, T, T>
{
    T operator()(const T& x, const T& y) const;
};

template <class T> // <class T=void> in C++14
struct divides : binary_function<T, T, T>
{
    T operator()(const T& x, const T& y) const;
};

template <class T> // <class T=void> in C++14
struct modulus : binary_function<T, T, T>
{
    T operator()(const T& x, const T& y) const;
};

template <class T> // <class T=void> in C++14
struct negate : unary_function<T, T>
{
    T operator()(const T& x) const;
};

template <class T> // <class T=void> in C++14
struct equal_to : binary_function<T, T, bool>
{
    bool operator()(const T& x, const T& y) const;
};

template <class T> // <class T=void> in C++14
struct not_equal_to : binary_function<T, T, bool>
{
    bool operator()(const T& x, const T& y) const;
};

template <class T> // <class T=void> in C++14
struct greater : binary_function<T, T, bool>
{
    bool operator()(const T& x, const T& y) const;
};

template <class T> // <class T=void> in C++14
struct less : binary_function<T, T, bool>
{
    bool operator()(const T& x, const T& y) const;
};

template <class T> // <class T=void> in C++14
struct greater_equal : binary_function<T, T, bool>
{
    bool operator()(const T& x, const T& y) const;
};

template <class T> // <class T=void> in C++14
struct less_equal : binary_function<T, T, bool>
{
    bool operator()(const T& x, const T& y) const;
};

template <class T> // <class T=void> in C++14
struct logical_and : binary_function<T, T, bool>
{
    bool operator()(const T& x, const T& y) const;
};

template <class T> // <class T=void> in C++14
struct logical_or : binary_function<T, T, bool>
{
    bool operator()(const T& x, const T& y) const;
};

template <class T> // <class T=void> in C++14
struct logical_not : unary_function<T, bool>
{
    bool operator()(const T& x) const;
};

template <class T> // <class T=void> in C++14
struct bit_and : unary_function<T, bool>
{
    bool operator()(const T& x, const T& y) const;
};

template <class T> // <class T=void> in C++14
struct bit_or : unary_function<T, bool>
{
    bool operator()(const T& x, const T& y) const;
};

template <class T> // <class T=void> in C++14
struct bit_xor : unary_function<T, bool>
{
    bool operator()(const T& x, const T& y) const;
};

template <class T=void> // C++14
struct bit_xor : unary_function<T, bool>
{
    bool operator()(const T& x) const;
};

template <class Predicate>
class unary_negate
    : public unary_function<typename Predicate::argument_type, bool>
{
public:
    explicit unary_negate(const Predicate& pred);
    bool operator()(const typename Predicate::argument_type& x) const;
};

template <class Predicate> unary_negate<Predicate> not1(const Predicate& pred);

template <class Predicate>
class binary_negate
    : public binary_function<typename Predicate::first_argument_type,
                             typename Predicate::second_argument_type,
                             bool>
{
public:
    explicit binary_negate(const Predicate& pred);
    bool operator()(const typename Predicate::first_argument_type& x,
                    const typename Predicate::second_argument_type& y) const;
};

template <class Predicate> binary_negate<Predicate> not2(const Predicate& pred);

template<class T> struct is_bind_expression;
template<class T> struct is_placeholder;

template<class Fn, class... BoundArgs>
  unspecified bind(Fn&&, BoundArgs&&...);
template<class R, class Fn, class... BoundArgs>
  unspecified bind(Fn&&, BoundArgs&&...);

namespace placeholders {
  // M is the implementation-defined number of placeholders
  extern unspecified _1;
  extern unspecified _2;
  .
  .
  .
  extern unspecified _Mp;
}

template <class Operation>
class binder1st
    : public unary_function<typename Operation::second_argument_type,
                            typename Operation::result_type>
{
protected:
    Operation                               op;
    typename Operation::first_argument_type value;
public:
    binder1st(const Operation& x, const typename Operation::first_argument_type y);
    typename Operation::result_type operator()(      typename Operation::second_argument_type& x) const;
    typename Operation::result_type operator()(const typename Operation::second_argument_type& x) const;
};

template <class Operation, class T>
binder1st<Operation> bind1st(const Operation& op, const T& x);

template <class Operation>
class binder2nd
    : public unary_function<typename Operation::first_argument_type,
                            typename Operation::result_type>
{
protected:
    Operation                                op;
    typename Operation::second_argument_type value;
public:
    binder2nd(const Operation& x, const typename Operation::second_argument_type y);
    typename Operation::result_type operator()(      typename Operation::first_argument_type& x) const;
    typename Operation::result_type operator()(const typename Operation::first_argument_type& x) const;
};

template <class Operation, class T>
binder2nd<Operation> bind2nd(const Operation& op, const T& x);

template <class Arg, class Result>
class pointer_to_unary_function : public unary_function<Arg, Result>
{
public:
    explicit pointer_to_unary_function(Result (*f)(Arg));
    Result operator()(Arg x) const;
};

template <class Arg, class Result>
pointer_to_unary_function<Arg,Result> ptr_fun(Result (*f)(Arg));

template <class Arg1, class Arg2, class Result>
class pointer_to_binary_function : public binary_function<Arg1, Arg2, Result>
{
public:
    explicit pointer_to_binary_function(Result (*f)(Arg1, Arg2));
    Result operator()(Arg1 x, Arg2 y) const;
};

template <class Arg1, class Arg2, class Result>
pointer_to_binary_function<Arg1,Arg2,Result> ptr_fun(Result (*f)(Arg1,Arg2));

template<class S, class T>
class mem_fun_t : public unary_function<T*, S>
{
public:
    explicit mem_fun_t(S (T::*p)());
    S operator()(T* p) const;
};

template<class S, class T, class A>
class mem_fun1_t : public binary_function<T*, A, S>
{
public:
    explicit mem_fun1_t(S (T::*p)(A));
    S operator()(T* p, A x) const;
};

template<class S, class T>          mem_fun_t<S,T>    mem_fun(S (T::*f)());
template<class S, class T, class A> mem_fun1_t<S,T,A> mem_fun(S (T::*f)(A));

template<class S, class T>
class mem_fun_ref_t : public unary_function<T, S>
{
public:
    explicit mem_fun_ref_t(S (T::*p)());
    S operator()(T& p) const;
};

template<class S, class T, class A>
class mem_fun1_ref_t : public binary_function<T, A, S>
{
public:
    explicit mem_fun1_ref_t(S (T::*p)(A));
    S operator()(T& p, A x) const;
};

template<class S, class T>          mem_fun_ref_t<S,T>    mem_fun_ref(S (T::*f)());
template<class S, class T, class A> mem_fun1_ref_t<S,T,A> mem_fun_ref(S (T::*f)(A));

template <class S, class T>
class const_mem_fun_t : public unary_function<const T*, S>
{
public:
    explicit const_mem_fun_t(S (T::*p)() const);
    S operator()(const T* p) const;
};

template <class S, class T, class A>
class const_mem_fun1_t : public binary_function<const T*, A, S>
{
public:
    explicit const_mem_fun1_t(S (T::*p)(A) const);
    S operator()(const T* p, A x) const;
};

template <class S, class T>          const_mem_fun_t<S,T>    mem_fun(S (T::*f)() const);
template <class S, class T, class A> const_mem_fun1_t<S,T,A> mem_fun(S (T::*f)(A) const);

template <class S, class T>
class const_mem_fun_ref_t : public unary_function<T, S>
{
public:
    explicit const_mem_fun_ref_t(S (T::*p)() const);
    S operator()(const T& p) const;
};

template <class S, class T, class A>
class const_mem_fun1_ref_t : public binary_function<T, A, S>
{
public:
    explicit const_mem_fun1_ref_t(S (T::*p)(A) const);
    S operator()(const T& p, A x) const;
};

template <class S, class T>          const_mem_fun_ref_t<S,T>    mem_fun_ref(S (T::*f)() const);
template <class S, class T, class A> const_mem_fun1_ref_t<S,T,A> mem_fun_ref(S (T::*f)(A) const);

template<class R, class T> unspecified mem_fn(R T::*);

class bad_function_call
    : public exception
{
};

template<class> class function; // undefined

template<class R, class... ArgTypes>
class function<R(ArgTypes...)>
  : public unary_function<T1, R>      // iff sizeof...(ArgTypes) == 1 and
                                      // ArgTypes contains T1
  : public binary_function<T1, T2, R> // iff sizeof...(ArgTypes) == 2 and
                                      // ArgTypes contains T1 and T2
{
public:
    typedef R result_type;

    // construct/copy/destroy:
    function() noexcept;
    function(nullptr_t) noexcept;
    function(const function&);
    function(function&&) noexcept;
    template<class F>
      function(F);
    template<Allocator Alloc>
      function(allocator_arg_t, const Alloc&) noexcept;
    template<Allocator Alloc>
      function(allocator_arg_t, const Alloc&, nullptr_t) noexcept;
    template<Allocator Alloc>
      function(allocator_arg_t, const Alloc&, const function&);
    template<Allocator Alloc>
      function(allocator_arg_t, const Alloc&, function&&);
    template<class F, Allocator Alloc>
      function(allocator_arg_t, const Alloc&, F);

    function& operator=(const function&);
    function& operator=(function&&) noexcept;
    function& operator=(nullptr_t) noexcept;
    template<class F>
      function& operator=(F&&);
    template<class F>
      function& operator=(reference_wrapper<F>) noexcept;

    ~function();

    // function modifiers:
    void swap(function&) noexcept;
    template<class F, class Alloc>
      void assign(F&&, const Alloc&);

    // function capacity:
    explicit operator bool() const noexcept;

    // function invocation:
    R operator()(ArgTypes...) const;

    // function target access:
    const std::type_info& target_type() const noexcept;
    template <typename T>       T* target() noexcept;
    template <typename T> const T* target() const noexcept;
};

// Null pointer comparisons:
template <class R, class ... ArgTypes>
  bool operator==(const function<R(ArgTypes...)>&, nullptr_t) noexcept;

template <class R, class ... ArgTypes>
  bool operator==(nullptr_t, const function<R(ArgTypes...)>&) noexcept;

template <class R, class ... ArgTypes>
  bool operator!=(const function<R(ArgTypes...)>&, nullptr_t) noexcept;

template <class  R, class ... ArgTypes>
  bool operator!=(nullptr_t, const function<R(ArgTypes...)>&) noexcept;

// specialized algorithms:
template <class  R, class ... ArgTypes>
  void swap(function<R(ArgTypes...)>&, function<R(ArgTypes...)>&) noexcept;

template <class T> struct hash;

template <> struct hash<bool>;
template <> struct hash<char>;
template <> struct hash<signed char>;
template <> struct hash<unsigned char>;
template <> struct hash<char16_t>;
template <> struct hash<char32_t>;
template <> struct hash<wchar_t>;
template <> struct hash<short>;
template <> struct hash<unsigned short>;
template <> struct hash<int>;
template <> struct hash<unsigned int>;
template <> struct hash<long>;
template <> struct hash<long long>;
template <> struct hash<unsigned long>;
template <> struct hash<unsigned long long>;

template <> struct hash<float>;
template <> struct hash<double>;
template <> struct hash<long double>;

template<class T> struct hash<T*>;

}  // std

POLICY:  For non-variadic implementations, the number of arguments is limited
         to 3.  It is hoped that the need for non-variadic implementations
         will be minimal.

*/
# 484 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/functional" 3


namespace std {inline namespace __1 {




template <class _Tp>

struct __attribute__ ((__type_visibility__("default"))) plus : binary_function<_Tp, _Tp, _Tp>
{
                                  __attribute__ ((__visibility__("hidden"), __always_inline__))
    _Tp operator()(const _Tp& __x, const _Tp& __y) const
        {return __x + __y;}
};
# 516 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/functional" 3
template <class _Tp>

struct __attribute__ ((__type_visibility__("default"))) minus : binary_function<_Tp, _Tp, _Tp>
{
                                  __attribute__ ((__visibility__("hidden"), __always_inline__))
    _Tp operator()(const _Tp& __x, const _Tp& __y) const
        {return __x - __y;}
};
# 541 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/functional" 3
template <class _Tp>

struct __attribute__ ((__type_visibility__("default"))) multiplies : binary_function<_Tp, _Tp, _Tp>
{
                                  __attribute__ ((__visibility__("hidden"), __always_inline__))
    _Tp operator()(const _Tp& __x, const _Tp& __y) const
        {return __x * __y;}
};
# 566 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/functional" 3
template <class _Tp>

struct __attribute__ ((__type_visibility__("default"))) divides : binary_function<_Tp, _Tp, _Tp>
{
                                  __attribute__ ((__visibility__("hidden"), __always_inline__))
    _Tp operator()(const _Tp& __x, const _Tp& __y) const
        {return __x / __y;}
};
# 591 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/functional" 3
template <class _Tp>

struct __attribute__ ((__type_visibility__("default"))) modulus : binary_function<_Tp, _Tp, _Tp>
{
                                  __attribute__ ((__visibility__("hidden"), __always_inline__))
    _Tp operator()(const _Tp& __x, const _Tp& __y) const
        {return __x % __y;}
};
# 616 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/functional" 3
template <class _Tp>

struct __attribute__ ((__type_visibility__("default"))) negate : unary_function<_Tp, _Tp>
{
                                  __attribute__ ((__visibility__("hidden"), __always_inline__))
    _Tp operator()(const _Tp& __x) const
        {return -__x;}
};
# 641 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/functional" 3
template <class _Tp>

struct __attribute__ ((__type_visibility__("default"))) equal_to : binary_function<_Tp, _Tp, bool>
{
                                  __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator()(const _Tp& __x, const _Tp& __y) const
        {return __x == __y;}
};
# 666 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/functional" 3
template <class _Tp>

struct __attribute__ ((__type_visibility__("default"))) not_equal_to : binary_function<_Tp, _Tp, bool>
{
                                  __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator()(const _Tp& __x, const _Tp& __y) const
        {return __x != __y;}
};
# 691 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/functional" 3
template <class _Tp>

struct __attribute__ ((__type_visibility__("default"))) greater : binary_function<_Tp, _Tp, bool>
{
                                  __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator()(const _Tp& __x, const _Tp& __y) const
        {return __x > __y;}
};
# 713 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/functional" 3
// less in <__functional_base>




template <class _Tp>

struct __attribute__ ((__type_visibility__("default"))) greater_equal : binary_function<_Tp, _Tp, bool>
{
                                  __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator()(const _Tp& __x, const _Tp& __y) const
        {return __x >= __y;}
};
# 743 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/functional" 3
template <class _Tp>

struct __attribute__ ((__type_visibility__("default"))) less_equal : binary_function<_Tp, _Tp, bool>
{
                                  __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator()(const _Tp& __x, const _Tp& __y) const
        {return __x <= __y;}
};
# 768 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/functional" 3
template <class _Tp>

struct __attribute__ ((__type_visibility__("default"))) logical_and : binary_function<_Tp, _Tp, bool>
{
                                  __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator()(const _Tp& __x, const _Tp& __y) const
        {return __x && __y;}
};
# 793 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/functional" 3
template <class _Tp>

struct __attribute__ ((__type_visibility__("default"))) logical_or : binary_function<_Tp, _Tp, bool>
{
                                  __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator()(const _Tp& __x, const _Tp& __y) const
        {return __x || __y;}
};
# 818 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/functional" 3
template <class _Tp>

struct __attribute__ ((__type_visibility__("default"))) logical_not : unary_function<_Tp, bool>
{
                                  __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator()(const _Tp& __x) const
        {return !__x;}
};
# 843 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/functional" 3
template <class _Tp>

struct __attribute__ ((__type_visibility__("default"))) bit_and : binary_function<_Tp, _Tp, _Tp>
{
                                  __attribute__ ((__visibility__("hidden"), __always_inline__))
    _Tp operator()(const _Tp& __x, const _Tp& __y) const
        {return __x & __y;}
};
# 868 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/functional" 3
template <class _Tp>

struct __attribute__ ((__type_visibility__("default"))) bit_or : binary_function<_Tp, _Tp, _Tp>
{
                                  __attribute__ ((__visibility__("hidden"), __always_inline__))
    _Tp operator()(const _Tp& __x, const _Tp& __y) const
        {return __x | __y;}
};
# 893 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/functional" 3
template <class _Tp>

struct __attribute__ ((__type_visibility__("default"))) bit_xor : binary_function<_Tp, _Tp, _Tp>
{
                                  __attribute__ ((__visibility__("hidden"), __always_inline__))
    _Tp operator()(const _Tp& __x, const _Tp& __y) const
        {return __x ^ __y;}
};
# 935 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/functional" 3
template <class _Predicate>
class __attribute__ ((__type_visibility__("default"))) unary_negate
    : public unary_function<typename _Predicate::argument_type, bool>
{
    _Predicate __pred_;
public:
                                  __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit unary_negate(const _Predicate& __pred)
        : __pred_(__pred) {}
                                  __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator()(const typename _Predicate::argument_type& __x) const
        {return !__pred_(__x);}
};

template <class _Predicate>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
unary_negate<_Predicate>
not1(const _Predicate& __pred) {return unary_negate<_Predicate>(__pred);}

template <class _Predicate>
class __attribute__ ((__type_visibility__("default"))) binary_negate
    : public binary_function<typename _Predicate::first_argument_type,
                             typename _Predicate::second_argument_type,
                             bool>
{
    _Predicate __pred_;
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit
    binary_negate(const _Predicate& __pred) : __pred_(__pred) {}

                                  __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator()(const typename _Predicate::first_argument_type& __x,
                    const typename _Predicate::second_argument_type& __y) const
        {return !__pred_(__x, __y);}
};

template <class _Predicate>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
binary_negate<_Predicate>
not2(const _Predicate& __pred) {return binary_negate<_Predicate>(__pred);}

template <class __Operation>
class __attribute__ ((__type_visibility__("default"))) binder1st
    : public unary_function<typename __Operation::second_argument_type,
                            typename __Operation::result_type>
{
protected:
    __Operation op;
    typename __Operation::first_argument_type value;
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) binder1st(const __Operation& __x,
                               const typename __Operation::first_argument_type __y)
        : op(__x), value(__y) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) typename __Operation::result_type operator()
        (typename __Operation::second_argument_type& __x) const
            {return op(value, __x);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) typename __Operation::result_type operator()
        (const typename __Operation::second_argument_type& __x) const
            {return op(value, __x);}
};

template <class __Operation, class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
binder1st<__Operation>
bind1st(const __Operation& __op, const _Tp& __x)
    {return binder1st<__Operation>(__op, __x);}

template <class __Operation>
class __attribute__ ((__type_visibility__("default"))) binder2nd
    : public unary_function<typename __Operation::first_argument_type,
                            typename __Operation::result_type>
{
protected:
    __Operation op;
    typename __Operation::second_argument_type value;
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    binder2nd(const __Operation& __x, const typename __Operation::second_argument_type __y)
        : op(__x), value(__y) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) typename __Operation::result_type operator()
        ( typename __Operation::first_argument_type& __x) const
            {return op(__x, value);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) typename __Operation::result_type operator()
        (const typename __Operation::first_argument_type& __x) const
            {return op(__x, value);}
};

template <class __Operation, class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
binder2nd<__Operation>
bind2nd(const __Operation& __op, const _Tp& __x)
    {return binder2nd<__Operation>(__op, __x);}

template <class _Arg, class _Result>
class __attribute__ ((__type_visibility__("default"))) pointer_to_unary_function
    : public unary_function<_Arg, _Result>
{
    _Result (*__f_)(_Arg);
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit pointer_to_unary_function(_Result (*__f)(_Arg))
        : __f_(__f) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) _Result operator()(_Arg __x) const
        {return __f_(__x);}
};

template <class _Arg, class _Result>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
pointer_to_unary_function<_Arg,_Result>
ptr_fun(_Result (*__f)(_Arg))
    {return pointer_to_unary_function<_Arg,_Result>(__f);}

template <class _Arg1, class _Arg2, class _Result>
class __attribute__ ((__type_visibility__("default"))) pointer_to_binary_function
    : public binary_function<_Arg1, _Arg2, _Result>
{
    _Result (*__f_)(_Arg1, _Arg2);
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit pointer_to_binary_function(_Result (*__f)(_Arg1, _Arg2))
        : __f_(__f) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) _Result operator()(_Arg1 __x, _Arg2 __y) const
        {return __f_(__x, __y);}
};

template <class _Arg1, class _Arg2, class _Result>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
pointer_to_binary_function<_Arg1,_Arg2,_Result>
ptr_fun(_Result (*__f)(_Arg1,_Arg2))
    {return pointer_to_binary_function<_Arg1,_Arg2,_Result>(__f);}

template<class _Sp, class _Tp>
class __attribute__ ((__type_visibility__("default"))) mem_fun_t : public unary_function<_Tp*, _Sp>
{
    _Sp (_Tp::*__p_)();
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit mem_fun_t(_Sp (_Tp::*__p)())
        : __p_(__p) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) _Sp operator()(_Tp* __p) const
        {return (__p->*__p_)();}
};

template<class _Sp, class _Tp, class _Ap>
class __attribute__ ((__type_visibility__("default"))) mem_fun1_t : public binary_function<_Tp*, _Ap, _Sp>
{
    _Sp (_Tp::*__p_)(_Ap);
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit mem_fun1_t(_Sp (_Tp::*__p)(_Ap))
        : __p_(__p) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) _Sp operator()(_Tp* __p, _Ap __x) const
        {return (__p->*__p_)(__x);}
};

template<class _Sp, class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
mem_fun_t<_Sp,_Tp>
mem_fun(_Sp (_Tp::*__f)())
    {return mem_fun_t<_Sp,_Tp>(__f);}

template<class _Sp, class _Tp, class _Ap>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
mem_fun1_t<_Sp,_Tp,_Ap>
mem_fun(_Sp (_Tp::*__f)(_Ap))
    {return mem_fun1_t<_Sp,_Tp,_Ap>(__f);}

template<class _Sp, class _Tp>
class __attribute__ ((__type_visibility__("default"))) mem_fun_ref_t : public unary_function<_Tp, _Sp>
{
    _Sp (_Tp::*__p_)();
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit mem_fun_ref_t(_Sp (_Tp::*__p)())
        : __p_(__p) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) _Sp operator()(_Tp& __p) const
        {return (__p.*__p_)();}
};

template<class _Sp, class _Tp, class _Ap>
class __attribute__ ((__type_visibility__("default"))) mem_fun1_ref_t : public binary_function<_Tp, _Ap, _Sp>
{
    _Sp (_Tp::*__p_)(_Ap);
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit mem_fun1_ref_t(_Sp (_Tp::*__p)(_Ap))
        : __p_(__p) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) _Sp operator()(_Tp& __p, _Ap __x) const
        {return (__p.*__p_)(__x);}
};

template<class _Sp, class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
mem_fun_ref_t<_Sp,_Tp>
mem_fun_ref(_Sp (_Tp::*__f)())
    {return mem_fun_ref_t<_Sp,_Tp>(__f);}

template<class _Sp, class _Tp, class _Ap>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
mem_fun1_ref_t<_Sp,_Tp,_Ap>
mem_fun_ref(_Sp (_Tp::*__f)(_Ap))
    {return mem_fun1_ref_t<_Sp,_Tp,_Ap>(__f);}

template <class _Sp, class _Tp>
class __attribute__ ((__type_visibility__("default"))) const_mem_fun_t : public unary_function<const _Tp*, _Sp>
{
    _Sp (_Tp::*__p_)() const;
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit const_mem_fun_t(_Sp (_Tp::*__p)() const)
        : __p_(__p) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) _Sp operator()(const _Tp* __p) const
        {return (__p->*__p_)();}
};

template <class _Sp, class _Tp, class _Ap>
class __attribute__ ((__type_visibility__("default"))) const_mem_fun1_t : public binary_function<const _Tp*, _Ap, _Sp>
{
    _Sp (_Tp::*__p_)(_Ap) const;
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit const_mem_fun1_t(_Sp (_Tp::*__p)(_Ap) const)
        : __p_(__p) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) _Sp operator()(const _Tp* __p, _Ap __x) const
        {return (__p->*__p_)(__x);}
};

template <class _Sp, class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
const_mem_fun_t<_Sp,_Tp>
mem_fun(_Sp (_Tp::*__f)() const)
    {return const_mem_fun_t<_Sp,_Tp>(__f);}

template <class _Sp, class _Tp, class _Ap>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
const_mem_fun1_t<_Sp,_Tp,_Ap>
mem_fun(_Sp (_Tp::*__f)(_Ap) const)
    {return const_mem_fun1_t<_Sp,_Tp,_Ap>(__f);}

template <class _Sp, class _Tp>
class __attribute__ ((__type_visibility__("default"))) const_mem_fun_ref_t : public unary_function<_Tp, _Sp>
{
    _Sp (_Tp::*__p_)() const;
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit const_mem_fun_ref_t(_Sp (_Tp::*__p)() const)
        : __p_(__p) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) _Sp operator()(const _Tp& __p) const
        {return (__p.*__p_)();}
};

template <class _Sp, class _Tp, class _Ap>
class __attribute__ ((__type_visibility__("default"))) const_mem_fun1_ref_t
    : public binary_function<_Tp, _Ap, _Sp>
{
    _Sp (_Tp::*__p_)(_Ap) const;
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit const_mem_fun1_ref_t(_Sp (_Tp::*__p)(_Ap) const)
        : __p_(__p) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) _Sp operator()(const _Tp& __p, _Ap __x) const
        {return (__p.*__p_)(__x);}
};

template <class _Sp, class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
const_mem_fun_ref_t<_Sp,_Tp>
mem_fun_ref(_Sp (_Tp::*__f)() const)
    {return const_mem_fun_ref_t<_Sp,_Tp>(__f);}

template <class _Sp, class _Tp, class _Ap>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
const_mem_fun1_ref_t<_Sp,_Tp,_Ap>
mem_fun_ref(_Sp (_Tp::*__f)(_Ap) const)
    {return const_mem_fun1_ref_t<_Sp,_Tp,_Ap>(__f);}




# 1 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/__functional_03" 1 3
// -*- C++ -*-
//===----------------------------------------------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is dual licensed under the MIT and the University of Illinois Open
// Source Licenses. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//




// manual variadic expansion for <functional>
# 18 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/__functional_03" 3


template <class _Tp>
class __mem_fn
    : public __weak_result_type<_Tp>
{
public:
    // types
    typedef _Tp type;
private:
    type __f_;

public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) __mem_fn(type __f) : __f_(__f) {}

    // invoke

    typename __invoke_return<type>::type
       operator() () const
       {
           return __invoke(__f_);
       }

    template <class _A0>
       typename __invoke_return0<type, _A0>::type
          operator() (_A0& __a0) const
          {
              return __invoke(__f_, __a0);
          }

    template <class _A0, class _A1>
       typename __invoke_return1<type, _A0, _A1>::type
          operator() (_A0& __a0, _A1& __a1) const
          {
              return __invoke(__f_, __a0, __a1);
          }

    template <class _A0, class _A1, class _A2>
       typename __invoke_return2<type, _A0, _A1, _A2>::type
          operator() (_A0& __a0, _A1& __a1, _A2& __a2) const
          {
              return __invoke(__f_, __a0, __a1, __a2);
          }
};

template<class _Rp, class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
__mem_fn<_Rp _Tp::*>
mem_fn(_Rp _Tp::* __pm)
{
    return __mem_fn<_Rp _Tp::*>(__pm);
}

template<class _Rp, class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
__mem_fn<_Rp (_Tp::*)()>
mem_fn(_Rp (_Tp::* __pm)())
{
    return __mem_fn<_Rp (_Tp::*)()>(__pm);
}

template<class _Rp, class _Tp, class _A0>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
__mem_fn<_Rp (_Tp::*)(_A0)>
mem_fn(_Rp (_Tp::* __pm)(_A0))
{
    return __mem_fn<_Rp (_Tp::*)(_A0)>(__pm);
}

template<class _Rp, class _Tp, class _A0, class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
__mem_fn<_Rp (_Tp::*)(_A0, _A1)>
mem_fn(_Rp (_Tp::* __pm)(_A0, _A1))
{
    return __mem_fn<_Rp (_Tp::*)(_A0, _A1)>(__pm);
}

template<class _Rp, class _Tp, class _A0, class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
__mem_fn<_Rp (_Tp::*)(_A0, _A1, _A2)>
mem_fn(_Rp (_Tp::* __pm)(_A0, _A1, _A2))
{
    return __mem_fn<_Rp (_Tp::*)(_A0, _A1, _A2)>(__pm);
}

template<class _Rp, class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
__mem_fn<_Rp (_Tp::*)() const>
mem_fn(_Rp (_Tp::* __pm)() const)
{
    return __mem_fn<_Rp (_Tp::*)() const>(__pm);
}

template<class _Rp, class _Tp, class _A0>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
__mem_fn<_Rp (_Tp::*)(_A0) const>
mem_fn(_Rp (_Tp::* __pm)(_A0) const)
{
    return __mem_fn<_Rp (_Tp::*)(_A0) const>(__pm);
}

template<class _Rp, class _Tp, class _A0, class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
__mem_fn<_Rp (_Tp::*)(_A0, _A1) const>
mem_fn(_Rp (_Tp::* __pm)(_A0, _A1) const)
{
    return __mem_fn<_Rp (_Tp::*)(_A0, _A1) const>(__pm);
}

template<class _Rp, class _Tp, class _A0, class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
__mem_fn<_Rp (_Tp::*)(_A0, _A1, _A2) const>
mem_fn(_Rp (_Tp::* __pm)(_A0, _A1, _A2) const)
{
    return __mem_fn<_Rp (_Tp::*)(_A0, _A1, _A2) const>(__pm);
}

template<class _Rp, class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
__mem_fn<_Rp (_Tp::*)() volatile>
mem_fn(_Rp (_Tp::* __pm)() volatile)
{
    return __mem_fn<_Rp (_Tp::*)() volatile>(__pm);
}

template<class _Rp, class _Tp, class _A0>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
__mem_fn<_Rp (_Tp::*)(_A0) volatile>
mem_fn(_Rp (_Tp::* __pm)(_A0) volatile)
{
    return __mem_fn<_Rp (_Tp::*)(_A0) volatile>(__pm);
}

template<class _Rp, class _Tp, class _A0, class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
__mem_fn<_Rp (_Tp::*)(_A0, _A1) volatile>
mem_fn(_Rp (_Tp::* __pm)(_A0, _A1) volatile)
{
    return __mem_fn<_Rp (_Tp::*)(_A0, _A1) volatile>(__pm);
}

template<class _Rp, class _Tp, class _A0, class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
__mem_fn<_Rp (_Tp::*)(_A0, _A1, _A2) volatile>
mem_fn(_Rp (_Tp::* __pm)(_A0, _A1, _A2) volatile)
{
    return __mem_fn<_Rp (_Tp::*)(_A0, _A1, _A2) volatile>(__pm);
}

template<class _Rp, class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
__mem_fn<_Rp (_Tp::*)() const volatile>
mem_fn(_Rp (_Tp::* __pm)() const volatile)
{
    return __mem_fn<_Rp (_Tp::*)() const volatile>(__pm);
}

template<class _Rp, class _Tp, class _A0>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
__mem_fn<_Rp (_Tp::*)(_A0) const volatile>
mem_fn(_Rp (_Tp::* __pm)(_A0) const volatile)
{
    return __mem_fn<_Rp (_Tp::*)(_A0) const volatile>(__pm);
}

template<class _Rp, class _Tp, class _A0, class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
__mem_fn<_Rp (_Tp::*)(_A0, _A1) const volatile>
mem_fn(_Rp (_Tp::* __pm)(_A0, _A1) const volatile)
{
    return __mem_fn<_Rp (_Tp::*)(_A0, _A1) const volatile>(__pm);
}

template<class _Rp, class _Tp, class _A0, class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
__mem_fn<_Rp (_Tp::*)(_A0, _A1, _A2) const volatile>
mem_fn(_Rp (_Tp::* __pm)(_A0, _A1, _A2) const volatile)
{
    return __mem_fn<_Rp (_Tp::*)(_A0, _A1, _A2) const volatile>(__pm);
}

// bad_function_call

class __attribute__ ((__visibility__("default"))) bad_function_call
    : public exception
{
};

template<class _Fp> class __attribute__ ((__type_visibility__("default"))) function; // undefined

namespace __function
{

template<class _Fp>
struct __maybe_derive_from_unary_function
{
};

template<class _Rp, class _A1>
struct __maybe_derive_from_unary_function<_Rp(_A1)>
    : public unary_function<_A1, _Rp>
{
};

template<class _Fp>
struct __maybe_derive_from_binary_function
{
};

template<class _Rp, class _A1, class _A2>
struct __maybe_derive_from_binary_function<_Rp(_A1, _A2)>
    : public binary_function<_A1, _A2, _Rp>
{
};

template<class _Fp> class __base;

template<class _Rp>
class __base<_Rp()>
{
    __base(const __base&);
    __base& operator=(const __base&);
public:
    __base() {}
    virtual ~__base() {}
    virtual __base* __clone() const = 0;
    virtual void __clone(__base*) const = 0;
    virtual void destroy() = 0;
    virtual void destroy_deallocate() = 0;
    virtual _Rp operator()() = 0;

    virtual const void* target(const type_info&) const = 0;
    virtual const std::type_info& target_type() const = 0;

};

template<class _Rp, class _A0>
class __base<_Rp(_A0)>
{
    __base(const __base&);
    __base& operator=(const __base&);
public:
    __base() {}
    virtual ~__base() {}
    virtual __base* __clone() const = 0;
    virtual void __clone(__base*) const = 0;
    virtual void destroy() = 0;
    virtual void destroy_deallocate() = 0;
    virtual _Rp operator()(_A0) = 0;

    virtual const void* target(const type_info&) const = 0;
    virtual const std::type_info& target_type() const = 0;

};

template<class _Rp, class _A0, class _A1>
class __base<_Rp(_A0, _A1)>
{
    __base(const __base&);
    __base& operator=(const __base&);
public:
    __base() {}
    virtual ~__base() {}
    virtual __base* __clone() const = 0;
    virtual void __clone(__base*) const = 0;
    virtual void destroy() = 0;
    virtual void destroy_deallocate() = 0;
    virtual _Rp operator()(_A0, _A1) = 0;

    virtual const void* target(const type_info&) const = 0;
    virtual const std::type_info& target_type() const = 0;

};

template<class _Rp, class _A0, class _A1, class _A2>
class __base<_Rp(_A0, _A1, _A2)>
{
    __base(const __base&);
    __base& operator=(const __base&);
public:
    __base() {}
    virtual ~__base() {}
    virtual __base* __clone() const = 0;
    virtual void __clone(__base*) const = 0;
    virtual void destroy() = 0;
    virtual void destroy_deallocate() = 0;
    virtual _Rp operator()(_A0, _A1, _A2) = 0;

    virtual const void* target(const type_info&) const = 0;
    virtual const std::type_info& target_type() const = 0;

};

template<class _FD, class _Alloc, class _FB> class __func;

template<class _Fp, class _Alloc, class _Rp>
class __func<_Fp, _Alloc, _Rp()>
    : public __base<_Rp()>
{
    __compressed_pair<_Fp, _Alloc> __f_;
public:
    explicit __func(_Fp __f) : __f_(std::__1::move(__f)) {}
    explicit __func(_Fp __f, _Alloc __a) : __f_(std::__1::move(__f), std::__1::move(__a)) {}
    virtual __base<_Rp()>* __clone() const;
    virtual void __clone(__base<_Rp()>*) const;
    virtual void destroy();
    virtual void destroy_deallocate();
    virtual _Rp operator()();

    virtual const void* target(const type_info&) const;
    virtual const std::type_info& target_type() const;

};

template<class _Fp, class _Alloc, class _Rp>
__base<_Rp()>*
__func<_Fp, _Alloc, _Rp()>::__clone() const
{
    typedef typename _Alloc::template rebind<__func>::other _Ap;
    _Ap __a(__f_.second());
    typedef __allocator_destructor<_Ap> _Dp;
    unique_ptr<__func, _Dp> __hold(__a.allocate(1), _Dp(__a, 1));
    ::new (__hold.get()) __func(__f_.first(), _Alloc(__a));
    return __hold.release();
}

template<class _Fp, class _Alloc, class _Rp>
void
__func<_Fp, _Alloc, _Rp()>::__clone(__base<_Rp()>* __p) const
{
    ::new (__p) __func(__f_.first(), __f_.second());
}

template<class _Fp, class _Alloc, class _Rp>
void
__func<_Fp, _Alloc, _Rp()>::destroy()
{
    __f_.~__compressed_pair<_Fp, _Alloc>();
}

template<class _Fp, class _Alloc, class _Rp>
void
__func<_Fp, _Alloc, _Rp()>::destroy_deallocate()
{
    typedef typename _Alloc::template rebind<__func>::other _Ap;
    _Ap __a(__f_.second());
    __f_.~__compressed_pair<_Fp, _Alloc>();
    __a.deallocate(this, 1);
}

template<class _Fp, class _Alloc, class _Rp>
_Rp
__func<_Fp, _Alloc, _Rp()>::operator()()
{
    return __invoke(__f_.first());
}



template<class _Fp, class _Alloc, class _Rp>
const void*
__func<_Fp, _Alloc, _Rp()>::target(const type_info& __ti) const
{
    if (__ti == typeid(_Fp))
        return &__f_.first();
    return (const void*)0;
}

template<class _Fp, class _Alloc, class _Rp>
const std::type_info&
__func<_Fp, _Alloc, _Rp()>::target_type() const
{
    return typeid(_Fp);
}



template<class _Fp, class _Alloc, class _Rp, class _A0>
class __func<_Fp, _Alloc, _Rp(_A0)>
    : public __base<_Rp(_A0)>
{
    __compressed_pair<_Fp, _Alloc> __f_;
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit __func(_Fp __f) : __f_(std::__1::move(__f)) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit __func(_Fp __f, _Alloc __a)
        : __f_(std::__1::move(__f), std::__1::move(__a)) {}
    virtual __base<_Rp(_A0)>* __clone() const;
    virtual void __clone(__base<_Rp(_A0)>*) const;
    virtual void destroy();
    virtual void destroy_deallocate();
    virtual _Rp operator()(_A0);

    virtual const void* target(const type_info&) const;
    virtual const std::type_info& target_type() const;

};

template<class _Fp, class _Alloc, class _Rp, class _A0>
__base<_Rp(_A0)>*
__func<_Fp, _Alloc, _Rp(_A0)>::__clone() const
{
    typedef typename _Alloc::template rebind<__func>::other _Ap;
    _Ap __a(__f_.second());
    typedef __allocator_destructor<_Ap> _Dp;
    unique_ptr<__func, _Dp> __hold(__a.allocate(1), _Dp(__a, 1));
    ::new (__hold.get()) __func(__f_.first(), _Alloc(__a));
    return __hold.release();
}

template<class _Fp, class _Alloc, class _Rp, class _A0>
void
__func<_Fp, _Alloc, _Rp(_A0)>::__clone(__base<_Rp(_A0)>* __p) const
{
    ::new (__p) __func(__f_.first(), __f_.second());
}

template<class _Fp, class _Alloc, class _Rp, class _A0>
void
__func<_Fp, _Alloc, _Rp(_A0)>::destroy()
{
    __f_.~__compressed_pair<_Fp, _Alloc>();
}

template<class _Fp, class _Alloc, class _Rp, class _A0>
void
__func<_Fp, _Alloc, _Rp(_A0)>::destroy_deallocate()
{
    typedef typename _Alloc::template rebind<__func>::other _Ap;
    _Ap __a(__f_.second());
    __f_.~__compressed_pair<_Fp, _Alloc>();
    __a.deallocate(this, 1);
}

template<class _Fp, class _Alloc, class _Rp, class _A0>
_Rp
__func<_Fp, _Alloc, _Rp(_A0)>::operator()(_A0 __a0)
{
    return __invoke(__f_.first(), __a0);
}



template<class _Fp, class _Alloc, class _Rp, class _A0>
const void*
__func<_Fp, _Alloc, _Rp(_A0)>::target(const type_info& __ti) const
{
    if (__ti == typeid(_Fp))
        return &__f_.first();
    return (const void*)0;
}

template<class _Fp, class _Alloc, class _Rp, class _A0>
const std::type_info&
__func<_Fp, _Alloc, _Rp(_A0)>::target_type() const
{
    return typeid(_Fp);
}



template<class _Fp, class _Alloc, class _Rp, class _A0, class _A1>
class __func<_Fp, _Alloc, _Rp(_A0, _A1)>
    : public __base<_Rp(_A0, _A1)>
{
    __compressed_pair<_Fp, _Alloc> __f_;
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit __func(_Fp __f) : __f_(std::__1::move(__f)) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit __func(_Fp __f, _Alloc __a)
        : __f_(std::__1::move(__f), std::__1::move(__a)) {}
    virtual __base<_Rp(_A0, _A1)>* __clone() const;
    virtual void __clone(__base<_Rp(_A0, _A1)>*) const;
    virtual void destroy();
    virtual void destroy_deallocate();
    virtual _Rp operator()(_A0, _A1);

    virtual const void* target(const type_info&) const;
    virtual const std::type_info& target_type() const;

};

template<class _Fp, class _Alloc, class _Rp, class _A0, class _A1>
__base<_Rp(_A0, _A1)>*
__func<_Fp, _Alloc, _Rp(_A0, _A1)>::__clone() const
{
    typedef typename _Alloc::template rebind<__func>::other _Ap;
    _Ap __a(__f_.second());
    typedef __allocator_destructor<_Ap> _Dp;
    unique_ptr<__func, _Dp> __hold(__a.allocate(1), _Dp(__a, 1));
    ::new (__hold.get()) __func(__f_.first(), _Alloc(__a));
    return __hold.release();
}

template<class _Fp, class _Alloc, class _Rp, class _A0, class _A1>
void
__func<_Fp, _Alloc, _Rp(_A0, _A1)>::__clone(__base<_Rp(_A0, _A1)>* __p) const
{
    ::new (__p) __func(__f_.first(), __f_.second());
}

template<class _Fp, class _Alloc, class _Rp, class _A0, class _A1>
void
__func<_Fp, _Alloc, _Rp(_A0, _A1)>::destroy()
{
    __f_.~__compressed_pair<_Fp, _Alloc>();
}

template<class _Fp, class _Alloc, class _Rp, class _A0, class _A1>
void
__func<_Fp, _Alloc, _Rp(_A0, _A1)>::destroy_deallocate()
{
    typedef typename _Alloc::template rebind<__func>::other _Ap;
    _Ap __a(__f_.second());
    __f_.~__compressed_pair<_Fp, _Alloc>();
    __a.deallocate(this, 1);
}

template<class _Fp, class _Alloc, class _Rp, class _A0, class _A1>
_Rp
__func<_Fp, _Alloc, _Rp(_A0, _A1)>::operator()(_A0 __a0, _A1 __a1)
{
    return __invoke(__f_.first(), __a0, __a1);
}



template<class _Fp, class _Alloc, class _Rp, class _A0, class _A1>
const void*
__func<_Fp, _Alloc, _Rp(_A0, _A1)>::target(const type_info& __ti) const
{
    if (__ti == typeid(_Fp))
        return &__f_.first();
    return (const void*)0;
}

template<class _Fp, class _Alloc, class _Rp, class _A0, class _A1>
const std::type_info&
__func<_Fp, _Alloc, _Rp(_A0, _A1)>::target_type() const
{
    return typeid(_Fp);
}



template<class _Fp, class _Alloc, class _Rp, class _A0, class _A1, class _A2>
class __func<_Fp, _Alloc, _Rp(_A0, _A1, _A2)>
    : public __base<_Rp(_A0, _A1, _A2)>
{
    __compressed_pair<_Fp, _Alloc> __f_;
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit __func(_Fp __f) : __f_(std::__1::move(__f)) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit __func(_Fp __f, _Alloc __a)
        : __f_(std::__1::move(__f), std::__1::move(__a)) {}
    virtual __base<_Rp(_A0, _A1, _A2)>* __clone() const;
    virtual void __clone(__base<_Rp(_A0, _A1, _A2)>*) const;
    virtual void destroy();
    virtual void destroy_deallocate();
    virtual _Rp operator()(_A0, _A1, _A2);

    virtual const void* target(const type_info&) const;
    virtual const std::type_info& target_type() const;

};

template<class _Fp, class _Alloc, class _Rp, class _A0, class _A1, class _A2>
__base<_Rp(_A0, _A1, _A2)>*
__func<_Fp, _Alloc, _Rp(_A0, _A1, _A2)>::__clone() const
{
    typedef typename _Alloc::template rebind<__func>::other _Ap;
    _Ap __a(__f_.second());
    typedef __allocator_destructor<_Ap> _Dp;
    unique_ptr<__func, _Dp> __hold(__a.allocate(1), _Dp(__a, 1));
    ::new (__hold.get()) __func(__f_.first(), _Alloc(__a));
    return __hold.release();
}

template<class _Fp, class _Alloc, class _Rp, class _A0, class _A1, class _A2>
void
__func<_Fp, _Alloc, _Rp(_A0, _A1, _A2)>::__clone(__base<_Rp(_A0, _A1, _A2)>* __p) const
{
    ::new (__p) __func(__f_.first(), __f_.second());
}

template<class _Fp, class _Alloc, class _Rp, class _A0, class _A1, class _A2>
void
__func<_Fp, _Alloc, _Rp(_A0, _A1, _A2)>::destroy()
{
    __f_.~__compressed_pair<_Fp, _Alloc>();
}

template<class _Fp, class _Alloc, class _Rp, class _A0, class _A1, class _A2>
void
__func<_Fp, _Alloc, _Rp(_A0, _A1, _A2)>::destroy_deallocate()
{
    typedef typename _Alloc::template rebind<__func>::other _Ap;
    _Ap __a(__f_.second());
    __f_.~__compressed_pair<_Fp, _Alloc>();
    __a.deallocate(this, 1);
}

template<class _Fp, class _Alloc, class _Rp, class _A0, class _A1, class _A2>
_Rp
__func<_Fp, _Alloc, _Rp(_A0, _A1, _A2)>::operator()(_A0 __a0, _A1 __a1, _A2 __a2)
{
    return __invoke(__f_.first(), __a0, __a1, __a2);
}



template<class _Fp, class _Alloc, class _Rp, class _A0, class _A1, class _A2>
const void*
__func<_Fp, _Alloc, _Rp(_A0, _A1, _A2)>::target(const type_info& __ti) const
{
    if (__ti == typeid(_Fp))
        return &__f_.first();
    return (const void*)0;
}

template<class _Fp, class _Alloc, class _Rp, class _A0, class _A1, class _A2>
const std::type_info&
__func<_Fp, _Alloc, _Rp(_A0, _A1, _A2)>::target_type() const
{
    return typeid(_Fp);
}



} // __function

template<class _Rp>
class __attribute__ ((__type_visibility__("default"))) function<_Rp()>
{
    typedef __function::__base<_Rp()> __base;
    aligned_storage<3*sizeof(void*)>::type __buf_;
    __base* __f_;

    template <class _Fp>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        static bool __not_null(const _Fp&) {return true;}
    template <class _R2>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        static bool __not_null(_R2 (*__p)()) {return __p;}
    template <class _R2>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        static bool __not_null(const function<_R2()>& __p) {return __p;}
public:
    typedef _Rp result_type;

    // 20.7.16.2.1, construct/copy/destroy:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit function() : __f_(0) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) function(nullptr_t) : __f_(0) {}
    function(const function&);
    template<class _Fp>
      function(_Fp,
               typename enable_if<!is_integral<_Fp>::value>::type* = 0);

    template<class _Alloc>
      __attribute__ ((__visibility__("hidden"), __always_inline__))
      function(allocator_arg_t, const _Alloc&) : __f_(0) {}
    template<class _Alloc>
      __attribute__ ((__visibility__("hidden"), __always_inline__))
      function(allocator_arg_t, const _Alloc&, nullptr_t) : __f_(0) {}
    template<class _Alloc>
      function(allocator_arg_t, const _Alloc&, const function&);
    template<class _Fp, class _Alloc>
      function(allocator_arg_t, const _Alloc& __a, _Fp __f,
               typename enable_if<!is_integral<_Fp>::value>::type* = 0);

    function& operator=(const function&);
    function& operator=(nullptr_t);
    template<class _Fp>
      typename enable_if
      <
        !is_integral<_Fp>::value,
        function&
      >::type
      operator=(_Fp);

    ~function();

    // 20.7.16.2.2, function modifiers:
    void swap(function&);
    template<class _Fp, class _Alloc>
      __attribute__ ((__visibility__("hidden"), __always_inline__))
      void assign(_Fp __f, const _Alloc& __a)
        {function(allocator_arg, __a, __f).swap(*this);}

    // 20.7.16.2.3, function capacity:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) operator bool() const {return __f_;}

private:
    // deleted overloads close possible hole in the type system
    template<class _R2>
      bool operator==(const function<_R2()>&) const;// = delete;
    template<class _R2>
      bool operator!=(const function<_R2()>&) const;// = delete;
public:
    // 20.7.16.2.4, function invocation:
    _Rp operator()() const;


    // 20.7.16.2.5, function target access:
    const std::type_info& target_type() const;
    template <typename _Tp> _Tp* target();
    template <typename _Tp> const _Tp* target() const;

};

template<class _Rp>
function<_Rp()>::function(const function& __f)
{
    if (__f.__f_ == 0)
        __f_ = 0;
    else if (__f.__f_ == (const __base*)&__f.__buf_)
    {
        __f_ = (__base*)&__buf_;
        __f.__f_->__clone(__f_);
    }
    else
        __f_ = __f.__f_->__clone();
}

template<class _Rp>
template<class _Alloc>
function<_Rp()>::function(allocator_arg_t, const _Alloc&, const function& __f)
{
    if (__f.__f_ == 0)
        __f_ = 0;
    else if (__f.__f_ == (const __base*)&__f.__buf_)
    {
        __f_ = (__base*)&__buf_;
        __f.__f_->__clone(__f_);
    }
    else
        __f_ = __f.__f_->__clone();
}

template<class _Rp>
template <class _Fp>
function<_Rp()>::function(_Fp __f,
                                     typename enable_if<!is_integral<_Fp>::value>::type*)
    : __f_(0)
{
    if (__not_null(__f))
    {
        typedef __function::__func<_Fp, allocator<_Fp>, _Rp()> _FF;
        if (sizeof(_FF) <= sizeof(__buf_))
        {
            __f_ = (__base*)&__buf_;
            ::new (__f_) _FF(__f);
        }
        else
        {
            typedef allocator<_FF> _Ap;
            _Ap __a;
            typedef __allocator_destructor<_Ap> _Dp;
            unique_ptr<__base, _Dp> __hold(__a.allocate(1), _Dp(__a, 1));
            ::new (__hold.get()) _FF(__f, allocator<_Fp>(__a));
            __f_ = __hold.release();
        }
    }
}

template<class _Rp>
template <class _Fp, class _Alloc>
function<_Rp()>::function(allocator_arg_t, const _Alloc& __a0, _Fp __f,
                                     typename enable_if<!is_integral<_Fp>::value>::type*)
    : __f_(0)
{
    typedef allocator_traits<_Alloc> __alloc_traits;
    if (__not_null(__f))
    {
        typedef __function::__func<_Fp, _Alloc, _Rp()> _FF;
        if (sizeof(_FF) <= sizeof(__buf_))
        {
            __f_ = (__base*)&__buf_;
            ::new (__f_) _FF(__f);
        }
        else
        {
            typedef typename __alloc_traits::template



                rebind_alloc<_FF>::other

                                                         _Ap;
            _Ap __a(__a0);
            typedef __allocator_destructor<_Ap> _Dp;
            unique_ptr<__base, _Dp> __hold(__a.allocate(1), _Dp(__a, 1));
            ::new (__hold.get()) _FF(__f, _Alloc(__a));
            __f_ = __hold.release();
        }
    }
}

template<class _Rp>
function<_Rp()>&
function<_Rp()>::operator=(const function& __f)
{
    function(__f).swap(*this);
    return *this;
}

template<class _Rp>
function<_Rp()>&
function<_Rp()>::operator=(nullptr_t)
{
    if (__f_ == (__base*)&__buf_)
        __f_->destroy();
    else if (__f_)
        __f_->destroy_deallocate();
    __f_ = 0;
}

template<class _Rp>
template <class _Fp>
typename enable_if
<
    !is_integral<_Fp>::value,
    function<_Rp()>&
>::type
function<_Rp()>::operator=(_Fp __f)
{
    function(std::__1::move(__f)).swap(*this);
    return *this;
}

template<class _Rp>
function<_Rp()>::~function()
{
    if (__f_ == (__base*)&__buf_)
        __f_->destroy();
    else if (__f_)
        __f_->destroy_deallocate();
}

template<class _Rp>
void
function<_Rp()>::swap(function& __f)
{
    if (__f_ == (__base*)&__buf_ && __f.__f_ == (__base*)&__f.__buf_)
    {
        typename aligned_storage<sizeof(__buf_)>::type __tempbuf;
        __base* __t = (__base*)&__tempbuf;
        __f_->__clone(__t);
        __f_->destroy();
        __f_ = 0;
        __f.__f_->__clone((__base*)&__buf_);
        __f.__f_->destroy();
        __f.__f_ = 0;
        __f_ = (__base*)&__buf_;
        __t->__clone((__base*)&__f.__buf_);
        __t->destroy();
        __f.__f_ = (__base*)&__f.__buf_;
    }
    else if (__f_ == (__base*)&__buf_)
    {
        __f_->__clone((__base*)&__f.__buf_);
        __f_->destroy();
        __f_ = __f.__f_;
        __f.__f_ = (__base*)&__f.__buf_;
    }
    else if (__f.__f_ == (__base*)&__f.__buf_)
    {
        __f.__f_->__clone((__base*)&__buf_);
        __f.__f_->destroy();
        __f.__f_ = __f_;
        __f_ = (__base*)&__buf_;
    }
    else
        std::__1::swap(__f_, __f.__f_);
}

template<class _Rp>
_Rp
function<_Rp()>::operator()() const
{

    if (__f_ == 0)
        throw bad_function_call();

    return (*__f_)();
}



template<class _Rp>
const std::type_info&
function<_Rp()>::target_type() const
{
    if (__f_ == 0)
        return typeid(void);
    return __f_->target_type();
}

template<class _Rp>
template <typename _Tp>
_Tp*
function<_Rp()>::target()
{
    if (__f_ == 0)
        return (_Tp*)0;
    return (_Tp*)__f_->target(typeid(_Tp));
}

template<class _Rp>
template <typename _Tp>
const _Tp*
function<_Rp()>::target() const
{
    if (__f_ == 0)
        return (const _Tp*)0;
    return (const _Tp*)__f_->target(typeid(_Tp));
}



template<class _Rp, class _A0>
class __attribute__ ((__type_visibility__("default"))) function<_Rp(_A0)>
    : public unary_function<_A0, _Rp>
{
    typedef __function::__base<_Rp(_A0)> __base;
    aligned_storage<3*sizeof(void*)>::type __buf_;
    __base* __f_;

    template <class _Fp>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        static bool __not_null(const _Fp&) {return true;}
    template <class _R2, class _B0>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        static bool __not_null(_R2 (*__p)(_B0)) {return __p;}
    template <class _R2, class _Cp>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        static bool __not_null(_R2 (_Cp::*__p)()) {return __p;}
    template <class _R2, class _Cp>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        static bool __not_null(_R2 (_Cp::*__p)() const) {return __p;}
    template <class _R2, class _Cp>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        static bool __not_null(_R2 (_Cp::*__p)() volatile) {return __p;}
    template <class _R2, class _Cp>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        static bool __not_null(_R2 (_Cp::*__p)() const volatile) {return __p;}
    template <class _R2, class _B0>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        static bool __not_null(const function<_R2(_B0)>& __p) {return __p;}
public:
    typedef _Rp result_type;

    // 20.7.16.2.1, construct/copy/destroy:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit function() : __f_(0) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) function(nullptr_t) : __f_(0) {}
    function(const function&);
    template<class _Fp>
      function(_Fp,
               typename enable_if<!is_integral<_Fp>::value>::type* = 0);

    template<class _Alloc>
      __attribute__ ((__visibility__("hidden"), __always_inline__))
      function(allocator_arg_t, const _Alloc&) : __f_(0) {}
    template<class _Alloc>
      __attribute__ ((__visibility__("hidden"), __always_inline__))
      function(allocator_arg_t, const _Alloc&, nullptr_t) : __f_(0) {}
    template<class _Alloc>
      function(allocator_arg_t, const _Alloc&, const function&);
    template<class _Fp, class _Alloc>
      function(allocator_arg_t, const _Alloc& __a, _Fp __f,
               typename enable_if<!is_integral<_Fp>::value>::type* = 0);

    function& operator=(const function&);
    function& operator=(nullptr_t);
    template<class _Fp>
      typename enable_if
      <
        !is_integral<_Fp>::value,
        function&
      >::type
      operator=(_Fp);

    ~function();

    // 20.7.16.2.2, function modifiers:
    void swap(function&);
    template<class _Fp, class _Alloc>
      __attribute__ ((__visibility__("hidden"), __always_inline__))
      void assign(_Fp __f, const _Alloc& __a)
        {function(allocator_arg, __a, __f).swap(*this);}

    // 20.7.16.2.3, function capacity:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) operator bool() const {return __f_;}

private:
    // deleted overloads close possible hole in the type system
    template<class _R2, class _B0>
      bool operator==(const function<_R2(_B0)>&) const;// = delete;
    template<class _R2, class _B0>
      bool operator!=(const function<_R2(_B0)>&) const;// = delete;
public:
    // 20.7.16.2.4, function invocation:
    _Rp operator()(_A0) const;


    // 20.7.16.2.5, function target access:
    const std::type_info& target_type() const;
    template <typename _Tp> _Tp* target();
    template <typename _Tp> const _Tp* target() const;

};

template<class _Rp, class _A0>
function<_Rp(_A0)>::function(const function& __f)
{
    if (__f.__f_ == 0)
        __f_ = 0;
    else if (__f.__f_ == (const __base*)&__f.__buf_)
    {
        __f_ = (__base*)&__buf_;
        __f.__f_->__clone(__f_);
    }
    else
        __f_ = __f.__f_->__clone();
}

template<class _Rp, class _A0>
template<class _Alloc>
function<_Rp(_A0)>::function(allocator_arg_t, const _Alloc&, const function& __f)
{
    if (__f.__f_ == 0)
        __f_ = 0;
    else if (__f.__f_ == (const __base*)&__f.__buf_)
    {
        __f_ = (__base*)&__buf_;
        __f.__f_->__clone(__f_);
    }
    else
        __f_ = __f.__f_->__clone();
}

template<class _Rp, class _A0>
template <class _Fp>
function<_Rp(_A0)>::function(_Fp __f,
                                     typename enable_if<!is_integral<_Fp>::value>::type*)
    : __f_(0)
{
    if (__not_null(__f))
    {
        typedef __function::__func<_Fp, allocator<_Fp>, _Rp(_A0)> _FF;
        if (sizeof(_FF) <= sizeof(__buf_))
        {
            __f_ = (__base*)&__buf_;
            ::new (__f_) _FF(__f);
        }
        else
        {
            typedef allocator<_FF> _Ap;
            _Ap __a;
            typedef __allocator_destructor<_Ap> _Dp;
            unique_ptr<__base, _Dp> __hold(__a.allocate(1), _Dp(__a, 1));
            ::new (__hold.get()) _FF(__f, allocator<_Fp>(__a));
            __f_ = __hold.release();
        }
    }
}

template<class _Rp, class _A0>
template <class _Fp, class _Alloc>
function<_Rp(_A0)>::function(allocator_arg_t, const _Alloc& __a0, _Fp __f,
                                     typename enable_if<!is_integral<_Fp>::value>::type*)
    : __f_(0)
{
    typedef allocator_traits<_Alloc> __alloc_traits;
    if (__not_null(__f))
    {
        typedef __function::__func<_Fp, _Alloc, _Rp(_A0)> _FF;
        if (sizeof(_FF) <= sizeof(__buf_))
        {
            __f_ = (__base*)&__buf_;
            ::new (__f_) _FF(__f);
        }
        else
        {
            typedef typename __alloc_traits::template



                rebind_alloc<_FF>::other

                                                         _Ap;
            _Ap __a(__a0);
            typedef __allocator_destructor<_Ap> _Dp;
            unique_ptr<__base, _Dp> __hold(__a.allocate(1), _Dp(__a, 1));
            ::new (__hold.get()) _FF(__f, _Alloc(__a));
            __f_ = __hold.release();
        }
    }
}

template<class _Rp, class _A0>
function<_Rp(_A0)>&
function<_Rp(_A0)>::operator=(const function& __f)
{
    function(__f).swap(*this);
    return *this;
}

template<class _Rp, class _A0>
function<_Rp(_A0)>&
function<_Rp(_A0)>::operator=(nullptr_t)
{
    if (__f_ == (__base*)&__buf_)
        __f_->destroy();
    else if (__f_)
        __f_->destroy_deallocate();
    __f_ = 0;
}

template<class _Rp, class _A0>
template <class _Fp>
typename enable_if
<
    !is_integral<_Fp>::value,
    function<_Rp(_A0)>&
>::type
function<_Rp(_A0)>::operator=(_Fp __f)
{
    function(std::__1::move(__f)).swap(*this);
    return *this;
}

template<class _Rp, class _A0>
function<_Rp(_A0)>::~function()
{
    if (__f_ == (__base*)&__buf_)
        __f_->destroy();
    else if (__f_)
        __f_->destroy_deallocate();
}

template<class _Rp, class _A0>
void
function<_Rp(_A0)>::swap(function& __f)
{
    if (__f_ == (__base*)&__buf_ && __f.__f_ == (__base*)&__f.__buf_)
    {
        typename aligned_storage<sizeof(__buf_)>::type __tempbuf;
        __base* __t = (__base*)&__tempbuf;
        __f_->__clone(__t);
        __f_->destroy();
        __f_ = 0;
        __f.__f_->__clone((__base*)&__buf_);
        __f.__f_->destroy();
        __f.__f_ = 0;
        __f_ = (__base*)&__buf_;
        __t->__clone((__base*)&__f.__buf_);
        __t->destroy();
        __f.__f_ = (__base*)&__f.__buf_;
    }
    else if (__f_ == (__base*)&__buf_)
    {
        __f_->__clone((__base*)&__f.__buf_);
        __f_->destroy();
        __f_ = __f.__f_;
        __f.__f_ = (__base*)&__f.__buf_;
    }
    else if (__f.__f_ == (__base*)&__f.__buf_)
    {
        __f.__f_->__clone((__base*)&__buf_);
        __f.__f_->destroy();
        __f.__f_ = __f_;
        __f_ = (__base*)&__buf_;
    }
    else
        std::__1::swap(__f_, __f.__f_);
}

template<class _Rp, class _A0>
_Rp
function<_Rp(_A0)>::operator()(_A0 __a0) const
{

    if (__f_ == 0)
        throw bad_function_call();

    return (*__f_)(__a0);
}



template<class _Rp, class _A0>
const std::type_info&
function<_Rp(_A0)>::target_type() const
{
    if (__f_ == 0)
        return typeid(void);
    return __f_->target_type();
}

template<class _Rp, class _A0>
template <typename _Tp>
_Tp*
function<_Rp(_A0)>::target()
{
    if (__f_ == 0)
        return (_Tp*)0;
    return (_Tp*)__f_->target(typeid(_Tp));
}

template<class _Rp, class _A0>
template <typename _Tp>
const _Tp*
function<_Rp(_A0)>::target() const
{
    if (__f_ == 0)
        return (const _Tp*)0;
    return (const _Tp*)__f_->target(typeid(_Tp));
}



template<class _Rp, class _A0, class _A1>
class __attribute__ ((__type_visibility__("default"))) function<_Rp(_A0, _A1)>
    : public binary_function<_A0, _A1, _Rp>
{
    typedef __function::__base<_Rp(_A0, _A1)> __base;
    aligned_storage<3*sizeof(void*)>::type __buf_;
    __base* __f_;

    template <class _Fp>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        static bool __not_null(const _Fp&) {return true;}
    template <class _R2, class _B0, class _B1>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        static bool __not_null(_R2 (*__p)(_B0, _B1)) {return __p;}
    template <class _R2, class _Cp, class _B1>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        static bool __not_null(_R2 (_Cp::*__p)(_B1)) {return __p;}
    template <class _R2, class _Cp, class _B1>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        static bool __not_null(_R2 (_Cp::*__p)(_B1) const) {return __p;}
    template <class _R2, class _Cp, class _B1>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        static bool __not_null(_R2 (_Cp::*__p)(_B1) volatile) {return __p;}
    template <class _R2, class _Cp, class _B1>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        static bool __not_null(_R2 (_Cp::*__p)(_B1) const volatile) {return __p;}
    template <class _R2, class _B0, class _B1>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        static bool __not_null(const function<_R2(_B0, _B1)>& __p) {return __p;}
public:
    typedef _Rp result_type;

    // 20.7.16.2.1, construct/copy/destroy:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit function() : __f_(0) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) function(nullptr_t) : __f_(0) {}
    function(const function&);
    template<class _Fp>
      function(_Fp,
               typename enable_if<!is_integral<_Fp>::value>::type* = 0);

    template<class _Alloc>
      __attribute__ ((__visibility__("hidden"), __always_inline__))
      function(allocator_arg_t, const _Alloc&) : __f_(0) {}
    template<class _Alloc>
      __attribute__ ((__visibility__("hidden"), __always_inline__))
      function(allocator_arg_t, const _Alloc&, nullptr_t) : __f_(0) {}
    template<class _Alloc>
      function(allocator_arg_t, const _Alloc&, const function&);
    template<class _Fp, class _Alloc>
      function(allocator_arg_t, const _Alloc& __a, _Fp __f,
               typename enable_if<!is_integral<_Fp>::value>::type* = 0);

    function& operator=(const function&);
    function& operator=(nullptr_t);
    template<class _Fp>
      typename enable_if
      <
        !is_integral<_Fp>::value,
        function&
      >::type
      operator=(_Fp);

    ~function();

    // 20.7.16.2.2, function modifiers:
    void swap(function&);
    template<class _Fp, class _Alloc>
      __attribute__ ((__visibility__("hidden"), __always_inline__))
      void assign(_Fp __f, const _Alloc& __a)
        {function(allocator_arg, __a, __f).swap(*this);}

    // 20.7.16.2.3, function capacity:
    operator bool() const {return __f_;}

private:
    // deleted overloads close possible hole in the type system
    template<class _R2, class _B0, class _B1>
      bool operator==(const function<_R2(_B0, _B1)>&) const;// = delete;
    template<class _R2, class _B0, class _B1>
      bool operator!=(const function<_R2(_B0, _B1)>&) const;// = delete;
public:
    // 20.7.16.2.4, function invocation:
    _Rp operator()(_A0, _A1) const;


    // 20.7.16.2.5, function target access:
    const std::type_info& target_type() const;
    template <typename _Tp> _Tp* target();
    template <typename _Tp> const _Tp* target() const;

};

template<class _Rp, class _A0, class _A1>
function<_Rp(_A0, _A1)>::function(const function& __f)
{
    if (__f.__f_ == 0)
        __f_ = 0;
    else if (__f.__f_ == (const __base*)&__f.__buf_)
    {
        __f_ = (__base*)&__buf_;
        __f.__f_->__clone(__f_);
    }
    else
        __f_ = __f.__f_->__clone();
}

template<class _Rp, class _A0, class _A1>
template<class _Alloc>
function<_Rp(_A0, _A1)>::function(allocator_arg_t, const _Alloc&, const function& __f)
{
    if (__f.__f_ == 0)
        __f_ = 0;
    else if (__f.__f_ == (const __base*)&__f.__buf_)
    {
        __f_ = (__base*)&__buf_;
        __f.__f_->__clone(__f_);
    }
    else
        __f_ = __f.__f_->__clone();
}

template<class _Rp, class _A0, class _A1>
template <class _Fp>
function<_Rp(_A0, _A1)>::function(_Fp __f,
                                 typename enable_if<!is_integral<_Fp>::value>::type*)
    : __f_(0)
{
    if (__not_null(__f))
    {
        typedef __function::__func<_Fp, allocator<_Fp>, _Rp(_A0, _A1)> _FF;
        if (sizeof(_FF) <= sizeof(__buf_))
        {
            __f_ = (__base*)&__buf_;
            ::new (__f_) _FF(__f);
        }
        else
        {
            typedef allocator<_FF> _Ap;
            _Ap __a;
            typedef __allocator_destructor<_Ap> _Dp;
            unique_ptr<__base, _Dp> __hold(__a.allocate(1), _Dp(__a, 1));
            ::new (__hold.get()) _FF(__f, allocator<_Fp>(__a));
            __f_ = __hold.release();
        }
    }
}

template<class _Rp, class _A0, class _A1>
template <class _Fp, class _Alloc>
function<_Rp(_A0, _A1)>::function(allocator_arg_t, const _Alloc& __a0, _Fp __f,
                                 typename enable_if<!is_integral<_Fp>::value>::type*)
    : __f_(0)
{
    typedef allocator_traits<_Alloc> __alloc_traits;
    if (__not_null(__f))
    {
        typedef __function::__func<_Fp, _Alloc, _Rp(_A0, _A1)> _FF;
        if (sizeof(_FF) <= sizeof(__buf_))
        {
            __f_ = (__base*)&__buf_;
            ::new (__f_) _FF(__f);
        }
        else
        {
            typedef typename __alloc_traits::template



                rebind_alloc<_FF>::other

                                                         _Ap;
            _Ap __a(__a0);
            typedef __allocator_destructor<_Ap> _Dp;
            unique_ptr<__base, _Dp> __hold(__a.allocate(1), _Dp(__a, 1));
            ::new (__hold.get()) _FF(__f, _Alloc(__a));
            __f_ = __hold.release();
        }
    }
}

template<class _Rp, class _A0, class _A1>
function<_Rp(_A0, _A1)>&
function<_Rp(_A0, _A1)>::operator=(const function& __f)
{
    function(__f).swap(*this);
    return *this;
}

template<class _Rp, class _A0, class _A1>
function<_Rp(_A0, _A1)>&
function<_Rp(_A0, _A1)>::operator=(nullptr_t)
{
    if (__f_ == (__base*)&__buf_)
        __f_->destroy();
    else if (__f_)
        __f_->destroy_deallocate();
    __f_ = 0;
}

template<class _Rp, class _A0, class _A1>
template <class _Fp>
typename enable_if
<
    !is_integral<_Fp>::value,
    function<_Rp(_A0, _A1)>&
>::type
function<_Rp(_A0, _A1)>::operator=(_Fp __f)
{
    function(std::__1::move(__f)).swap(*this);
    return *this;
}

template<class _Rp, class _A0, class _A1>
function<_Rp(_A0, _A1)>::~function()
{
    if (__f_ == (__base*)&__buf_)
        __f_->destroy();
    else if (__f_)
        __f_->destroy_deallocate();
}

template<class _Rp, class _A0, class _A1>
void
function<_Rp(_A0, _A1)>::swap(function& __f)
{
    if (__f_ == (__base*)&__buf_ && __f.__f_ == (__base*)&__f.__buf_)
    {
        typename aligned_storage<sizeof(__buf_)>::type __tempbuf;
        __base* __t = (__base*)&__tempbuf;
        __f_->__clone(__t);
        __f_->destroy();
        __f_ = 0;
        __f.__f_->__clone((__base*)&__buf_);
        __f.__f_->destroy();
        __f.__f_ = 0;
        __f_ = (__base*)&__buf_;
        __t->__clone((__base*)&__f.__buf_);
        __t->destroy();
        __f.__f_ = (__base*)&__f.__buf_;
    }
    else if (__f_ == (__base*)&__buf_)
    {
        __f_->__clone((__base*)&__f.__buf_);
        __f_->destroy();
        __f_ = __f.__f_;
        __f.__f_ = (__base*)&__f.__buf_;
    }
    else if (__f.__f_ == (__base*)&__f.__buf_)
    {
        __f.__f_->__clone((__base*)&__buf_);
        __f.__f_->destroy();
        __f.__f_ = __f_;
        __f_ = (__base*)&__buf_;
    }
    else
        std::__1::swap(__f_, __f.__f_);
}

template<class _Rp, class _A0, class _A1>
_Rp
function<_Rp(_A0, _A1)>::operator()(_A0 __a0, _A1 __a1) const
{

    if (__f_ == 0)
        throw bad_function_call();

    return (*__f_)(__a0, __a1);
}



template<class _Rp, class _A0, class _A1>
const std::type_info&
function<_Rp(_A0, _A1)>::target_type() const
{
    if (__f_ == 0)
        return typeid(void);
    return __f_->target_type();
}

template<class _Rp, class _A0, class _A1>
template <typename _Tp>
_Tp*
function<_Rp(_A0, _A1)>::target()
{
    if (__f_ == 0)
        return (_Tp*)0;
    return (_Tp*)__f_->target(typeid(_Tp));
}

template<class _Rp, class _A0, class _A1>
template <typename _Tp>
const _Tp*
function<_Rp(_A0, _A1)>::target() const
{
    if (__f_ == 0)
        return (const _Tp*)0;
    return (const _Tp*)__f_->target(typeid(_Tp));
}



template<class _Rp, class _A0, class _A1, class _A2>
class __attribute__ ((__type_visibility__("default"))) function<_Rp(_A0, _A1, _A2)>
{
    typedef __function::__base<_Rp(_A0, _A1, _A2)> __base;
    aligned_storage<3*sizeof(void*)>::type __buf_;
    __base* __f_;

    template <class _Fp>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        static bool __not_null(const _Fp&) {return true;}
    template <class _R2, class _B0, class _B1, class _B2>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        static bool __not_null(_R2 (*__p)(_B0, _B1, _B2)) {return __p;}
    template <class _R2, class _Cp, class _B1, class _B2>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        static bool __not_null(_R2 (_Cp::*__p)(_B1, _B2)) {return __p;}
    template <class _R2, class _Cp, class _B1, class _B2>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        static bool __not_null(_R2 (_Cp::*__p)(_B1, _B2) const) {return __p;}
    template <class _R2, class _Cp, class _B1, class _B2>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        static bool __not_null(_R2 (_Cp::*__p)(_B1, _B2) volatile) {return __p;}
    template <class _R2, class _Cp, class _B1, class _B2>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        static bool __not_null(_R2 (_Cp::*__p)(_B1, _B2) const volatile) {return __p;}
    template <class _R2, class _B0, class _B1, class _B2>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        static bool __not_null(const function<_R2(_B0, _B1, _B2)>& __p) {return __p;}
public:
    typedef _Rp result_type;

    // 20.7.16.2.1, construct/copy/destroy:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit function() : __f_(0) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) function(nullptr_t) : __f_(0) {}
    function(const function&);
    template<class _Fp>
      function(_Fp,
               typename enable_if<!is_integral<_Fp>::value>::type* = 0);

    template<class _Alloc>
      __attribute__ ((__visibility__("hidden"), __always_inline__))
      function(allocator_arg_t, const _Alloc&) : __f_(0) {}
    template<class _Alloc>
      __attribute__ ((__visibility__("hidden"), __always_inline__))
      function(allocator_arg_t, const _Alloc&, nullptr_t) : __f_(0) {}
    template<class _Alloc>
      function(allocator_arg_t, const _Alloc&, const function&);
    template<class _Fp, class _Alloc>
      function(allocator_arg_t, const _Alloc& __a, _Fp __f,
               typename enable_if<!is_integral<_Fp>::value>::type* = 0);

    function& operator=(const function&);
    function& operator=(nullptr_t);
    template<class _Fp>
      typename enable_if
      <
        !is_integral<_Fp>::value,
        function&
      >::type
      operator=(_Fp);

    ~function();

    // 20.7.16.2.2, function modifiers:
    void swap(function&);
    template<class _Fp, class _Alloc>
      __attribute__ ((__visibility__("hidden"), __always_inline__))
      void assign(_Fp __f, const _Alloc& __a)
        {function(allocator_arg, __a, __f).swap(*this);}

    // 20.7.16.2.3, function capacity:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) operator bool() const {return __f_;}

private:
    // deleted overloads close possible hole in the type system
    template<class _R2, class _B0, class _B1, class _B2>
      bool operator==(const function<_R2(_B0, _B1, _B2)>&) const;// = delete;
    template<class _R2, class _B0, class _B1, class _B2>
      bool operator!=(const function<_R2(_B0, _B1, _B2)>&) const;// = delete;
public:
    // 20.7.16.2.4, function invocation:
    _Rp operator()(_A0, _A1, _A2) const;


    // 20.7.16.2.5, function target access:
    const std::type_info& target_type() const;
    template <typename _Tp> _Tp* target();
    template <typename _Tp> const _Tp* target() const;

};

template<class _Rp, class _A0, class _A1, class _A2>
function<_Rp(_A0, _A1, _A2)>::function(const function& __f)
{
    if (__f.__f_ == 0)
        __f_ = 0;
    else if (__f.__f_ == (const __base*)&__f.__buf_)
    {
        __f_ = (__base*)&__buf_;
        __f.__f_->__clone(__f_);
    }
    else
        __f_ = __f.__f_->__clone();
}

template<class _Rp, class _A0, class _A1, class _A2>
template<class _Alloc>
function<_Rp(_A0, _A1, _A2)>::function(allocator_arg_t, const _Alloc&,
                                      const function& __f)
{
    if (__f.__f_ == 0)
        __f_ = 0;
    else if (__f.__f_ == (const __base*)&__f.__buf_)
    {
        __f_ = (__base*)&__buf_;
        __f.__f_->__clone(__f_);
    }
    else
        __f_ = __f.__f_->__clone();
}

template<class _Rp, class _A0, class _A1, class _A2>
template <class _Fp>
function<_Rp(_A0, _A1, _A2)>::function(_Fp __f,
                                     typename enable_if<!is_integral<_Fp>::value>::type*)
    : __f_(0)
{
    if (__not_null(__f))
    {
        typedef __function::__func<_Fp, allocator<_Fp>, _Rp(_A0, _A1, _A2)> _FF;
        if (sizeof(_FF) <= sizeof(__buf_))
        {
            __f_ = (__base*)&__buf_;
            ::new (__f_) _FF(__f);
        }
        else
        {
            typedef allocator<_FF> _Ap;
            _Ap __a;
            typedef __allocator_destructor<_Ap> _Dp;
            unique_ptr<__base, _Dp> __hold(__a.allocate(1), _Dp(__a, 1));
            ::new (__hold.get()) _FF(__f, allocator<_Fp>(__a));
            __f_ = __hold.release();
        }
    }
}

template<class _Rp, class _A0, class _A1, class _A2>
template <class _Fp, class _Alloc>
function<_Rp(_A0, _A1, _A2)>::function(allocator_arg_t, const _Alloc& __a0, _Fp __f,
                                     typename enable_if<!is_integral<_Fp>::value>::type*)
    : __f_(0)
{
    typedef allocator_traits<_Alloc> __alloc_traits;
    if (__not_null(__f))
    {
        typedef __function::__func<_Fp, _Alloc, _Rp(_A0, _A1, _A2)> _FF;
        if (sizeof(_FF) <= sizeof(__buf_))
        {
            __f_ = (__base*)&__buf_;
            ::new (__f_) _FF(__f);
        }
        else
        {
            typedef typename __alloc_traits::template



                rebind_alloc<_FF>::other

                                                         _Ap;
            _Ap __a(__a0);
            typedef __allocator_destructor<_Ap> _Dp;
            unique_ptr<__base, _Dp> __hold(__a.allocate(1), _Dp(__a, 1));
            ::new (__hold.get()) _FF(__f, _Alloc(__a));
            __f_ = __hold.release();
        }
    }
}

template<class _Rp, class _A0, class _A1, class _A2>
function<_Rp(_A0, _A1, _A2)>&
function<_Rp(_A0, _A1, _A2)>::operator=(const function& __f)
{
    function(__f).swap(*this);
    return *this;
}

template<class _Rp, class _A0, class _A1, class _A2>
function<_Rp(_A0, _A1, _A2)>&
function<_Rp(_A0, _A1, _A2)>::operator=(nullptr_t)
{
    if (__f_ == (__base*)&__buf_)
        __f_->destroy();
    else if (__f_)
        __f_->destroy_deallocate();
    __f_ = 0;
}

template<class _Rp, class _A0, class _A1, class _A2>
template <class _Fp>
typename enable_if
<
    !is_integral<_Fp>::value,
    function<_Rp(_A0, _A1, _A2)>&
>::type
function<_Rp(_A0, _A1, _A2)>::operator=(_Fp __f)
{
    function(std::__1::move(__f)).swap(*this);
    return *this;
}

template<class _Rp, class _A0, class _A1, class _A2>
function<_Rp(_A0, _A1, _A2)>::~function()
{
    if (__f_ == (__base*)&__buf_)
        __f_->destroy();
    else if (__f_)
        __f_->destroy_deallocate();
}

template<class _Rp, class _A0, class _A1, class _A2>
void
function<_Rp(_A0, _A1, _A2)>::swap(function& __f)
{
    if (__f_ == (__base*)&__buf_ && __f.__f_ == (__base*)&__f.__buf_)
    {
        typename aligned_storage<sizeof(__buf_)>::type __tempbuf;
        __base* __t = (__base*)&__tempbuf;
        __f_->__clone(__t);
        __f_->destroy();
        __f_ = 0;
        __f.__f_->__clone((__base*)&__buf_);
        __f.__f_->destroy();
        __f.__f_ = 0;
        __f_ = (__base*)&__buf_;
        __t->__clone((__base*)&__f.__buf_);
        __t->destroy();
        __f.__f_ = (__base*)&__f.__buf_;
    }
    else if (__f_ == (__base*)&__buf_)
    {
        __f_->__clone((__base*)&__f.__buf_);
        __f_->destroy();
        __f_ = __f.__f_;
        __f.__f_ = (__base*)&__f.__buf_;
    }
    else if (__f.__f_ == (__base*)&__f.__buf_)
    {
        __f.__f_->__clone((__base*)&__buf_);
        __f.__f_->destroy();
        __f.__f_ = __f_;
        __f_ = (__base*)&__buf_;
    }
    else
        std::__1::swap(__f_, __f.__f_);
}

template<class _Rp, class _A0, class _A1, class _A2>
_Rp
function<_Rp(_A0, _A1, _A2)>::operator()(_A0 __a0, _A1 __a1, _A2 __a2) const
{

    if (__f_ == 0)
        throw bad_function_call();

    return (*__f_)(__a0, __a1, __a2);
}



template<class _Rp, class _A0, class _A1, class _A2>
const std::type_info&
function<_Rp(_A0, _A1, _A2)>::target_type() const
{
    if (__f_ == 0)
        return typeid(void);
    return __f_->target_type();
}

template<class _Rp, class _A0, class _A1, class _A2>
template <typename _Tp>
_Tp*
function<_Rp(_A0, _A1, _A2)>::target()
{
    if (__f_ == 0)
        return (_Tp*)0;
    return (_Tp*)__f_->target(typeid(_Tp));
}

template<class _Rp, class _A0, class _A1, class _A2>
template <typename _Tp>
const _Tp*
function<_Rp(_A0, _A1, _A2)>::target() const
{
    if (__f_ == 0)
        return (const _Tp*)0;
    return (const _Tp*)__f_->target(typeid(_Tp));
}



template <class _Fp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator==(const function<_Fp>& __f, nullptr_t) {return !__f;}

template <class _Fp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator==(nullptr_t, const function<_Fp>& __f) {return !__f;}

template <class _Fp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator!=(const function<_Fp>& __f, nullptr_t) {return (bool)__f;}

template <class _Fp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator!=(nullptr_t, const function<_Fp>& __f) {return (bool)__f;}

template <class _Fp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
swap(function<_Fp>& __x, function<_Fp>& __y)
{return __x.swap(__y);}

template<class _Tp> struct __is_bind_expression : public false_type {};
template<class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_bind_expression
    : public __is_bind_expression<typename remove_cv<_Tp>::type> {};

template<class _Tp> struct __is_placeholder : public integral_constant<int, 0> {};
template<class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_placeholder
    : public __is_placeholder<typename remove_cv<_Tp>::type> {};

namespace placeholders
{

template <int _Np> struct __ph {};

extern __ph<1> _1;
extern __ph<2> _2;
extern __ph<3> _3;
extern __ph<4> _4;
extern __ph<5> _5;
extern __ph<6> _6;
extern __ph<7> _7;
extern __ph<8> _8;
extern __ph<9> _9;
extern __ph<10> _10;

} // placeholders

template<int _Np>
struct __is_placeholder<placeholders::__ph<_Np> >
    : public integral_constant<int, _Np> {};

template <class _Tp, class _Uj>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_Tp&
__mu(reference_wrapper<_Tp> __t, _Uj&)
{
    return __t.get();
}
/*
template <bool _IsBindExpr, class _Ti, class ..._Uj>
struct __mu_return1 {};

template <class _Ti, class ..._Uj>
struct __mu_return1<true, _Ti, _Uj...>
{
    typedef typename result_of<_Ti(_Uj...)>::type type;
};

template <class _Ti, class ..._Uj, size_t ..._Indx>
inline _LIBCPP_INLINE_VISIBILITY
typename __mu_return1<true, _Ti, _Uj...>::type
__mu_expand(_Ti& __ti, tuple<_Uj...>&& __uj, __tuple_indices<_Indx...>)
{
    __ti(_VSTD::forward<typename tuple_element<_Indx, _Uj>::type>(_VSTD::get<_Indx>(__uj))...);
}

template <class _Ti, class ..._Uj>
inline _LIBCPP_INLINE_VISIBILITY
typename enable_if
<
    is_bind_expression<_Ti>::value,
    typename __mu_return1<is_bind_expression<_Ti>::value, _Ti, _Uj...>::type
>::type
__mu(_Ti& __ti, tuple<_Uj...>& __uj)
{
    typedef typename __make_tuple_indices<sizeof...(_Uj)>::type __indices;
    return  __mu_expand(__ti, __uj, __indices());
}

template <bool IsPh, class _Ti, class _Uj>
struct __mu_return2 {};

template <class _Ti, class _Uj>
struct __mu_return2<true, _Ti, _Uj>
{
    typedef typename tuple_element<is_placeholder<_Ti>::value - 1, _Uj>::type type;
};

template <class _Ti, class _Uj>
inline _LIBCPP_INLINE_VISIBILITY
typename enable_if
<
    0 < is_placeholder<_Ti>::value,
    typename __mu_return2<0 < is_placeholder<_Ti>::value, _Ti, _Uj>::type
>::type
__mu(_Ti&, _Uj& __uj)
{
    const size_t _Indx = is_placeholder<_Ti>::value - 1;
    // compiler bug workaround
    typename tuple_element<_Indx, _Uj>::type __t = _VSTD::get<_Indx>(__uj);
    return __t;
//    return _VSTD::forward<typename tuple_element<_Indx, _Uj>::type>(_VSTD::get<_Indx>(__uj));
}

template <class _Ti, class _Uj>
inline _LIBCPP_INLINE_VISIBILITY
typename enable_if
<
    !is_bind_expression<_Ti>::value &&
    is_placeholder<_Ti>::value == 0 &&
    !__is_reference_wrapper<_Ti>::value,
    _Ti&
>::type
__mu(_Ti& __ti, _Uj& __uj)
{
    return __ti;
}

template <class _Ti, bool IsBindEx, bool IsPh, class _TupleUj>
struct ____mu_return;

template <class _Ti, class ..._Uj>
struct ____mu_return<_Ti, true, false, tuple<_Uj...> >
{
    typedef typename result_of<_Ti(_Uj...)>::type type;
};

template <class _Ti, class _TupleUj>
struct ____mu_return<_Ti, false, true, _TupleUj>
{
    typedef typename tuple_element<is_placeholder<_Ti>::value - 1,
                                   _TupleUj>::type&& type;
};

template <class _Ti, class _TupleUj>
struct ____mu_return<_Ti, false, false, _TupleUj>
{
    typedef _Ti& type;
};

template <class _Ti, class _TupleUj>
struct __mu_return
    : public ____mu_return<_Ti,
                           is_bind_expression<_Ti>::value,
                           0 < is_placeholder<_Ti>::value,
                           _TupleUj>
{
};

template <class _Ti, class _TupleUj>
struct __mu_return<reference_wrapper<_Ti>, _TupleUj>
{
    typedef _Ti& type;
};

template <class _Fp, class _BoundArgs, class _TupleUj>
struct __bind_return;

template <class _Fp, class ..._BoundArgs, class _TupleUj>
struct __bind_return<_Fp, tuple<_BoundArgs...>, _TupleUj>
{
    typedef typename __ref_return
    <
        _Fp&,
        typename __mu_return
        <
            _BoundArgs,
            _TupleUj
        >::type...
    >::type type;
};

template <class _Fp, class ..._BoundArgs, class _TupleUj>
struct __bind_return<_Fp, const tuple<_BoundArgs...>, _TupleUj>
{
    typedef typename __ref_return
    <
        _Fp&,
        typename __mu_return
        <
            const _BoundArgs,
            _TupleUj
        >::type...
    >::type type;
};

template <class _Fp, class _BoundArgs, size_t ..._Indx, class _Args>
inline _LIBCPP_INLINE_VISIBILITY
typename __bind_return<_Fp, _BoundArgs, _Args>::type
__apply_functor(_Fp& __f, _BoundArgs& __bound_args, __tuple_indices<_Indx...>,
                _Args&& __args)
{
    return __invoke(__f, __mu(_VSTD::get<_Indx>(__bound_args), __args)...);
}

template<class _Fp, class ..._BoundArgs>
class __bind
{
    _Fp __f_;
    tuple<_BoundArgs...> __bound_args_;

    typedef typename __make_tuple_indices<sizeof...(_BoundArgs)>::type __indices;
public:
    template <class _Gp, class ..._BA>
      explicit __bind(_Gp&& __f, _BA&& ...__bound_args)
        : __f_(_VSTD::forward<_Gp>(__f)),
          __bound_args_(_VSTD::forward<_BA>(__bound_args)...) {}

    template <class ..._Args>
        typename __bind_return<_Fp, tuple<_BoundArgs...>, tuple<_Args&&...> >::type
        operator()(_Args&& ...__args)
        {
            // compiler bug workaround
            return __apply_functor(__f_, __bound_args_, __indices(),
                                  tuple<_Args&&...>(__args...));
        }

    template <class ..._Args>
        typename __bind_return<_Fp, tuple<_BoundArgs...>, tuple<_Args&&...> >::type
        operator()(_Args&& ...__args) const
        {
            return __apply_functor(__f_, __bound_args_, __indices(),
                                   tuple<_Args&&...>(__args...));
        }
};

template<class _Fp, class ..._BoundArgs>
struct __is_bind_expression<__bind<_Fp, _BoundArgs...> > : public true_type {};

template<class _Rp, class _Fp, class ..._BoundArgs>
class __bind_r
    : public __bind<_Fp, _BoundArgs...>
{
    typedef __bind<_Fp, _BoundArgs...> base;
public:
    typedef _Rp result_type;

    template <class _Gp, class ..._BA>
      explicit __bind_r(_Gp&& __f, _BA&& ...__bound_args)
        : base(_VSTD::forward<_Gp>(__f),
               _VSTD::forward<_BA>(__bound_args)...) {}

    template <class ..._Args>
        result_type
        operator()(_Args&& ...__args)
        {
            return base::operator()(_VSTD::forward<_Args>(__args)...);
        }

    template <class ..._Args>
        result_type
        operator()(_Args&& ...__args) const
        {
            return base::operator()(_VSTD::forward<_Args>(__args)...);
        }
};

template<class _Rp, class _Fp, class ..._BoundArgs>
struct __is_bind_expression<__bind_r<_Rp, _Fp, _BoundArgs...> > : public true_type {};

template<class _Fp, class ..._BoundArgs>
inline _LIBCPP_INLINE_VISIBILITY
__bind<typename decay<_Fp>::type, typename decay<_BoundArgs>::type...>
bind(_Fp&& __f, _BoundArgs&&... __bound_args)
{
    typedef __bind<typename decay<_Fp>::type, typename decay<_BoundArgs>::type...> type;
    return type(_VSTD::forward<_Fp>(__f), _VSTD::forward<_BoundArgs>(__bound_args)...);
}

template<class _Rp, class _Fp, class ..._BoundArgs>
inline _LIBCPP_INLINE_VISIBILITY
__bind_r<_Rp, typename decay<_Fp>::type, typename decay<_BoundArgs>::type...>
bind(_Fp&& __f, _BoundArgs&&... __bound_args)
{
    typedef __bind_r<_Rp, typename decay<_Fp>::type, typename decay<_BoundArgs>::type...> type;
    return type(_VSTD::forward<_Fp>(__f), _VSTD::forward<_BoundArgs>(__bound_args)...);
}
*/
# 1204 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/functional" 2 3
# 2201 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/functional" 3
template <>
struct __attribute__ ((__type_visibility__("default"))) hash<bool>
    : public unary_function<bool, size_t>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_t operator()(bool __v) const throw() {return static_cast<size_t>(__v);}
};

template <>
struct __attribute__ ((__type_visibility__("default"))) hash<char>
    : public unary_function<char, size_t>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_t operator()(char __v) const throw() {return static_cast<size_t>(__v);}
};

template <>
struct __attribute__ ((__type_visibility__("default"))) hash<signed char>
    : public unary_function<signed char, size_t>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_t operator()(signed char __v) const throw() {return static_cast<size_t>(__v);}
};

template <>
struct __attribute__ ((__type_visibility__("default"))) hash<unsigned char>
    : public unary_function<unsigned char, size_t>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_t operator()(unsigned char __v) const throw() {return static_cast<size_t>(__v);}
};



template <>
struct __attribute__ ((__type_visibility__("default"))) hash<char16_t>
    : public unary_function<char16_t, size_t>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_t operator()(char16_t __v) const throw() {return static_cast<size_t>(__v);}
};

template <>
struct __attribute__ ((__type_visibility__("default"))) hash<char32_t>
    : public unary_function<char32_t, size_t>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_t operator()(char32_t __v) const throw() {return static_cast<size_t>(__v);}
};



template <>
struct __attribute__ ((__type_visibility__("default"))) hash<wchar_t>
    : public unary_function<wchar_t, size_t>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_t operator()(wchar_t __v) const throw() {return static_cast<size_t>(__v);}
};

template <>
struct __attribute__ ((__type_visibility__("default"))) hash<short>
    : public unary_function<short, size_t>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_t operator()(short __v) const throw() {return static_cast<size_t>(__v);}
};

template <>
struct __attribute__ ((__type_visibility__("default"))) hash<unsigned short>
    : public unary_function<unsigned short, size_t>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_t operator()(unsigned short __v) const throw() {return static_cast<size_t>(__v);}
};

template <>
struct __attribute__ ((__type_visibility__("default"))) hash<int>
    : public unary_function<int, size_t>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_t operator()(int __v) const throw() {return static_cast<size_t>(__v);}
};

template <>
struct __attribute__ ((__type_visibility__("default"))) hash<unsigned int>
    : public unary_function<unsigned int, size_t>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_t operator()(unsigned int __v) const throw() {return static_cast<size_t>(__v);}
};

template <>
struct __attribute__ ((__type_visibility__("default"))) hash<long>
    : public unary_function<long, size_t>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_t operator()(long __v) const throw() {return static_cast<size_t>(__v);}
};

template <>
struct __attribute__ ((__type_visibility__("default"))) hash<unsigned long>
    : public unary_function<unsigned long, size_t>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_t operator()(unsigned long __v) const throw() {return static_cast<size_t>(__v);}
};

template <>
struct __attribute__ ((__type_visibility__("default"))) hash<long long>
    : public __scalar_hash<long long>
{
};

template <>
struct __attribute__ ((__type_visibility__("default"))) hash<unsigned long long>
    : public __scalar_hash<unsigned long long>
{
};

template <>
struct __attribute__ ((__type_visibility__("default"))) hash<float>
    : public __scalar_hash<float>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_t operator()(float __v) const throw()
    {
        // -0.0 and 0.0 should return same hash
       if (__v == 0)
           return 0;
        return __scalar_hash<float>::operator()(__v);
    }
};

template <>
struct __attribute__ ((__type_visibility__("default"))) hash<double>
    : public __scalar_hash<double>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_t operator()(double __v) const throw()
    {
        // -0.0 and 0.0 should return same hash
       if (__v == 0)
           return 0;
        return __scalar_hash<double>::operator()(__v);
    }
};

template <>
struct __attribute__ ((__type_visibility__("default"))) hash<long double>
    : public __scalar_hash<long double>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_t operator()(long double __v) const throw()
    {
        // -0.0 and 0.0 should return same hash
        if (__v == 0)
            return 0;
# 2379 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/functional" 3
        // Zero out padding bits
        union
        {
            long double __t;
            struct
            {
                size_t __a;
                size_t __b;
            };
        } __u;
        __u.__a = 0;
        __u.__b = 0;
        __u.__t = __v;
        return __u.__a ^ __u.__b;



    }
};
# 2415 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/functional" 3
// struct hash<T*> in <memory>

} }
# 178 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/mutex" 2 3




# 1 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/__undef_min_max" 1 3
// -*- C++ -*-
//===----------------------------------------------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is dual licensed under the MIT and the University of Illinois Open
// Source Licenses. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
# 183 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/mutex" 2 3
# 186 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/mutex" 3


namespace std {inline namespace __1 {

class __attribute__ ((__type_visibility__("default"))) recursive_mutex
{
    pthread_mutex_t __m_;

public:
     recursive_mutex();
     ~recursive_mutex();

private:
    recursive_mutex(const recursive_mutex&); // = delete;
    recursive_mutex& operator=(const recursive_mutex&); // = delete;

public:
    void lock();
    bool try_lock() throw();
    void unlock() throw();

    typedef pthread_mutex_t* native_handle_type;
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    native_handle_type native_handle() {return &__m_;}
};

class __attribute__ ((__type_visibility__("default"))) timed_mutex
{
    mutex __m_;
    condition_variable __cv_;
    bool __locked_;
public:
     timed_mutex();
     ~timed_mutex();

private:
    timed_mutex(const timed_mutex&); // = delete;
    timed_mutex& operator=(const timed_mutex&); // = delete;

public:
    void lock();
    bool try_lock() throw();
    template <class _Rep, class _Period>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        bool try_lock_for(const chrono::duration<_Rep, _Period>& __d)
            {return try_lock_until(chrono::steady_clock::now() + __d);}
    template <class _Clock, class _Duration>
        bool try_lock_until(const chrono::time_point<_Clock, _Duration>& __t);
    void unlock() throw();
};

template <class _Clock, class _Duration>
bool
timed_mutex::try_lock_until(const chrono::time_point<_Clock, _Duration>& __t)
{
    using namespace chrono;
    unique_lock<mutex> __lk(__m_);
    bool no_timeout = _Clock::now() < __t;
    while (no_timeout && __locked_)
        no_timeout = __cv_.wait_until(__lk, __t) == cv_status::no_timeout;
    if (!__locked_)
    {
        __locked_ = true;
        return true;
    }
    return false;
}

class __attribute__ ((__type_visibility__("default"))) recursive_timed_mutex
{
    mutex __m_;
    condition_variable __cv_;
    size_t __count_;
    pthread_t __id_;
public:
     recursive_timed_mutex();
     ~recursive_timed_mutex();

private:
    recursive_timed_mutex(const recursive_timed_mutex&); // = delete;
    recursive_timed_mutex& operator=(const recursive_timed_mutex&); // = delete;

public:
    void lock();
    bool try_lock() throw();
    template <class _Rep, class _Period>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        bool try_lock_for(const chrono::duration<_Rep, _Period>& __d)
            {return try_lock_until(chrono::steady_clock::now() + __d);}
    template <class _Clock, class _Duration>
        bool try_lock_until(const chrono::time_point<_Clock, _Duration>& __t);
    void unlock() throw();
};

template <class _Clock, class _Duration>
bool
recursive_timed_mutex::try_lock_until(const chrono::time_point<_Clock, _Duration>& __t)
{
    using namespace chrono;
    pthread_t __id = pthread_self();
    unique_lock<mutex> lk(__m_);
    if (pthread_equal(__id, __id_))
    {
        if (__count_ == numeric_limits<size_t>::max())
            return false;
        ++__count_;
        return true;
    }
    bool no_timeout = _Clock::now() < __t;
    while (no_timeout && __count_ != 0)
        no_timeout = __cv_.wait_until(lk, __t) == cv_status::no_timeout;
    if (__count_ == 0)
    {
        __count_ = 1;
        __id_ = __id;
        return true;
    }
    return false;
}

template <class _L0, class _L1>
int
try_lock(_L0& __l0, _L1& __l1)
{
    unique_lock<_L0> __u0(__l0, try_to_lock);
    if (__u0.owns_lock())
    {
        if (__l1.try_lock())
        {
            __u0.release();
            return -1;
        }
        else
            return 1;
    }
    return 0;
}
# 345 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/mutex" 3
template <class _L0, class _L1>
void
lock(_L0& __l0, _L1& __l1)
{
    while (true)
    {
        {
            unique_lock<_L0> __u0(__l0);
            if (__l1.try_lock())
            {
                __u0.release();
                break;
            }
        }
        sched_yield();
        {
            unique_lock<_L1> __u1(__l1);
            if (__l0.try_lock())
            {
                __u1.release();
                break;
            }
        }
        sched_yield();
    }
}
# 428 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/mutex" 3
struct __attribute__ ((__type_visibility__("default"))) once_flag;
# 438 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/mutex" 3
template<class _Callable>
__attribute__ ((__visibility__("hidden"), __always_inline__))
void call_once(once_flag&, _Callable);



struct __attribute__ ((__type_visibility__("default"))) once_flag
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))

        once_flag() throw() : __state_(0) {}

private:
    once_flag(const once_flag&); // = delete;
    once_flag& operator=(const once_flag&); // = delete;

    unsigned long __state_;






    template<class _Callable>
    friend
    void call_once(once_flag&, _Callable);

};
# 500 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/mutex" 3
template <class _Fp>
class __call_once_param
{
    _Fp __f_;
public:




    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit __call_once_param(const _Fp& __f) : __f_(__f) {}


    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void operator()()
    {
        __f_();
    }
};



template <class _Fp>
void
__call_once_proxy(void* __vp)
{
    __call_once_param<_Fp>* __p = static_cast<__call_once_param<_Fp>*>(__vp);
    (*__p)();
}

__attribute__ ((__visibility__("default"))) void __call_once(volatile unsigned long&, void*, void(*)(void*));
# 550 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/mutex" 3
template<class _Callable>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
call_once(once_flag& __flag, _Callable __func)
{
    if (__flag.__state_ != ~0ul)
    {
        __call_once_param<_Callable> __p(__func);
        __call_once(__flag.__state_, &__p, &__call_once_proxy<_Callable>);
    }
}



} }
# 19 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/__locale" 2 3


# 1 "/usr/include/locale.h" 1 3 4
/*
 * Copyright (c) 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)locale.h	8.1 (Berkeley) 6/2/93
 * $FreeBSD: /repoman/r/ncvs/src/include/locale.h,v 1.7 2002/10/09 09:19:27 tjr Exp $
 */





# 1 "/usr/include/_locale.h" 1 3 4
/*
 * Copyright (c) 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)locale.h	8.1 (Berkeley) 6/2/93
 * $FreeBSD: /repoman/r/ncvs/src/include/locale.h,v 1.7 2002/10/09 09:19:27 tjr Exp $
 */







struct lconv {
 char *decimal_point;
 char *thousands_sep;
 char *grouping;
 char *int_curr_symbol;
 char *currency_symbol;
 char *mon_decimal_point;
 char *mon_thousands_sep;
 char *mon_grouping;
 char *positive_sign;
 char *negative_sign;
 char int_frac_digits;
 char frac_digits;
 char p_cs_precedes;
 char p_sep_by_space;
 char n_cs_precedes;
 char n_sep_by_space;
 char p_sign_posn;
 char n_sign_posn;
 char int_p_cs_precedes;
 char int_n_cs_precedes;
 char int_p_sep_by_space;
 char int_n_sep_by_space;
 char int_p_sign_posn;
 char int_n_sign_posn;
};



extern "C" {
struct lconv *localeconv(void);
}
# 41 "/usr/include/locale.h" 2 3 4
# 52 "/usr/include/locale.h" 3 4
extern "C" {
char *setlocale(int, const char *);
}
# 22 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/__locale" 2 3
# 34 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/__locale" 3
# 1 "/usr/include/xlocale.h" 1 3 4
/*
 * Copyright (c) 2005 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
# 33 "/usr/include/xlocale.h" 3 4
struct _xlocale; /* forward reference */
typedef struct _xlocale * locale_t;



# 1 "/usr/include/_xlocale.h" 1 3 4
/*
 * Copyright (c) 2005 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */






extern "C" {
int ___mb_cur_max(void);
int ___mb_cur_max_l(locale_t);
}
# 38 "/usr/include/xlocale.h" 2 3 4
# 65 "/usr/include/xlocale.h" 3 4
extern "C" {
extern const locale_t _c_locale;

locale_t duplocale(locale_t);
int freelocale(locale_t);
struct lconv * localeconv_l(locale_t);
locale_t newlocale(int, const char *, locale_t);
const char * querylocale(int, locale_t);
locale_t uselocale(locale_t);
}



# 1 "/usr/include/xlocale/_ctype.h" 1 3 4
/*
 * Copyright (c) 2005 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */




/*
 * Use inline functions if we are allowed to and the compiler supports them.
 */



/* See comments in <machine/_type.h> about __darwin_ct_rune_t. */
extern "C" {
unsigned long ___runetype_l(__darwin_ct_rune_t, locale_t);
__darwin_ct_rune_t ___tolower_l(__darwin_ct_rune_t, locale_t);
__darwin_ct_rune_t ___toupper_l(__darwin_ct_rune_t, locale_t);
}

extern "C" {
int __maskrune_l(__darwin_ct_rune_t, unsigned long, locale_t);
}

inline int
__istype_l(__darwin_ct_rune_t _c, unsigned long _f, locale_t _l)
{
 return !!(isascii(_c) ? (_DefaultRuneLocale.__runetype[_c] & _f)
  : __maskrune_l(_c, _f, _l));
}

inline __darwin_ct_rune_t
__toupper_l(__darwin_ct_rune_t _c, locale_t _l)
{
 return isascii(_c) ? _DefaultRuneLocale.__mapupper[_c]
  : ___toupper_l(_c, _l);
}

inline __darwin_ct_rune_t
__tolower_l(__darwin_ct_rune_t _c, locale_t _l)
{
 return isascii(_c) ? _DefaultRuneLocale.__maplower[_c]
  : ___tolower_l(_c, _l);
}

inline int
__wcwidth_l(__darwin_ct_rune_t _c, locale_t _l)
{
 unsigned int _x;

 if (_c == 0)
  return (0);
 _x = (unsigned int)__maskrune_l(_c, 0xe0000000L|0x00040000L, _l);
 if ((_x & 0xe0000000L) != 0)
  return ((_x & 0xe0000000L) >> 30);
 return ((_x & 0x00040000L) != 0 ? 1 : -1);
}



inline int
digittoint_l(int c, locale_t l)
{
 return (__maskrune_l(c, 0x0F, l));
}

inline int
isalnum_l(int c, locale_t l)
{
 return (__istype_l(c, 0x00000100L|0x00000400L, l));
}

inline int
isalpha_l(int c, locale_t l)
{
 return (__istype_l(c, 0x00000100L, l));
}

inline int
isblank_l(int c, locale_t l)
{
 return (__istype_l(c, 0x00020000L, l));
}

inline int
iscntrl_l(int c, locale_t l)
{
 return (__istype_l(c, 0x00000200L, l));
}

inline int
isdigit_l(int c, locale_t l)
{
 return (__istype_l(c, 0x00000400L, l));
}

inline int
isgraph_l(int c, locale_t l)
{
 return (__istype_l(c, 0x00000800L, l));
}

inline int
ishexnumber_l(int c, locale_t l)
{
 return (__istype_l(c, 0x00010000L, l));
}

inline int
isideogram_l(int c, locale_t l)
{
 return (__istype_l(c, 0x00080000L, l));
}

inline int
islower_l(int c, locale_t l)
{
 return (__istype_l(c, 0x00001000L, l));
}

inline int
isnumber_l(int c, locale_t l)
{
 return (__istype_l(c, 0x00000400L, l));
}

inline int
isphonogram_l(int c, locale_t l)
{
 return (__istype_l(c, 0x00200000L, l));
}

inline int
isprint_l(int c, locale_t l)
{
 return (__istype_l(c, 0x00040000L, l));
}

inline int
ispunct_l(int c, locale_t l)
{
 return (__istype_l(c, 0x00002000L, l));
}

inline int
isrune_l(int c, locale_t l)
{
 return (__istype_l(c, 0xFFFFFFF0L, l));
}

inline int
isspace_l(int c, locale_t l)
{
 return (__istype_l(c, 0x00004000L, l));
}

inline int
isspecial_l(int c, locale_t l)
{
 return (__istype_l(c, 0x00100000L, l));
}

inline int
isupper_l(int c, locale_t l)
{
 return (__istype_l(c, 0x00008000L, l));
}

inline int
isxdigit_l(int c, locale_t l)
{
 return (__istype_l(c, 0x00010000L, l));
}

inline int
tolower_l(int c, locale_t l)
{
        return (__tolower_l(c, l));
}

inline int
toupper_l(int c, locale_t l)
{
        return (__toupper_l(c, l));
}
# 78 "/usr/include/xlocale.h" 2 3 4


# 1 "/usr/include/xlocale/__wctype.h" 1 3 4
/*
 * Copyright (c) 2005 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */







inline int
iswalnum_l(wint_t _wc, locale_t _l)
{
 return (__istype_l(_wc, 0x00000100L|0x00000400L, _l));
}

inline int
iswalpha_l(wint_t _wc, locale_t _l)
{
 return (__istype_l(_wc, 0x00000100L, _l));
}

inline int
iswcntrl_l(wint_t _wc, locale_t _l)
{
 return (__istype_l(_wc, 0x00000200L, _l));
}

inline int
iswctype_l(wint_t _wc, wctype_t _charclass, locale_t _l)
{
 return (__istype_l(_wc, _charclass, _l));
}

inline int
iswdigit_l(wint_t _wc, locale_t _l)
{
 return (__istype_l(_wc, 0x00000400L, _l));
}

inline int
iswgraph_l(wint_t _wc, locale_t _l)
{
 return (__istype_l(_wc, 0x00000800L, _l));
}

inline int
iswlower_l(wint_t _wc, locale_t _l)
{
 return (__istype_l(_wc, 0x00001000L, _l));
}

inline int
iswprint_l(wint_t _wc, locale_t _l)
{
 return (__istype_l(_wc, 0x00040000L, _l));
}

inline int
iswpunct_l(wint_t _wc, locale_t _l)
{
 return (__istype_l(_wc, 0x00002000L, _l));
}

inline int
iswspace_l(wint_t _wc, locale_t _l)
{
 return (__istype_l(_wc, 0x00004000L, _l));
}

inline int
iswupper_l(wint_t _wc, locale_t _l)
{
 return (__istype_l(_wc, 0x00008000L, _l));
}

inline int
iswxdigit_l(wint_t _wc, locale_t _l)
{
 return (__istype_l(_wc, 0x00010000L, _l));
}

inline wint_t
towlower_l(wint_t _wc, locale_t _l)
{
        return (__tolower_l(_wc, _l));
}

inline wint_t
towupper_l(wint_t _wc, locale_t _l)
{
        return (__toupper_l(_wc, _l));
}
# 135 "/usr/include/xlocale/__wctype.h" 3 4
extern "C" {
wctype_t
 wctype_l(const char *, locale_t);
}
# 81 "/usr/include/xlocale.h" 2 3 4
# 95 "/usr/include/xlocale.h" 3 4
# 1 "/usr/include/xlocale/_stdio.h" 1 3 4
/*
 * Copyright (c) 2005, 2009, 2010 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */




extern "C" {

int fprintf_l(FILE * , locale_t , const char * , ...)
        __attribute__((__format__ (__printf__, 3, 4)));
int fscanf_l(FILE * , locale_t , const char * , ...)
        __attribute__((__format__ (__scanf__, 3, 4)));
int printf_l(locale_t , const char * , ...)
        __attribute__((__format__ (__printf__, 2, 3)));
int scanf_l(locale_t , const char * , ...)
        __attribute__((__format__ (__scanf__, 2, 3)));
int sprintf_l(char * , locale_t , const char * , ...)
        __attribute__((__format__ (__printf__, 3, 4)));
int sscanf_l(const char * , locale_t , const char * , ...)
        __attribute__((__format__ (__scanf__, 3, 4)));
int vfprintf_l(FILE * , locale_t , const char * , va_list)
        __attribute__((__format__ (__printf__, 3, 0)));
int vprintf_l(locale_t , const char * , va_list)
        __attribute__((__format__ (__printf__, 2, 0)));
int vsprintf_l(char * , locale_t , const char * , va_list)
        __attribute__((__format__ (__printf__, 3, 0)));


int snprintf_l(char * , size_t, locale_t , const char * , ...)
        __attribute__((__format__ (__printf__, 4, 5)));
int vfscanf_l(FILE * , locale_t , const char * , va_list)
        __attribute__((__format__ (__scanf__, 3, 0)));
int vscanf_l(locale_t , const char * , va_list)
        __attribute__((__format__ (__scanf__, 2, 0)));
int vsnprintf_l(char * , size_t, locale_t , const char * , va_list)
        __attribute__((__format__ (__printf__, 4, 0)));
int vsscanf_l(const char * , locale_t , const char * , va_list)
        __attribute__((__format__ (__scanf__, 3, 0)));



int dprintf_l(int, locale_t , const char * , ...)
        __attribute__((__format__ (__printf__, 3, 4))) __attribute__((availability(macosx,introduced=10.7)));
int vdprintf_l(int, locale_t , const char * , va_list)
        __attribute__((__format__ (__printf__, 3, 0))) __attribute__((availability(macosx,introduced=10.7)));




int asprintf_l(char ** , locale_t , const char * , ...)
        __attribute__((__format__ (__printf__, 3, 4)));
int vasprintf_l(char ** , locale_t , const char * , va_list)
        __attribute__((__format__ (__printf__, 3, 0)));


}
# 96 "/usr/include/xlocale.h" 2 3 4


# 1 "/usr/include/xlocale/_stdlib.h" 1 3 4
/*
 * Copyright (c) 2005 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */




extern "C" {
double atof_l(const char *, locale_t);
int atoi_l(const char *, locale_t);
long atol_l(const char *, locale_t);

long long
  atoll_l(const char *, locale_t);

int mblen_l(const char *, size_t, locale_t);
size_t mbstowcs_l(wchar_t * , const char * , size_t,
     locale_t);
int mbtowc_l(wchar_t * , const char * , size_t,
     locale_t);
double strtod_l(const char *, char **, locale_t) __asm("_" "strtod_l" );
float strtof_l(const char *, char **, locale_t) __asm("_" "strtof_l" );
long strtol_l(const char *, char **, int, locale_t);
long double
  strtold_l(const char *, char **, locale_t);
long long
  strtoll_l(const char *, char **, int, locale_t);

long long
  strtoq_l(const char *, char **, int, locale_t);

unsigned long
  strtoul_l(const char *, char **, int, locale_t);
unsigned long long
  strtoull_l(const char *, char **, int, locale_t);

unsigned long long
  strtouq_l(const char *, char **, int, locale_t);

size_t wcstombs_l(char * , const wchar_t * , size_t,
     locale_t);
int wctomb_l(char *, wchar_t, locale_t);

/* Poison the following routines if -fshort-wchar is set */



}
# 99 "/usr/include/xlocale.h" 2 3 4


# 1 "/usr/include/xlocale/_string.h" 1 3 4
/*
 * Copyright (c) 2005 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */




extern "C" {
int strcoll_l(const char *, const char *, locale_t);
size_t strxfrm_l(char *, const char *, size_t, locale_t);
int strcasecmp_l(const char *, const char *, locale_t);
char *strcasestr_l(const char *, const char *, locale_t);
int strncasecmp_l(const char *, const char *, size_t, locale_t);
}
# 102 "/usr/include/xlocale.h" 2 3 4


# 1 "/usr/include/xlocale/_time.h" 1 3 4
/*
 * Copyright (c) 2005, 2009 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */




extern "C" {
size_t strftime_l(char * , size_t, const char * ,
  const struct tm * , locale_t)
  __asm("_" "strftime_l" ) __attribute__((__format__ (__strftime__, 3, 0)));
char *strptime_l(const char * , const char * ,
  struct tm * , locale_t)
  __asm("_" "strptime_l" ) __attribute__((__format__ (__strftime__, 2, 0)));
}
# 105 "/usr/include/xlocale.h" 2 3 4


# 1 "/usr/include/xlocale/_wchar.h" 1 3 4
/*
 * Copyright (c) 2005 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */




/* Initially added in Issue 4 */
extern "C" {
wint_t btowc_l(int, locale_t);
wint_t fgetwc_l(FILE *, locale_t);
wchar_t *fgetws_l(wchar_t * , int, FILE * , locale_t);
wint_t fputwc_l(wchar_t, FILE *, locale_t);
int fputws_l(const wchar_t * , FILE * , locale_t);
int fwprintf_l(FILE * , locale_t, const wchar_t * , ...);
int fwscanf_l(FILE * , locale_t, const wchar_t * , ...);
wint_t getwc_l(FILE *, locale_t);
wint_t getwchar_l(locale_t);
size_t mbrlen_l(const char * , size_t, mbstate_t * ,
     locale_t);
size_t mbrtowc_l(wchar_t * , const char * , size_t,
     mbstate_t * , locale_t);
int mbsinit_l(const mbstate_t *, locale_t);
size_t mbsrtowcs_l(wchar_t * , const char ** , size_t,
     mbstate_t * , locale_t);
wint_t putwc_l(wchar_t, FILE *, locale_t);
wint_t putwchar_l(wchar_t, locale_t);
int swprintf_l(wchar_t * , size_t n, locale_t,
  const wchar_t * , ...);
int swscanf_l(const wchar_t * , locale_t,
  const wchar_t * , ...);
wint_t ungetwc_l(wint_t, FILE *, locale_t);
int vfwprintf_l(FILE * , locale_t, const wchar_t * ,
  __darwin_va_list);
int vswprintf_l(wchar_t * , size_t n, locale_t,
  const wchar_t * , __darwin_va_list);
int vwprintf_l(locale_t, const wchar_t * , __darwin_va_list);
size_t wcrtomb_l(char * , wchar_t, mbstate_t * ,
     locale_t);
int wcscoll_l(const wchar_t *, const wchar_t *, locale_t);
size_t wcsftime_l(wchar_t * , size_t, const wchar_t * ,
  const struct tm * , locale_t)
  __asm("_" "wcsftime_l" );
size_t wcsrtombs_l(char * , const wchar_t ** , size_t,
     mbstate_t * , locale_t);
double wcstod_l(const wchar_t * , wchar_t ** , locale_t);
long wcstol_l(const wchar_t * , wchar_t ** , int,
     locale_t);
unsigned long
 wcstoul_l(const wchar_t * , wchar_t ** , int,
     locale_t);
int wcswidth_l(const wchar_t *, size_t, locale_t);
size_t wcsxfrm_l(wchar_t * , const wchar_t * , size_t,
     locale_t);
int wctob_l(wint_t, locale_t);
int wcwidth_l(wchar_t, locale_t);
int wprintf_l(locale_t, const wchar_t * , ...);
int wscanf_l(locale_t, const wchar_t * , ...);
}



/* Additional functionality provided by:
 * POSIX.1-2001
 */


extern "C" {
int vfwscanf_l(FILE * , locale_t, const wchar_t * ,
  __darwin_va_list);
int vswscanf_l(const wchar_t * , locale_t,
  const wchar_t * , __darwin_va_list);
int vwscanf_l(locale_t, const wchar_t * , __darwin_va_list);
float wcstof_l(const wchar_t * , wchar_t ** , locale_t);
long double
 wcstold_l(const wchar_t * , wchar_t ** , locale_t);

long long
 wcstoll_l(const wchar_t * , wchar_t ** , int,
     locale_t);
unsigned long long
 wcstoull_l(const wchar_t * , wchar_t ** , int,
     locale_t);

}




/* Additional functionality provided by:
 * POSIX.1-2008
 */


extern "C" {
size_t mbsnrtowcs_l(wchar_t * , const char ** , size_t,
     size_t, mbstate_t * , locale_t);
int wcscasecmp_l(const wchar_t *, const wchar_t *, locale_t) __attribute__((availability(macosx,introduced=10.7)));
int wcsncasecmp_l(const wchar_t *, const wchar_t *, size_t n, locale_t) __attribute__((availability(macosx,introduced=10.7)));
size_t wcsnrtombs_l(char * , const wchar_t ** , size_t,
     size_t, mbstate_t * , locale_t);
}




/* Darwin extensions */


extern "C" {
wchar_t *fgetwln_l(FILE * , size_t *, locale_t) __attribute__((availability(macosx,introduced=10.7)));
}




/* Poison the following routines if -fshort-wchar is set */
# 108 "/usr/include/xlocale.h" 2 3 4


# 1 "/usr/include/xlocale/_wctype.h" 1 3 4
/*
 * Copyright (c) 2005 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */







inline int
iswblank_l(wint_t _wc, locale_t _l)
{
 return (__istype_l(_wc, 0x00020000L, _l));
}

inline int
iswhexnumber_l(wint_t _wc, locale_t _l)
{
 return (__istype_l(_wc, 0x00010000L, _l));
}

inline int
iswideogram_l(wint_t _wc, locale_t _l)
{
 return (__istype_l(_wc, 0x00080000L, _l));
}

inline int
iswnumber_l(wint_t _wc, locale_t _l)
{
 return (__istype_l(_wc, 0x00000400L, _l));
}

inline int
iswphonogram_l(wint_t _wc, locale_t _l)
{
 return (__istype_l(_wc, 0x00200000L, _l));
}

inline int
iswrune_l(wint_t _wc, locale_t _l)
{
 return (__istype_l(_wc, 0xFFFFFFF0L, _l));
}

inline int
iswspecial_l(wint_t _wc, locale_t _l)
{
 return (__istype_l(_wc, 0x00100000L, _l));
}
# 86 "/usr/include/xlocale/_wctype.h" 3 4
extern "C" {
wint_t nextwctype_l(wint_t, wctype_t, locale_t);
wint_t towctrans_l(wint_t, wctrans_t, locale_t);
wctrans_t
 wctrans_l(const char *, locale_t);
}
# 111 "/usr/include/xlocale.h" 2 3 4
# 35 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/__locale" 2 3
# 39 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/__locale" 3


namespace std {inline namespace __1 {

class __attribute__ ((__type_visibility__("default"))) locale;

template <class _Facet>
__attribute__ ((__visibility__("hidden"), __always_inline__))
bool
has_facet(const locale&) throw();

template <class _Facet>
__attribute__ ((__visibility__("hidden"), __always_inline__))
const _Facet&
use_facet(const locale&);

class __attribute__ ((__type_visibility__("default"))) locale
{
public:
    // types:
    class __attribute__ ((__type_visibility__("default"))) facet;
    class __attribute__ ((__type_visibility__("default"))) id;

    typedef int category;
    static const category // values assigned here are for exposition only
        none = 0,
        collate = (1 << 0),
        ctype = (1 << 1),
        monetary = (1 << 3),
        numeric = (1 << 4),
        time = (1 << 5),
        messages = (1 << 2),
        all = collate | ctype | monetary | numeric | time | messages;

    // construct/copy/destroy:
    locale() throw();
    locale(const locale&) throw();
    explicit locale(const char*);
    explicit locale(const string&);
    locale(const locale&, const char*, category);
    locale(const locale&, const string&, category);
    template <class _Facet>
        __attribute__ ((__visibility__("hidden"), __always_inline__)) locale(const locale&, _Facet*);
    locale(const locale&, const locale&, category);

    ~locale();

    const locale& operator=(const locale&) throw();

    template <class _Facet> locale combine(const locale&) const;

    // locale operations:
    string name() const;
    bool operator==(const locale&) const;
    bool operator!=(const locale& __y) const {return !(*this == __y);}
    template <class _CharT, class _Traits, class _Allocator>
      bool operator()(const basic_string<_CharT, _Traits, _Allocator>&,
                      const basic_string<_CharT, _Traits, _Allocator>&) const;

    // global locale objects:
    static locale global(const locale&);
    static const locale& classic();

private:
    class __imp;
    __imp* __locale_;

    void __install_ctor(const locale&, facet*, long);
    static locale& __global();
    bool has_facet(id&) const;
    const facet* use_facet(id&) const;

    template <class _Facet> friend bool has_facet(const locale&) throw();
    template <class _Facet> friend const _Facet& use_facet(const locale&);
};

class __attribute__ ((__type_visibility__("default"))) locale::facet
    : public __shared_count
{
protected:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit facet(size_t __refs = 0)
        : __shared_count(static_cast<long>(__refs)-1) {}

    virtual ~facet();

//    facet(const facet&) = delete;     // effectively done in __shared_count
//    void operator=(const facet&) = delete;
private:
    virtual void __on_zero_shared() throw();
};

class __attribute__ ((__type_visibility__("default"))) locale::id
{
    once_flag __flag_;
    int32_t __id_;

    static int32_t __next_id;
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) id() :__id_(0) {}
private:
    void __init();
    void operator=(const id&); // = delete;
    id(const id&); // = delete;
public: // only needed for tests
    long __get();

    friend class locale;
    friend class locale::__imp;
};

template <class _Facet>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
locale::locale(const locale& __other, _Facet* __f)
{
    __install_ctor(__other, __f, __f ? __f->id.__get() : 0);
}

template <class _Facet>
locale
locale::combine(const locale& __other) const
{

    if (!std::__1::has_facet<_Facet>(__other))
        throw runtime_error("locale::combine: locale missing facet");

    return locale(*this, &const_cast<_Facet&>(std::__1::use_facet<_Facet>(__other)));
}

template <class _Facet>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
has_facet(const locale& __l) throw()
{
    return __l.has_facet(_Facet::id);
}

template <class _Facet>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
const _Facet&
use_facet(const locale& __l)
{
    return static_cast<const _Facet&>(*__l.use_facet(_Facet::id));
}

// template <class _CharT> class collate;

template <class _CharT>
class __attribute__ ((__type_visibility__("default"))) collate
    : public locale::facet
{
public:
    typedef _CharT char_type;
    typedef basic_string<char_type> string_type;

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit collate(size_t __refs = 0)
        : locale::facet(__refs) {}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    int compare(const char_type* __lo1, const char_type* __hi1,
                const char_type* __lo2, const char_type* __hi2) const
    {
        return do_compare(__lo1, __hi1, __lo2, __hi2);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    string_type transform(const char_type* __lo, const char_type* __hi) const
    {
        return do_transform(__lo, __hi);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    long hash(const char_type* __lo, const char_type* __hi) const
    {
        return do_hash(__lo, __hi);
    }

    static locale::id id;

protected:
    ~collate();
    virtual int do_compare(const char_type* __lo1, const char_type* __hi1,
                           const char_type* __lo2, const char_type* __hi2) const;
    virtual string_type do_transform(const char_type* __lo, const char_type* __hi) const
        {return string_type(__lo, __hi);}
    virtual long do_hash(const char_type* __lo, const char_type* __hi) const;
};

template <class _CharT> locale::id collate<_CharT>::id;

template <class _CharT>
collate<_CharT>::~collate()
{
}

template <class _CharT>
int
collate<_CharT>::do_compare(const char_type* __lo1, const char_type* __hi1,
                            const char_type* __lo2, const char_type* __hi2) const
{
    for (; __lo2 != __hi2; ++__lo1, ++__lo2)
    {
        if (__lo1 == __hi1 || *__lo1 < *__lo2)
            return -1;
        if (*__lo2 < *__lo1)
            return 1;
    }
    return __lo1 != __hi1;
}

template <class _CharT>
long
collate<_CharT>::do_hash(const char_type* __lo, const char_type* __hi) const
{
    size_t __h = 0;
    const size_t __sr = 8 * sizeof(size_t) - 8;
    const size_t __mask = size_t(0xF) << (__sr + 4);
    for(const char_type* __p = __lo; __p != __hi; ++__p)
    {
        __h = (__h << 4) + static_cast<size_t>(*__p);
        size_t __g = __h & __mask;
        __h ^= __g | (__g >> __sr);
    }
    return static_cast<long>(__h);
}

extern template class __attribute__ ((__type_visibility__("default"))) collate<char>;
extern template class __attribute__ ((__type_visibility__("default"))) collate<wchar_t>;

// template <class CharT> class collate_byname;

template <class _CharT> class __attribute__ ((__type_visibility__("default"))) collate_byname;

template <>
class __attribute__ ((__type_visibility__("default"))) collate_byname<char>
    : public collate<char>
{
    locale_t __l;
public:
    typedef char char_type;
    typedef basic_string<char_type> string_type;

    explicit collate_byname(const char* __n, size_t __refs = 0);
    explicit collate_byname(const string& __n, size_t __refs = 0);

protected:
    ~collate_byname();
    virtual int do_compare(const char_type* __lo1, const char_type* __hi1,
                           const char_type* __lo2, const char_type* __hi2) const;
    virtual string_type do_transform(const char_type* __lo, const char_type* __hi) const;
};

template <>
class __attribute__ ((__type_visibility__("default"))) collate_byname<wchar_t>
    : public collate<wchar_t>
{
    locale_t __l;
public:
    typedef wchar_t char_type;
    typedef basic_string<char_type> string_type;

    explicit collate_byname(const char* __n, size_t __refs = 0);
    explicit collate_byname(const string& __n, size_t __refs = 0);

protected:
    ~collate_byname();

    virtual int do_compare(const char_type* __lo1, const char_type* __hi1,
                           const char_type* __lo2, const char_type* __hi2) const;
    virtual string_type do_transform(const char_type* __lo, const char_type* __hi) const;
};

template <class _CharT, class _Traits, class _Allocator>
bool
locale::operator()(const basic_string<_CharT, _Traits, _Allocator>& __x,
                   const basic_string<_CharT, _Traits, _Allocator>& __y) const
{
    return std::__1::use_facet<std::__1::collate<_CharT> >(*this).compare(
                                       __x.data(), __x.data() + __x.size(),
                                       __y.data(), __y.data() + __y.size()) < 0;
}

// template <class charT> class ctype

class __attribute__ ((__type_visibility__("default"))) ctype_base
{
public:
# 353 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/__locale" 3
    typedef __uint32_t mask;







    static const mask space = 0x00004000L;
    static const mask print = 0x00040000L;
    static const mask cntrl = 0x00000200L;
    static const mask upper = 0x00008000L;
    static const mask lower = 0x00001000L;
    static const mask alpha = 0x00000100L;
    static const mask digit = 0x00000400L;
    static const mask punct = 0x00002000L;
    static const mask xdigit = 0x00010000L;



    static const mask blank = 0x00020000L;
# 400 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/__locale" 3
    static const mask alnum = alpha | digit;
    static const mask graph = alnum | punct;

    __attribute__ ((__visibility__("hidden"), __always_inline__)) ctype_base() {}
};

template <class _CharT> class __attribute__ ((__type_visibility__("default"))) ctype;

template <>
class __attribute__ ((__type_visibility__("default"))) ctype<wchar_t>
    : public locale::facet,
      public ctype_base
{
public:
    typedef wchar_t char_type;

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit ctype(size_t __refs = 0)
        : locale::facet(__refs) {}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool is(mask __m, char_type __c) const
    {
        return do_is(__m, __c);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const char_type* is(const char_type* __low, const char_type* __high, mask* __vec) const
    {
        return do_is(__low, __high, __vec);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const char_type* scan_is(mask __m, const char_type* __low, const char_type* __high) const
    {
        return do_scan_is(__m, __low, __high);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const char_type* scan_not(mask __m, const char_type* __low, const char_type* __high) const
    {
        return do_scan_not(__m, __low, __high);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    char_type toupper(char_type __c) const
    {
        return do_toupper(__c);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const char_type* toupper(char_type* __low, const char_type* __high) const
    {
        return do_toupper(__low, __high);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    char_type tolower(char_type __c) const
    {
        return do_tolower(__c);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const char_type* tolower(char_type* __low, const char_type* __high) const
    {
        return do_tolower(__low, __high);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    char_type widen(char __c) const
    {
        return do_widen(__c);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const char* widen(const char* __low, const char* __high, char_type* __to) const
    {
        return do_widen(__low, __high, __to);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    char narrow(char_type __c, char __dfault) const
    {
        return do_narrow(__c, __dfault);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const char_type* narrow(const char_type* __low, const char_type* __high, char __dfault, char* __to) const
    {
        return do_narrow(__low, __high, __dfault, __to);
    }

    static locale::id id;

protected:
    ~ctype();
    virtual bool do_is(mask __m, char_type __c) const;
    virtual const char_type* do_is(const char_type* __low, const char_type* __high, mask* __vec) const;
    virtual const char_type* do_scan_is(mask __m, const char_type* __low, const char_type* __high) const;
    virtual const char_type* do_scan_not(mask __m, const char_type* __low, const char_type* __high) const;
    virtual char_type do_toupper(char_type) const;
    virtual const char_type* do_toupper(char_type* __low, const char_type* __high) const;
    virtual char_type do_tolower(char_type) const;
    virtual const char_type* do_tolower(char_type* __low, const char_type* __high) const;
    virtual char_type do_widen(char) const;
    virtual const char* do_widen(const char* __low, const char* __high, char_type* __dest) const;
    virtual char do_narrow(char_type, char __dfault) const;
    virtual const char_type* do_narrow(const char_type* __low, const char_type* __high, char __dfault, char* __dest) const;
};

template <>
class __attribute__ ((__type_visibility__("default"))) ctype<char>
    : public locale::facet, public ctype_base
{
    const mask* __tab_;
    bool __del_;
public:
    typedef char char_type;

    explicit ctype(const mask* __tab = 0, bool __del = false, size_t __refs = 0);

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool is(mask __m, char_type __c) const
    {
        return isascii(__c) ? (__tab_[static_cast<int>(__c)] & __m) !=0 : false;
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const char_type* is(const char_type* __low, const char_type* __high, mask* __vec) const
    {
        for (; __low != __high; ++__low, ++__vec)
            *__vec = isascii(*__low) ? __tab_[static_cast<int>(*__low)] : 0;
        return __low;
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const char_type* scan_is (mask __m, const char_type* __low, const char_type* __high) const
    {
        for (; __low != __high; ++__low)
            if (isascii(*__low) && (__tab_[static_cast<int>(*__low)] & __m))
                break;
        return __low;
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const char_type* scan_not(mask __m, const char_type* __low, const char_type* __high) const
    {
        for (; __low != __high; ++__low)
            if (!(isascii(*__low) && (__tab_[static_cast<int>(*__low)] & __m)))
                break;
        return __low;
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    char_type toupper(char_type __c) const
    {
        return do_toupper(__c);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const char_type* toupper(char_type* __low, const char_type* __high) const
    {
        return do_toupper(__low, __high);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    char_type tolower(char_type __c) const
    {
        return do_tolower(__c);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const char_type* tolower(char_type* __low, const char_type* __high) const
    {
        return do_tolower(__low, __high);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    char_type widen(char __c) const
    {
        return do_widen(__c);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const char* widen(const char* __low, const char* __high, char_type* __to) const
    {
        return do_widen(__low, __high, __to);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    char narrow(char_type __c, char __dfault) const
    {
        return do_narrow(__c, __dfault);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const char* narrow(const char_type* __low, const char_type* __high, char __dfault, char* __to) const
    {
        return do_narrow(__low, __high, __dfault, __to);
    }

    static locale::id id;


    static const size_t table_size = (1 <<8 );



    __attribute__ ((__visibility__("hidden"), __always_inline__)) const mask* table() const throw() {return __tab_;}
    static const mask* classic_table() throw();
# 619 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/__locale" 3
protected:
    ~ctype();
    virtual char_type do_toupper(char_type __c) const;
    virtual const char_type* do_toupper(char_type* __low, const char_type* __high) const;
    virtual char_type do_tolower(char_type __c) const;
    virtual const char_type* do_tolower(char_type* __low, const char_type* __high) const;
    virtual char_type do_widen(char __c) const;
    virtual const char* do_widen(const char* __low, const char* __high, char_type* __to) const;
    virtual char do_narrow(char_type __c, char __dfault) const;
    virtual const char* do_narrow(const char_type* __low, const char_type* __high, char __dfault, char* __to) const;
};

// template <class CharT> class ctype_byname;

template <class _CharT> class __attribute__ ((__type_visibility__("default"))) ctype_byname;

template <>
class __attribute__ ((__type_visibility__("default"))) ctype_byname<char>
    : public ctype<char>
{
    locale_t __l;

public:
    explicit ctype_byname(const char*, size_t = 0);
    explicit ctype_byname(const string&, size_t = 0);

protected:
    ~ctype_byname();
    virtual char_type do_toupper(char_type) const;
    virtual const char_type* do_toupper(char_type* __low, const char_type* __high) const;
    virtual char_type do_tolower(char_type) const;
    virtual const char_type* do_tolower(char_type* __low, const char_type* __high) const;
};

template <>
class __attribute__ ((__type_visibility__("default"))) ctype_byname<wchar_t>
    : public ctype<wchar_t>
{
    locale_t __l;

public:
    explicit ctype_byname(const char*, size_t = 0);
    explicit ctype_byname(const string&, size_t = 0);

protected:
    ~ctype_byname();
    virtual bool do_is(mask __m, char_type __c) const;
    virtual const char_type* do_is(const char_type* __low, const char_type* __high, mask* __vec) const;
    virtual const char_type* do_scan_is(mask __m, const char_type* __low, const char_type* __high) const;
    virtual const char_type* do_scan_not(mask __m, const char_type* __low, const char_type* __high) const;
    virtual char_type do_toupper(char_type) const;
    virtual const char_type* do_toupper(char_type* __low, const char_type* __high) const;
    virtual char_type do_tolower(char_type) const;
    virtual const char_type* do_tolower(char_type* __low, const char_type* __high) const;
    virtual char_type do_widen(char) const;
    virtual const char* do_widen(const char* __low, const char* __high, char_type* __dest) const;
    virtual char do_narrow(char_type, char __dfault) const;
    virtual const char_type* do_narrow(const char_type* __low, const char_type* __high, char __dfault, char* __dest) const;
};

template <class _CharT>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
isspace(_CharT __c, const locale& __loc)
{
    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::space, __c);
}

template <class _CharT>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
isprint(_CharT __c, const locale& __loc)
{
    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::print, __c);
}

template <class _CharT>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
iscntrl(_CharT __c, const locale& __loc)
{
    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::cntrl, __c);
}

template <class _CharT>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
isupper(_CharT __c, const locale& __loc)
{
    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::upper, __c);
}

template <class _CharT>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
islower(_CharT __c, const locale& __loc)
{
    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::lower, __c);
}

template <class _CharT>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
isalpha(_CharT __c, const locale& __loc)
{
    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::alpha, __c);
}

template <class _CharT>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
isdigit(_CharT __c, const locale& __loc)
{
    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::digit, __c);
}

template <class _CharT>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
ispunct(_CharT __c, const locale& __loc)
{
    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::punct, __c);
}

template <class _CharT>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
isxdigit(_CharT __c, const locale& __loc)
{
    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::xdigit, __c);
}

template <class _CharT>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
isalnum(_CharT __c, const locale& __loc)
{
    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::alnum, __c);
}

template <class _CharT>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
isgraph(_CharT __c, const locale& __loc)
{
    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::graph, __c);
}

template <class _CharT>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_CharT
toupper(_CharT __c, const locale& __loc)
{
    return use_facet<ctype<_CharT> >(__loc).toupper(__c);
}

template <class _CharT>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_CharT
tolower(_CharT __c, const locale& __loc)
{
    return use_facet<ctype<_CharT> >(__loc).tolower(__c);
}

// codecvt_base

class __attribute__ ((__type_visibility__("default"))) codecvt_base
{
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) codecvt_base() {}
    enum result {ok, partial, error, noconv};
};

// template <class internT, class externT, class stateT> class codecvt;

template <class _InternT, class _ExternT, class _StateT> class __attribute__ ((__type_visibility__("default"))) codecvt;

// template <> class codecvt<char, char, mbstate_t>

template <>
class __attribute__ ((__type_visibility__("default"))) codecvt<char, char, mbstate_t>
    : public locale::facet,
      public codecvt_base
{
public:
    typedef char intern_type;
    typedef char extern_type;
    typedef mbstate_t state_type;

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit codecvt(size_t __refs = 0)
        : locale::facet(__refs) {}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    result out(state_type& __st,
               const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,
               extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const
    {
        return do_out(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    result unshift(state_type& __st,
                   extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const
    {
        return do_unshift(__st, __to, __to_end, __to_nxt);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    result in(state_type& __st,
              const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,
              intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const
    {
        return do_in(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    int encoding() const throw()
    {
        return do_encoding();
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool always_noconv() const throw()
    {
        return do_always_noconv();
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    int length(state_type& __st, const extern_type* __frm, const extern_type* __end, size_t __mx) const
    {
        return do_length(__st, __frm, __end, __mx);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    int max_length() const throw()
    {
        return do_max_length();
    }

    static locale::id id;

protected:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit codecvt(const char*, size_t __refs = 0)
        : locale::facet(__refs) {}

    ~codecvt();

    virtual result do_out(state_type& __st,
                          const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,
                          extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;
    virtual result do_in(state_type& __st,
                         const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,
                         intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const;
    virtual result do_unshift(state_type& __st,
                              extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;
    virtual int do_encoding() const throw();
    virtual bool do_always_noconv() const throw();
    virtual int do_length(state_type& __st, const extern_type* __frm, const extern_type* __end, size_t __mx) const;
    virtual int do_max_length() const throw();
};

// template <> class codecvt<wchar_t, char, mbstate_t>

template <>
class __attribute__ ((__type_visibility__("default"))) codecvt<wchar_t, char, mbstate_t>
    : public locale::facet,
      public codecvt_base
{
    locale_t __l;
public:
    typedef wchar_t intern_type;
    typedef char extern_type;
    typedef mbstate_t state_type;

    explicit codecvt(size_t __refs = 0);

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    result out(state_type& __st,
               const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,
               extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const
    {
        return do_out(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    result unshift(state_type& __st,
                   extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const
    {
        return do_unshift(__st, __to, __to_end, __to_nxt);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    result in(state_type& __st,
              const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,
              intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const
    {
        return do_in(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    int encoding() const throw()
    {
        return do_encoding();
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool always_noconv() const throw()
    {
        return do_always_noconv();
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    int length(state_type& __st, const extern_type* __frm, const extern_type* __end, size_t __mx) const
    {
        return do_length(__st, __frm, __end, __mx);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    int max_length() const throw()
    {
        return do_max_length();
    }

    static locale::id id;

protected:
    explicit codecvt(const char*, size_t __refs = 0);

    ~codecvt();

    virtual result do_out(state_type& __st,
                          const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,
                          extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;
    virtual result do_in(state_type& __st,
                         const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,
                         intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const;
    virtual result do_unshift(state_type& __st,
                              extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;
    virtual int do_encoding() const throw();
    virtual bool do_always_noconv() const throw();
    virtual int do_length(state_type&, const extern_type* __frm, const extern_type* __end, size_t __mx) const;
    virtual int do_max_length() const throw();
};

// template <> class codecvt<char16_t, char, mbstate_t>

template <>
class __attribute__ ((__type_visibility__("default"))) codecvt<char16_t, char, mbstate_t>
    : public locale::facet,
      public codecvt_base
{
public:
    typedef char16_t intern_type;
    typedef char extern_type;
    typedef mbstate_t state_type;

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit codecvt(size_t __refs = 0)
        : locale::facet(__refs) {}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    result out(state_type& __st,
               const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,
               extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const
    {
        return do_out(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    result unshift(state_type& __st,
                   extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const
    {
        return do_unshift(__st, __to, __to_end, __to_nxt);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    result in(state_type& __st,
              const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,
              intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const
    {
        return do_in(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    int encoding() const throw()
    {
        return do_encoding();
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool always_noconv() const throw()
    {
        return do_always_noconv();
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    int length(state_type& __st, const extern_type* __frm, const extern_type* __end, size_t __mx) const
    {
        return do_length(__st, __frm, __end, __mx);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    int max_length() const throw()
    {
        return do_max_length();
    }

    static locale::id id;

protected:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit codecvt(const char*, size_t __refs = 0)
        : locale::facet(__refs) {}

    ~codecvt();

    virtual result do_out(state_type& __st,
                          const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,
                          extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;
    virtual result do_in(state_type& __st,
                         const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,
                         intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const;
    virtual result do_unshift(state_type& __st,
                              extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;
    virtual int do_encoding() const throw();
    virtual bool do_always_noconv() const throw();
    virtual int do_length(state_type&, const extern_type* __frm, const extern_type* __end, size_t __mx) const;
    virtual int do_max_length() const throw();
};

// template <> class codecvt<char32_t, char, mbstate_t>

template <>
class __attribute__ ((__type_visibility__("default"))) codecvt<char32_t, char, mbstate_t>
    : public locale::facet,
      public codecvt_base
{
public:
    typedef char32_t intern_type;
    typedef char extern_type;
    typedef mbstate_t state_type;

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit codecvt(size_t __refs = 0)
        : locale::facet(__refs) {}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    result out(state_type& __st,
               const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,
               extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const
    {
        return do_out(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    result unshift(state_type& __st,
                   extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const
    {
        return do_unshift(__st, __to, __to_end, __to_nxt);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    result in(state_type& __st,
              const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,
              intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const
    {
        return do_in(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    int encoding() const throw()
    {
        return do_encoding();
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool always_noconv() const throw()
    {
        return do_always_noconv();
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    int length(state_type& __st, const extern_type* __frm, const extern_type* __end, size_t __mx) const
    {
        return do_length(__st, __frm, __end, __mx);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    int max_length() const throw()
    {
        return do_max_length();
    }

    static locale::id id;

protected:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit codecvt(const char*, size_t __refs = 0)
        : locale::facet(__refs) {}

    ~codecvt();

    virtual result do_out(state_type& __st,
                          const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,
                          extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;
    virtual result do_in(state_type& __st,
                         const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,
                         intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const;
    virtual result do_unshift(state_type& __st,
                              extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;
    virtual int do_encoding() const throw();
    virtual bool do_always_noconv() const throw();
    virtual int do_length(state_type&, const extern_type* __frm, const extern_type* __end, size_t __mx) const;
    virtual int do_max_length() const throw();
};

// template <class _InternT, class _ExternT, class _StateT> class codecvt_byname

template <class _InternT, class _ExternT, class _StateT>
class __attribute__ ((__type_visibility__("default"))) codecvt_byname
    : public codecvt<_InternT, _ExternT, _StateT>
{
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit codecvt_byname(const char* __nm, size_t __refs = 0)
        : codecvt<_InternT, _ExternT, _StateT>(__nm, __refs) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit codecvt_byname(const string& __nm, size_t __refs = 0)
        : codecvt<_InternT, _ExternT, _StateT>(__nm.c_str(), __refs) {}
protected:
    ~codecvt_byname();
};

template <class _InternT, class _ExternT, class _StateT>
codecvt_byname<_InternT, _ExternT, _StateT>::~codecvt_byname()
{
}

extern template class __attribute__ ((__type_visibility__("default"))) codecvt_byname<char, char, mbstate_t>;
extern template class __attribute__ ((__type_visibility__("default"))) codecvt_byname<wchar_t, char, mbstate_t>;
extern template class __attribute__ ((__type_visibility__("default"))) codecvt_byname<char16_t, char, mbstate_t>;
extern template class __attribute__ ((__type_visibility__("default"))) codecvt_byname<char32_t, char, mbstate_t>;

__attribute__ ((__visibility__("default"))) void __throw_runtime_error(const char*);

template <size_t _Np>
struct __narrow_to_utf8
{
    template <class _OutputIterator, class _CharT>
    _OutputIterator
    operator()(_OutputIterator __s, const _CharT* __wb, const _CharT* __we) const;
};

template <>
struct __narrow_to_utf8<8>
{
    template <class _OutputIterator, class _CharT>
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    _OutputIterator
    operator()(_OutputIterator __s, const _CharT* __wb, const _CharT* __we) const
    {
        for (; __wb < __we; ++__wb, ++__s)
            *__s = *__wb;
        return __s;
    }
};

template <>
struct __narrow_to_utf8<16>
    : public codecvt<char16_t, char, mbstate_t>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    __narrow_to_utf8() : codecvt<char16_t, char, mbstate_t>(1) {}

    ~__narrow_to_utf8();

    template <class _OutputIterator, class _CharT>
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    _OutputIterator
    operator()(_OutputIterator __s, const _CharT* __wb, const _CharT* __we) const
    {
        result __r = ok;
        mbstate_t __mb;
        while (__wb < __we && __r != error)
        {
            const int __sz = 32;
            char __buf[__sz];
            char* __bn;
            const char16_t* __wn = (const char16_t*)__wb;
            __r = do_out(__mb, (const char16_t*)__wb, (const char16_t*)__we, __wn,
                         __buf, __buf+__sz, __bn);
            if (__r == codecvt_base::error || __wn == (const char16_t*)__wb)
                __throw_runtime_error("locale not supported");
            for (const char* __p = __buf; __p < __bn; ++__p, ++__s)
                *__s = *__p;
            __wb = (const _CharT*)__wn;
        }
        return __s;
    }
};

template <>
struct __narrow_to_utf8<32>
    : public codecvt<char32_t, char, mbstate_t>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    __narrow_to_utf8() : codecvt<char32_t, char, mbstate_t>(1) {}

    ~__narrow_to_utf8();

    template <class _OutputIterator, class _CharT>
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    _OutputIterator
    operator()(_OutputIterator __s, const _CharT* __wb, const _CharT* __we) const
    {
        result __r = ok;
        mbstate_t __mb;
        while (__wb < __we && __r != error)
        {
            const int __sz = 32;
            char __buf[__sz];
            char* __bn;
            const char32_t* __wn = (const char32_t*)__wb;
            __r = do_out(__mb, (const char32_t*)__wb, (const char32_t*)__we, __wn,
                         __buf, __buf+__sz, __bn);
            if (__r == codecvt_base::error || __wn == (const char32_t*)__wb)
                __throw_runtime_error("locale not supported");
            for (const char* __p = __buf; __p < __bn; ++__p, ++__s)
                *__s = *__p;
            __wb = (const _CharT*)__wn;
        }
        return __s;
    }
};

template <size_t _Np>
struct __widen_from_utf8
{
    template <class _OutputIterator>
    _OutputIterator
    operator()(_OutputIterator __s, const char* __nb, const char* __ne) const;
};

template <>
struct __widen_from_utf8<8>
{
    template <class _OutputIterator>
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    _OutputIterator
    operator()(_OutputIterator __s, const char* __nb, const char* __ne) const
    {
        for (; __nb < __ne; ++__nb, ++__s)
            *__s = *__nb;
        return __s;
    }
};

template <>
struct __widen_from_utf8<16>
    : public codecvt<char16_t, char, mbstate_t>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    __widen_from_utf8() : codecvt<char16_t, char, mbstate_t>(1) {}

    ~__widen_from_utf8();

    template <class _OutputIterator>
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    _OutputIterator
    operator()(_OutputIterator __s, const char* __nb, const char* __ne) const
    {
        result __r = ok;
        mbstate_t __mb;
        while (__nb < __ne && __r != error)
        {
            const int __sz = 32;
            char16_t __buf[__sz];
            char16_t* __bn;
            const char* __nn = __nb;
            __r = do_in(__mb, __nb, __ne - __nb > __sz ? __nb+__sz : __ne, __nn,
                        __buf, __buf+__sz, __bn);
            if (__r == codecvt_base::error || __nn == __nb)
                __throw_runtime_error("locale not supported");
            for (const char16_t* __p = __buf; __p < __bn; ++__p, ++__s)
                *__s = (wchar_t)*__p;
            __nb = __nn;
        }
        return __s;
    }
};

template <>
struct __widen_from_utf8<32>
    : public codecvt<char32_t, char, mbstate_t>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    __widen_from_utf8() : codecvt<char32_t, char, mbstate_t>(1) {}

    ~__widen_from_utf8();

    template <class _OutputIterator>
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    _OutputIterator
    operator()(_OutputIterator __s, const char* __nb, const char* __ne) const
    {
        result __r = ok;
        mbstate_t __mb;
        while (__nb < __ne && __r != error)
        {
            const int __sz = 32;
            char32_t __buf[__sz];
            char32_t* __bn;
            const char* __nn = __nb;
            __r = do_in(__mb, __nb, __ne - __nb > __sz ? __nb+__sz : __ne, __nn,
                        __buf, __buf+__sz, __bn);
            if (__r == codecvt_base::error || __nn == __nb)
                __throw_runtime_error("locale not supported");
            for (const char32_t* __p = __buf; __p < __bn; ++__p, ++__s)
                *__s = (wchar_t)*__p;
            __nb = __nn;
        }
        return __s;
    }
};

// template <class charT> class numpunct

template <class _CharT> class __attribute__ ((__type_visibility__("default"))) numpunct;

template <>
class __attribute__ ((__type_visibility__("default"))) numpunct<char>
    : public locale::facet
{
public:
    typedef char char_type;
    typedef basic_string<char_type> string_type;

    explicit numpunct(size_t __refs = 0);

    __attribute__ ((__visibility__("hidden"), __always_inline__)) char_type decimal_point() const {return do_decimal_point();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) char_type thousands_sep() const {return do_thousands_sep();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) string grouping() const {return do_grouping();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) string_type truename() const {return do_truename();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) string_type falsename() const {return do_falsename();}

    static locale::id id;

protected:
    ~numpunct();
    virtual char_type do_decimal_point() const;
    virtual char_type do_thousands_sep() const;
    virtual string do_grouping() const;
    virtual string_type do_truename() const;
    virtual string_type do_falsename() const;

    char_type __decimal_point_;
    char_type __thousands_sep_;
    string __grouping_;
};

template <>
class __attribute__ ((__type_visibility__("default"))) numpunct<wchar_t>
    : public locale::facet
{
public:
    typedef wchar_t char_type;
    typedef basic_string<char_type> string_type;

    explicit numpunct(size_t __refs = 0);

    __attribute__ ((__visibility__("hidden"), __always_inline__)) char_type decimal_point() const {return do_decimal_point();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) char_type thousands_sep() const {return do_thousands_sep();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) string grouping() const {return do_grouping();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) string_type truename() const {return do_truename();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) string_type falsename() const {return do_falsename();}

    static locale::id id;

protected:
    ~numpunct();
    virtual char_type do_decimal_point() const;
    virtual char_type do_thousands_sep() const;
    virtual string do_grouping() const;
    virtual string_type do_truename() const;
    virtual string_type do_falsename() const;

    char_type __decimal_point_;
    char_type __thousands_sep_;
    string __grouping_;
};

// template <class charT> class numpunct_byname

template <class charT> class __attribute__ ((__type_visibility__("default"))) numpunct_byname;

template <>
class __attribute__ ((__type_visibility__("default"))) numpunct_byname<char>
: public numpunct<char>
{
public:
    typedef char char_type;
    typedef basic_string<char_type> string_type;

    explicit numpunct_byname(const char* __nm, size_t __refs = 0);
    explicit numpunct_byname(const string& __nm, size_t __refs = 0);

protected:
    ~numpunct_byname();

private:
    void __init(const char*);
};

template <>
class __attribute__ ((__type_visibility__("default"))) numpunct_byname<wchar_t>
: public numpunct<wchar_t>
{
public:
    typedef wchar_t char_type;
    typedef basic_string<char_type> string_type;

    explicit numpunct_byname(const char* __nm, size_t __refs = 0);
    explicit numpunct_byname(const string& __nm, size_t __refs = 0);

protected:
    ~numpunct_byname();

private:
    void __init(const char*);
};

} }
# 217 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/ios" 2 3
# 225 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/ios" 3


namespace std {inline namespace __1 {

typedef ptrdiff_t streamsize;

class __attribute__ ((__type_visibility__("default"))) ios_base
{
public:
    class __attribute__ ((__type_visibility__("default"))) failure;

    typedef unsigned int fmtflags;
    static const fmtflags boolalpha = 0x0001;
    static const fmtflags dec = 0x0002;
    static const fmtflags fixed = 0x0004;
    static const fmtflags hex = 0x0008;
    static const fmtflags internal = 0x0010;
    static const fmtflags left = 0x0020;
    static const fmtflags oct = 0x0040;
    static const fmtflags right = 0x0080;
    static const fmtflags scientific = 0x0100;
    static const fmtflags showbase = 0x0200;
    static const fmtflags showpoint = 0x0400;
    static const fmtflags showpos = 0x0800;
    static const fmtflags skipws = 0x1000;
    static const fmtflags unitbuf = 0x2000;
    static const fmtflags uppercase = 0x4000;
    static const fmtflags adjustfield = left | right | internal;
    static const fmtflags basefield = dec | oct | hex;
    static const fmtflags floatfield = scientific | fixed;

    typedef unsigned int iostate;
    typedef iostate io_state;
    static const iostate badbit = 0x1;
    static const iostate eofbit = 0x2;
    static const iostate failbit = 0x4;
    static const iostate goodbit = 0x0;

    typedef unsigned int openmode;
    typedef openmode open_mode;
    static const openmode app = 0x01;
    static const openmode ate = 0x02;
    static const openmode binary = 0x04;
    static const openmode in = 0x08;
    static const openmode out = 0x10;
    static const openmode trunc = 0x20;

    enum seekdir {beg, cur, end};
    typedef seekdir seek_dir;

    typedef std::__1::streamoff streamoff;
    typedef std::__1::streampos streampos;

    class __attribute__ ((__type_visibility__("default"))) Init;

    // 27.5.2.2 fmtflags state:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) fmtflags flags() const;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) fmtflags flags(fmtflags __fmtfl);
    __attribute__ ((__visibility__("hidden"), __always_inline__)) fmtflags setf(fmtflags __fmtfl);
    __attribute__ ((__visibility__("hidden"), __always_inline__)) fmtflags setf(fmtflags __fmtfl, fmtflags __mask);
    __attribute__ ((__visibility__("hidden"), __always_inline__)) void unsetf(fmtflags __mask);

    __attribute__ ((__visibility__("hidden"), __always_inline__)) streamsize precision() const;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) streamsize precision(streamsize __prec);
    __attribute__ ((__visibility__("hidden"), __always_inline__)) streamsize width() const;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) streamsize width(streamsize __wide);

    // 27.5.2.3 locales:
    locale imbue(const locale& __loc);
    locale getloc() const;

    // 27.5.2.5 storage:
    static int xalloc();
    long& iword(int __index);
    void*& pword(int __index);

    // destructor
    virtual ~ios_base();

    // 27.5.2.6 callbacks;
    enum event { erase_event, imbue_event, copyfmt_event };
    typedef void (*event_callback)(event, ios_base&, int __index);
    void register_callback(event_callback __fn, int __index);

private:
    ios_base(const ios_base&); // = delete;
    ios_base& operator=(const ios_base&); // = delete;

public:
    static bool sync_with_stdio(bool __sync = true);

    __attribute__ ((__visibility__("hidden"), __always_inline__)) iostate rdstate() const;
    void clear(iostate __state = goodbit);
    __attribute__ ((__visibility__("hidden"), __always_inline__)) void setstate(iostate __state);

    __attribute__ ((__visibility__("hidden"), __always_inline__)) bool good() const;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) bool eof() const;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) bool fail() const;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) bool bad() const;

    __attribute__ ((__visibility__("hidden"), __always_inline__)) iostate exceptions() const;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) void exceptions(iostate __iostate);

    void __set_badbit_and_consider_rethrow();
    void __set_failbit_and_consider_rethrow();

protected:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    ios_base() {// purposefully does no initialization
               }

    void init(void* __sb);
    __attribute__ ((__visibility__("hidden"), __always_inline__)) void* rdbuf() const {return __rdbuf_;}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void rdbuf(void* __sb)
    {
        __rdbuf_ = __sb;
        clear();
    }

    void __call_callbacks(event);
    void copyfmt(const ios_base&);
    void move(ios_base&);
    void swap(ios_base&) throw();

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void set_rdbuf(void* __sb)
    {
        __rdbuf_ = __sb;
    }

private:
    // All data members must be scalars
    fmtflags __fmtflags_;
    streamsize __precision_;
    streamsize __width_;
    iostate __rdstate_;
    iostate __exceptions_;
    void* __rdbuf_;
    void* __loc_;
    event_callback* __fn_;
    int* __index_;
    size_t __event_size_;
    size_t __event_cap_;



    static int __xindex_;

    long* __iarray_;
    size_t __iarray_size_;
    size_t __iarray_cap_;
    void** __parray_;
    size_t __parray_size_;
    size_t __parray_cap_;
};

//enum class io_errc
struct __attribute__ ((__type_visibility__("default"))) io_errc { enum __lx
{
    stream = 1
};
__lx __v_; __attribute__ ((__visibility__("hidden"), __always_inline__)) io_errc(__lx __v) : __v_(__v) {} __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit io_errc(int __v) : __v_(static_cast<__lx>(__v)) {} __attribute__ ((__visibility__("hidden"), __always_inline__)) operator int() const {return __v_;} };

template <>
struct __attribute__ ((__type_visibility__("default"))) is_error_code_enum<io_errc> : public true_type { };


template <>
struct __attribute__ ((__type_visibility__("default"))) is_error_code_enum<io_errc::__lx> : public true_type { };


__attribute__ ((__visibility__("default")))
const error_category& iostream_category() throw();

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
error_code
make_error_code(io_errc __e) throw()
{
    return error_code(static_cast<int>(__e), iostream_category());
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
error_condition
make_error_condition(io_errc __e) throw()
{
    return error_condition(static_cast<int>(__e), iostream_category());
}

class __attribute__ ((__visibility__("default"))) ios_base::failure
    : public system_error
{
public:
    explicit failure(const string& __msg, const error_code& __ec = io_errc::stream);
    explicit failure(const char* __msg, const error_code& __ec = io_errc::stream);
    virtual ~failure() throw();
};

class __attribute__ ((__type_visibility__("default"))) ios_base::Init
{
public:
    Init();
    ~Init();
};

// fmtflags

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
ios_base::fmtflags
ios_base::flags() const
{
    return __fmtflags_;
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
ios_base::fmtflags
ios_base::flags(fmtflags __fmtfl)
{
    fmtflags __r = __fmtflags_;
    __fmtflags_ = __fmtfl;
    return __r;
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
ios_base::fmtflags
ios_base::setf(fmtflags __fmtfl)
{
    fmtflags __r = __fmtflags_;
    __fmtflags_ |= __fmtfl;
    return __r;
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
ios_base::unsetf(fmtflags __mask)
{
    __fmtflags_ &= ~__mask;
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
ios_base::fmtflags
ios_base::setf(fmtflags __fmtfl, fmtflags __mask)
{
    fmtflags __r = __fmtflags_;
    unsetf(__mask);
    __fmtflags_ |= __fmtfl & __mask;
    return __r;
}

// precision

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
streamsize
ios_base::precision() const
{
    return __precision_;
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
streamsize
ios_base::precision(streamsize __prec)
{
    streamsize __r = __precision_;
    __precision_ = __prec;
    return __r;
}

// width

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
streamsize
ios_base::width() const
{
    return __width_;
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
streamsize
ios_base::width(streamsize __wide)
{
    streamsize __r = __width_;
    __width_ = __wide;
    return __r;
}

// iostate

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
ios_base::iostate
ios_base::rdstate() const
{
    return __rdstate_;
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
ios_base::setstate(iostate __state)
{
    clear(__rdstate_ | __state);
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
ios_base::good() const
{
    return __rdstate_ == 0;
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
ios_base::eof() const
{
    return (__rdstate_ & eofbit) != 0;
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
ios_base::fail() const
{
    return (__rdstate_ & (failbit | badbit)) != 0;
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
ios_base::bad() const
{
    return (__rdstate_ & badbit) != 0;
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
ios_base::iostate
ios_base::exceptions() const
{
    return __exceptions_;
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
ios_base::exceptions(iostate __iostate)
{
    __exceptions_ = __iostate;
    clear(__rdstate_);
}

template <class _CharT, class _Traits>
class __attribute__ ((__type_visibility__("default"))) basic_ios
    : public ios_base
{
public:
    // types:
    typedef _CharT char_type;
    typedef _Traits traits_type;

    typedef typename traits_type::int_type int_type;
    typedef typename traits_type::pos_type pos_type;
    typedef typename traits_type::off_type off_type;

    __attribute__ ((__visibility__("hidden"), __always_inline__))

        operator bool() const {return !fail();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) bool operator!() const {return fail();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) iostate rdstate() const {return ios_base::rdstate();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) void clear(iostate __state = goodbit) {ios_base::clear(__state);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) void setstate(iostate __state) {ios_base::setstate(__state);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) bool good() const {return ios_base::good();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) bool eof() const {return ios_base::eof();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) bool fail() const {return ios_base::fail();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) bool bad() const {return ios_base::bad();}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) iostate exceptions() const {return ios_base::exceptions();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) void exceptions(iostate __iostate) {ios_base::exceptions(__iostate);}

    // 27.5.4.1 Constructor/destructor:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit basic_ios(basic_streambuf<char_type,traits_type>* __sb);
    virtual ~basic_ios();

    // 27.5.4.2 Members:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    basic_ostream<char_type, traits_type>* tie() const;
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    basic_ostream<char_type, traits_type>* tie(basic_ostream<char_type, traits_type>* __tiestr);

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    basic_streambuf<char_type, traits_type>* rdbuf() const;
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    basic_streambuf<char_type, traits_type>* rdbuf(basic_streambuf<char_type, traits_type>* __sb);

    basic_ios& copyfmt(const basic_ios& __rhs);

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    char_type fill() const;
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    char_type fill(char_type __ch);

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    locale imbue(const locale& __loc);

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    char narrow(char_type __c, char __dfault) const;
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    char_type widen(char __c) const;

protected:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    basic_ios() {// purposefully does no initialization
                }
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void init(basic_streambuf<char_type, traits_type>* __sb);

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void move(basic_ios& __rhs);




    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void swap(basic_ios& __rhs) throw();
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void set_rdbuf(basic_streambuf<char_type, traits_type>* __sb);
private:
    basic_ostream<char_type, traits_type>* __tie_;
     mutable int_type __fill_;
};

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_ios<_CharT, _Traits>::basic_ios(basic_streambuf<char_type,traits_type>* __sb)
{
    init(__sb);
}

template <class _CharT, class _Traits>
basic_ios<_CharT, _Traits>::~basic_ios()
{
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
basic_ios<_CharT, _Traits>::init(basic_streambuf<char_type, traits_type>* __sb)
{
    ios_base::init(__sb);
    __tie_ = 0;
    __fill_ = traits_type::eof();
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_ostream<_CharT, _Traits>*
basic_ios<_CharT, _Traits>::tie() const
{
    return __tie_;
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_ostream<_CharT, _Traits>*
basic_ios<_CharT, _Traits>::tie(basic_ostream<char_type, traits_type>* __tiestr)
{
    basic_ostream<char_type, traits_type>* __r = __tie_;
    __tie_ = __tiestr;
    return __r;
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_streambuf<_CharT, _Traits>*
basic_ios<_CharT, _Traits>::rdbuf() const
{
    return static_cast<basic_streambuf<char_type, traits_type>*>(ios_base::rdbuf());
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_streambuf<_CharT, _Traits>*
basic_ios<_CharT, _Traits>::rdbuf(basic_streambuf<char_type, traits_type>* __sb)
{
    basic_streambuf<char_type, traits_type>* __r = rdbuf();
    ios_base::rdbuf(__sb);
    return __r;
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
locale
basic_ios<_CharT, _Traits>::imbue(const locale& __loc)
{
    locale __r = getloc();
    ios_base::imbue(__loc);
    if (rdbuf())
        rdbuf()->pubimbue(__loc);
    return __r;
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
char
basic_ios<_CharT, _Traits>::narrow(char_type __c, char __dfault) const
{
    return use_facet<ctype<char_type> >(getloc()).narrow(__c, __dfault);
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_CharT
basic_ios<_CharT, _Traits>::widen(char __c) const
{
    return use_facet<ctype<char_type> >(getloc()).widen(__c);
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_CharT
basic_ios<_CharT, _Traits>::fill() const
{
    if (traits_type::eq_int_type(traits_type::eof(), __fill_))
        __fill_ = widen(' ');
    return __fill_;
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_CharT
basic_ios<_CharT, _Traits>::fill(char_type __ch)
{
    char_type __r = __fill_;
    __fill_ = __ch;
    return __r;
}

template <class _CharT, class _Traits>
basic_ios<_CharT, _Traits>&
basic_ios<_CharT, _Traits>::copyfmt(const basic_ios& __rhs)
{
    if (this != &__rhs)
    {
        __call_callbacks(erase_event);
        ios_base::copyfmt(__rhs);
        __tie_ = __rhs.__tie_;
        __fill_ = __rhs.__fill_;
        __call_callbacks(copyfmt_event);
        exceptions(__rhs.exceptions());
    }
    return *this;
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
basic_ios<_CharT, _Traits>::move(basic_ios& __rhs)
{
    ios_base::move(__rhs);
    __tie_ = __rhs.__tie_;
    __rhs.__tie_ = 0;
    __fill_ = __rhs.__fill_;
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
basic_ios<_CharT, _Traits>::swap(basic_ios& __rhs) throw()
{
    ios_base::swap(__rhs);
    std::__1::swap(__tie_, __rhs.__tie_);
    std::__1::swap(__fill_, __rhs.__fill_);
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
basic_ios<_CharT, _Traits>::set_rdbuf(basic_streambuf<char_type, traits_type>* __sb)
{
    ios_base::set_rdbuf(__sb);
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
ios_base&
boolalpha(ios_base& __str)
{
    __str.setf(ios_base::boolalpha);
    return __str;
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
ios_base&
noboolalpha(ios_base& __str)
{
    __str.unsetf(ios_base::boolalpha);
    return __str;
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
ios_base&
showbase(ios_base& __str)
{
    __str.setf(ios_base::showbase);
    return __str;
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
ios_base&
noshowbase(ios_base& __str)
{
    __str.unsetf(ios_base::showbase);
    return __str;
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
ios_base&
showpoint(ios_base& __str)
{
    __str.setf(ios_base::showpoint);
    return __str;
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
ios_base&
noshowpoint(ios_base& __str)
{
    __str.unsetf(ios_base::showpoint);
    return __str;
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
ios_base&
showpos(ios_base& __str)
{
    __str.setf(ios_base::showpos);
    return __str;
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
ios_base&
noshowpos(ios_base& __str)
{
    __str.unsetf(ios_base::showpos);
    return __str;
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
ios_base&
skipws(ios_base& __str)
{
    __str.setf(ios_base::skipws);
    return __str;
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
ios_base&
noskipws(ios_base& __str)
{
    __str.unsetf(ios_base::skipws);
    return __str;
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
ios_base&
uppercase(ios_base& __str)
{
    __str.setf(ios_base::uppercase);
    return __str;
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
ios_base&
nouppercase(ios_base& __str)
{
    __str.unsetf(ios_base::uppercase);
    return __str;
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
ios_base&
unitbuf(ios_base& __str)
{
    __str.setf(ios_base::unitbuf);
    return __str;
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
ios_base&
nounitbuf(ios_base& __str)
{
    __str.unsetf(ios_base::unitbuf);
    return __str;
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
ios_base&
internal(ios_base& __str)
{
    __str.setf(ios_base::internal, ios_base::adjustfield);
    return __str;
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
ios_base&
left(ios_base& __str)
{
    __str.setf(ios_base::left, ios_base::adjustfield);
    return __str;
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
ios_base&
right(ios_base& __str)
{
    __str.setf(ios_base::right, ios_base::adjustfield);
    return __str;
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
ios_base&
dec(ios_base& __str)
{
    __str.setf(ios_base::dec, ios_base::basefield);
    return __str;
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
ios_base&
hex(ios_base& __str)
{
    __str.setf(ios_base::hex, ios_base::basefield);
    return __str;
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
ios_base&
oct(ios_base& __str)
{
    __str.setf(ios_base::oct, ios_base::basefield);
    return __str;
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
ios_base&
fixed(ios_base& __str)
{
    __str.setf(ios_base::fixed, ios_base::floatfield);
    return __str;
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
ios_base&
scientific(ios_base& __str)
{
    __str.setf(ios_base::scientific, ios_base::floatfield);
    return __str;
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
ios_base&
hexfloat(ios_base& __str)
{
    __str.setf(ios_base::fixed | ios_base::scientific, ios_base::floatfield);
    return __str;
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
ios_base&
defaultfloat(ios_base& __str)
{
    __str.unsetf(ios_base::floatfield);
    return __str;
}

template <class _CharT, class _Traits>
class __save_flags
{
    typedef basic_ios<_CharT, _Traits> __stream_type;
    typedef typename __stream_type::fmtflags fmtflags;

    __stream_type& __stream_;
    fmtflags __fmtflags_;
    _CharT __fill_;

    __save_flags(const __save_flags&);
    __save_flags& operator=(const __save_flags&);
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit __save_flags(__stream_type& __stream)
        : __stream_(__stream),
          __fmtflags_(__stream.flags()),
          __fill_(__stream.fill())
        {}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    ~__save_flags()
    {
        __stream_.flags(__fmtflags_);
        __stream_.fill(__fill_);
    }
};

} }
# 39 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/iostream" 2 3
# 1 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/streambuf" 1 3
// -*- C++ -*-
//===------------------------- streambuf ----------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is dual licensed under the MIT and the University of Illinois Open
// Source Licenses. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//




/*
    streambuf synopsis

namespace std
{

template <class charT, class traits = char_traits<charT> >
class basic_streambuf
{
public:
    // types:
    typedef charT char_type;
    typedef traits traits_type;
    typedef typename traits_type::int_type int_type;
    typedef typename traits_type::pos_type pos_type;
    typedef typename traits_type::off_type off_type;

    virtual ~basic_streambuf();

    // 27.6.2.2.1 locales:
    locale pubimbue(const locale& loc);
    locale getloc() const;

    // 27.6.2.2.2 buffer and positioning:
    basic_streambuf* pubsetbuf(char_type* s, streamsize n);
    pos_type pubseekoff(off_type off, ios_base::seekdir way,
                        ios_base::openmode which = ios_base::in | ios_base::out);
    pos_type pubseekpos(pos_type sp,
                        ios_base::openmode which = ios_base::in | ios_base::out);
    int pubsync();

    // Get and put areas:
    // 27.6.2.2.3 Get area:
    streamsize in_avail();
    int_type snextc();
    int_type sbumpc();
    int_type sgetc();
    streamsize sgetn(char_type* s, streamsize n);

    // 27.6.2.2.4 Putback:
    int_type sputbackc(char_type c);
    int_type sungetc();

    // 27.6.2.2.5 Put area:
    int_type sputc(char_type c);
    streamsize sputn(const char_type* s, streamsize n);

protected:
    basic_streambuf();
    basic_streambuf(const basic_streambuf& rhs);
    basic_streambuf& operator=(const basic_streambuf& rhs);
    void swap(basic_streambuf& rhs);

    // 27.6.2.3.2 Get area:
    char_type* eback() const;
    char_type* gptr() const;
    char_type* egptr() const;
    void gbump(int n);
    void setg(char_type* gbeg, char_type* gnext, char_type* gend);

    // 27.6.2.3.3 Put area:
    char_type* pbase() const;
    char_type* pptr() const;
    char_type* epptr() const;
    void pbump(int n);
    void setp(char_type* pbeg, char_type* pend);

    // 27.6.2.4 virtual functions:
    // 27.6.2.4.1 Locales:
    virtual void imbue(const locale& loc);

    // 27.6.2.4.2 Buffer management and positioning:
    virtual basic_streambuf* setbuf(char_type* s, streamsize n);
    virtual pos_type seekoff(off_type off, ios_base::seekdir way,
                             ios_base::openmode which = ios_base::in | ios_base::out);
    virtual pos_type seekpos(pos_type sp,
                             ios_base::openmode which = ios_base::in | ios_base::out);
    virtual int sync();

    // 27.6.2.4.3 Get area:
    virtual streamsize showmanyc();
    virtual streamsize xsgetn(char_type* s, streamsize n);
    virtual int_type underflow();
    virtual int_type uflow();

    // 27.6.2.4.4 Putback:
    virtual int_type pbackfail(int_type c = traits_type::eof());

    // 27.6.2.4.5 Put area:
    virtual streamsize xsputn(const char_type* s, streamsize n);
    virtual int_type overflow (int_type c = traits_type::eof());
};

}  // std

*/
# 117 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/streambuf" 3


namespace std {inline namespace __1 {

template <class _CharT, class _Traits>
class __attribute__ ((__type_visibility__("default"))) basic_streambuf
{
public:
    // types:
    typedef _CharT char_type;
    typedef _Traits traits_type;
    typedef typename traits_type::int_type int_type;
    typedef typename traits_type::pos_type pos_type;
    typedef typename traits_type::off_type off_type;

    virtual ~basic_streambuf();

    // 27.6.2.2.1 locales:
    locale pubimbue(const locale& __loc);
    locale getloc() const;

    // 27.6.2.2.2 buffer and positioning:
    basic_streambuf* pubsetbuf(char_type* __s, streamsize __n);
    pos_type pubseekoff(off_type __off, ios_base::seekdir __way,
                        ios_base::openmode __which = ios_base::in | ios_base::out);
    pos_type pubseekpos(pos_type __sp,
                        ios_base::openmode __which = ios_base::in | ios_base::out);
    int pubsync();

    // Get and put areas:
    // 27.6.2.2.3 Get area:
    streamsize in_avail();
    int_type snextc();
    int_type sbumpc();
    int_type sgetc();
    streamsize sgetn(char_type* __s, streamsize __n);

    // 27.6.2.2.4 Putback:
    int_type sputbackc(char_type __c);
    int_type sungetc();

    // 27.6.2.2.5 Put area:
    int_type sputc(char_type __c);
    streamsize sputn(const char_type* __s, streamsize __n);

protected:
    basic_streambuf();
    basic_streambuf(const basic_streambuf& __rhs);
    basic_streambuf& operator=(const basic_streambuf& __rhs);
    void swap(basic_streambuf& __rhs);

    // 27.6.2.3.2 Get area:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) char_type* eback() const {return __binp_;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) char_type* gptr() const {return __ninp_;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) char_type* egptr() const {return __einp_;}
    void gbump(int __n);
    void setg(char_type* __gbeg, char_type* __gnext, char_type* __gend);

    // 27.6.2.3.3 Put area:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) char_type* pbase() const {return __bout_;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) char_type* pptr() const {return __nout_;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) char_type* epptr() const {return __eout_;}
    void pbump(int __n);
    void setp(char_type* __pbeg, char_type* __pend);

    // 27.6.2.4 virtual functions:
    // 27.6.2.4.1 Locales:
    virtual void imbue(const locale& __loc);

    // 27.6.2.4.2 Buffer management and positioning:
    virtual basic_streambuf* setbuf(char_type* __s, streamsize __n);
    virtual pos_type seekoff(off_type __off, ios_base::seekdir __way,
                             ios_base::openmode __which = ios_base::in | ios_base::out);
    virtual pos_type seekpos(pos_type __sp,
                             ios_base::openmode __which = ios_base::in | ios_base::out);
    virtual int sync();

    // 27.6.2.4.3 Get area:
    virtual streamsize showmanyc();
    virtual streamsize xsgetn(char_type* __s, streamsize __n);
    virtual int_type underflow();
    virtual int_type uflow();

    // 27.6.2.4.4 Putback:
    virtual int_type pbackfail(int_type __c = traits_type::eof());

    // 27.6.2.4.5 Put area:
    virtual streamsize xsputn(const char_type* __s, streamsize __n);
    virtual int_type overflow(int_type __c = traits_type::eof());

private:
    locale __loc_;
    char_type* __binp_;
    char_type* __ninp_;
    char_type* __einp_;
    char_type* __bout_;
    char_type* __nout_;
    char_type* __eout_;
};

template <class _CharT, class _Traits>
basic_streambuf<_CharT, _Traits>::~basic_streambuf()
{
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
locale
basic_streambuf<_CharT, _Traits>::pubimbue(const locale& __loc)
{
    imbue(__loc);
    locale __r = __loc_;
    __loc_ = __loc;
    return __r;
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
locale
basic_streambuf<_CharT, _Traits>::getloc() const
{
    return __loc_;
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_streambuf<_CharT, _Traits>*
basic_streambuf<_CharT, _Traits>::pubsetbuf(char_type* __s, streamsize __n)
{
    return setbuf(__s, __n);
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename basic_streambuf<_CharT, _Traits>::pos_type
basic_streambuf<_CharT, _Traits>::pubseekoff(off_type __off,
                                             ios_base::seekdir __way,
                                             ios_base::openmode __which)
{
    return seekoff(__off, __way, __which);
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename basic_streambuf<_CharT, _Traits>::pos_type
basic_streambuf<_CharT, _Traits>::pubseekpos(pos_type __sp,
                                             ios_base::openmode __which)
{
    return seekpos(__sp, __which);
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
int
basic_streambuf<_CharT, _Traits>::pubsync()
{
    return sync();
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
streamsize
basic_streambuf<_CharT, _Traits>::in_avail()
{
    if (__ninp_ < __einp_)
        return static_cast<streamsize>(__einp_ - __ninp_);
    return showmanyc();
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename basic_streambuf<_CharT, _Traits>::int_type
basic_streambuf<_CharT, _Traits>::snextc()
{
    if (sbumpc() == traits_type::eof())
        return traits_type::eof();
    return sgetc();
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename basic_streambuf<_CharT, _Traits>::int_type
basic_streambuf<_CharT, _Traits>::sbumpc()
{
    if (__ninp_ == __einp_)
        return uflow();
    return traits_type::to_int_type(*__ninp_++);
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename basic_streambuf<_CharT, _Traits>::int_type
basic_streambuf<_CharT, _Traits>::sgetc()
{
    if (__ninp_ == __einp_)
        return underflow();
    return traits_type::to_int_type(*__ninp_);
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
streamsize
basic_streambuf<_CharT, _Traits>::sgetn(char_type* __s, streamsize __n)
{
    return xsgetn(__s, __n);
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename basic_streambuf<_CharT, _Traits>::int_type
basic_streambuf<_CharT, _Traits>::sputbackc(char_type __c)
{
    if (__binp_ == __ninp_ || !traits_type::eq(__c, __ninp_[-1]))
        return pbackfail(traits_type::to_int_type(__c));
    return traits_type::to_int_type(*--__ninp_);
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename basic_streambuf<_CharT, _Traits>::int_type
basic_streambuf<_CharT, _Traits>::sungetc()
{
    if (__binp_ == __ninp_)
        return pbackfail();
    return traits_type::to_int_type(*--__ninp_);
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename basic_streambuf<_CharT, _Traits>::int_type
basic_streambuf<_CharT, _Traits>::sputc(char_type __c)
{
    if (__nout_ == __eout_)
        return overflow(traits_type::to_int_type(__c));
    *__nout_++ = __c;
    return traits_type::to_int_type(__c);
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
streamsize
basic_streambuf<_CharT, _Traits>::sputn(const char_type* __s, streamsize __n)
{
    return xsputn(__s, __n);
}

template <class _CharT, class _Traits>
basic_streambuf<_CharT, _Traits>::basic_streambuf()
    : __binp_(0),
      __ninp_(0),
      __einp_(0),
      __bout_(0),
      __nout_(0),
      __eout_(0)
{
}

template <class _CharT, class _Traits>
basic_streambuf<_CharT, _Traits>::basic_streambuf(const basic_streambuf& __sb)
    : __loc_(__sb.__loc_),
      __binp_(__sb.__binp_),
      __ninp_(__sb.__ninp_),
      __einp_(__sb.__einp_),
      __bout_(__sb.__bout_),
      __nout_(__sb.__nout_),
      __eout_(__sb.__eout_)
{
}

template <class _CharT, class _Traits>
basic_streambuf<_CharT, _Traits>&
basic_streambuf<_CharT, _Traits>::operator=(const basic_streambuf& __sb)
{
    __loc_ = __sb.__loc_;
    __binp_ = __sb.__binp_;
    __ninp_ = __sb.__ninp_;
    __einp_ = __sb.__einp_;
    __bout_ = __sb.__bout_;
    __nout_ = __sb.__nout_;
    __eout_ = __sb.__eout_;
    return *this;
}

template <class _CharT, class _Traits>
void
basic_streambuf<_CharT, _Traits>::swap(basic_streambuf& __sb)
{
    std::__1::swap(__loc_, __sb.__loc_);
    std::__1::swap(__binp_, __sb.__binp_);
    std::__1::swap(__ninp_, __sb.__ninp_);
    std::__1::swap(__einp_, __sb.__einp_);
    std::__1::swap(__bout_, __sb.__bout_);
    std::__1::swap(__nout_, __sb.__nout_);
    std::__1::swap(__eout_, __sb.__eout_);
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
basic_streambuf<_CharT, _Traits>::gbump(int __n)
{
    __ninp_ += __n;
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
basic_streambuf<_CharT, _Traits>::setg(char_type* __gbeg, char_type* __gnext,
                                                          char_type* __gend)
{
    __binp_ = __gbeg;
    __ninp_ = __gnext;
    __einp_ = __gend;
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
basic_streambuf<_CharT, _Traits>::pbump(int __n)
{
    __nout_ += __n;
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
basic_streambuf<_CharT, _Traits>::setp(char_type* __pbeg, char_type* __pend)
{
    __bout_ = __nout_ = __pbeg;
    __eout_ = __pend;
}

template <class _CharT, class _Traits>
void
basic_streambuf<_CharT, _Traits>::imbue(const locale&)
{
}

template <class _CharT, class _Traits>
basic_streambuf<_CharT, _Traits>*
basic_streambuf<_CharT, _Traits>::setbuf(char_type*, streamsize)
{
    return this;
}

template <class _CharT, class _Traits>
typename basic_streambuf<_CharT, _Traits>::pos_type
basic_streambuf<_CharT, _Traits>::seekoff(off_type, ios_base::seekdir,
                                          ios_base::openmode)
{
    return pos_type(off_type(-1));
}

template <class _CharT, class _Traits>
typename basic_streambuf<_CharT, _Traits>::pos_type
basic_streambuf<_CharT, _Traits>::seekpos(pos_type, ios_base::openmode)
{
    return pos_type(off_type(-1));
}

template <class _CharT, class _Traits>
int
basic_streambuf<_CharT, _Traits>::sync()
{
    return 0;
}

template <class _CharT, class _Traits>
streamsize
basic_streambuf<_CharT, _Traits>::showmanyc()
{
    return 0;
}

template <class _CharT, class _Traits>
streamsize
basic_streambuf<_CharT, _Traits>::xsgetn(char_type* __s, streamsize __n)
{
    const int_type __eof = traits_type::eof();
    int_type __c;
    streamsize __i = 0;
    for (;__i < __n; ++__i, ++__s)
    {
        if (__ninp_ < __einp_)
            *__s = *__ninp_++;
        else if ((__c = uflow()) != __eof)
            *__s = traits_type::to_char_type(__c);
        else
            break;
    }
    return __i;
}

template <class _CharT, class _Traits>
typename basic_streambuf<_CharT, _Traits>::int_type
basic_streambuf<_CharT, _Traits>::underflow()
{
    return traits_type::eof();
}

template <class _CharT, class _Traits>
typename basic_streambuf<_CharT, _Traits>::int_type
basic_streambuf<_CharT, _Traits>::uflow()
{
    if (underflow() == traits_type::eof())
        return traits_type::eof();
    return traits_type::to_int_type(*__ninp_++);
}

template <class _CharT, class _Traits>
typename basic_streambuf<_CharT, _Traits>::int_type
basic_streambuf<_CharT, _Traits>::pbackfail(int_type)
{
    return traits_type::eof();
}

template <class _CharT, class _Traits>
streamsize
basic_streambuf<_CharT, _Traits>::xsputn(const char_type* __s, streamsize __n)
{
    streamsize __i = 0;
    int_type __eof = traits_type::eof();
    for (; __i < __n; ++__s, ++__i)
    {
        if (__nout_ < __eout_)
            *__nout_++ = *__s;
        else if (overflow(traits_type::to_int_type(*__s)) == __eof)
            break;
    }
    return __i;
}

template <class _CharT, class _Traits>
typename basic_streambuf<_CharT, _Traits>::int_type
basic_streambuf<_CharT, _Traits>::overflow(int_type)
{
    return traits_type::eof();
}







} }
# 40 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/iostream" 2 3
# 1 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/istream" 1 3
// -*- C++ -*-
//===--------------------------- istream ----------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is dual licensed under the MIT and the University of Illinois Open
// Source Licenses. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//




/*
    istream synopsis

template <class charT, class traits = char_traits<charT> >
class basic_istream
    : virtual public basic_ios<charT,traits>
{
public:
    // types (inherited from basic_ios (27.5.4)):
    typedef charT                          char_type;
    typedef traits                         traits_type;
    typedef typename traits_type::int_type int_type;
    typedef typename traits_type::pos_type pos_type;
    typedef typename traits_type::off_type off_type;

    // 27.7.1.1.1 Constructor/destructor:
    explicit basic_istream(basic_streambuf<char_type, traits_type>* sb);
    basic_istream(basic_istream&& rhs);
    virtual ~basic_istream();

    // 27.7.1.1.2 Assign/swap:
    basic_istream& operator=(basic_istream&& rhs);
    void swap(basic_istream& rhs);

    // 27.7.1.1.3 Prefix/suffix:
    class sentry;

    // 27.7.1.2 Formatted input:
    basic_istream& operator>>(basic_istream& (*pf)(basic_istream&));
    basic_istream& operator>>(basic_ios<char_type, traits_type>&
                              (*pf)(basic_ios<char_type, traits_type>&));
    basic_istream& operator>>(ios_base& (*pf)(ios_base&));
    basic_istream& operator>>(basic_streambuf<char_type, traits_type>* sb);
    basic_istream& operator>>(bool& n);
    basic_istream& operator>>(short& n);
    basic_istream& operator>>(unsigned short& n);
    basic_istream& operator>>(int& n);
    basic_istream& operator>>(unsigned int& n);
    basic_istream& operator>>(long& n);
    basic_istream& operator>>(unsigned long& n);
    basic_istream& operator>>(long long& n);
    basic_istream& operator>>(unsigned long long& n);
    basic_istream& operator>>(float& f);
    basic_istream& operator>>(double& f);
    basic_istream& operator>>(long double& f);
    basic_istream& operator>>(void*& p);

    // 27.7.1.3 Unformatted input:
    streamsize gcount() const;
    int_type get();
    basic_istream& get(char_type& c);
    basic_istream& get(char_type* s, streamsize n);
    basic_istream& get(char_type* s, streamsize n, char_type delim);
    basic_istream& get(basic_streambuf<char_type,traits_type>& sb);
    basic_istream& get(basic_streambuf<char_type,traits_type>& sb, char_type delim);

    basic_istream& getline(char_type* s, streamsize n);
    basic_istream& getline(char_type* s, streamsize n, char_type delim);

    basic_istream& ignore(streamsize n = 1, int_type delim = traits_type::eof());
    int_type peek();
    basic_istream& read (char_type* s, streamsize n);
    streamsize readsome(char_type* s, streamsize n);

    basic_istream& putback(char_type c);
    basic_istream& unget();
    int sync();

    pos_type tellg();
    basic_istream& seekg(pos_type);
    basic_istream& seekg(off_type, ios_base::seekdir);
};

// 27.7.1.2.3 character extraction templates:
template<class charT, class traits>
  basic_istream<charT,traits>& operator>>(basic_istream<charT,traits>&, charT&);

template<class traits>
  basic_istream<char,traits>& operator>>(basic_istream<char,traits>&, unsigned char&);

template<class traits>
  basic_istream<char,traits>& operator>>(basic_istream<char,traits>&, signed char&);

template<class charT, class traits>
  basic_istream<charT,traits>& operator>>(basic_istream<charT,traits>&, charT*);

template<class traits>
  basic_istream<char,traits>& operator>>(basic_istream<char,traits>&, unsigned char*);

template<class traits>
  basic_istream<char,traits>& operator>>(basic_istream<char,traits>&, signed char*);

template <class charT, class traits>
  void
  swap(basic_istream<charT, traits>& x, basic_istream<charT, traits>& y);

typedef basic_istream<char> istream;
typedef basic_istream<wchar_t> wistream;

template <class charT, class traits = char_traits<charT> >
class basic_iostream :
    public basic_istream<charT,traits>,
    public basic_ostream<charT,traits>
{
public:
    // types:
    typedef charT                          char_type;
    typedef traits                         traits_type;
    typedef typename traits_type::int_type int_type;
    typedef typename traits_type::pos_type pos_type;
    typedef typename traits_type::off_type off_type;

    // constructor/destructor
    explicit basic_iostream(basic_streambuf<char_type, traits_type>* sb);
    basic_iostream(basic_iostream&& rhs);
    virtual ~basic_iostream();

    // assign/swap
    basic_iostream& operator=(basic_iostream&& rhs);
    void swap(basic_iostream& rhs);
};

template <class charT, class traits>
  void
  swap(basic_iostream<charT, traits>& x, basic_iostream<charT, traits>& y);

typedef basic_iostream<char> iostream;
typedef basic_iostream<wchar_t> wiostream;

template <class charT, class traits>
  basic_istream<charT,traits>&
  ws(basic_istream<charT,traits>& is);

template <class charT, class traits, class T>
  basic_istream<charT, traits>&
  operator>>(basic_istream<charT, traits>&& is, T& x);

}  // std

*/



# 1 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/ostream" 1 3
// -*- C++ -*-
//===-------------------------- ostream -----------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is dual licensed under the MIT and the University of Illinois Open
// Source Licenses. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//




/*
    ostream synopsis

template <class charT, class traits = char_traits<charT> >
class basic_ostream
    : virtual public basic_ios<charT,traits>
{
public:
    // types (inherited from basic_ios (27.5.4)):
    typedef charT                          char_type;
    typedef traits                         traits_type;
    typedef typename traits_type::int_type int_type;
    typedef typename traits_type::pos_type pos_type;
    typedef typename traits_type::off_type off_type;

    // 27.7.2.2 Constructor/destructor:
    explicit basic_ostream(basic_streambuf<char_type,traits>* sb);
    basic_ostream(basic_ostream&& rhs);
    virtual ~basic_ostream();

    // 27.7.2.3 Assign/swap
    basic_ostream& operator=(const basic_ostream& rhs) = delete; // C++14
    basic_ostream& operator=(basic_ostream&& rhs);
    void swap(basic_ostream& rhs);

    // 27.7.2.4 Prefix/suffix:
    class sentry;

    // 27.7.2.6 Formatted output:
    basic_ostream& operator<<(basic_ostream& (*pf)(basic_ostream&));
    basic_ostream& operator<<(basic_ios<charT, traits>& (*pf)(basic_ios<charT,traits>&));
    basic_ostream& operator<<(ios_base& (*pf)(ios_base&));
    basic_ostream& operator<<(bool n);
    basic_ostream& operator<<(short n);
    basic_ostream& operator<<(unsigned short n);
    basic_ostream& operator<<(int n);
    basic_ostream& operator<<(unsigned int n);
    basic_ostream& operator<<(long n);
    basic_ostream& operator<<(unsigned long n);
    basic_ostream& operator<<(long long n);
    basic_ostream& operator<<(unsigned long long n);
    basic_ostream& operator<<(float f);
    basic_ostream& operator<<(double f);
    basic_ostream& operator<<(long double f);
    basic_ostream& operator<<(const void* p);
    basic_ostream& operator<<(basic_streambuf<char_type,traits>* sb);

    // 27.7.2.7 Unformatted output:
    basic_ostream& put(char_type c);
    basic_ostream& write(const char_type* s, streamsize n);
    basic_ostream& flush();

    // 27.7.2.5 seeks:
    pos_type tellp();
    basic_ostream& seekp(pos_type);
    basic_ostream& seekp(off_type, ios_base::seekdir);
};

// 27.7.2.6.4 character inserters

template<class charT, class traits>
  basic_ostream<charT,traits>& operator<<(basic_ostream<charT,traits>&, charT);

template<class charT, class traits>
  basic_ostream<charT,traits>& operator<<(basic_ostream<charT,traits>&, char);

template<class traits>
  basic_ostream<char,traits>& operator<<(basic_ostream<char,traits>&, char);

// signed and unsigned

template<class traits>
  basic_ostream<char,traits>& operator<<(basic_ostream<char,traits>&, signed char);

template<class traits>
  basic_ostream<char,traits>& operator<<(basic_ostream<char,traits>&, unsigned char);

// NTBS
template<class charT, class traits>
  basic_ostream<charT,traits>& operator<<(basic_ostream<charT,traits>&, const charT*);

template<class charT, class traits>
  basic_ostream<charT,traits>& operator<<(basic_ostream<charT,traits>&, const char*);

template<class traits>
  basic_ostream<char,traits>& operator<<(basic_ostream<char,traits>&, const char*);

// signed and unsigned
template<class traits>
basic_ostream<char,traits>& operator<<(basic_ostream<char,traits>&, const signed char*);

template<class traits>
  basic_ostream<char,traits>& operator<<(basic_ostream<char,traits>&, const unsigned char*);

// swap:
template <class charT, class traits>
  void swap(basic_ostream<charT, traits>& x, basic_ostream<charT, traits>& y);

template <class charT, class traits>
  basic_ostream<charT,traits>& endl(basic_ostream<charT,traits>& os);

template <class charT, class traits>
  basic_ostream<charT,traits>& ends(basic_ostream<charT,traits>& os);

template <class charT, class traits>
  basic_ostream<charT,traits>& flush(basic_ostream<charT,traits>& os);

// rvalue stream insertion
template <class charT, class traits, class T>
  basic_ostream<charT, traits>&
  operator<<(basic_ostream<charT, traits>&& os, const T& x);

}  // std

*/





# 1 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/locale" 1 3
// -*- C++ -*-
//===-------------------------- locale ------------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is dual licensed under the MIT and the University of Illinois Open
// Source Licenses. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//




/*
    locale synopsis

namespace std
{

class locale
{
public:
    // types:
    class facet;
    class id;

    typedef int category;
    static const category // values assigned here are for exposition only
        none     = 0x000,
        collate  = 0x010,
        ctype    = 0x020,
        monetary = 0x040,
        numeric  = 0x080,
        time     = 0x100,
        messages = 0x200,
        all = collate | ctype | monetary | numeric | time | messages;

    // construct/copy/destroy:
    locale() noexcept;
    locale(const locale& other) noexcept;
    explicit locale(const char* std_name);
    explicit locale(const string& std_name);
    locale(const locale& other, const char* std_name, category);
    locale(const locale& other, const string& std_name, category);
    template <class Facet> locale(const locale& other, Facet* f);
    locale(const locale& other, const locale& one, category);

    ~locale(); // not virtual

    const locale& operator=(const locale& other) noexcept;

    template <class Facet> locale combine(const locale& other) const;

    // locale operations:
    basic_string<char> name() const;
    bool operator==(const locale& other) const;
    bool operator!=(const locale& other) const;
    template <class charT, class Traits, class Allocator>
      bool operator()(const basic_string<charT,Traits,Allocator>& s1,
                      const basic_string<charT,Traits,Allocator>& s2) const;

    // global locale objects:
    static locale global(const locale&);
    static const locale& classic();
};

template <class Facet> const Facet& use_facet(const locale&);
template <class Facet> bool has_facet(const locale&) noexcept;

// 22.3.3, convenience interfaces:
template <class charT> bool isspace (charT c, const locale& loc);
template <class charT> bool isprint (charT c, const locale& loc);
template <class charT> bool iscntrl (charT c, const locale& loc);
template <class charT> bool isupper (charT c, const locale& loc);
template <class charT> bool islower (charT c, const locale& loc);
template <class charT> bool isalpha (charT c, const locale& loc);
template <class charT> bool isdigit (charT c, const locale& loc);
template <class charT> bool ispunct (charT c, const locale& loc);
template <class charT> bool isxdigit(charT c, const locale& loc);
template <class charT> bool isalnum (charT c, const locale& loc);
template <class charT> bool isgraph (charT c, const locale& loc);
template <class charT> charT toupper(charT c, const locale& loc);
template <class charT> charT tolower(charT c, const locale& loc);

template<class Codecvt, class Elem = wchar_t,
         class Wide_alloc = allocator<Elem>,
         class Byte_alloc = allocator<char>>
class wstring_convert
{
public:
    typedef basic_string<char, char_traits<char>, Byte_alloc> byte_string;
    typedef basic_string<Elem, char_traits<Elem>, Wide_alloc> wide_string;
    typedef typename Codecvt::state_type                      state_type;
    typedef typename wide_string::traits_type::int_type       int_type;

    explicit wstring_convert(Codecvt* pcvt = new Codecvt);          // explicit in C++14
    wstring_convert(Codecvt* pcvt, state_type state);
    explicit wstring_convert(const byte_string& byte_err,           // explicit in C++14
                    const wide_string& wide_err = wide_string());
    wstring_convert(const wstring_convert&) = delete;               // C++14
    wstring_convert & operator=(const wstring_convert &) = delete;  // C++14
    ~wstring_convert();

    wide_string from_bytes(char byte);
    wide_string from_bytes(const char* ptr);
    wide_string from_bytes(const byte_string& str);
    wide_string from_bytes(const char* first, const char* last);

    byte_string to_bytes(Elem wchar);
    byte_string to_bytes(const Elem* wptr);
    byte_string to_bytes(const wide_string& wstr);
    byte_string to_bytes(const Elem* first, const Elem* last);

    size_t converted() const; // noexcept in C++14
    state_type state() const;
};

template <class Codecvt, class Elem = wchar_t, class Tr = char_traits<Elem>>
class wbuffer_convert
    : public basic_streambuf<Elem, Tr>
{
public:
    typedef typename Tr::state_type state_type;

    explicit wbuffer_convert(streambuf* bytebuf = 0, Codecvt* pcvt = new Codecvt,
                    state_type state = state_type());       // explicit in C++14
    wbuffer_convert(const wbuffer_convert&) = delete;               // C++14
    wbuffer_convert & operator=(const wbuffer_convert &) = delete;  // C++14
    ~wbuffer_convert();                                             // C++14
    
    streambuf* rdbuf() const;
    streambuf* rdbuf(streambuf* bytebuf);

    state_type state() const;
};

// 22.4.1 and 22.4.1.3, ctype:
class ctype_base;
template <class charT> class ctype;
template <> class ctype<char>; // specialization
template <class charT> class ctype_byname;
template <> class ctype_byname<char>; // specialization

class codecvt_base;
template <class internT, class externT, class stateT> class codecvt;
template <class internT, class externT, class stateT> class codecvt_byname;

// 22.4.2 and 22.4.3, numeric:
template <class charT, class InputIterator> class num_get;
template <class charT, class OutputIterator> class num_put;
template <class charT> class numpunct;
template <class charT> class numpunct_byname;

// 22.4.4, col lation:
template <class charT> class collate;
template <class charT> class collate_byname;

// 22.4.5, date and time:
class time_base;
template <class charT, class InputIterator> class time_get;
template <class charT, class InputIterator> class time_get_byname;
template <class charT, class OutputIterator> class time_put;
template <class charT, class OutputIterator> class time_put_byname;

// 22.4.6, money:
class money_base;
template <class charT, class InputIterator> class money_get;
template <class charT, class OutputIterator> class money_put;
template <class charT, bool Intl> class moneypunct;
template <class charT, bool Intl> class moneypunct_byname;

// 22.4.7, message retrieval:
class messages_base;
template <class charT> class messages;
template <class charT> class messages_byname;

}  // std

*/
# 192 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/locale" 3
# 1 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/cstdlib" 1 3
// -*- C++ -*-
//===--------------------------- cstdlib ----------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is dual licensed under the MIT and the University of Illinois Open
// Source Licenses. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//




/*
    cstdlib synopsis

Macros:

    EXIT_FAILURE
    EXIT_SUCCESS
    MB_CUR_MAX
    NULL
    RAND_MAX

namespace std
{

Types:

    size_t
    div_t
    ldiv_t
    lldiv_t                                                               // C99

double    atof (const char* nptr);
int       atoi (const char* nptr);
long      atol (const char* nptr);
long long atoll(const char* nptr);                                        // C99
double             strtod  (const char* restrict nptr, char** restrict endptr);
float              strtof  (const char* restrict nptr, char** restrict endptr); // C99
long double        strtold (const char* restrict nptr, char** restrict endptr); // C99
long               strtol  (const char* restrict nptr, char** restrict endptr, int base);
long long          strtoll (const char* restrict nptr, char** restrict endptr, int base); // C99
unsigned long      strtoul (const char* restrict nptr, char** restrict endptr, int base);
unsigned long long strtoull(const char* restrict nptr, char** restrict endptr, int base); // C99
int rand(void);
void srand(unsigned int seed);
void* calloc(size_t nmemb, size_t size);
void free(void* ptr);
void* malloc(size_t size);
void* realloc(void* ptr, size_t size);
void abort(void);
int atexit(void (*func)(void));
void exit(int status);
void _Exit(int status);
char* getenv(const char* name);
int system(const char* string);
void* bsearch(const void* key, const void* base, size_t nmemb, size_t size,
              int (*compar)(const void *, const void *));
void qsort(void* base, size_t nmemb, size_t size,
           int (*compar)(const void *, const void *));
int         abs(      int j);
long        abs(     long j);
long long   abs(long long j);                                             // C++0X
long       labs(     long j);
long long llabs(long long j);                                             // C99
div_t     div(      int numer,       int denom);
ldiv_t    div(     long numer,      long denom);
lldiv_t   div(long long numer, long long denom);                          // C++0X
ldiv_t   ldiv(     long numer,      long denom);
lldiv_t lldiv(long long numer, long long denom);                          // C99
int mblen(const char* s, size_t n);
int mbtowc(wchar_t* restrict pwc, const char* restrict s, size_t n);
int wctomb(char* s, wchar_t wchar);
size_t mbstowcs(wchar_t* restrict pwcs, const char* restrict s, size_t n);
size_t wcstombs(char* restrict s, const wchar_t* restrict pwcs, size_t n);
int at_quick_exit(void (*func)(void))                                     // C++11
void quick_exit(int status);                                              // C++11
void *aligned_alloc(size_t alignment, size_t size);                       // C11

}  // std

*/
# 93 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/cstdlib" 3


namespace std {inline namespace __1 {

using ::size_t;
using ::div_t;
using ::ldiv_t;

using ::lldiv_t;

using ::atof;
using ::atoi;
using ::atol;

using ::atoll;

using ::strtod;
using ::strtof;
using ::strtold;
using ::strtol;

using ::strtoll;

using ::strtoul;

using ::strtoull;

using ::rand;
using ::srand;
using ::calloc;
using ::free;
using ::malloc;
using ::realloc;
using ::abort;
using ::atexit;
using ::exit;
using ::_Exit;
using ::getenv;
using ::system;
using ::bsearch;
using ::qsort;
using ::abs;
using ::labs;

using ::llabs;

using ::div;
using ::ldiv;

using ::lldiv;

using ::mblen;
using ::mbtowc;
using ::wctomb;
using ::mbstowcs;
using ::wcstombs;
# 157 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/cstdlib" 3
// MSVCRT already has the correct prototype in <stdlib.h> #ifdef __cplusplus

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long abs( long __x) throw() {return labs(__x);}

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long long abs(long long __x) throw() {return llabs(__x);}


inline __attribute__ ((__visibility__("hidden"), __always_inline__)) ldiv_t div( long __x, long __y) throw() {return ldiv(__x, __y);}

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) lldiv_t div(long long __x, long long __y) throw() {return lldiv(__x, __y);}



} }
# 193 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/locale" 2 3




# 1 "/usr/include/nl_types.h" 1 3 4
/*	$NetBSD: nl_types.h,v 1.9 2000/10/03 19:53:32 sommerfeld Exp $	*/

/*-
 * Copyright (c) 1996 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by J.T. Conklin.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 * $FreeBSD: src/include/nl_types.h,v 1.11 2005/02/27 16:20:53 phantom Exp $
 */






# 1 "/usr/include/sys/types.h" 1 3 4
/*
 * Copyright (c) 2000-2008 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
/* Copyright (c) 1995 NeXT Computer, Inc. All Rights Reserved */
/*
 * Copyright (c) 1982, 1986, 1991, 1993, 1994
 *	The Regents of the University of California.  All rights reserved.
 * (c) UNIX System Laboratories, Inc.
 * All or some portions of this file are derived from material licensed
 * to the University of California by American Telephone and Telegraph
 * Co. or Unix System Laboratories, Inc. and are reproduced herein with
 * the permission of UNIX System Laboratories, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)types.h	8.4 (Berkeley) 1/21/94
 */
# 77 "/usr/include/sys/types.h" 3 4
/* Machine type dependent parameters. */






typedef unsigned char u_char;
typedef unsigned short u_short;
typedef unsigned int u_int;

typedef unsigned long u_long;


typedef unsigned short ushort; /* Sys V compatibility */
typedef unsigned int uint; /* Sys V compatibility */


typedef u_int64_t u_quad_t; /* quads */
typedef int64_t quad_t;
typedef quad_t * qaddr_t;

typedef char * caddr_t; /* core address */
typedef int32_t daddr_t; /* disk address */



typedef u_int32_t fixpt_t; /* fixed point number */


# 1 "/usr/include/sys/_types/_blkcnt_t.h" 1 3 4
/*
 * Copyright (c) 2003-2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */


typedef __darwin_blkcnt_t blkcnt_t;
# 107 "/usr/include/sys/types.h" 2 3 4
# 1 "/usr/include/sys/_types/_blksize_t.h" 1 3 4
/*
 * Copyright (c) 2003-2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */


typedef __darwin_blksize_t blksize_t;
# 108 "/usr/include/sys/types.h" 2 3 4
# 1 "/usr/include/sys/_types/_gid_t.h" 1 3 4
/*
 * Copyright (c) 2003-2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */


typedef __darwin_gid_t gid_t;
# 109 "/usr/include/sys/types.h" 2 3 4
# 1 "/usr/include/sys/_types/_in_addr_t.h" 1 3 4
/*
 * Copyright (c) 2003-2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */


typedef __uint32_t in_addr_t; /* base type for internet address */
# 110 "/usr/include/sys/types.h" 2 3 4
# 1 "/usr/include/sys/_types/_in_port_t.h" 1 3 4
/*
 * Copyright (c) 2003-2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */


typedef __uint16_t in_port_t;
# 111 "/usr/include/sys/types.h" 2 3 4
# 1 "/usr/include/sys/_types/_ino_t.h" 1 3 4
/*
 * Copyright (c) 2003-2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */


typedef __darwin_ino_t ino_t; /* inode number */
# 112 "/usr/include/sys/types.h" 2 3 4


# 1 "/usr/include/sys/_types/_ino64_t.h" 1 3 4
/*
 * Copyright (c) 2003-2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */


typedef __darwin_ino64_t ino64_t; /* 64bit inode number */
# 115 "/usr/include/sys/types.h" 2 3 4


# 1 "/usr/include/sys/_types/_key_t.h" 1 3 4
/*
 * Copyright (c) 2003-2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */


typedef __int32_t key_t; /* IPC key (for Sys V IPC) */
# 118 "/usr/include/sys/types.h" 2 3 4

# 1 "/usr/include/sys/_types/_nlink_t.h" 1 3 4
/*
 * Copyright (c) 2003-2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */


typedef __uint16_t nlink_t; /* link count */
# 120 "/usr/include/sys/types.h" 2 3 4




typedef int32_t segsz_t; /* segment size */
typedef int32_t swblk_t; /* swap offset */




/* Major, minor numbers, dev_t's. */

/*
 * These lowercase macros tend to match member functions in some C++ code,
 * so for C++, we must use inline functions instead.
 */

static inline __int32_t major(__uint32_t _x)
{
 return (__int32_t)(((__uint32_t)_x >> 24) & 0xff);
}

static inline __int32_t minor(__uint32_t _x)
{
 return (__int32_t)((_x) & 0xffffff);
}

static inline dev_t makedev(__uint32_t _major, __uint32_t _minor)
{
 return (dev_t)(((_major) << 24) | (_minor));
}
# 166 "/usr/include/sys/types.h" 3 4
# 1 "/usr/include/sys/_types/_useconds_t.h" 1 3 4
/*
 * Copyright (c) 2003-2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */


typedef __darwin_useconds_t useconds_t;
# 167 "/usr/include/sys/types.h" 2 3 4
# 1 "/usr/include/sys/_types/_suseconds_t.h" 1 3 4
/*
 * Copyright (c) 2003-2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */


typedef __darwin_suseconds_t suseconds_t;
# 168 "/usr/include/sys/types.h" 2 3 4







/*
 * This code is present here in order to maintain historical backward
 * compatability, and is intended to be removed at some point in the
 * future; please include <sys/select.h> instead.
 */

# 1 "/usr/include/sys/_types/_fd_def.h" 1 3 4
/*
 * Copyright (c) 2003-2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */


/*
 * Select uses bit masks of file descriptors in longs.  These macros
 * manipulate such bit fields (the filesystem macros use chars).  The
 * extra protection here is to permit application redefinition above
 * the default size.
 */
# 45 "/usr/include/sys/_types/_fd_def.h" 3 4
extern "C" {
typedef struct fd_set {
 __int32_t fds_bits[((((1024) % ((sizeof(__int32_t) * 8))) == 0) ? ((1024) / ((sizeof(__int32_t) * 8))) : (((1024) / ((sizeof(__int32_t) * 8))) + 1))];
} fd_set;
}

/* This inline avoids argument side-effect issues with FD_ISSET() */
static inline int
__darwin_fd_isset(int _n, const struct fd_set *_p)
{
 return (_p->fds_bits[(unsigned long)_n/(sizeof(__int32_t) * 8)] & ((__int32_t)(1<<((unsigned long)_n % (sizeof(__int32_t) * 8)))));
}






/*
 * Use the built-in bzero function instead of the library version so that
 * we do not pollute the namespace or introduce prototype warnings.
 */
# 181 "/usr/include/sys/types.h" 2 3 4




typedef __int32_t fd_mask;

/*
 * Select uses bit masks of file descriptors in longs.  These macros
 * manipulate such bit fields (the filesystem macros use chars).  The
 * extra protection here is to permit application redefinition above
 * the default size.
 */

# 1 "/usr/include/sys/_types/_fd_setsize.h" 1 3 4
/*
 * Copyright (c) 2003-2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
# 194 "/usr/include/sys/types.h" 2 3 4
# 1 "/usr/include/sys/_types/_fd_set.h" 1 3 4
/*
 * Copyright (c) 2003-2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
# 195 "/usr/include/sys/types.h" 2 3 4
# 1 "/usr/include/sys/_types/_fd_clr.h" 1 3 4
/*
 * Copyright (c) 2003-2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
# 196 "/usr/include/sys/types.h" 2 3 4
# 1 "/usr/include/sys/_types/_fd_zero.h" 1 3 4
/*
 * Copyright (c) 2003-2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
# 197 "/usr/include/sys/types.h" 2 3 4
# 1 "/usr/include/sys/_types/_fd_isset.h" 1 3 4
/*
 * Copyright (c) 2003-2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
# 198 "/usr/include/sys/types.h" 2 3 4


# 1 "/usr/include/sys/_types/_fd_copy.h" 1 3 4
/*
 * Copyright (c) 2003-2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
# 201 "/usr/include/sys/types.h" 2 3 4
# 226 "/usr/include/sys/types.h" 3 4
/* statvfs and fstatvfs */


# 1 "/usr/include/sys/_types/_fsblkcnt_t.h" 1 3 4
/*
 * Copyright (c) 2003-2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */


typedef __darwin_fsblkcnt_t fsblkcnt_t;
# 229 "/usr/include/sys/types.h" 2 3 4
# 1 "/usr/include/sys/_types/_fsfilcnt_t.h" 1 3 4
/*
 * Copyright (c) 2003-2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */


typedef __darwin_fsfilcnt_t fsfilcnt_t;
# 230 "/usr/include/sys/types.h" 2 3 4
# 46 "/usr/include/nl_types.h" 2 3 4
# 89 "/usr/include/nl_types.h" 3 4
typedef struct __nl_cat_d {
 void *__data;
 int __size;
} *nl_catd;


# 1 "/usr/include/_types/_nl_item.h" 1 3 4
/*
 * Copyright (c) 2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */



typedef __darwin_nl_item nl_item;
# 95 "/usr/include/nl_types.h" 2 3 4

extern "C" {
nl_catd catopen(const char *, int);
char *catgets(nl_catd, int, int, const char *)
 __attribute__((__format_arg__(4)));
int catclose(nl_catd);
}
# 198 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/locale" 2 3






# 1 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/__undef_min_max" 1 3
// -*- C++ -*-
//===----------------------------------------------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is dual licensed under the MIT and the University of Illinois Open
// Source Licenses. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
# 205 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/locale" 2 3
# 208 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/locale" 3


namespace std {inline namespace __1 {
# 223 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/locale" 3
typedef std::__1::remove_pointer<locale_t>::type __locale_struct;
typedef std::__1::unique_ptr<__locale_struct, __typeof__(&freelocale)> __locale_unique_ptr;




// OSX has nice foo_l() functions that let you turn off use of the global
// locale.  Linux, not so much.  The following functions avoid the locale when
// that's possible and otherwise do the wrong thing.  FIXME.
# 408 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/locale" 3
// __scan_keyword
// Scans [__b, __e) until a match is found in the basic_strings range
//  [__kb, __ke) or until it can be shown that there is no match in [__kb, __ke).
//  __b will be incremented (visibly), consuming CharT until a match is found
//  or proved to not exist.  A keyword may be "", in which will match anything.
//  If one keyword is a prefix of another, and the next CharT in the input
//  might match another keyword, the algorithm will attempt to find the longest
//  matching keyword.  If the longer matching keyword ends up not matching, then
//  no keyword match is found.  If no keyword match is found, __ke is returned
//  and failbit is set in __err.
//  Else an iterator pointing to the matching keyword is found.  If more than
//  one keyword matches, an iterator to the first matching keyword is returned.
//  If on exit __b == __e, eofbit is set in __err.  If __case_sensitive is false,
//  __ct is used to force to lower case before comparing characters.
//  Examples:
//  Keywords:  "a", "abb"
//  If the input is "a", the first keyword matches and eofbit is set.
//  If the input is "abc", no match is found and "ab" are consumed.
template <class _InputIterator, class _ForwardIterator, class _Ctype>
__attribute__ ((__visibility__("hidden")))
_ForwardIterator
__scan_keyword(_InputIterator& __b, _InputIterator __e,
               _ForwardIterator __kb, _ForwardIterator __ke,
               const _Ctype& __ct, ios_base::iostate& __err,
               bool __case_sensitive = true)
{
    typedef typename iterator_traits<_InputIterator>::value_type _CharT;
    size_t __nkw = static_cast<size_t>(std::__1::distance(__kb, __ke));
    const unsigned char __doesnt_match = '\0';
    const unsigned char __might_match = '\1';
    const unsigned char __does_match = '\2';
    unsigned char __statbuf[100];
    unsigned char* __status = __statbuf;
    unique_ptr<unsigned char, void(*)(void*)> __stat_hold(0, free);
    if (__nkw > sizeof(__statbuf))
    {
        __status = (unsigned char*)malloc(__nkw);
        if (__status == 0)
            __throw_bad_alloc();
        __stat_hold.reset(__status);
    }
    size_t __n_might_match = __nkw; // At this point, any keyword might match
    size_t __n_does_match = 0; // but none of them definitely do
    // Initialize all statuses to __might_match, except for "" keywords are __does_match
    unsigned char* __st = __status;
    for (_ForwardIterator __ky = __kb; __ky != __ke; ++__ky, ++__st)
    {
        if (!__ky->empty())
            *__st = __might_match;
        else
        {
            *__st = __does_match;
            --__n_might_match;
            ++__n_does_match;
        }
    }
    // While there might be a match, test keywords against the next CharT
    for (size_t __indx = 0; __b != __e && __n_might_match > 0; ++__indx)
    {
        // Peek at the next CharT but don't consume it
        _CharT __c = *__b;
        if (!__case_sensitive)
            __c = __ct.toupper(__c);
        bool __consume = false;
        // For each keyword which might match, see if the __indx character is __c
        // If a match if found, consume __c
        // If a match is found, and that is the last character in the keyword,
        //    then that keyword matches.
        // If the keyword doesn't match this character, then change the keyword
        //    to doesn't match
        __st = __status;
        for (_ForwardIterator __ky = __kb; __ky != __ke; ++__ky, ++__st)
        {
            if (*__st == __might_match)
            {
                _CharT __kc = (*__ky)[__indx];
                if (!__case_sensitive)
                    __kc = __ct.toupper(__kc);
                if (__c == __kc)
                {
                    __consume = true;
                    if (__ky->size() == __indx+1)
                    {
                        *__st = __does_match;
                        --__n_might_match;
                        ++__n_does_match;
                    }
                }
                else
                {
                    *__st = __doesnt_match;
                    --__n_might_match;
                }
            }
        }
        // consume if we matched a character
        if (__consume)
        {
            ++__b;
            // If we consumed a character and there might be a matched keyword that
            //   was marked matched on a previous iteration, then such keywords
            //   which are now marked as not matching.
            if (__n_might_match + __n_does_match > 1)
            {
                __st = __status;
                for (_ForwardIterator __ky = __kb; __ky != __ke; ++__ky, ++__st)
                {
                    if (*__st == __does_match && __ky->size() != __indx+1)
                    {
                        *__st = __doesnt_match;
                        --__n_does_match;
                    }
                }
            }
        }
    }
    // We've exited the loop because we hit eof and/or we have no more "might matches".
    if (__b == __e)
        __err |= ios_base::eofbit;
    // Return the first matching result
    for (__st = __status; __kb != __ke; ++__kb, ++__st)
        if (*__st == __does_match)
            break;
    if (__kb == __ke)
        __err |= ios_base::failbit;
    return __kb;
}

struct __attribute__ ((__type_visibility__("default"))) __num_get_base
{
    static const int __num_get_buf_sz = 40;

    static int __get_base(ios_base&);
    static const char __src[33];
};

__attribute__ ((__visibility__("default")))
void __check_grouping(const string& __grouping, unsigned* __g, unsigned* __g_end,
                      ios_base::iostate& __err);

template <class _CharT>
struct __num_get
    : protected __num_get_base
{
    static string __stage2_int_prep(ios_base& __iob, _CharT* __atoms, _CharT& __thousands_sep);
    static string __stage2_float_prep(ios_base& __iob, _CharT* __atoms, _CharT& __decimal_point,
                                      _CharT& __thousands_sep);
    static int __stage2_int_loop(_CharT __ct, int __base, char* __a, char*& __a_end,
                  unsigned& __dc, _CharT __thousands_sep, const string& __grouping,
                  unsigned* __g, unsigned*& __g_end, _CharT* __atoms);
    static int __stage2_float_loop(_CharT __ct, bool& __in_units, char& __exp,
                                   char* __a, char*& __a_end,
                                   _CharT __decimal_point, _CharT __thousands_sep,
                                   const string& __grouping, unsigned* __g,
                                   unsigned*& __g_end, unsigned& __dc, _CharT* __atoms);
};

template <class _CharT>
string
__num_get<_CharT>::__stage2_int_prep(ios_base& __iob, _CharT* __atoms, _CharT& __thousands_sep)
{
    locale __loc = __iob.getloc();
    use_facet<ctype<_CharT> >(__loc).widen(__src, __src + 26, __atoms);
    const numpunct<_CharT>& __np = use_facet<numpunct<_CharT> >(__loc);
    __thousands_sep = __np.thousands_sep();
    return __np.grouping();
}

template <class _CharT>
string
__num_get<_CharT>::__stage2_float_prep(ios_base& __iob, _CharT* __atoms, _CharT& __decimal_point,
                    _CharT& __thousands_sep)
{
    locale __loc = __iob.getloc();
    use_facet<ctype<_CharT> >(__loc).widen(__src, __src + 32, __atoms);
    const numpunct<_CharT>& __np = use_facet<numpunct<_CharT> >(__loc);
    __decimal_point = __np.decimal_point();
    __thousands_sep = __np.thousands_sep();
    return __np.grouping();
}

template <class _CharT>
int
__num_get<_CharT>::__stage2_int_loop(_CharT __ct, int __base, char* __a, char*& __a_end,
                  unsigned& __dc, _CharT __thousands_sep, const string& __grouping,
                  unsigned* __g, unsigned*& __g_end, _CharT* __atoms)
{
    if (__a_end == __a && (__ct == __atoms[24] || __ct == __atoms[25]))
    {
        *__a_end++ = __ct == __atoms[24] ? '+' : '-';
        __dc = 0;
        return 0;
    }
    if (__grouping.size() != 0 && __ct == __thousands_sep)
    {
        if (__g_end-__g < __num_get_buf_sz)
        {
            *__g_end++ = __dc;
            __dc = 0;
        }
        return 0;
    }
    ptrdiff_t __f = find(__atoms, __atoms + 26, __ct) - __atoms;
    if (__f >= 24)
        return -1;
    switch (__base)
    {
    case 8:
    case 10:
        if (__f >= __base)
            return -1;
        break;
    case 16:
        if (__f < 22)
            break;
        if (__a_end != __a && __a_end - __a <= 2 && __a_end[-1] == '0')
        {
            __dc = 0;
            *__a_end++ = __src[__f];
            return 0;
        }
        return -1;
    }
    *__a_end++ = __src[__f];
    ++__dc;
    return 0;
}

template <class _CharT>
int
__num_get<_CharT>::__stage2_float_loop(_CharT __ct, bool& __in_units, char& __exp, char* __a, char*& __a_end,
                    _CharT __decimal_point, _CharT __thousands_sep, const string& __grouping,
                    unsigned* __g, unsigned*& __g_end, unsigned& __dc, _CharT* __atoms)
{
    if (__ct == __decimal_point)
    {
        if (!__in_units)
            return -1;
        __in_units = false;
        *__a_end++ = '.';
        if (__grouping.size() != 0 && __g_end-__g < __num_get_buf_sz)
            *__g_end++ = __dc;
        return 0;
    }
    if (__ct == __thousands_sep && __grouping.size() != 0)
    {
        if (!__in_units)
            return -1;
        if (__g_end-__g < __num_get_buf_sz)
        {
            *__g_end++ = __dc;
            __dc = 0;
        }
        return 0;
    }
    ptrdiff_t __f = find(__atoms, __atoms + 32, __ct) - __atoms;
    if (__f >= 32)
        return -1;
    char __x = __src[__f];
    if (__x == '-' || __x == '+')
    {
        if (__a_end == __a || (__a_end[-1] & 0x5F) == (__exp & 0x7F))
        {
            *__a_end++ = __x;
            return 0;
        }
        return -1;
    }
    if (__x == 'x' || __x == 'X')
        __exp = 'P';
    else if ((__x & 0x5F) == __exp)
    {
        __exp |= 0x80;
        if (__in_units)
        {
            __in_units = false;
            if (__grouping.size() != 0 && __g_end-__g < __num_get_buf_sz)
                *__g_end++ = __dc;
        }
    }
    *__a_end++ = __x;
    if (__f >= 22)
        return 0;
    ++__dc;
    return 0;
}

extern template struct __attribute__ ((__type_visibility__("default"))) __num_get<char>;
extern template struct __attribute__ ((__type_visibility__("default"))) __num_get<wchar_t>;

template <class _CharT, class _InputIterator = istreambuf_iterator<_CharT> >
class __attribute__ ((__type_visibility__("default"))) num_get
    : public locale::facet,
      private __num_get<_CharT>
{
public:
    typedef _CharT char_type;
    typedef _InputIterator iter_type;

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit num_get(size_t __refs = 0)
        : locale::facet(__refs) {}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,
                  ios_base::iostate& __err, bool& __v) const
    {
        return do_get(__b, __e, __iob, __err, __v);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,
                  ios_base::iostate& __err, long& __v) const
    {
        return do_get(__b, __e, __iob, __err, __v);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,
                  ios_base::iostate& __err, long long& __v) const
    {
        return do_get(__b, __e, __iob, __err, __v);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,
                  ios_base::iostate& __err, unsigned short& __v) const
    {
        return do_get(__b, __e, __iob, __err, __v);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,
                  ios_base::iostate& __err, unsigned int& __v) const
    {
        return do_get(__b, __e, __iob, __err, __v);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,
                  ios_base::iostate& __err, unsigned long& __v) const
    {
        return do_get(__b, __e, __iob, __err, __v);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,
                  ios_base::iostate& __err, unsigned long long& __v) const
    {
        return do_get(__b, __e, __iob, __err, __v);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,
                  ios_base::iostate& __err, float& __v) const
    {
        return do_get(__b, __e, __iob, __err, __v);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,
                  ios_base::iostate& __err, double& __v) const
    {
        return do_get(__b, __e, __iob, __err, __v);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,
                  ios_base::iostate& __err, long double& __v) const
    {
        return do_get(__b, __e, __iob, __err, __v);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,
                  ios_base::iostate& __err, void*& __v) const
    {
        return do_get(__b, __e, __iob, __err, __v);
    }

    static locale::id id;

protected:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    ~num_get() {}

    template <class _Fp>
    iter_type __do_get_floating_point
                            (iter_type __b, iter_type __e, ios_base& __iob,
                             ios_base::iostate& __err, _Fp& __v) const;

    template <class _Signed>
    iter_type __do_get_signed
                            (iter_type __b, iter_type __e, ios_base& __iob,
                             ios_base::iostate& __err, _Signed& __v) const;

    template <class _Unsigned>
    iter_type __do_get_unsigned
                            (iter_type __b, iter_type __e, ios_base& __iob,
                             ios_base::iostate& __err, _Unsigned& __v) const;


    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,
                             ios_base::iostate& __err, bool& __v) const;

    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,
                             ios_base::iostate& __err, long& __v) const
    { return this->__do_get_signed ( __b, __e, __iob, __err, __v ); }

    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,
                             ios_base::iostate& __err, long long& __v) const
    { return this->__do_get_signed ( __b, __e, __iob, __err, __v ); }

    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,
                             ios_base::iostate& __err, unsigned short& __v) const
    { return this->__do_get_unsigned ( __b, __e, __iob, __err, __v ); }

    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,
                             ios_base::iostate& __err, unsigned int& __v) const
    { return this->__do_get_unsigned ( __b, __e, __iob, __err, __v ); }

    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,
                             ios_base::iostate& __err, unsigned long& __v) const
    { return this->__do_get_unsigned ( __b, __e, __iob, __err, __v ); }

    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,
                             ios_base::iostate& __err, unsigned long long& __v) const
    { return this->__do_get_unsigned ( __b, __e, __iob, __err, __v ); }

    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,
                             ios_base::iostate& __err, float& __v) const
    { return this->__do_get_floating_point ( __b, __e, __iob, __err, __v ); }

    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,
                             ios_base::iostate& __err, double& __v) const
    { return this->__do_get_floating_point ( __b, __e, __iob, __err, __v ); }

    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,
                             ios_base::iostate& __err, long double& __v) const
    { return this->__do_get_floating_point ( __b, __e, __iob, __err, __v ); }

    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,
                             ios_base::iostate& __err, void*& __v) const;
};

template <class _CharT, class _InputIterator>
locale::id
num_get<_CharT, _InputIterator>::id;

template <class _Tp>
_Tp
__num_get_signed_integral(const char* __a, const char* __a_end,
                          ios_base::iostate& __err, int __base)
{
    if (__a != __a_end)
    {
        typename remove_reference<__typeof__((*__error()))>::type __save_errno = (*__error());
        (*__error()) = 0;
        char *__p2;
        long long __ll = strtoll_l(__a, &__p2, __base, 0);
        typename remove_reference<__typeof__((*__error()))>::type __current_errno = (*__error());
        if (__current_errno == 0)
            (*__error()) = __save_errno;
        if (__p2 != __a_end)
        {
            __err = ios_base::failbit;
            return 0;
        }
        else if (__current_errno == 34 ||
                 __ll < numeric_limits<_Tp>::min() ||
                 numeric_limits<_Tp>::max() < __ll)
        {
            __err = ios_base::failbit;
            if (__ll > 0)
                return numeric_limits<_Tp>::max();
            else
                return numeric_limits<_Tp>::min();
        }
        return static_cast<_Tp>(__ll);
    }
    __err = ios_base::failbit;
    return 0;
}

template <class _Tp>
_Tp
__num_get_unsigned_integral(const char* __a, const char* __a_end,
                            ios_base::iostate& __err, int __base)
{
    if (__a != __a_end)
    {
        if (*__a == '-')
        {
            __err = ios_base::failbit;
            return 0;
        }
        typename remove_reference<__typeof__((*__error()))>::type __save_errno = (*__error());
        (*__error()) = 0;
        char *__p2;
        unsigned long long __ll = strtoull_l(__a, &__p2, __base, 0);
        typename remove_reference<__typeof__((*__error()))>::type __current_errno = (*__error());
        if (__current_errno == 0)
            (*__error()) = __save_errno;
        if (__p2 != __a_end)
        {
            __err = ios_base::failbit;
            return 0;
        }
        else if (__current_errno == 34 ||
                 numeric_limits<_Tp>::max() < __ll)
        {
            __err = ios_base::failbit;
            return numeric_limits<_Tp>::max();
        }
        return static_cast<_Tp>(__ll);
    }
    __err = ios_base::failbit;
    return 0;
}

template <class _Tp>
_Tp
__num_get_float(const char* __a, const char* __a_end, ios_base::iostate& __err)
{
    if (__a != __a_end)
    {
        typename remove_reference<__typeof__((*__error()))>::type __save_errno = (*__error());
        (*__error()) = 0;
        char *__p2;
        long double __ld = strtold_l(__a, &__p2, 0);
        typename remove_reference<__typeof__((*__error()))>::type __current_errno = (*__error());
        if (__current_errno == 0)
            (*__error()) = __save_errno;
        if (__p2 != __a_end)
        {
            __err = ios_base::failbit;
            return 0;
        }
        else if (__current_errno == 34)
            __err = ios_base::failbit;
        return static_cast<_Tp>(__ld);
    }
    __err = ios_base::failbit;
    return 0;
}

template <class _CharT, class _InputIterator>
_InputIterator
num_get<_CharT, _InputIterator>::do_get(iter_type __b, iter_type __e,
                                        ios_base& __iob,
                                        ios_base::iostate& __err,
                                        bool& __v) const
{
    if ((__iob.flags() & ios_base::boolalpha) == 0)
    {
        long __lv = -1;
        __b = do_get(__b, __e, __iob, __err, __lv);
        switch (__lv)
        {
        case 0:
            __v = false;
            break;
        case 1:
            __v = true;
            break;
        default:
            __v = true;
            __err = ios_base::failbit;
            break;
        }
        return __b;
    }
    const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__iob.getloc());
    const numpunct<_CharT>& __np = use_facet<numpunct<_CharT> >(__iob.getloc());
    typedef typename numpunct<_CharT>::string_type string_type;
    const string_type __names[2] = {__np.truename(), __np.falsename()};
    const string_type* __i = __scan_keyword(__b, __e, __names, __names+2,
                                            __ct, __err);
    __v = __i == __names;
    return __b;
}

// signed

template <class _CharT, class _InputIterator>
template <class _Signed>
_InputIterator
num_get<_CharT, _InputIterator>::__do_get_signed(iter_type __b, iter_type __e,
                                        ios_base& __iob,
                                        ios_base::iostate& __err,
                                        _Signed& __v) const
{
    // Stage 1
    int __base = this->__get_base(__iob);
    // Stage 2
    char_type __atoms[26];
    char_type __thousands_sep;
    string __grouping = this->__stage2_int_prep(__iob, __atoms, __thousands_sep);
    string __buf;
    __buf.resize(__buf.capacity());
    char* __a = &__buf[0];
    char* __a_end = __a;
    unsigned __g[__num_get_base::__num_get_buf_sz];
    unsigned* __g_end = __g;
    unsigned __dc = 0;
    for (; __b != __e; ++__b)
    {
        if (__a_end == __a + __buf.size())
        {
            size_t __tmp = __buf.size();
            __buf.resize(2*__buf.size());
            __buf.resize(__buf.capacity());
            __a = &__buf[0];
            __a_end = __a + __tmp;
        }
        if (this->__stage2_int_loop(*__b, __base, __a, __a_end, __dc,
                                    __thousands_sep, __grouping, __g, __g_end,
                                    __atoms))
            break;
    }
    if (__grouping.size() != 0 && __g_end-__g < __num_get_base::__num_get_buf_sz)
        *__g_end++ = __dc;
    // Stage 3
    __v = __num_get_signed_integral<_Signed>(__a, __a_end, __err, __base);
    // Digit grouping checked
    __check_grouping(__grouping, __g, __g_end, __err);
    // EOF checked
    if (__b == __e)
        __err |= ios_base::eofbit;
    return __b;
}

// unsigned

template <class _CharT, class _InputIterator>
template <class _Unsigned>
_InputIterator
num_get<_CharT, _InputIterator>::__do_get_unsigned(iter_type __b, iter_type __e,
                                        ios_base& __iob,
                                        ios_base::iostate& __err,
                                        _Unsigned& __v) const
{
    // Stage 1
    int __base = this->__get_base(__iob);
    // Stage 2
    char_type __atoms[26];
    char_type __thousands_sep;
    string __grouping = this->__stage2_int_prep(__iob, __atoms, __thousands_sep);
    string __buf;
    __buf.resize(__buf.capacity());
    char* __a = &__buf[0];
    char* __a_end = __a;
    unsigned __g[__num_get_base::__num_get_buf_sz];
    unsigned* __g_end = __g;
    unsigned __dc = 0;
    for (; __b != __e; ++__b)
    {
        if (__a_end == __a + __buf.size())
        {
            size_t __tmp = __buf.size();
            __buf.resize(2*__buf.size());
            __buf.resize(__buf.capacity());
            __a = &__buf[0];
            __a_end = __a + __tmp;
        }
        if (this->__stage2_int_loop(*__b, __base, __a, __a_end, __dc,
                                    __thousands_sep, __grouping, __g, __g_end,
                                    __atoms))
            break;
    }
    if (__grouping.size() != 0 && __g_end-__g < __num_get_base::__num_get_buf_sz)
        *__g_end++ = __dc;
    // Stage 3
    __v = __num_get_unsigned_integral<_Unsigned>(__a, __a_end, __err, __base);
    // Digit grouping checked
    __check_grouping(__grouping, __g, __g_end, __err);
    // EOF checked
    if (__b == __e)
        __err |= ios_base::eofbit;
    return __b;
}

// floating point

template <class _CharT, class _InputIterator>
template <class _Fp>
_InputIterator
num_get<_CharT, _InputIterator>::__do_get_floating_point(iter_type __b, iter_type __e,
                                        ios_base& __iob,
                                        ios_base::iostate& __err,
                                        _Fp& __v) const
{
    // Stage 1, nothing to do
    // Stage 2
    char_type __atoms[32];
    char_type __decimal_point;
    char_type __thousands_sep;
    string __grouping = this->__stage2_float_prep(__iob, __atoms,
                                                  __decimal_point,
                                                  __thousands_sep);
    string __buf;
    __buf.resize(__buf.capacity());
    char* __a = &__buf[0];
    char* __a_end = __a;
    unsigned __g[__num_get_base::__num_get_buf_sz];
    unsigned* __g_end = __g;
    unsigned __dc = 0;
    bool __in_units = true;
    char __exp = 'E';
    for (; __b != __e; ++__b)
    {
        if (__a_end == __a + __buf.size())
        {
            size_t __tmp = __buf.size();
            __buf.resize(2*__buf.size());
            __buf.resize(__buf.capacity());
            __a = &__buf[0];
            __a_end = __a + __tmp;
        }
        if (this->__stage2_float_loop(*__b, __in_units, __exp, __a, __a_end,
                                      __decimal_point, __thousands_sep,
                                      __grouping, __g, __g_end,
                                      __dc, __atoms))
            break;
    }
    if (__grouping.size() != 0 && __in_units && __g_end-__g < __num_get_base::__num_get_buf_sz)
        *__g_end++ = __dc;
    // Stage 3
    __v = __num_get_float<_Fp>(__a, __a_end, __err);
    // Digit grouping checked
    __check_grouping(__grouping, __g, __g_end, __err);
    // EOF checked
    if (__b == __e)
        __err |= ios_base::eofbit;
    return __b;
}

template <class _CharT, class _InputIterator>
_InputIterator
num_get<_CharT, _InputIterator>::do_get(iter_type __b, iter_type __e,
                                        ios_base& __iob,
                                        ios_base::iostate& __err,
                                        void*& __v) const
{
    // Stage 1
    int __base = 16;
    // Stage 2
    char_type __atoms[26];
    char_type __thousands_sep = 0;
    string __grouping;
    use_facet<ctype<_CharT> >(__iob.getloc()).widen(__num_get_base::__src,
                                                    __num_get_base::__src + 26, __atoms);
    string __buf;
    __buf.resize(__buf.capacity());
    char* __a = &__buf[0];
    char* __a_end = __a;
    unsigned __g[__num_get_base::__num_get_buf_sz];
    unsigned* __g_end = __g;
    unsigned __dc = 0;
    for (; __b != __e; ++__b)
    {
        if (__a_end == __a + __buf.size())
        {
            size_t __tmp = __buf.size();
            __buf.resize(2*__buf.size());
            __buf.resize(__buf.capacity());
            __a = &__buf[0];
            __a_end = __a + __tmp;
        }
        if (this->__stage2_int_loop(*__b, __base, __a, __a_end, __dc,
                                    __thousands_sep, __grouping,
                                    __g, __g_end, __atoms))
            break;
    }
    // Stage 3
    __buf.resize(__a_end - __a);

    if (sscanf_l(__buf.c_str(), 0, "%p", &__v) != 1)



        __err = ios_base::failbit;
    // EOF checked
    if (__b == __e)
        __err |= ios_base::eofbit;
    return __b;
}

extern template class __attribute__ ((__type_visibility__("default"))) num_get<char>;
extern template class __attribute__ ((__type_visibility__("default"))) num_get<wchar_t>;

struct __attribute__ ((__type_visibility__("default"))) __num_put_base
{
protected:
    static void __format_int(char* __fmt, const char* __len, bool __signd,
                             ios_base::fmtflags __flags);
    static bool __format_float(char* __fmt, const char* __len,
                               ios_base::fmtflags __flags);
    static char* __identify_padding(char* __nb, char* __ne,
                                    const ios_base& __iob);
};

template <class _CharT>
struct __num_put
    : protected __num_put_base
{
    static void __widen_and_group_int(char* __nb, char* __np, char* __ne,
                                      _CharT* __ob, _CharT*& __op, _CharT*& __oe,
                                      const locale& __loc);
    static void __widen_and_group_float(char* __nb, char* __np, char* __ne,
                                        _CharT* __ob, _CharT*& __op, _CharT*& __oe,
                                        const locale& __loc);
};

template <class _CharT>
void
__num_put<_CharT>::__widen_and_group_int(char* __nb, char* __np, char* __ne,
                                         _CharT* __ob, _CharT*& __op, _CharT*& __oe,
                                         const locale& __loc)
{
    const ctype<_CharT>& __ct = use_facet<ctype<_CharT> > (__loc);
    const numpunct<_CharT>& __npt = use_facet<numpunct<_CharT> >(__loc);
    string __grouping = __npt.grouping();
    if (__grouping.empty())
    {
        __ct.widen(__nb, __ne, __ob);
        __oe = __ob + (__ne - __nb);
    }
    else
    {
        __oe = __ob;
        char* __nf = __nb;
        if (*__nf == '-' || *__nf == '+')
            *__oe++ = __ct.widen(*__nf++);
        if (__ne - __nf >= 2 && __nf[0] == '0' && (__nf[1] == 'x' ||
                                                   __nf[1] == 'X'))
        {
            *__oe++ = __ct.widen(*__nf++);
            *__oe++ = __ct.widen(*__nf++);
        }
        reverse(__nf, __ne);
        _CharT __thousands_sep = __npt.thousands_sep();
        unsigned __dc = 0;
        unsigned __dg = 0;
        for (char* __p = __nf; __p < __ne; ++__p)
        {
            if (static_cast<unsigned>(__grouping[__dg]) > 0 &&
                __dc == static_cast<unsigned>(__grouping[__dg]))
            {
                *__oe++ = __thousands_sep;
                __dc = 0;
                if (__dg < __grouping.size()-1)
                    ++__dg;
            }
            *__oe++ = __ct.widen(*__p);
            ++__dc;
        }
        reverse(__ob + (__nf - __nb), __oe);
    }
    if (__np == __ne)
        __op = __oe;
    else
        __op = __ob + (__np - __nb);
}

template <class _CharT>
void
__num_put<_CharT>::__widen_and_group_float(char* __nb, char* __np, char* __ne,
                                           _CharT* __ob, _CharT*& __op, _CharT*& __oe,
                                           const locale& __loc)
{
    const ctype<_CharT>& __ct = use_facet<ctype<_CharT> > (__loc);
    const numpunct<_CharT>& __npt = use_facet<numpunct<_CharT> >(__loc);
    string __grouping = __npt.grouping();
    __oe = __ob;
    char* __nf = __nb;
    if (*__nf == '-' || *__nf == '+')
        *__oe++ = __ct.widen(*__nf++);
    char* __ns;
    if (__ne - __nf >= 2 && __nf[0] == '0' && (__nf[1] == 'x' ||
                                               __nf[1] == 'X'))
    {
        *__oe++ = __ct.widen(*__nf++);
        *__oe++ = __ct.widen(*__nf++);
        for (__ns = __nf; __ns < __ne; ++__ns)
            if (!isxdigit_l(*__ns, 0))
                break;
    }
    else
    {
        for (__ns = __nf; __ns < __ne; ++__ns)
            if (!isdigit_l(*__ns, 0))
                break;
    }
    if (__grouping.empty())
    {
        __ct.widen(__nf, __ns, __oe);
        __oe += __ns - __nf;
    }
    else
    {
        reverse(__nf, __ns);
        _CharT __thousands_sep = __npt.thousands_sep();
        unsigned __dc = 0;
        unsigned __dg = 0;
        for (char* __p = __nf; __p < __ns; ++__p)
        {
            if (__grouping[__dg] > 0 && __dc == static_cast<unsigned>(__grouping[__dg]))
            {
                *__oe++ = __thousands_sep;
                __dc = 0;
                if (__dg < __grouping.size()-1)
                    ++__dg;
            }
            *__oe++ = __ct.widen(*__p);
            ++__dc;
        }
        reverse(__ob + (__nf - __nb), __oe);
    }
    for (__nf = __ns; __nf < __ne; ++__nf)
    {
        if (*__nf == '.')
        {
            *__oe++ = __npt.decimal_point();
            ++__nf;
            break;
        }
        else
            *__oe++ = __ct.widen(*__nf);
    }
    __ct.widen(__nf, __ne, __oe);
    __oe += __ne - __nf;
    if (__np == __ne)
        __op = __oe;
    else
        __op = __ob + (__np - __nb);
}

extern template struct __attribute__ ((__type_visibility__("default"))) __num_put<char>;
extern template struct __attribute__ ((__type_visibility__("default"))) __num_put<wchar_t>;

template <class _CharT, class _OutputIterator = ostreambuf_iterator<_CharT> >
class __attribute__ ((__type_visibility__("default"))) num_put
    : public locale::facet,
      private __num_put<_CharT>
{
public:
    typedef _CharT char_type;
    typedef _OutputIterator iter_type;

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit num_put(size_t __refs = 0)
        : locale::facet(__refs) {}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,
                  bool __v) const
    {
        return do_put(__s, __iob, __fl, __v);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,
                  long __v) const
    {
        return do_put(__s, __iob, __fl, __v);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,
                  long long __v) const
    {
        return do_put(__s, __iob, __fl, __v);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,
                  unsigned long __v) const
    {
        return do_put(__s, __iob, __fl, __v);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,
                  unsigned long long __v) const
    {
        return do_put(__s, __iob, __fl, __v);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,
                  double __v) const
    {
        return do_put(__s, __iob, __fl, __v);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,
                  long double __v) const
    {
        return do_put(__s, __iob, __fl, __v);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,
                  const void* __v) const
    {
        return do_put(__s, __iob, __fl, __v);
    }

    static locale::id id;

protected:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    ~num_put() {}

    virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,
                             bool __v) const;
    virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,
                             long __v) const;
    virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,
                             long long __v) const;
    virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,
                             unsigned long) const;
    virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,
                             unsigned long long) const;
    virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,
                             double __v) const;
    virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,
                             long double __v) const;
    virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,
                             const void* __v) const;
};

template <class _CharT, class _OutputIterator>
locale::id
num_put<_CharT, _OutputIterator>::id;

template <class _CharT, class _OutputIterator>
__attribute__ ((__visibility__("hidden")))
_OutputIterator
__pad_and_output(_OutputIterator __s,
                 const _CharT* __ob, const _CharT* __op, const _CharT* __oe,
                 ios_base& __iob, _CharT __fl)
{
    streamsize __sz = __oe - __ob;
    streamsize __ns = __iob.width();
    if (__ns > __sz)
        __ns -= __sz;
    else
        __ns = 0;
    for (;__ob < __op; ++__ob, ++__s)
        *__s = *__ob;
    for (; __ns; --__ns, ++__s)
        *__s = __fl;
    for (; __ob < __oe; ++__ob, ++__s)
        *__s = *__ob;
    __iob.width(0);
    return __s;
}





template <class _CharT, class _Traits>
__attribute__ ((__visibility__("hidden")))
ostreambuf_iterator<_CharT, _Traits>
__pad_and_output(ostreambuf_iterator<_CharT, _Traits> __s,
                 const _CharT* __ob, const _CharT* __op, const _CharT* __oe,
                 ios_base& __iob, _CharT __fl)
{
    if (__s.__sbuf_ == std::__1::__get_nullptr_t())
        return __s;
    streamsize __sz = __oe - __ob;
    streamsize __ns = __iob.width();
    if (__ns > __sz)
        __ns -= __sz;
    else
        __ns = 0;
    streamsize __np = __op - __ob;
    if (__np > 0)
    {
        if (__s.__sbuf_->sputn(__ob, __np) != __np)
        {
            __s.__sbuf_ = std::__1::__get_nullptr_t();
            return __s;
        }
    }
    if (__ns > 0)
    {
        basic_string<_CharT, _Traits> __sp(__ns, __fl);
        if (__s.__sbuf_->sputn(__sp.data(), __ns) != __ns)
        {
            __s.__sbuf_ = std::__1::__get_nullptr_t();
            return __s;
        }
    }
    __np = __oe - __op;
    if (__np > 0)
    {
        if (__s.__sbuf_->sputn(__op, __np) != __np)
        {
            __s.__sbuf_ = std::__1::__get_nullptr_t();
            return __s;
        }
    }
    __iob.width(0);
    return __s;
}



template <class _CharT, class _OutputIterator>
_OutputIterator
num_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob,
                                         char_type __fl, bool __v) const
{
    if ((__iob.flags() & ios_base::boolalpha) == 0)
        return do_put(__s, __iob, __fl, (unsigned long)__v);
    const numpunct<char_type>& __np = use_facet<numpunct<char_type> >(__iob.getloc());
    typedef typename numpunct<char_type>::string_type string_type;




    string_type __nm = __v ? __np.truename() : __np.falsename();

    for (typename string_type::iterator __i = __nm.begin(); __i != __nm.end(); ++__i, ++__s)
        *__s = *__i;
    return __s;
}

template <class _CharT, class _OutputIterator>
_OutputIterator
num_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob,
                                         char_type __fl, long __v) const
{
    // Stage 1 - Get number in narrow char
    char __fmt[6] = {'%', 0};
    const char* __len = "l";
    this->__format_int(__fmt+1, __len, true, __iob.flags());
    const unsigned __nbuf = (numeric_limits<long>::digits / 3)
                          + ((numeric_limits<long>::digits % 3) != 0)
                          + 1;
    char __nar[__nbuf];

    int __nc = snprintf_l(__nar, sizeof(__nar), 0, __fmt, __v);



    char* __ne = __nar + __nc;
    char* __np = this->__identify_padding(__nar, __ne, __iob);
    // Stage 2 - Widen __nar while adding thousands separators
    char_type __o[2*(__nbuf-1) - 1];
    char_type* __op; // pad here
    char_type* __oe; // end of output
    this->__widen_and_group_int(__nar, __np, __ne, __o, __op, __oe, __iob.getloc());
    // [__o, __oe) contains thousands_sep'd wide number
    // Stage 3 & 4
    return __pad_and_output(__s, __o, __op, __oe, __iob, __fl);
}

template <class _CharT, class _OutputIterator>
_OutputIterator
num_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob,
                                         char_type __fl, long long __v) const
{
    // Stage 1 - Get number in narrow char
    char __fmt[8] = {'%', 0};
    const char* __len = "ll";
    this->__format_int(__fmt+1, __len, true, __iob.flags());
    const unsigned __nbuf = (numeric_limits<long long>::digits / 3)
                          + ((numeric_limits<long long>::digits % 3) != 0)
                          + 1;
    char __nar[__nbuf];

    int __nc = snprintf_l(__nar, sizeof(__nar), 0, __fmt, __v);



    char* __ne = __nar + __nc;
    char* __np = this->__identify_padding(__nar, __ne, __iob);
    // Stage 2 - Widen __nar while adding thousands separators
    char_type __o[2*(__nbuf-1) - 1];
    char_type* __op; // pad here
    char_type* __oe; // end of output
    this->__widen_and_group_int(__nar, __np, __ne, __o, __op, __oe, __iob.getloc());
    // [__o, __oe) contains thousands_sep'd wide number
    // Stage 3 & 4
    return __pad_and_output(__s, __o, __op, __oe, __iob, __fl);
}

template <class _CharT, class _OutputIterator>
_OutputIterator
num_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob,
                                         char_type __fl, unsigned long __v) const
{
    // Stage 1 - Get number in narrow char
    char __fmt[6] = {'%', 0};
    const char* __len = "l";
    this->__format_int(__fmt+1, __len, false, __iob.flags());
    const unsigned __nbuf = (numeric_limits<unsigned long>::digits / 3)
                          + ((numeric_limits<unsigned long>::digits % 3) != 0)
                          + 1;
    char __nar[__nbuf];

    int __nc = snprintf_l(__nar, sizeof(__nar), 0, __fmt, __v);



    char* __ne = __nar + __nc;
    char* __np = this->__identify_padding(__nar, __ne, __iob);
    // Stage 2 - Widen __nar while adding thousands separators
    char_type __o[2*(__nbuf-1) - 1];
    char_type* __op; // pad here
    char_type* __oe; // end of output
    this->__widen_and_group_int(__nar, __np, __ne, __o, __op, __oe, __iob.getloc());
    // [__o, __oe) contains thousands_sep'd wide number
    // Stage 3 & 4
    return __pad_and_output(__s, __o, __op, __oe, __iob, __fl);
}

template <class _CharT, class _OutputIterator>
_OutputIterator
num_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob,
                                         char_type __fl, unsigned long long __v) const
{
    // Stage 1 - Get number in narrow char
    char __fmt[8] = {'%', 0};
    const char* __len = "ll";
    this->__format_int(__fmt+1, __len, false, __iob.flags());
    const unsigned __nbuf = (numeric_limits<unsigned long long>::digits / 3)
                          + ((numeric_limits<unsigned long long>::digits % 3) != 0)
                          + 1;
    char __nar[__nbuf];

    int __nc = snprintf_l(__nar, sizeof(__nar), 0, __fmt, __v);



    char* __ne = __nar + __nc;
    char* __np = this->__identify_padding(__nar, __ne, __iob);
    // Stage 2 - Widen __nar while adding thousands separators
    char_type __o[2*(__nbuf-1) - 1];
    char_type* __op; // pad here
    char_type* __oe; // end of output
    this->__widen_and_group_int(__nar, __np, __ne, __o, __op, __oe, __iob.getloc());
    // [__o, __oe) contains thousands_sep'd wide number
    // Stage 3 & 4
    return __pad_and_output(__s, __o, __op, __oe, __iob, __fl);
}

template <class _CharT, class _OutputIterator>
_OutputIterator
num_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob,
                                         char_type __fl, double __v) const
{
    // Stage 1 - Get number in narrow char
    char __fmt[8] = {'%', 0};
    const char* __len = "";
    bool __specify_precision = this->__format_float(__fmt+1, __len, __iob.flags());
    const unsigned __nbuf = 30;
    char __nar[__nbuf];
    char* __nb = __nar;
    int __nc;
    if (__specify_precision)

        __nc = snprintf_l(__nb, __nbuf, 0, __fmt,
                                   (int)__iob.precision(), __v);




    else

        __nc = snprintf_l(__nb, __nbuf, 0, __fmt, __v);



    unique_ptr<char, void(*)(void*)> __nbh(0, free);
    if (__nc > static_cast<int>(__nbuf-1))
    {
        if (__specify_precision)

            __nc = asprintf_l(&__nb, 0, __fmt, (int)__iob.precision(), __v);




        else

            __nc = asprintf_l(&__nb, 0, __fmt, __v);



        if (__nb == 0)
            __throw_bad_alloc();
        __nbh.reset(__nb);
    }
    char* __ne = __nb + __nc;
    char* __np = this->__identify_padding(__nb, __ne, __iob);
    // Stage 2 - Widen __nar while adding thousands separators
    char_type __o[2*(__nbuf-1) - 1];
    char_type* __ob = __o;
    unique_ptr<char_type, void(*)(void*)> __obh(0, free);
    if (__nb != __nar)
    {
        __ob = (char_type*)malloc(2*static_cast<size_t>(__nc)*sizeof(char_type));
        if (__ob == 0)
            __throw_bad_alloc();
        __obh.reset(__ob);
    }
    char_type* __op; // pad here
    char_type* __oe; // end of output
    this->__widen_and_group_float(__nb, __np, __ne, __ob, __op, __oe, __iob.getloc());
    // [__o, __oe) contains thousands_sep'd wide number
    // Stage 3 & 4
    __s = __pad_and_output(__s, __ob, __op, __oe, __iob, __fl);
    return __s;
}

template <class _CharT, class _OutputIterator>
_OutputIterator
num_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob,
                                         char_type __fl, long double __v) const
{
    // Stage 1 - Get number in narrow char
    char __fmt[8] = {'%', 0};
    const char* __len = "L";
    bool __specify_precision = this->__format_float(__fmt+1, __len, __iob.flags());
    const unsigned __nbuf = 30;
    char __nar[__nbuf];
    char* __nb = __nar;
    int __nc;
    if (__specify_precision)

        __nc = snprintf_l(__nb, __nbuf, 0, __fmt,
                                   (int)__iob.precision(), __v);




    else

        __nc = snprintf_l(__nb, __nbuf, 0, __fmt, __v);



    unique_ptr<char, void(*)(void*)> __nbh(0, free);
    if (__nc > static_cast<int>(__nbuf-1))
    {
        if (__specify_precision)

            __nc = asprintf_l(&__nb, 0, __fmt, (int)__iob.precision(), __v);




        else

            __nc = asprintf_l(&__nb, 0, __fmt, __v);



        if (__nb == 0)
            __throw_bad_alloc();
        __nbh.reset(__nb);
    }
    char* __ne = __nb + __nc;
    char* __np = this->__identify_padding(__nb, __ne, __iob);
    // Stage 2 - Widen __nar while adding thousands separators
    char_type __o[2*(__nbuf-1) - 1];
    char_type* __ob = __o;
    unique_ptr<char_type, void(*)(void*)> __obh(0, free);
    if (__nb != __nar)
    {
        __ob = (char_type*)malloc(2*static_cast<size_t>(__nc)*sizeof(char_type));
        if (__ob == 0)
            __throw_bad_alloc();
        __obh.reset(__ob);
    }
    char_type* __op; // pad here
    char_type* __oe; // end of output
    this->__widen_and_group_float(__nb, __np, __ne, __ob, __op, __oe, __iob.getloc());
    // [__o, __oe) contains thousands_sep'd wide number
    // Stage 3 & 4
    __s = __pad_and_output(__s, __ob, __op, __oe, __iob, __fl);
    return __s;
}

template <class _CharT, class _OutputIterator>
_OutputIterator
num_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob,
                                         char_type __fl, const void* __v) const
{
    // Stage 1 - Get pointer in narrow char
    char __fmt[6] = "%p";
    const unsigned __nbuf = 20;
    char __nar[__nbuf];

    int __nc = snprintf_l(__nar, sizeof(__nar), 0, __fmt, __v);



    char* __ne = __nar + __nc;
    char* __np = this->__identify_padding(__nar, __ne, __iob);
    // Stage 2 - Widen __nar
    char_type __o[2*(__nbuf-1) - 1];
    char_type* __op; // pad here
    char_type* __oe; // end of output
    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__iob.getloc());
    __ct.widen(__nar, __ne, __o);
    __oe = __o + (__ne - __nar);
    if (__np == __ne)
        __op = __oe;
    else
        __op = __o + (__np - __nar);
    // [__o, __oe) contains wide number
    // Stage 3 & 4
    return __pad_and_output(__s, __o, __op, __oe, __iob, __fl);
}

extern template class __attribute__ ((__type_visibility__("default"))) num_put<char>;
extern template class __attribute__ ((__type_visibility__("default"))) num_put<wchar_t>;

template <class _CharT, class _InputIterator>
__attribute__ ((__visibility__("hidden")))
int
__get_up_to_n_digits(_InputIterator& __b, _InputIterator __e,
                     ios_base::iostate& __err, const ctype<_CharT>& __ct, int __n)
{
    // Precondition:  __n >= 1
    if (__b == __e)
    {
        __err |= ios_base::eofbit | ios_base::failbit;
        return 0;
    }
    // get first digit
    _CharT __c = *__b;
    if (!__ct.is(ctype_base::digit, __c))
    {
        __err |= ios_base::failbit;
        return 0;
    }
    int __r = __ct.narrow(__c, 0) - '0';
    for (++__b, --__n; __b != __e && __n > 0; ++__b, --__n)
    {
        // get next digit
        __c = *__b;
        if (!__ct.is(ctype_base::digit, __c))
            return __r;
        __r = __r * 10 + __ct.narrow(__c, 0) - '0';
    }
    if (__b == __e)
        __err |= ios_base::eofbit;
    return __r;
}

class __attribute__ ((__type_visibility__("default"))) time_base
{
public:
    enum dateorder {no_order, dmy, mdy, ymd, ydm};
};

template <class _CharT>
class __attribute__ ((__type_visibility__("default"))) __time_get_c_storage
{
protected:
    typedef basic_string<_CharT> string_type;

    virtual const string_type* __weeks() const;
    virtual const string_type* __months() const;
    virtual const string_type* __am_pm() const;
    virtual const string_type& __c() const;
    virtual const string_type& __r() const;
    virtual const string_type& __x() const;
    virtual const string_type& __X() const;
};

template <class _CharT, class _InputIterator = istreambuf_iterator<_CharT> >
class __attribute__ ((__type_visibility__("default"))) time_get
    : public locale::facet,
      public time_base,
      private __time_get_c_storage<_CharT>
{
public:
    typedef _CharT char_type;
    typedef _InputIterator iter_type;
    typedef time_base::dateorder dateorder;
    typedef basic_string<char_type> string_type;

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit time_get(size_t __refs = 0)
        : locale::facet(__refs) {}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    dateorder date_order() const
    {
        return this->do_date_order();
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iter_type get_time(iter_type __b, iter_type __e, ios_base& __iob,
                       ios_base::iostate& __err, tm* __tm) const
    {
        return do_get_time(__b, __e, __iob, __err, __tm);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iter_type get_date(iter_type __b, iter_type __e, ios_base& __iob,
                       ios_base::iostate& __err, tm* __tm) const
    {
        return do_get_date(__b, __e, __iob, __err, __tm);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iter_type get_weekday(iter_type __b, iter_type __e, ios_base& __iob,
                          ios_base::iostate& __err, tm* __tm) const
    {
        return do_get_weekday(__b, __e, __iob, __err, __tm);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iter_type get_monthname(iter_type __b, iter_type __e, ios_base& __iob,
                            ios_base::iostate& __err, tm* __tm) const
    {
        return do_get_monthname(__b, __e, __iob, __err, __tm);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iter_type get_year(iter_type __b, iter_type __e, ios_base& __iob,
                       ios_base::iostate& __err, tm* __tm) const
    {
        return do_get_year(__b, __e, __iob, __err, __tm);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,
                  ios_base::iostate& __err, tm *__tm,
                  char __fmt, char __mod = 0) const
    {
        return do_get(__b, __e, __iob, __err, __tm, __fmt, __mod);
    }

    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,
                  ios_base::iostate& __err, tm* __tm,
                  const char_type* __fmtb, const char_type* __fmte) const;

    static locale::id id;

protected:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    ~time_get() {}

    virtual dateorder do_date_order() const;
    virtual iter_type do_get_time(iter_type __b, iter_type __e, ios_base& __iob,
                                  ios_base::iostate& __err, tm* __tm) const;
    virtual iter_type do_get_date(iter_type __b, iter_type __e, ios_base& __iob,
                                  ios_base::iostate& __err, tm* __tm) const;
    virtual iter_type do_get_weekday(iter_type __b, iter_type __e, ios_base& __iob,
                                     ios_base::iostate& __err, tm* __tm) const;
    virtual iter_type do_get_monthname(iter_type __b, iter_type __e, ios_base& __iob,
                                       ios_base::iostate& __err, tm* __tm) const;
    virtual iter_type do_get_year(iter_type __b, iter_type __e, ios_base& __iob,
                                  ios_base::iostate& __err, tm* __tm) const;
    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,
                             ios_base::iostate& __err, tm* __tm,
                             char __fmt, char __mod) const;
private:
    void __get_white_space(iter_type& __b, iter_type __e,
                           ios_base::iostate& __err, const ctype<char_type>& __ct) const;
    void __get_percent(iter_type& __b, iter_type __e, ios_base::iostate& __err,
                       const ctype<char_type>& __ct) const;

    void __get_weekdayname(int& __m,
                           iter_type& __b, iter_type __e,
                           ios_base::iostate& __err,
                           const ctype<char_type>& __ct) const;
    void __get_monthname(int& __m,
                         iter_type& __b, iter_type __e,
                         ios_base::iostate& __err,
                         const ctype<char_type>& __ct) const;
    void __get_day(int& __d,
                   iter_type& __b, iter_type __e,
                   ios_base::iostate& __err,
                   const ctype<char_type>& __ct) const;
    void __get_month(int& __m,
                     iter_type& __b, iter_type __e,
                     ios_base::iostate& __err,
                     const ctype<char_type>& __ct) const;
    void __get_year(int& __y,
                   iter_type& __b, iter_type __e,
                   ios_base::iostate& __err,
                   const ctype<char_type>& __ct) const;
    void __get_year4(int& __y,
                    iter_type& __b, iter_type __e,
                    ios_base::iostate& __err,
                    const ctype<char_type>& __ct) const;
    void __get_hour(int& __d,
                    iter_type& __b, iter_type __e,
                    ios_base::iostate& __err,
                    const ctype<char_type>& __ct) const;
    void __get_12_hour(int& __h,
                       iter_type& __b, iter_type __e,
                       ios_base::iostate& __err,
                       const ctype<char_type>& __ct) const;
    void __get_am_pm(int& __h,
                     iter_type& __b, iter_type __e,
                     ios_base::iostate& __err,
                     const ctype<char_type>& __ct) const;
    void __get_minute(int& __m,
                      iter_type& __b, iter_type __e,
                      ios_base::iostate& __err,
                      const ctype<char_type>& __ct) const;
    void __get_second(int& __s,
                      iter_type& __b, iter_type __e,
                      ios_base::iostate& __err,
                      const ctype<char_type>& __ct) const;
    void __get_weekday(int& __w,
                       iter_type& __b, iter_type __e,
                       ios_base::iostate& __err,
                       const ctype<char_type>& __ct) const;
    void __get_day_year_num(int& __w,
                            iter_type& __b, iter_type __e,
                            ios_base::iostate& __err,
                            const ctype<char_type>& __ct) const;
};

template <class _CharT, class _InputIterator>
locale::id
time_get<_CharT, _InputIterator>::id;

// time_get primitives

template <class _CharT, class _InputIterator>
void
time_get<_CharT, _InputIterator>::__get_weekdayname(int& __w,
                                                    iter_type& __b, iter_type __e,
                                                    ios_base::iostate& __err,
                                                    const ctype<char_type>& __ct) const
{
    // Note:  ignoring case comes from the POSIX strptime spec
    const string_type* __wk = this->__weeks();
    ptrdiff_t __i = __scan_keyword(__b, __e, __wk, __wk+14, __ct, __err, false) - __wk;
    if (__i < 14)
        __w = __i % 7;
}

template <class _CharT, class _InputIterator>
void
time_get<_CharT, _InputIterator>::__get_monthname(int& __m,
                                                  iter_type& __b, iter_type __e,
                                                  ios_base::iostate& __err,
                                                  const ctype<char_type>& __ct) const
{
    // Note:  ignoring case comes from the POSIX strptime spec
    const string_type* __month = this->__months();
    ptrdiff_t __i = __scan_keyword(__b, __e, __month, __month+24, __ct, __err, false) - __month;
    if (__i < 24)
        __m = __i % 12;
}

template <class _CharT, class _InputIterator>
void
time_get<_CharT, _InputIterator>::__get_day(int& __d,
                                            iter_type& __b, iter_type __e,
                                            ios_base::iostate& __err,
                                            const ctype<char_type>& __ct) const
{
    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 2);
    if (!(__err & ios_base::failbit) && 1 <= __t && __t <= 31)
        __d = __t;
    else
        __err |= ios_base::failbit;
}

template <class _CharT, class _InputIterator>
void
time_get<_CharT, _InputIterator>::__get_month(int& __m,
                                              iter_type& __b, iter_type __e,
                                              ios_base::iostate& __err,
                                              const ctype<char_type>& __ct) const
{
    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 2) - 1;
    if (!(__err & ios_base::failbit) && __t <= 11)
        __m = __t;
    else
        __err |= ios_base::failbit;
}

template <class _CharT, class _InputIterator>
void
time_get<_CharT, _InputIterator>::__get_year(int& __y,
                                             iter_type& __b, iter_type __e,
                                             ios_base::iostate& __err,
                                             const ctype<char_type>& __ct) const
{
    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 4);
    if (!(__err & ios_base::failbit))
    {
        if (__t < 69)
            __t += 2000;
        else if (69 <= __t && __t <= 99)
            __t += 1900;
        __y = __t - 1900;
    }
}

template <class _CharT, class _InputIterator>
void
time_get<_CharT, _InputIterator>::__get_year4(int& __y,
                                              iter_type& __b, iter_type __e,
                                              ios_base::iostate& __err,
                                              const ctype<char_type>& __ct) const
{
    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 4);
    if (!(__err & ios_base::failbit))
        __y = __t - 1900;
}

template <class _CharT, class _InputIterator>
void
time_get<_CharT, _InputIterator>::__get_hour(int& __h,
                                             iter_type& __b, iter_type __e,
                                             ios_base::iostate& __err,
                                             const ctype<char_type>& __ct) const
{
    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 2);
    if (!(__err & ios_base::failbit) && __t <= 23)
        __h = __t;
    else
        __err |= ios_base::failbit;
}

template <class _CharT, class _InputIterator>
void
time_get<_CharT, _InputIterator>::__get_12_hour(int& __h,
                                                iter_type& __b, iter_type __e,
                                                ios_base::iostate& __err,
                                                const ctype<char_type>& __ct) const
{
    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 2);
    if (!(__err & ios_base::failbit) && 1 <= __t && __t <= 12)
        __h = __t;
    else
        __err |= ios_base::failbit;
}

template <class _CharT, class _InputIterator>
void
time_get<_CharT, _InputIterator>::__get_minute(int& __m,
                                               iter_type& __b, iter_type __e,
                                               ios_base::iostate& __err,
                                               const ctype<char_type>& __ct) const
{
    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 2);
    if (!(__err & ios_base::failbit) && __t <= 59)
        __m = __t;
    else
        __err |= ios_base::failbit;
}

template <class _CharT, class _InputIterator>
void
time_get<_CharT, _InputIterator>::__get_second(int& __s,
                                               iter_type& __b, iter_type __e,
                                               ios_base::iostate& __err,
                                               const ctype<char_type>& __ct) const
{
    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 2);
    if (!(__err & ios_base::failbit) && __t <= 60)
        __s = __t;
    else
        __err |= ios_base::failbit;
}

template <class _CharT, class _InputIterator>
void
time_get<_CharT, _InputIterator>::__get_weekday(int& __w,
                                                iter_type& __b, iter_type __e,
                                                ios_base::iostate& __err,
                                                const ctype<char_type>& __ct) const
{
    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 1);
    if (!(__err & ios_base::failbit) && __t <= 6)
        __w = __t;
    else
        __err |= ios_base::failbit;
}

template <class _CharT, class _InputIterator>
void
time_get<_CharT, _InputIterator>::__get_day_year_num(int& __d,
                                                     iter_type& __b, iter_type __e,
                                                     ios_base::iostate& __err,
                                                     const ctype<char_type>& __ct) const
{
    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 3);
    if (!(__err & ios_base::failbit) && __t <= 365)
        __d = __t;
    else
        __err |= ios_base::failbit;
}

template <class _CharT, class _InputIterator>
void
time_get<_CharT, _InputIterator>::__get_white_space(iter_type& __b, iter_type __e,
                                                    ios_base::iostate& __err,
                                                    const ctype<char_type>& __ct) const
{
    for (; __b != __e && __ct.is(ctype_base::space, *__b); ++__b)
        ;
    if (__b == __e)
        __err |= ios_base::eofbit;
}

template <class _CharT, class _InputIterator>
void
time_get<_CharT, _InputIterator>::__get_am_pm(int& __h,
                                              iter_type& __b, iter_type __e,
                                              ios_base::iostate& __err,
                                              const ctype<char_type>& __ct) const
{
    const string_type* __ap = this->__am_pm();
    if (__ap[0].size() + __ap[1].size() == 0)
    {
        __err |= ios_base::failbit;
        return;
    }
    ptrdiff_t __i = __scan_keyword(__b, __e, __ap, __ap+2, __ct, __err, false) - __ap;
    if (__i == 0 && __h == 12)
        __h = 0;
    else if (__i == 1 && __h < 12)
        __h += 12;
}

template <class _CharT, class _InputIterator>
void
time_get<_CharT, _InputIterator>::__get_percent(iter_type& __b, iter_type __e,
                                                ios_base::iostate& __err,
                                                const ctype<char_type>& __ct) const
{
    if (__b == __e)
    {
        __err |= ios_base::eofbit | ios_base::failbit;
        return;
    }
    if (__ct.narrow(*__b, 0) != '%')
        __err |= ios_base::failbit;
    else if(++__b == __e)
        __err |= ios_base::eofbit;
}

// time_get end primitives

template <class _CharT, class _InputIterator>
_InputIterator
time_get<_CharT, _InputIterator>::get(iter_type __b, iter_type __e,
                                      ios_base& __iob,
                                      ios_base::iostate& __err, tm* __tm,
                                      const char_type* __fmtb, const char_type* __fmte) const
{
    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__iob.getloc());
    __err = ios_base::goodbit;
    while (__fmtb != __fmte && __err == ios_base::goodbit)
    {
        if (__b == __e)
        {
            __err = ios_base::failbit;
            break;
        }
        if (__ct.narrow(*__fmtb, 0) == '%')
        {
            if (++__fmtb == __fmte)
            {
                __err = ios_base::failbit;
                break;
            }
            char __cmd = __ct.narrow(*__fmtb, 0);
            char __opt = '\0';
            if (__cmd == 'E' || __cmd == '0')
            {
                if (++__fmtb == __fmte)
                {
                    __err = ios_base::failbit;
                    break;
                }
                __opt = __cmd;
                __cmd = __ct.narrow(*__fmtb, 0);
            }
            __b = do_get(__b, __e, __iob, __err, __tm, __cmd, __opt);
            ++__fmtb;
        }
        else if (__ct.is(ctype_base::space, *__fmtb))
        {
            for (++__fmtb; __fmtb != __fmte && __ct.is(ctype_base::space, *__fmtb); ++__fmtb)
                ;
            for ( ; __b != __e && __ct.is(ctype_base::space, *__b); ++__b)
                ;
        }
        else if (__ct.toupper(*__b) == __ct.toupper(*__fmtb))
        {
            ++__b;
            ++__fmtb;
        }
        else
            __err = ios_base::failbit;
    }
    if (__b == __e)
        __err |= ios_base::eofbit;
    return __b;
}

template <class _CharT, class _InputIterator>
typename time_get<_CharT, _InputIterator>::dateorder
time_get<_CharT, _InputIterator>::do_date_order() const
{
    return mdy;
}

template <class _CharT, class _InputIterator>
_InputIterator
time_get<_CharT, _InputIterator>::do_get_time(iter_type __b, iter_type __e,
                                              ios_base& __iob,
                                              ios_base::iostate& __err,
                                              tm* __tm) const
{
    const char_type __fmt[] = {'%', 'H', ':', '%', 'M', ':', '%', 'S'};
    return get(__b, __e, __iob, __err, __tm, __fmt, __fmt + sizeof(__fmt)/sizeof(__fmt[0]));
}

template <class _CharT, class _InputIterator>
_InputIterator
time_get<_CharT, _InputIterator>::do_get_date(iter_type __b, iter_type __e,
                                              ios_base& __iob,
                                              ios_base::iostate& __err,
                                              tm* __tm) const
{
    const string_type& __fmt = this->__x();
    return get(__b, __e, __iob, __err, __tm, __fmt.data(), __fmt.data() + __fmt.size());
}

template <class _CharT, class _InputIterator>
_InputIterator
time_get<_CharT, _InputIterator>::do_get_weekday(iter_type __b, iter_type __e,
                                                 ios_base& __iob,
                                                 ios_base::iostate& __err,
                                                 tm* __tm) const
{
    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__iob.getloc());
    __get_weekdayname(__tm->tm_wday, __b, __e, __err, __ct);
    return __b;
}

template <class _CharT, class _InputIterator>
_InputIterator
time_get<_CharT, _InputIterator>::do_get_monthname(iter_type __b, iter_type __e,
                                                   ios_base& __iob,
                                                   ios_base::iostate& __err,
                                                   tm* __tm) const
{
    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__iob.getloc());
    __get_monthname(__tm->tm_mon, __b, __e, __err, __ct);
    return __b;
}

template <class _CharT, class _InputIterator>
_InputIterator
time_get<_CharT, _InputIterator>::do_get_year(iter_type __b, iter_type __e,
                                              ios_base& __iob,
                                              ios_base::iostate& __err,
                                              tm* __tm) const
{
    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__iob.getloc());
    __get_year(__tm->tm_year, __b, __e, __err, __ct);
    return __b;
}

template <class _CharT, class _InputIterator>
_InputIterator
time_get<_CharT, _InputIterator>::do_get(iter_type __b, iter_type __e,
                                         ios_base& __iob,
                                         ios_base::iostate& __err, tm* __tm,
                                         char __fmt, char) const
{
    __err = ios_base::goodbit;
    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__iob.getloc());
    switch (__fmt)
    {
    case 'a':
    case 'A':
        __get_weekdayname(__tm->tm_wday, __b, __e, __err, __ct);
        break;
    case 'b':
    case 'B':
    case 'h':
        __get_monthname(__tm->tm_mon, __b, __e, __err, __ct);
        break;
    case 'c':
        {
        const string_type& __fm = this->__c();
        __b = get(__b, __e, __iob, __err, __tm, __fm.data(), __fm.data() + __fm.size());
        }
        break;
    case 'd':
    case 'e':
        __get_day(__tm->tm_mday, __b, __e, __err, __ct);
        break;
    case 'D':
        {
        const char_type __fm[] = {'%', 'm', '/', '%', 'd', '/', '%', 'y'};
        __b = get(__b, __e, __iob, __err, __tm, __fm, __fm + sizeof(__fm)/sizeof(__fm[0]));
        }
        break;
    case 'F':
        {
        const char_type __fm[] = {'%', 'Y', '-', '%', 'm', '-', '%', 'd'};
        __b = get(__b, __e, __iob, __err, __tm, __fm, __fm + sizeof(__fm)/sizeof(__fm[0]));
        }
        break;
    case 'H':
        __get_hour(__tm->tm_hour, __b, __e, __err, __ct);
        break;
    case 'I':
        __get_12_hour(__tm->tm_hour, __b, __e, __err, __ct);
        break;
    case 'j':
        __get_day_year_num(__tm->tm_yday, __b, __e, __err, __ct);
        break;
    case 'm':
        __get_month(__tm->tm_mon, __b, __e, __err, __ct);
        break;
    case 'M':
        __get_minute(__tm->tm_min, __b, __e, __err, __ct);
        break;
    case 'n':
    case 't':
        __get_white_space(__b, __e, __err, __ct);
        break;
    case 'p':
        __get_am_pm(__tm->tm_hour, __b, __e, __err, __ct);
        break;
    case 'r':
        {
        const char_type __fm[] = {'%', 'I', ':', '%', 'M', ':', '%', 'S', ' ', '%', 'p'};
        __b = get(__b, __e, __iob, __err, __tm, __fm, __fm + sizeof(__fm)/sizeof(__fm[0]));
        }
        break;
    case 'R':
        {
        const char_type __fm[] = {'%', 'H', ':', '%', 'M'};
        __b = get(__b, __e, __iob, __err, __tm, __fm, __fm + sizeof(__fm)/sizeof(__fm[0]));
        }
        break;
    case 'S':
        __get_second(__tm->tm_sec, __b, __e, __err, __ct);
        break;
    case 'T':
        {
        const char_type __fm[] = {'%', 'H', ':', '%', 'M', ':', '%', 'S'};
        __b = get(__b, __e, __iob, __err, __tm, __fm, __fm + sizeof(__fm)/sizeof(__fm[0]));
        }
        break;
    case 'w':
        __get_weekday(__tm->tm_wday, __b, __e, __err, __ct);
        break;
    case 'x':
        return do_get_date(__b, __e, __iob, __err, __tm);
    case 'X':
        {
        const string_type& __fm = this->__X();
        __b = get(__b, __e, __iob, __err, __tm, __fm.data(), __fm.data() + __fm.size());
        }
        break;
    case 'y':
        __get_year(__tm->tm_year, __b, __e, __err, __ct);
        break;
    case 'Y':
        __get_year4(__tm->tm_year, __b, __e, __err, __ct);
        break;
    case '%':
        __get_percent(__b, __e, __err, __ct);
        break;
    default:
        __err |= ios_base::failbit;
    }
    return __b;
}

extern template class __attribute__ ((__type_visibility__("default"))) time_get<char>;
extern template class __attribute__ ((__type_visibility__("default"))) time_get<wchar_t>;

class __attribute__ ((__type_visibility__("default"))) __time_get
{
protected:
    locale_t __loc_;

    __time_get(const char* __nm);
    __time_get(const string& __nm);
    ~__time_get();
};

template <class _CharT>
class __attribute__ ((__type_visibility__("default"))) __time_get_storage
    : public __time_get
{
protected:
    typedef basic_string<_CharT> string_type;

    string_type __weeks_[14];
    string_type __months_[24];
    string_type __am_pm_[2];
    string_type __c_;
    string_type __r_;
    string_type __x_;
    string_type __X_;

    explicit __time_get_storage(const char* __nm);
    explicit __time_get_storage(const string& __nm);

    __attribute__ ((__visibility__("hidden"), __always_inline__)) ~__time_get_storage() {}

    time_base::dateorder __do_date_order() const;

private:
    void init(const ctype<_CharT>&);
    string_type __analyze(char __fmt, const ctype<_CharT>&);
};

template <class _CharT, class _InputIterator = istreambuf_iterator<_CharT> >
class __attribute__ ((__type_visibility__("default"))) time_get_byname
    : public time_get<_CharT, _InputIterator>,
      private __time_get_storage<_CharT>
{
public:
    typedef time_base::dateorder dateorder;
    typedef _InputIterator iter_type;
    typedef _CharT char_type;
    typedef basic_string<char_type> string_type;

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit time_get_byname(const char* __nm, size_t __refs = 0)
        : time_get<_CharT, _InputIterator>(__refs),
          __time_get_storage<_CharT>(__nm) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit time_get_byname(const string& __nm, size_t __refs = 0)
        : time_get<_CharT, _InputIterator>(__refs),
          __time_get_storage<_CharT>(__nm) {}

protected:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    ~time_get_byname() {}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    virtual dateorder do_date_order() const {return this->__do_date_order();}
private:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    virtual const string_type* __weeks() const {return this->__weeks_;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    virtual const string_type* __months() const {return this->__months_;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    virtual const string_type* __am_pm() const {return this->__am_pm_;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    virtual const string_type& __c() const {return this->__c_;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    virtual const string_type& __r() const {return this->__r_;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    virtual const string_type& __x() const {return this->__x_;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    virtual const string_type& __X() const {return this->__X_;}
};

extern template class __attribute__ ((__type_visibility__("default"))) time_get_byname<char>;
extern template class __attribute__ ((__type_visibility__("default"))) time_get_byname<wchar_t>;

class __attribute__ ((__type_visibility__("default"))) __time_put
{
    locale_t __loc_;
protected:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) __time_put() : __loc_(0) {}
    __time_put(const char* __nm);
    __time_put(const string& __nm);
    ~__time_put();
    void __do_put(char* __nb, char*& __ne, const tm* __tm,
                  char __fmt, char __mod) const;
    void __do_put(wchar_t* __wb, wchar_t*& __we, const tm* __tm,
                  char __fmt, char __mod) const;
};

template <class _CharT, class _OutputIterator = ostreambuf_iterator<_CharT> >
class __attribute__ ((__type_visibility__("default"))) time_put
    : public locale::facet,
      private __time_put
{
public:
    typedef _CharT char_type;
    typedef _OutputIterator iter_type;

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit time_put(size_t __refs = 0)
        : locale::facet(__refs) {}

    iter_type put(iter_type __s, ios_base& __iob, char_type __fl, const tm* __tm,
                  const char_type* __pb, const char_type* __pe) const;

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,
                  const tm* __tm, char __fmt, char __mod = 0) const
    {
        return do_put(__s, __iob, __fl, __tm, __fmt, __mod);
    }

    static locale::id id;

protected:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    ~time_put() {}
    virtual iter_type do_put(iter_type __s, ios_base&, char_type, const tm* __tm,
                             char __fmt, char __mod) const;

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit time_put(const char* __nm, size_t __refs)
        : locale::facet(__refs),
          __time_put(__nm) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit time_put(const string& __nm, size_t __refs)
        : locale::facet(__refs),
          __time_put(__nm) {}
};

template <class _CharT, class _OutputIterator>
locale::id
time_put<_CharT, _OutputIterator>::id;

template <class _CharT, class _OutputIterator>
_OutputIterator
time_put<_CharT, _OutputIterator>::put(iter_type __s, ios_base& __iob,
                                       char_type __fl, const tm* __tm,
                                       const char_type* __pb,
                                       const char_type* __pe) const
{
    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__iob.getloc());
    for (; __pb != __pe; ++__pb)
    {
        if (__ct.narrow(*__pb, 0) == '%')
        {
            if (++__pb == __pe)
            {
                *__s++ = __pb[-1];
                break;
            }
            char __mod = 0;
            char __fmt = __ct.narrow(*__pb, 0);
            if (__fmt == 'E' || __fmt == 'O')
            {
                if (++__pb == __pe)
                {
                    *__s++ = __pb[-2];
                    *__s++ = __pb[-1];
                    break;
                }
                __mod = __fmt;
                __fmt = __ct.narrow(*__pb, 0);
            }
            __s = do_put(__s, __iob, __fl, __tm, __fmt, __mod);
        }
        else
            *__s++ = *__pb;
    }
    return __s;
}

template <class _CharT, class _OutputIterator>
_OutputIterator
time_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base&,
                                          char_type, const tm* __tm,
                                          char __fmt, char __mod) const
{
    char_type __nar[100];
    char_type* __nb = __nar;
    char_type* __ne = __nb + 100;
    __do_put(__nb, __ne, __tm, __fmt, __mod);
    return std::__1::copy(__nb, __ne, __s);
}

extern template class __attribute__ ((__type_visibility__("default"))) time_put<char>;
extern template class __attribute__ ((__type_visibility__("default"))) time_put<wchar_t>;

template <class _CharT, class _OutputIterator = ostreambuf_iterator<_CharT> >
class __attribute__ ((__type_visibility__("default"))) time_put_byname
    : public time_put<_CharT, _OutputIterator>
{
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit time_put_byname(const char* __nm, size_t __refs = 0)
        : time_put<_CharT, _OutputIterator>(__nm, __refs) {}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit time_put_byname(const string& __nm, size_t __refs = 0)
        : time_put<_CharT, _OutputIterator>(__nm, __refs) {}

protected:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    ~time_put_byname() {}
};

extern template class __attribute__ ((__type_visibility__("default"))) time_put_byname<char>;
extern template class __attribute__ ((__type_visibility__("default"))) time_put_byname<wchar_t>;

// money_base

class __attribute__ ((__type_visibility__("default"))) money_base
{
public:
    enum part {none, space, symbol, sign, value};
    struct pattern {char field[4];};

    __attribute__ ((__visibility__("hidden"), __always_inline__)) money_base() {}
};

// moneypunct

template <class _CharT, bool _International = false>
class __attribute__ ((__type_visibility__("default"))) moneypunct
    : public locale::facet,
      public money_base
{
public:
    typedef _CharT char_type;
    typedef basic_string<char_type> string_type;

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit moneypunct(size_t __refs = 0)
        : locale::facet(__refs) {}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) char_type decimal_point() const {return do_decimal_point();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) char_type thousands_sep() const {return do_thousands_sep();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) string grouping() const {return do_grouping();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) string_type curr_symbol() const {return do_curr_symbol();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) string_type positive_sign() const {return do_positive_sign();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) string_type negative_sign() const {return do_negative_sign();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) int frac_digits() const {return do_frac_digits();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) pattern pos_format() const {return do_pos_format();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) pattern neg_format() const {return do_neg_format();}

    static locale::id id;
    static const bool intl = _International;

protected:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    ~moneypunct() {}

    virtual char_type do_decimal_point() const {return numeric_limits<char_type>::max();}
    virtual char_type do_thousands_sep() const {return numeric_limits<char_type>::max();}
    virtual string do_grouping() const {return string();}
    virtual string_type do_curr_symbol() const {return string_type();}
    virtual string_type do_positive_sign() const {return string_type();}
    virtual string_type do_negative_sign() const {return string_type(1, '-');}
    virtual int do_frac_digits() const {return 0;}
    virtual pattern do_pos_format() const
        {pattern __p = {{symbol, sign, none, value}}; return __p;}
    virtual pattern do_neg_format() const
        {pattern __p = {{symbol, sign, none, value}}; return __p;}
};

template <class _CharT, bool _International>
locale::id
moneypunct<_CharT, _International>::id;

template <class _CharT, bool _International>
const bool
moneypunct<_CharT, _International>::intl;

extern template class __attribute__ ((__type_visibility__("default"))) moneypunct<char, false>;
extern template class __attribute__ ((__type_visibility__("default"))) moneypunct<char, true>;
extern template class __attribute__ ((__type_visibility__("default"))) moneypunct<wchar_t, false>;
extern template class __attribute__ ((__type_visibility__("default"))) moneypunct<wchar_t, true>;

// moneypunct_byname

template <class _CharT, bool _International = false>
class __attribute__ ((__type_visibility__("default"))) moneypunct_byname
    : public moneypunct<_CharT, _International>
{
public:
    typedef money_base::pattern pattern;
    typedef _CharT char_type;
    typedef basic_string<char_type> string_type;

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit moneypunct_byname(const char* __nm, size_t __refs = 0)
        : moneypunct<_CharT, _International>(__refs) {init(__nm);}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit moneypunct_byname(const string& __nm, size_t __refs = 0)
        : moneypunct<_CharT, _International>(__refs) {init(__nm.c_str());}

protected:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    ~moneypunct_byname() {}

    virtual char_type do_decimal_point() const {return __decimal_point_;}
    virtual char_type do_thousands_sep() const {return __thousands_sep_;}
    virtual string do_grouping() const {return __grouping_;}
    virtual string_type do_curr_symbol() const {return __curr_symbol_;}
    virtual string_type do_positive_sign() const {return __positive_sign_;}
    virtual string_type do_negative_sign() const {return __negative_sign_;}
    virtual int do_frac_digits() const {return __frac_digits_;}
    virtual pattern do_pos_format() const {return __pos_format_;}
    virtual pattern do_neg_format() const {return __neg_format_;}

private:
    char_type __decimal_point_;
    char_type __thousands_sep_;
    string __grouping_;
    string_type __curr_symbol_;
    string_type __positive_sign_;
    string_type __negative_sign_;
    int __frac_digits_;
    pattern __pos_format_;
    pattern __neg_format_;

    void init(const char*);
};

template<> void moneypunct_byname<char, false>::init(const char*);
template<> void moneypunct_byname<char, true>::init(const char*);
template<> void moneypunct_byname<wchar_t, false>::init(const char*);
template<> void moneypunct_byname<wchar_t, true>::init(const char*);

extern template class __attribute__ ((__type_visibility__("default"))) moneypunct_byname<char, false>;
extern template class __attribute__ ((__type_visibility__("default"))) moneypunct_byname<char, true>;
extern template class __attribute__ ((__type_visibility__("default"))) moneypunct_byname<wchar_t, false>;
extern template class __attribute__ ((__type_visibility__("default"))) moneypunct_byname<wchar_t, true>;

// money_get

template <class _CharT>
class __money_get
{
protected:
    typedef _CharT char_type;
    typedef basic_string<char_type> string_type;

    __attribute__ ((__visibility__("hidden"), __always_inline__)) __money_get() {}

    static void __gather_info(bool __intl, const locale& __loc,
                              money_base::pattern& __pat, char_type& __dp,
                              char_type& __ts, string& __grp,
                              string_type& __sym, string_type& __psn,
                              string_type& __nsn, int& __fd);
};

template <class _CharT>
void
__money_get<_CharT>::__gather_info(bool __intl, const locale& __loc,
                                   money_base::pattern& __pat, char_type& __dp,
                                   char_type& __ts, string& __grp,
                                   string_type& __sym, string_type& __psn,
                                   string_type& __nsn, int& __fd)
{
    if (__intl)
    {
        const moneypunct<char_type, true>& __mp =
            use_facet<moneypunct<char_type, true> >(__loc);
        __pat = __mp.neg_format();
        __nsn = __mp.negative_sign();
        __psn = __mp.positive_sign();
        __dp = __mp.decimal_point();
        __ts = __mp.thousands_sep();
        __grp = __mp.grouping();
        __sym = __mp.curr_symbol();
        __fd = __mp.frac_digits();
    }
    else
    {
        const moneypunct<char_type, false>& __mp =
            use_facet<moneypunct<char_type, false> >(__loc);
        __pat = __mp.neg_format();
        __nsn = __mp.negative_sign();
        __psn = __mp.positive_sign();
        __dp = __mp.decimal_point();
        __ts = __mp.thousands_sep();
        __grp = __mp.grouping();
        __sym = __mp.curr_symbol();
        __fd = __mp.frac_digits();
    }
}

extern template class __attribute__ ((__type_visibility__("default"))) __money_get<char>;
extern template class __attribute__ ((__type_visibility__("default"))) __money_get<wchar_t>;

template <class _CharT, class _InputIterator = istreambuf_iterator<_CharT> >
class __attribute__ ((__type_visibility__("default"))) money_get
    : public locale::facet,
      private __money_get<_CharT>
{
public:
    typedef _CharT char_type;
    typedef _InputIterator iter_type;
    typedef basic_string<char_type> string_type;

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit money_get(size_t __refs = 0)
        : locale::facet(__refs) {}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iter_type get(iter_type __b, iter_type __e, bool __intl, ios_base& __iob,
                  ios_base::iostate& __err, long double& __v) const
    {
        return do_get(__b, __e, __intl, __iob, __err, __v);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iter_type get(iter_type __b, iter_type __e, bool __intl, ios_base& __iob,
                  ios_base::iostate& __err, string_type& __v) const
    {
        return do_get(__b, __e, __intl, __iob, __err, __v);
    }

    static locale::id id;

protected:

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    ~money_get() {}

    virtual iter_type do_get(iter_type __b, iter_type __e, bool __intl,
                             ios_base& __iob, ios_base::iostate& __err,
                             long double& __v) const;
    virtual iter_type do_get(iter_type __b, iter_type __e, bool __intl,
                             ios_base& __iob, ios_base::iostate& __err,
                             string_type& __v) const;

private:
    static bool __do_get(iter_type& __b, iter_type __e,
                         bool __intl, const locale& __loc,
                         ios_base::fmtflags __flags, ios_base::iostate& __err,
                         bool& __neg, const ctype<char_type>& __ct,
                         unique_ptr<char_type, void(*)(void*)>& __wb,
                         char_type*& __wn, char_type* __we);
};

template <class _CharT, class _InputIterator>
locale::id
money_get<_CharT, _InputIterator>::id;

__attribute__ ((__visibility__("default"))) void __do_nothing(void*);

template <class _Tp>
__attribute__ ((__visibility__("hidden")))
void
__double_or_nothing(unique_ptr<_Tp, void(*)(void*)>& __b, _Tp*& __n, _Tp*& __e)
{
    bool __owns = __b.get_deleter() != __do_nothing;
    size_t __cur_cap = static_cast<size_t>(__e-__b.get()) * sizeof(_Tp);
    size_t __new_cap = __cur_cap < numeric_limits<size_t>::max() / 2 ?
                       2 * __cur_cap : numeric_limits<size_t>::max();
    size_t __n_off = static_cast<size_t>(__n - __b.get());
    _Tp* __t = (_Tp*)realloc(__owns ? __b.get() : 0, __new_cap);
    if (__t == 0)
        __throw_bad_alloc();
    if (__owns)
        __b.release();
    __b = unique_ptr<_Tp, void(*)(void*)>(__t, free);
    __new_cap /= sizeof(_Tp);
    __n = __b.get() + __n_off;
    __e = __b.get() + __new_cap;
}

// true == success
template <class _CharT, class _InputIterator>
bool
money_get<_CharT, _InputIterator>::__do_get(iter_type& __b, iter_type __e,
                                            bool __intl, const locale& __loc,
                                            ios_base::fmtflags __flags,
                                            ios_base::iostate& __err,
                                            bool& __neg,
                                            const ctype<char_type>& __ct,
                                            unique_ptr<char_type, void(*)(void*)>& __wb,
                                            char_type*& __wn, char_type* __we)
{
    const unsigned __bz = 100;
    unsigned __gbuf[__bz];
    unique_ptr<unsigned, void(*)(void*)> __gb(__gbuf, __do_nothing);
    unsigned* __gn = __gb.get();
    unsigned* __ge = __gn + __bz;
    money_base::pattern __pat;
    char_type __dp;
    char_type __ts;
    string __grp;
    string_type __sym;
    string_type __psn;
    string_type __nsn;
    // Capture the spaces read into money_base::{space,none} so they
    // can be compared to initial spaces in __sym.
    string_type __spaces;
    int __fd;
    __money_get<_CharT>::__gather_info(__intl, __loc, __pat, __dp, __ts, __grp,
                                       __sym, __psn, __nsn, __fd);
    const string_type* __trailing_sign = 0;
    __wn = __wb.get();
    for (unsigned __p = 0; __p < 4 && __b != __e; ++__p)
    {
        switch (__pat.field[__p])
        {
        case money_base::space:
            if (__p != 3)
            {
                if (__ct.is(ctype_base::space, *__b))
                    __spaces.push_back(*__b++);
                else
                {
                    __err |= ios_base::failbit;
                    return false;
                }
            }
            // drop through
        case money_base::none:
            if (__p != 3)
            {
                while (__b != __e && __ct.is(ctype_base::space, *__b))
                    __spaces.push_back(*__b++);
            }
            break;
        case money_base::sign:
            if (__psn.size() + __nsn.size() > 0)
            {
                if (__psn.size() == 0 || __nsn.size() == 0)
                { // sign is optional
                    if (__psn.size() > 0)
                    { // __nsn.size() == 0
                        if (*__b == __psn[0])
                        {
                            ++__b;
                            if (__psn.size() > 1)
                                __trailing_sign = &__psn;
                        }
                        else
                            __neg = true;
                    }
                    else if (*__b == __nsn[0]) // __nsn.size() > 0 &&  __psn.size() == 0
                    {
                        ++__b;
                        __neg = true;
                        if (__nsn.size() > 1)
                            __trailing_sign = &__nsn;
                    }
                }
                else // sign is required
                {
                    if (*__b == __psn[0])
                    {
                        ++__b;
                        if (__psn.size() > 1)
                            __trailing_sign = &__psn;
                    }
                    else if (*__b == __nsn[0])
                    {
                        ++__b;
                        __neg = true;
                        if (__nsn.size() > 1)
                            __trailing_sign = &__nsn;
                    }
                    else
                    {
                        __err |= ios_base::failbit;
                        return false;
                    }
                }
            }
            break;
        case money_base::symbol:
            {
            bool __more_needed = __trailing_sign ||
                                 (__p < 2) ||
                                 (__p == 2 && __pat.field[3] != static_cast<char>(money_base::none));
            bool __sb = (__flags & ios_base::showbase) != 0;
            if (__sb || __more_needed)
            {
                typename string_type::const_iterator __sym_space_end = __sym.begin();
                if (__p > 0 && (__pat.field[__p - 1] == money_base::none ||
                                __pat.field[__p - 1] == money_base::space)) {
                    // Match spaces we've already read against spaces at
                    // the beginning of __sym.
                    while (__sym_space_end != __sym.end() &&
                           __ct.is(ctype_base::space, *__sym_space_end))
                        ++__sym_space_end;
                    const size_t __num_spaces = __sym_space_end - __sym.begin();
                    if (__num_spaces > __spaces.size() ||
                        !equal(__spaces.end() - __num_spaces, __spaces.end(),
                               __sym.begin())) {
                        // No match. Put __sym_space_end back at the
                        // beginning of __sym, which will prevent a
                        // match in the next loop.
                        __sym_space_end = __sym.begin();
                    }
                }
                typename string_type::const_iterator __sym_curr_char = __sym_space_end;
                while (__sym_curr_char != __sym.end() && __b != __e &&
                       *__b == *__sym_curr_char) {
                    ++__b;
                    ++__sym_curr_char;
                }
                if (__sb && __sym_curr_char != __sym.end())
                {
                    __err |= ios_base::failbit;
                    return false;
                }
            }
            }
            break;
        case money_base::value:
            {
            unsigned __ng = 0;
            for (; __b != __e; ++__b)
            {
                char_type __c = *__b;
                if (__ct.is(ctype_base::digit, __c))
                {
                    if (__wn == __we)
                        __double_or_nothing(__wb, __wn, __we);
                    *__wn++ = __c;
                    ++__ng;
                }
                else if (__grp.size() > 0 && __ng > 0 && __c == __ts)
                {
                    if (__gn == __ge)
                        __double_or_nothing(__gb, __gn, __ge);
                    *__gn++ = __ng;
                    __ng = 0;
                }
                else
                    break;
            }
            if (__gb.get() != __gn && __ng > 0)
            {
                if (__gn == __ge)
                    __double_or_nothing(__gb, __gn, __ge);
                *__gn++ = __ng;
            }
            if (__fd > 0)
            {
                if (__b == __e || *__b != __dp)
                {
                    __err |= ios_base::failbit;
                    return false;
                }
                for (++__b; __fd > 0; --__fd, ++__b)
                {
                    if (__b == __e || !__ct.is(ctype_base::digit, *__b))
                    {
                        __err |= ios_base::failbit;
                        return false;
                    }
                    if (__wn == __we)
                        __double_or_nothing(__wb, __wn, __we);
                    *__wn++ = *__b;
                }
            }
            if (__wn == __wb.get())
            {
                __err |= ios_base::failbit;
                return false;
            }
            }
            break;
        }
    }
    if (__trailing_sign)
    {
        for (unsigned __i = 1; __i < __trailing_sign->size(); ++__i, ++__b)
        {
            if (__b == __e || *__b != (*__trailing_sign)[__i])
            {
                __err |= ios_base::failbit;
                return false;
            }
        }
    }
    if (__gb.get() != __gn)
    {
        ios_base::iostate __et = ios_base::goodbit;
        __check_grouping(__grp, __gb.get(), __gn, __et);
        if (__et)
        {
            __err |= ios_base::failbit;
            return false;
        }
    }
    return true;
}

template <class _CharT, class _InputIterator>
_InputIterator
money_get<_CharT, _InputIterator>::do_get(iter_type __b, iter_type __e,
                                          bool __intl, ios_base& __iob,
                                          ios_base::iostate& __err,
                                          long double& __v) const
{
    const int __bz = 100;
    char_type __wbuf[__bz];
    unique_ptr<char_type, void(*)(void*)> __wb(__wbuf, __do_nothing);
    char_type* __wn;
    char_type* __we = __wbuf + __bz;
    locale __loc = __iob.getloc();
    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__loc);
    bool __neg = false;
    if (__do_get(__b, __e, __intl, __loc, __iob.flags(), __err, __neg, __ct,
                 __wb, __wn, __we))
    {
        const char __src[] = "0123456789";
        char_type __atoms[sizeof(__src)-1];
        __ct.widen(__src, __src + (sizeof(__src)-1), __atoms);
        char __nbuf[__bz];
        char* __nc = __nbuf;
        unique_ptr<char, void(*)(void*)> __h(0, free);
        if (__wn - __wb.get() > __bz-2)
        {
            __h.reset((char*)malloc(static_cast<size_t>(__wn - __wb.get() + 2)));
            if (__h.get() == 0)
                __throw_bad_alloc();
            __nc = __h.get();
        }
        if (__neg)
            *__nc++ = '-';
        for (const char_type* __w = __wb.get(); __w < __wn; ++__w, ++__nc)
            *__nc = __src[find(__atoms, std::__1::end(__atoms), *__w) - __atoms];
        *__nc = char();
        if (sscanf(__nbuf, "%Lf", &__v) != 1)
            __throw_runtime_error("money_get error");
    }
    if (__b == __e)
        __err |= ios_base::eofbit;
    return __b;
}

template <class _CharT, class _InputIterator>
_InputIterator
money_get<_CharT, _InputIterator>::do_get(iter_type __b, iter_type __e,
                                          bool __intl, ios_base& __iob,
                                          ios_base::iostate& __err,
                                          string_type& __v) const
{
    const int __bz = 100;
    char_type __wbuf[__bz];
    unique_ptr<char_type, void(*)(void*)> __wb(__wbuf, __do_nothing);
    char_type* __wn;
    char_type* __we = __wbuf + __bz;
    locale __loc = __iob.getloc();
    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__loc);
    bool __neg = false;
    if (__do_get(__b, __e, __intl, __loc, __iob.flags(), __err, __neg, __ct,
                 __wb, __wn, __we))
    {
        __v.clear();
        if (__neg)
            __v.push_back(__ct.widen('-'));
        char_type __z = __ct.widen('0');
        char_type* __w;
        for (__w = __wb.get(); __w < __wn-1; ++__w)
            if (*__w != __z)
                break;
        __v.append(__w, __wn);
    }
    if (__b == __e)
        __err |= ios_base::eofbit;
    return __b;
}

extern template class __attribute__ ((__type_visibility__("default"))) money_get<char>;
extern template class __attribute__ ((__type_visibility__("default"))) money_get<wchar_t>;

// money_put

template <class _CharT>
class __money_put
{
protected:
    typedef _CharT char_type;
    typedef basic_string<char_type> string_type;

    __attribute__ ((__visibility__("hidden"), __always_inline__)) __money_put() {}

    static void __gather_info(bool __intl, bool __neg, const locale& __loc,
                              money_base::pattern& __pat, char_type& __dp,
                              char_type& __ts, string& __grp,
                              string_type& __sym, string_type& __sn,
                              int& __fd);
    static void __format(char_type* __mb, char_type*& __mi, char_type*& __me,
                         ios_base::fmtflags __flags,
                         const char_type* __db, const char_type* __de,
                         const ctype<char_type>& __ct, bool __neg,
                         const money_base::pattern& __pat, char_type __dp,
                         char_type __ts, const string& __grp,
                         const string_type& __sym, const string_type& __sn,
                         int __fd);
};

template <class _CharT>
void
__money_put<_CharT>::__gather_info(bool __intl, bool __neg, const locale& __loc,
                                   money_base::pattern& __pat, char_type& __dp,
                                   char_type& __ts, string& __grp,
                                   string_type& __sym, string_type& __sn,
                                   int& __fd)
{
    if (__intl)
    {
        const moneypunct<char_type, true>& __mp =
            use_facet<moneypunct<char_type, true> >(__loc);
        if (__neg)
        {
            __pat = __mp.neg_format();
            __sn = __mp.negative_sign();
        }
        else
        {
            __pat = __mp.pos_format();
            __sn = __mp.positive_sign();
        }
        __dp = __mp.decimal_point();
        __ts = __mp.thousands_sep();
        __grp = __mp.grouping();
        __sym = __mp.curr_symbol();
        __fd = __mp.frac_digits();
    }
    else
    {
        const moneypunct<char_type, false>& __mp =
            use_facet<moneypunct<char_type, false> >(__loc);
        if (__neg)
        {
            __pat = __mp.neg_format();
            __sn = __mp.negative_sign();
        }
        else
        {
            __pat = __mp.pos_format();
            __sn = __mp.positive_sign();
        }
        __dp = __mp.decimal_point();
        __ts = __mp.thousands_sep();
        __grp = __mp.grouping();
        __sym = __mp.curr_symbol();
        __fd = __mp.frac_digits();
    }
}

template <class _CharT>
void
__money_put<_CharT>::__format(char_type* __mb, char_type*& __mi, char_type*& __me,
                              ios_base::fmtflags __flags,
                              const char_type* __db, const char_type* __de,
                              const ctype<char_type>& __ct, bool __neg,
                              const money_base::pattern& __pat, char_type __dp,
                              char_type __ts, const string& __grp,
                              const string_type& __sym, const string_type& __sn,
                              int __fd)
{
    __me = __mb;
    for (unsigned __p = 0; __p < 4; ++__p)
    {
        switch (__pat.field[__p])
        {
        case money_base::none:
            __mi = __me;
            break;
        case money_base::space:
            __mi = __me;
            *__me++ = __ct.widen(' ');
            break;
        case money_base::sign:
            if (!__sn.empty())
                *__me++ = __sn[0];
            break;
        case money_base::symbol:
            if (!__sym.empty() && (__flags & ios_base::showbase))
                __me = std::__1::copy(__sym.begin(), __sym.end(), __me);
            break;
        case money_base::value:
            {
            // remember start of value so we can reverse it
            char_type* __t = __me;
            // find beginning of digits
            if (__neg)
                ++__db;
            // find end of digits
            const char_type* __d;
            for (__d = __db; __d < __de; ++__d)
                if (!__ct.is(ctype_base::digit, *__d))
                    break;
            // print fractional part
            if (__fd > 0)
            {
                int __f;
                for (__f = __fd; __d > __db && __f > 0; --__f)
                    *__me++ = *--__d;
                char_type __z = __f > 0 ? __ct.widen('0') : char_type();
                for (; __f > 0; --__f)
                    *__me++ = __z;
                *__me++ = __dp;
            }
            // print units part
            if (__d == __db)
            {
                *__me++ = __ct.widen('0');
            }
            else
            {
                unsigned __ng = 0;
                unsigned __ig = 0;
                unsigned __gl = __grp.empty() ? numeric_limits<unsigned>::max()
                                              : static_cast<unsigned>(__grp[__ig]);
                while (__d != __db)
                {
                    if (__ng == __gl)
                    {
                        *__me++ = __ts;
                        __ng = 0;
                        if (++__ig < __grp.size())
                            __gl = __grp[__ig] == numeric_limits<char>::max() ?
                                        numeric_limits<unsigned>::max() :
                                        static_cast<unsigned>(__grp[__ig]);
                    }
                    *__me++ = *--__d;
                    ++__ng;
                }
            }
            // reverse it
            reverse(__t, __me);
            }
            break;
        }
    }
    // print rest of sign, if any
    if (__sn.size() > 1)
        __me = std::__1::copy(__sn.begin()+1, __sn.end(), __me);
    // set alignment
    if ((__flags & ios_base::adjustfield) == ios_base::left)
        __mi = __me;
    else if ((__flags & ios_base::adjustfield) != ios_base::internal)
        __mi = __mb;
}

extern template class __attribute__ ((__type_visibility__("default"))) __money_put<char>;
extern template class __attribute__ ((__type_visibility__("default"))) __money_put<wchar_t>;

template <class _CharT, class _OutputIterator = ostreambuf_iterator<_CharT> >
class __attribute__ ((__type_visibility__("default"))) money_put
    : public locale::facet,
      private __money_put<_CharT>
{
public:
    typedef _CharT char_type;
    typedef _OutputIterator iter_type;
    typedef basic_string<char_type> string_type;

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit money_put(size_t __refs = 0)
        : locale::facet(__refs) {}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iter_type put(iter_type __s, bool __intl, ios_base& __iob, char_type __fl,
                  long double __units) const
    {
        return do_put(__s, __intl, __iob, __fl, __units);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iter_type put(iter_type __s, bool __intl, ios_base& __iob, char_type __fl,
                  const string_type& __digits) const
    {
        return do_put(__s, __intl, __iob, __fl, __digits);
    }

    static locale::id id;

protected:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    ~money_put() {}

    virtual iter_type do_put(iter_type __s, bool __intl, ios_base& __iob,
                             char_type __fl, long double __units) const;
    virtual iter_type do_put(iter_type __s, bool __intl, ios_base& __iob,
                             char_type __fl, const string_type& __digits) const;
};

template <class _CharT, class _OutputIterator>
locale::id
money_put<_CharT, _OutputIterator>::id;

template <class _CharT, class _OutputIterator>
_OutputIterator
money_put<_CharT, _OutputIterator>::do_put(iter_type __s, bool __intl,
                                           ios_base& __iob, char_type __fl,
                                           long double __units) const
{
    // convert to char
    const size_t __bs = 100;
    char __buf[__bs];
    char* __bb = __buf;
    char_type __digits[__bs];
    char_type* __db = __digits;
    size_t __n = static_cast<size_t>(snprintf(__bb, __bs, "%.0Lf", __units));
    unique_ptr<char, void(*)(void*)> __hn(0, free);
    unique_ptr<char_type, void(*)(void*)> __hd(0, free);
    // secure memory for digit storage
    if (__n > __bs-1)
    {

        __n = static_cast<size_t>(asprintf_l(&__bb, 0, "%.0Lf", __units));



        if (__bb == 0)
            __throw_bad_alloc();
        __hn.reset(__bb);
        __hd.reset((char_type*)malloc(__n * sizeof(char_type)));
        if (__hd == std::__1::__get_nullptr_t())
            __throw_bad_alloc();
        __db = __hd.get();
    }
    // gather info
    locale __loc = __iob.getloc();
    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__loc);
    __ct.widen(__bb, __bb + __n, __db);
    bool __neg = __n > 0 && __bb[0] == '-';
    money_base::pattern __pat;
    char_type __dp;
    char_type __ts;
    string __grp;
    string_type __sym;
    string_type __sn;
    int __fd;
    this->__gather_info(__intl, __neg, __loc, __pat, __dp, __ts, __grp, __sym, __sn, __fd);
    // secure memory for formatting
    char_type __mbuf[__bs];
    char_type* __mb = __mbuf;
    unique_ptr<char_type, void(*)(void*)> __hw(0, free);
    size_t __exn = static_cast<int>(__n) > __fd ?
                   (__n - static_cast<size_t>(__fd)) * 2 + __sn.size() +
                    __sym.size() + static_cast<size_t>(__fd) + 1
                 : __sn.size() + __sym.size() + static_cast<size_t>(__fd) + 2;
    if (__exn > __bs)
    {
        __hw.reset((char_type*)malloc(__exn * sizeof(char_type)));
        __mb = __hw.get();
        if (__mb == 0)
            __throw_bad_alloc();
    }
    // format
    char_type* __mi;
    char_type* __me;
    this->__format(__mb, __mi, __me, __iob.flags(),
                   __db, __db + __n, __ct,
                   __neg, __pat, __dp, __ts, __grp, __sym, __sn, __fd);
    return __pad_and_output(__s, __mb, __mi, __me, __iob, __fl);
}

template <class _CharT, class _OutputIterator>
_OutputIterator
money_put<_CharT, _OutputIterator>::do_put(iter_type __s, bool __intl,
                                           ios_base& __iob, char_type __fl,
                                           const string_type& __digits) const
{
    // gather info
    locale __loc = __iob.getloc();
    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__loc);
    bool __neg = __digits.size() > 0 && __digits[0] == __ct.widen('-');
    money_base::pattern __pat;
    char_type __dp;
    char_type __ts;
    string __grp;
    string_type __sym;
    string_type __sn;
    int __fd;
    this->__gather_info(__intl, __neg, __loc, __pat, __dp, __ts, __grp, __sym, __sn, __fd);
    // secure memory for formatting
    char_type __mbuf[100];
    char_type* __mb = __mbuf;
    unique_ptr<char_type, void(*)(void*)> __h(0, free);
    size_t __exn = static_cast<int>(__digits.size()) > __fd ?
                   (__digits.size() - static_cast<size_t>(__fd)) * 2 +
                    __sn.size() + __sym.size() + static_cast<size_t>(__fd) + 1
                 : __sn.size() + __sym.size() + static_cast<size_t>(__fd) + 2;
    if (__exn > 100)
    {
        __h.reset((char_type*)malloc(__exn * sizeof(char_type)));
        __mb = __h.get();
        if (__mb == 0)
            __throw_bad_alloc();
    }
    // format
    char_type* __mi;
    char_type* __me;
    this->__format(__mb, __mi, __me, __iob.flags(),
                   __digits.data(), __digits.data() + __digits.size(), __ct,
                   __neg, __pat, __dp, __ts, __grp, __sym, __sn, __fd);
    return __pad_and_output(__s, __mb, __mi, __me, __iob, __fl);
}

extern template class __attribute__ ((__type_visibility__("default"))) money_put<char>;
extern template class __attribute__ ((__type_visibility__("default"))) money_put<wchar_t>;

// messages

class __attribute__ ((__type_visibility__("default"))) messages_base
{
public:
    typedef ptrdiff_t catalog;

    __attribute__ ((__visibility__("hidden"), __always_inline__)) messages_base() {}
};

template <class _CharT>
class __attribute__ ((__type_visibility__("default"))) messages
    : public locale::facet,
      public messages_base
{
public:
    typedef _CharT char_type;
    typedef basic_string<_CharT> string_type;

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit messages(size_t __refs = 0)
        : locale::facet(__refs) {}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    catalog open(const basic_string<char>& __nm, const locale& __loc) const
    {
        return do_open(__nm, __loc);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    string_type get(catalog __c, int __set, int __msgid,
                    const string_type& __dflt) const
    {
        return do_get(__c, __set, __msgid, __dflt);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void close(catalog __c) const
    {
        do_close(__c);
    }

    static locale::id id;

protected:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    ~messages() {}

    virtual catalog do_open(const basic_string<char>&, const locale&) const;
    virtual string_type do_get(catalog, int __set, int __msgid,
                               const string_type& __dflt) const;
    virtual void do_close(catalog) const;
};

template <class _CharT>
locale::id
messages<_CharT>::id;

template <class _CharT>
typename messages<_CharT>::catalog
messages<_CharT>::do_open(const basic_string<char>& __nm, const locale&) const
{



    catalog __cat = (catalog)catopen(__nm.c_str(), 1);
    if (__cat != -1)
        __cat = static_cast<catalog>((static_cast<size_t>(__cat) >> 1));
    return __cat;

}

template <class _CharT>
typename messages<_CharT>::string_type
messages<_CharT>::do_get(catalog __c, int __set, int __msgid,
                         const string_type& __dflt) const
{



    string __ndflt;
    __narrow_to_utf8<sizeof(char_type)*8>()(back_inserter(__ndflt),
                                                       __dflt.c_str(),
                                                       __dflt.c_str() + __dflt.size());
    if (__c != -1)
        __c <<= 1;
    nl_catd __cat = (nl_catd)__c;
    char* __n = catgets(__cat, __set, __msgid, __ndflt.c_str());
    string_type __w;
    __widen_from_utf8<sizeof(char_type)*8>()(back_inserter(__w),
                                                        __n, __n + strlen(__n));
    return __w;

}

template <class _CharT>
void
messages<_CharT>::do_close(catalog __c) const
{

    if (__c != -1)
        __c <<= 1;
    nl_catd __cat = (nl_catd)__c;
    catclose(__cat);

}

extern template class __attribute__ ((__type_visibility__("default"))) messages<char>;
extern template class __attribute__ ((__type_visibility__("default"))) messages<wchar_t>;

template <class _CharT>
class __attribute__ ((__type_visibility__("default"))) messages_byname
    : public messages<_CharT>
{
public:
    typedef messages_base::catalog catalog;
    typedef basic_string<_CharT> string_type;

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit messages_byname(const char*, size_t __refs = 0)
        : messages<_CharT>(__refs) {}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit messages_byname(const string&, size_t __refs = 0)
        : messages<_CharT>(__refs) {}

protected:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    ~messages_byname() {}
};

extern template class __attribute__ ((__type_visibility__("default"))) messages_byname<char>;
extern template class __attribute__ ((__type_visibility__("default"))) messages_byname<wchar_t>;

template<class _Codecvt, class _Elem = wchar_t,
         class _Wide_alloc = allocator<_Elem>,
         class _Byte_alloc = allocator<char> >
class __attribute__ ((__type_visibility__("default"))) wstring_convert
{
public:
    typedef basic_string<char, char_traits<char>, _Byte_alloc> byte_string;
    typedef basic_string<_Elem, char_traits<_Elem>, _Wide_alloc> wide_string;
    typedef typename _Codecvt::state_type state_type;
    typedef typename wide_string::traits_type::int_type int_type;

private:
    byte_string __byte_err_string_;
    wide_string __wide_err_string_;
    _Codecvt* __cvtptr_;
    state_type __cvtstate_;
    size_t __cvtcount_;

    wstring_convert(const wstring_convert& __wc);
    wstring_convert& operator=(const wstring_convert& __wc);
public:
                                 wstring_convert(_Codecvt* __pcvt = new _Codecvt);
    wstring_convert(_Codecvt* __pcvt, state_type __state);
                                 wstring_convert(const byte_string& __byte_err,
                    const wide_string& __wide_err = wide_string());



    ~wstring_convert();

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    wide_string from_bytes(char __byte)
        {return from_bytes(&__byte, &__byte+1);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    wide_string from_bytes(const char* __ptr)
        {return from_bytes(__ptr, __ptr + char_traits<char>::length(__ptr));}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    wide_string from_bytes(const byte_string& __str)
        {return from_bytes(__str.data(), __str.data() + __str.size());}
    wide_string from_bytes(const char* __first, const char* __last);

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    byte_string to_bytes(_Elem __wchar)
        {return to_bytes(&__wchar, &__wchar+1);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    byte_string to_bytes(const _Elem* __wptr)
        {return to_bytes(__wptr, __wptr + char_traits<_Elem>::length(__wptr));}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    byte_string to_bytes(const wide_string& __wstr)
        {return to_bytes(__wstr.data(), __wstr.data() + __wstr.size());}
    byte_string to_bytes(const _Elem* __first, const _Elem* __last);

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_t converted() const throw() {return __cvtcount_;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    state_type state() const {return __cvtstate_;}
};

template<class _Codecvt, class _Elem, class _Wide_alloc, class _Byte_alloc>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
wstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::
    wstring_convert(_Codecvt* __pcvt)
        : __cvtptr_(__pcvt), __cvtstate_(), __cvtcount_(0)
{
}

template<class _Codecvt, class _Elem, class _Wide_alloc, class _Byte_alloc>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
wstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::
    wstring_convert(_Codecvt* __pcvt, state_type __state)
        : __cvtptr_(__pcvt), __cvtstate_(__state), __cvtcount_(0)
{
}

template<class _Codecvt, class _Elem, class _Wide_alloc, class _Byte_alloc>
wstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::
    wstring_convert(const byte_string& __byte_err, const wide_string& __wide_err)
        : __byte_err_string_(__byte_err), __wide_err_string_(__wide_err),
          __cvtstate_(), __cvtcount_(0)
{
    __cvtptr_ = new _Codecvt;
}
# 3847 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/locale" 3
template<class _Codecvt, class _Elem, class _Wide_alloc, class _Byte_alloc>
wstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::~wstring_convert()
{
    delete __cvtptr_;
}

template<class _Codecvt, class _Elem, class _Wide_alloc, class _Byte_alloc>
typename wstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::wide_string
wstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::
    from_bytes(const char* __frm, const char* __frm_end)
{
    __cvtcount_ = 0;
    if (__cvtptr_ != std::__1::__get_nullptr_t())
    {
        wide_string __ws(2*(__frm_end - __frm), _Elem());
        if (__frm != __frm_end)
            __ws.resize(__ws.capacity());
        codecvt_base::result __r = codecvt_base::ok;
        state_type __st = __cvtstate_;
        if (__frm != __frm_end)
        {
            _Elem* __to = &__ws[0];
            _Elem* __to_end = __to + __ws.size();
            const char* __frm_nxt;
            do
            {
                _Elem* __to_nxt;
                __r = __cvtptr_->in(__st, __frm, __frm_end, __frm_nxt,
                                          __to, __to_end, __to_nxt);
                __cvtcount_ += __frm_nxt - __frm;
                if (__frm_nxt == __frm)
                {
                    __r = codecvt_base::error;
                }
                else if (__r == codecvt_base::noconv)
                {
                    __ws.resize(__to - &__ws[0]);
                    // This only gets executed if _Elem is char
                    __ws.append((const _Elem*)__frm, (const _Elem*)__frm_end);
                    __frm = __frm_nxt;
                    __r = codecvt_base::ok;
                }
                else if (__r == codecvt_base::ok)
                {
                    __ws.resize(__to_nxt - &__ws[0]);
                    __frm = __frm_nxt;
                }
                else if (__r == codecvt_base::partial)
                {
                    ptrdiff_t __s = __to_nxt - &__ws[0];
                    __ws.resize(2 * __s);
                    __to = &__ws[0] + __s;
                    __to_end = &__ws[0] + __ws.size();
                    __frm = __frm_nxt;
                }
            } while (__r == codecvt_base::partial && __frm_nxt < __frm_end);
        }
        if (__r == codecvt_base::ok)
            return __ws;
    }

    if (__wide_err_string_.empty())
        throw range_error("wstring_convert: from_bytes error");

    return __wide_err_string_;
}

template<class _Codecvt, class _Elem, class _Wide_alloc, class _Byte_alloc>
typename wstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::byte_string
wstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::
    to_bytes(const _Elem* __frm, const _Elem* __frm_end)
{
    __cvtcount_ = 0;
    if (__cvtptr_ != std::__1::__get_nullptr_t())
    {
        byte_string __bs(2*(__frm_end - __frm), char());
        if (__frm != __frm_end)
            __bs.resize(__bs.capacity());
        codecvt_base::result __r = codecvt_base::ok;
        state_type __st = __cvtstate_;
        if (__frm != __frm_end)
        {
            char* __to = &__bs[0];
            char* __to_end = __to + __bs.size();
            const _Elem* __frm_nxt;
            do
            {
                char* __to_nxt;
                __r = __cvtptr_->out(__st, __frm, __frm_end, __frm_nxt,
                                           __to, __to_end, __to_nxt);
                __cvtcount_ += __frm_nxt - __frm;
                if (__frm_nxt == __frm)
                {
                    __r = codecvt_base::error;
                }
                else if (__r == codecvt_base::noconv)
                {
                    __bs.resize(__to - &__bs[0]);
                    // This only gets executed if _Elem is char
                    __bs.append((const char*)__frm, (const char*)__frm_end);
                    __frm = __frm_nxt;
                    __r = codecvt_base::ok;
                }
                else if (__r == codecvt_base::ok)
                {
                    __bs.resize(__to_nxt - &__bs[0]);
                    __frm = __frm_nxt;
                }
                else if (__r == codecvt_base::partial)
                {
                    ptrdiff_t __s = __to_nxt - &__bs[0];
                    __bs.resize(2 * __s);
                    __to = &__bs[0] + __s;
                    __to_end = &__bs[0] + __bs.size();
                    __frm = __frm_nxt;
                }
            } while (__r == codecvt_base::partial && __frm_nxt < __frm_end);
        }
        if (__r == codecvt_base::ok)
        {
            size_t __s = __bs.size();
            __bs.resize(__bs.capacity());
            char* __to = &__bs[0] + __s;
            char* __to_end = __to + __bs.size();
            do
            {
                char* __to_nxt;
                __r = __cvtptr_->unshift(__st, __to, __to_end, __to_nxt);
                if (__r == codecvt_base::noconv)
                {
                    __bs.resize(__to - &__bs[0]);
                    __r = codecvt_base::ok;
                }
                else if (__r == codecvt_base::ok)
                {
                    __bs.resize(__to_nxt - &__bs[0]);
                }
                else if (__r == codecvt_base::partial)
                {
                    ptrdiff_t __sp = __to_nxt - &__bs[0];
                    __bs.resize(2 * __sp);
                    __to = &__bs[0] + __sp;
                    __to_end = &__bs[0] + __bs.size();
                }
            } while (__r == codecvt_base::partial);
            if (__r == codecvt_base::ok)
                return __bs;
        }
    }

    if (__byte_err_string_.empty())
        throw range_error("wstring_convert: to_bytes error");

    return __byte_err_string_;
}

template <class _Codecvt, class _Elem = wchar_t, class _Tr = char_traits<_Elem> >
class __attribute__ ((__type_visibility__("default"))) wbuffer_convert
    : public basic_streambuf<_Elem, _Tr>
{
public:
    // types:
    typedef _Elem char_type;
    typedef _Tr traits_type;
    typedef typename traits_type::int_type int_type;
    typedef typename traits_type::pos_type pos_type;
    typedef typename traits_type::off_type off_type;
    typedef typename _Codecvt::state_type state_type;

private:
    char* __extbuf_;
    const char* __extbufnext_;
    const char* __extbufend_;
    char __extbuf_min_[8];
    size_t __ebs_;
    char_type* __intbuf_;
    size_t __ibs_;
    streambuf* __bufptr_;
    _Codecvt* __cv_;
    state_type __st_;
    ios_base::openmode __cm_;
    bool __owns_eb_;
    bool __owns_ib_;
    bool __always_noconv_;

    wbuffer_convert(const wbuffer_convert&);
    wbuffer_convert& operator=(const wbuffer_convert&);
public:
                                 wbuffer_convert(streambuf* __bytebuf = 0,
            _Codecvt* __pcvt = new _Codecvt, state_type __state = state_type());
    ~wbuffer_convert();

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    streambuf* rdbuf() const {return __bufptr_;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    streambuf* rdbuf(streambuf* __bytebuf)
    {
        streambuf* __r = __bufptr_;
        __bufptr_ = __bytebuf;
        return __r;
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    state_type state() const {return __st_;}

protected:
    virtual int_type underflow();
    virtual int_type pbackfail(int_type __c = traits_type::eof());
    virtual int_type overflow (int_type __c = traits_type::eof());
    virtual basic_streambuf<char_type, traits_type>* setbuf(char_type* __s,
                                                            streamsize __n);
    virtual pos_type seekoff(off_type __off, ios_base::seekdir __way,
                             ios_base::openmode __wch = ios_base::in | ios_base::out);
    virtual pos_type seekpos(pos_type __sp,
                             ios_base::openmode __wch = ios_base::in | ios_base::out);
    virtual int sync();

private:
    bool __read_mode();
    void __write_mode();
    wbuffer_convert* __close();
};

template <class _Codecvt, class _Elem, class _Tr>
wbuffer_convert<_Codecvt, _Elem, _Tr>::
    wbuffer_convert(streambuf* __bytebuf, _Codecvt* __pcvt, state_type __state)
    : __extbuf_(0),
      __extbufnext_(0),
      __extbufend_(0),
      __ebs_(0),
      __intbuf_(0),
      __ibs_(0),
      __bufptr_(__bytebuf),
      __cv_(__pcvt),
      __st_(__state),
      __cm_(0),
      __owns_eb_(false),
      __owns_ib_(false),
      __always_noconv_(__cv_ ? __cv_->always_noconv() : false)
{
    setbuf(0, 4096);
}

template <class _Codecvt, class _Elem, class _Tr>
wbuffer_convert<_Codecvt, _Elem, _Tr>::~wbuffer_convert()
{
    __close();
    delete __cv_;
    if (__owns_eb_)
        delete [] __extbuf_;
    if (__owns_ib_)
        delete [] __intbuf_;
}

template <class _Codecvt, class _Elem, class _Tr>
typename wbuffer_convert<_Codecvt, _Elem, _Tr>::int_type
wbuffer_convert<_Codecvt, _Elem, _Tr>::underflow()
{
    if (__cv_ == 0 || __bufptr_ == 0)
        return traits_type::eof();
    bool __initial = __read_mode();
    char_type __1buf;
    if (this->gptr() == 0)
        this->setg(&__1buf, &__1buf+1, &__1buf+1);
    const size_t __unget_sz = __initial ? 0 : min<size_t>((this->egptr() - this->eback()) / 2, 4);
    int_type __c = traits_type::eof();
    if (this->gptr() == this->egptr())
    {
        memmove(this->eback(), this->egptr() - __unget_sz, __unget_sz * sizeof(char_type));
        if (__always_noconv_)
        {
            streamsize __nmemb = static_cast<streamsize>(this->egptr() - this->eback() - __unget_sz);
            __nmemb = __bufptr_->sgetn((char*)this->eback() + __unget_sz, __nmemb);
            if (__nmemb != 0)
            {
                this->setg(this->eback(),
                           this->eback() + __unget_sz,
                           this->eback() + __unget_sz + __nmemb);
                __c = *this->gptr();
            }
        }
        else
        {
            memmove(__extbuf_, __extbufnext_, __extbufend_ - __extbufnext_);
            __extbufnext_ = __extbuf_ + (__extbufend_ - __extbufnext_);
            __extbufend_ = __extbuf_ + (__extbuf_ == __extbuf_min_ ? sizeof(__extbuf_min_) : __ebs_);
            streamsize __nmemb = std::__1::min(static_cast<streamsize>(this->egptr() - this->eback() - __unget_sz),
                                 static_cast<streamsize>(__extbufend_ - __extbufnext_));
            codecvt_base::result __r;
            state_type __svs = __st_;
            streamsize __nr = __bufptr_->sgetn(const_cast<char*>(__extbufnext_), __nmemb);
            if (__nr != 0)
            {
                __extbufend_ = __extbufnext_ + __nr;
                char_type* __inext;
                __r = __cv_->in(__st_, __extbuf_, __extbufend_, __extbufnext_,
                                       this->eback() + __unget_sz,
                                       this->egptr(), __inext);
                if (__r == codecvt_base::noconv)
                {
                    this->setg((char_type*)__extbuf_, (char_type*)__extbuf_, (char_type*)__extbufend_);
                    __c = *this->gptr();
                }
                else if (__inext != this->eback() + __unget_sz)
                {
                    this->setg(this->eback(), this->eback() + __unget_sz, __inext);
                    __c = *this->gptr();
                }
            }
        }
    }
    else
        __c = *this->gptr();
    if (this->eback() == &__1buf)
        this->setg(0, 0, 0);
    return __c;
}

template <class _Codecvt, class _Elem, class _Tr>
typename wbuffer_convert<_Codecvt, _Elem, _Tr>::int_type
wbuffer_convert<_Codecvt, _Elem, _Tr>::pbackfail(int_type __c)
{
    if (__cv_ != 0 && __bufptr_ != 0 && this->eback() < this->gptr())
    {
        if (traits_type::eq_int_type(__c, traits_type::eof()))
        {
            this->gbump(-1);
            return traits_type::not_eof(__c);
        }
        if (traits_type::eq(traits_type::to_char_type(__c), this->gptr()[-1]))
        {
            this->gbump(-1);
            *this->gptr() = traits_type::to_char_type(__c);
            return __c;
        }
    }
    return traits_type::eof();
}

template <class _Codecvt, class _Elem, class _Tr>
typename wbuffer_convert<_Codecvt, _Elem, _Tr>::int_type
wbuffer_convert<_Codecvt, _Elem, _Tr>::overflow(int_type __c)
{
    if (__cv_ == 0 || __bufptr_ == 0)
        return traits_type::eof();
    __write_mode();
    char_type __1buf;
    char_type* __pb_save = this->pbase();
    char_type* __epb_save = this->epptr();
    if (!traits_type::eq_int_type(__c, traits_type::eof()))
    {
        if (this->pptr() == 0)
            this->setp(&__1buf, &__1buf+1);
        *this->pptr() = traits_type::to_char_type(__c);
        this->pbump(1);
    }
    if (this->pptr() != this->pbase())
    {
        if (__always_noconv_)
        {
            streamsize __nmemb = static_cast<streamsize>(this->pptr() - this->pbase());
            if (__bufptr_->sputn((const char*)this->pbase(), __nmemb) != __nmemb)
                return traits_type::eof();
        }
        else
        {
            char* __extbe = __extbuf_;
            codecvt_base::result __r;
            do
            {
                const char_type* __e;
                __r = __cv_->out(__st_, this->pbase(), this->pptr(), __e,
                                        __extbuf_, __extbuf_ + __ebs_, __extbe);
                if (__e == this->pbase())
                    return traits_type::eof();
                if (__r == codecvt_base::noconv)
                {
                    streamsize __nmemb = static_cast<size_t>(this->pptr() - this->pbase());
                    if (__bufptr_->sputn((const char*)this->pbase(), __nmemb) != __nmemb)
                        return traits_type::eof();
                }
                else if (__r == codecvt_base::ok || __r == codecvt_base::partial)
                {
                    streamsize __nmemb = static_cast<size_t>(__extbe - __extbuf_);
                    if (__bufptr_->sputn(__extbuf_, __nmemb) != __nmemb)
                        return traits_type::eof();
                    if (__r == codecvt_base::partial)
                    {
                        this->setp((char_type*)__e, this->pptr());
                        this->pbump(this->epptr() - this->pbase());
                    }
                }
                else
                    return traits_type::eof();
            } while (__r == codecvt_base::partial);
        }
        this->setp(__pb_save, __epb_save);
    }
    return traits_type::not_eof(__c);
}

template <class _Codecvt, class _Elem, class _Tr>
basic_streambuf<_Elem, _Tr>*
wbuffer_convert<_Codecvt, _Elem, _Tr>::setbuf(char_type* __s, streamsize __n)
{
    this->setg(0, 0, 0);
    this->setp(0, 0);
    if (__owns_eb_)
        delete [] __extbuf_;
    if (__owns_ib_)
        delete [] __intbuf_;
    __ebs_ = __n;
    if (__ebs_ > sizeof(__extbuf_min_))
    {
        if (__always_noconv_ && __s)
        {
            __extbuf_ = (char*)__s;
            __owns_eb_ = false;
        }
        else
        {
            __extbuf_ = new char[__ebs_];
            __owns_eb_ = true;
        }
    }
    else
    {
        __extbuf_ = __extbuf_min_;
        __ebs_ = sizeof(__extbuf_min_);
        __owns_eb_ = false;
    }
    if (!__always_noconv_)
    {
        __ibs_ = max<streamsize>(__n, sizeof(__extbuf_min_));
        if (__s && __ibs_ >= sizeof(__extbuf_min_))
        {
            __intbuf_ = __s;
            __owns_ib_ = false;
        }
        else
        {
            __intbuf_ = new char_type[__ibs_];
            __owns_ib_ = true;
        }
    }
    else
    {
        __ibs_ = 0;
        __intbuf_ = 0;
        __owns_ib_ = false;
    }
    return this;
}

template <class _Codecvt, class _Elem, class _Tr>
typename wbuffer_convert<_Codecvt, _Elem, _Tr>::pos_type
wbuffer_convert<_Codecvt, _Elem, _Tr>::seekoff(off_type __off, ios_base::seekdir __way,
                                        ios_base::openmode __om)
{
    int __width = __cv_->encoding();
    if (__cv_ == 0 || __bufptr_ == 0 || (__width <= 0 && __off != 0) || sync())
        return pos_type(off_type(-1));
    // __width > 0 || __off == 0
    switch (__way)
    {
    case ios_base::beg:
        break;
    case ios_base::cur:
        break;
    case ios_base::end:
        break;
    default:
        return pos_type(off_type(-1));
    }
    pos_type __r = __bufptr_->pubseekoff(__width * __off, __way, __om);
    __r.state(__st_);
    return __r;
}

template <class _Codecvt, class _Elem, class _Tr>
typename wbuffer_convert<_Codecvt, _Elem, _Tr>::pos_type
wbuffer_convert<_Codecvt, _Elem, _Tr>::seekpos(pos_type __sp, ios_base::openmode __wch)
{
    if (__cv_ == 0 || __bufptr_ == 0 || sync())
        return pos_type(off_type(-1));
    if (__bufptr_->pubseekpos(__sp, __wch) == pos_type(off_type(-1)))
        return pos_type(off_type(-1));
    return __sp;
}

template <class _Codecvt, class _Elem, class _Tr>
int
wbuffer_convert<_Codecvt, _Elem, _Tr>::sync()
{
    if (__cv_ == 0 || __bufptr_ == 0)
        return 0;
    if (__cm_ & ios_base::out)
    {
        if (this->pptr() != this->pbase())
            if (overflow() == traits_type::eof())
                return -1;
        codecvt_base::result __r;
        do
        {
            char* __extbe;
            __r = __cv_->unshift(__st_, __extbuf_, __extbuf_ + __ebs_, __extbe);
            streamsize __nmemb = static_cast<streamsize>(__extbe - __extbuf_);
            if (__bufptr_->sputn(__extbuf_, __nmemb) != __nmemb)
                return -1;
        } while (__r == codecvt_base::partial);
        if (__r == codecvt_base::error)
            return -1;
        if (__bufptr_->pubsync())
            return -1;
    }
    else if (__cm_ & ios_base::in)
    {
        off_type __c;
        if (__always_noconv_)
            __c = this->egptr() - this->gptr();
        else
        {
            int __width = __cv_->encoding();
            __c = __extbufend_ - __extbufnext_;
            if (__width > 0)
                __c += __width * (this->egptr() - this->gptr());
            else
            {
                if (this->gptr() != this->egptr())
                {
                    reverse(this->gptr(), this->egptr());
                    codecvt_base::result __r;
                    const char_type* __e = this->gptr();
                    char* __extbe;
                    do
                    {
                        __r = __cv_->out(__st_, __e, this->egptr(), __e,
                                         __extbuf_, __extbuf_ + __ebs_, __extbe);
                        switch (__r)
                        {
                        case codecvt_base::noconv:
                            __c += this->egptr() - this->gptr();
                            break;
                        case codecvt_base::ok:
                        case codecvt_base::partial:
                            __c += __extbe - __extbuf_;
                            break;
                        default:
                            return -1;
                        }
                    } while (__r == codecvt_base::partial);
                }
            }
        }
        if (__bufptr_->pubseekoff(-__c, ios_base::cur, __cm_) == pos_type(off_type(-1)))
            return -1;
        this->setg(0, 0, 0);
        __cm_ = 0;
    }
    return 0;
}

template <class _Codecvt, class _Elem, class _Tr>
bool
wbuffer_convert<_Codecvt, _Elem, _Tr>::__read_mode()
{
    if (!(__cm_ & ios_base::in))
    {
        this->setp(0, 0);
        if (__always_noconv_)
            this->setg((char_type*)__extbuf_,
                       (char_type*)__extbuf_ + __ebs_,
                       (char_type*)__extbuf_ + __ebs_);
        else
            this->setg(__intbuf_, __intbuf_ + __ibs_, __intbuf_ + __ibs_);
        __cm_ = ios_base::in;
        return true;
    }
    return false;
}

template <class _Codecvt, class _Elem, class _Tr>
void
wbuffer_convert<_Codecvt, _Elem, _Tr>::__write_mode()
{
    if (!(__cm_ & ios_base::out))
    {
        this->setg(0, 0, 0);
        if (__ebs_ > sizeof(__extbuf_min_))
        {
            if (__always_noconv_)
                this->setp((char_type*)__extbuf_,
                           (char_type*)__extbuf_ + (__ebs_ - 1));
            else
                this->setp(__intbuf_, __intbuf_ + (__ibs_ - 1));
        }
        else
            this->setp(0, 0);
        __cm_ = ios_base::out;
    }
}

template <class _Codecvt, class _Elem, class _Tr>
wbuffer_convert<_Codecvt, _Elem, _Tr>*
wbuffer_convert<_Codecvt, _Elem, _Tr>::__close()
{
    wbuffer_convert* __rt = 0;
    if (__cv_ != 0 && __bufptr_ != 0)
    {
        __rt = this;
        if ((__cm_ & ios_base::out) && sync())
            __rt = 0;
    }
    return __rt;
}

} }
# 134 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/ostream" 2 3

# 1 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/bitset" 1 3
// -*- C++ -*-
//===---------------------------- bitset ----------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is dual licensed under the MIT and the University of Illinois Open
// Source Licenses. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//




/*
    bitset synopsis

namespace std
{

namespace std {

template <size_t N>
class bitset
{
public:
    // bit reference:
    class reference
    {
        friend class bitset;
        reference() noexcept;
    public:
        ~reference() noexcept;
        reference& operator=(bool x) noexcept;           // for b[i] = x;
        reference& operator=(const reference&) noexcept; // for b[i] = b[j];
        bool operator~() const noexcept;                 // flips the bit
        operator bool() const noexcept;                  // for x = b[i];
        reference& flip() noexcept;                      // for b[i].flip();
    };

    // 23.3.5.1 constructors:
    constexpr bitset() noexcept;
    constexpr bitset(unsigned long long val) noexcept;
    template <class charT>
        explicit bitset(const charT* str,
                        typename basic_string<charT>::size_type n = basic_string<charT>::npos,
                        charT zero = charT('0'), charT one = charT('1'));
    template<class charT, class traits, class Allocator>
        explicit bitset(const basic_string<charT,traits,Allocator>& str,
                        typename basic_string<charT,traits,Allocator>::size_type pos = 0,
                        typename basic_string<charT,traits,Allocator>::size_type n =
                                 basic_string<charT,traits,Allocator>::npos,
                        charT zero = charT('0'), charT one = charT('1'));

    // 23.3.5.2 bitset operations:
    bitset& operator&=(const bitset& rhs) noexcept;
    bitset& operator|=(const bitset& rhs) noexcept;
    bitset& operator^=(const bitset& rhs) noexcept;
    bitset& operator<<=(size_t pos) noexcept;
    bitset& operator>>=(size_t pos) noexcept;
    bitset& set() noexcept;
    bitset& set(size_t pos, bool val = true);
    bitset& reset() noexcept;
    bitset& reset(size_t pos);
    bitset operator~() const noexcept;
    bitset& flip() noexcept;
    bitset& flip(size_t pos);

    // element access:
    constexpr bool operator[](size_t pos) const; // for b[i];
    reference operator[](size_t pos);            // for b[i];
    unsigned long to_ulong() const;
    unsigned long long to_ullong() const;
    template <class charT, class traits, class Allocator>
        basic_string<charT, traits, Allocator> to_string(charT zero = charT('0'), charT one = charT('1')) const;
    template <class charT, class traits>
        basic_string<charT, traits, allocator<charT> > to_string(charT zero = charT('0'), charT one = charT('1')) const;
    template <class charT>
        basic_string<charT, char_traits<charT>, allocator<charT> > to_string(charT zero = charT('0'), charT one = charT('1')) const;
    basic_string<char, char_traits<char>, allocator<char> > to_string(char zero = '0', char one = '1') const;
    size_t count() const noexcept;
    constexpr size_t size() const noexcept;
    bool operator==(const bitset& rhs) const noexcept;
    bool operator!=(const bitset& rhs) const noexcept;
    bool test(size_t pos) const;
    bool all() const noexcept;
    bool any() const noexcept;
    bool none() const noexcept;
    bitset operator<<(size_t pos) const noexcept;
    bitset operator>>(size_t pos) const noexcept;
};

// 23.3.5.3 bitset operators:
template <size_t N>
bitset<N> operator&(const bitset<N>&, const bitset<N>&) noexcept;

template <size_t N>
bitset<N> operator|(const bitset<N>&, const bitset<N>&) noexcept;

template <size_t N>
bitset<N> operator^(const bitset<N>&, const bitset<N>&) noexcept;

template <class charT, class traits, size_t N>
basic_istream<charT, traits>&
operator>>(basic_istream<charT, traits>& is, bitset<N>& x);

template <class charT, class traits, size_t N>
basic_ostream<charT, traits>&
operator<<(basic_ostream<charT, traits>& os, const bitset<N>& x);

template <size_t N> struct hash<std::bitset<N>>;

}  // std

*/
# 118 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/bitset" 3



# 1 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/__bit_reference" 1 3
// -*- C++ -*-
//===----------------------------------------------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is dual licensed under the MIT and the University of Illinois Open
// Source Licenses. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//








# 1 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/__undef_min_max" 1 3
// -*- C++ -*-
//===----------------------------------------------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is dual licensed under the MIT and the University of Illinois Open
// Source Licenses. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
# 18 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/__bit_reference" 2 3
# 21 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/__bit_reference" 3


namespace std {inline namespace __1 {

template <class _Cp, bool _IsConst, typename _Cp::__storage_type = 0> class __bit_iterator;
template <class _Cp> class __bit_const_reference;

template <class _Tp>
struct __has_storage_type
{
    static const bool value = false;
};

template <class _Cp, bool = __has_storage_type<_Cp>::value>
class __bit_reference
{
    typedef typename _Cp::__storage_type __storage_type;
    typedef typename _Cp::__storage_pointer __storage_pointer;

    __storage_pointer __seg_;
    __storage_type __mask_;


    friend typename _Cp::__self;



    friend class __bit_const_reference<_Cp>;
    friend class __bit_iterator<_Cp, false>;
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) operator bool() const throw()
        {return static_cast<bool>(*__seg_ & __mask_);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) bool operator ~() const throw()
        {return !static_cast<bool>(*this);}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    __bit_reference& operator=(bool __x) throw()
    {
        if (__x)
            *__seg_ |= __mask_;
        else
            *__seg_ &= ~__mask_;
        return *this;
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    __bit_reference& operator=(const __bit_reference& __x) throw()
        {return operator=(static_cast<bool>(__x));}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) void flip() throw() {*__seg_ ^= __mask_;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) __bit_iterator<_Cp, false> operator&() const throw()
        {return __bit_iterator<_Cp, false>(__seg_, static_cast<unsigned>(__ctz(__mask_)));}
private:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    __bit_reference(__storage_pointer __s, __storage_type __m) throw()
        : __seg_(__s), __mask_(__m) {}
};

template <class _Cp>
class __bit_reference<_Cp, false>
{
};

template <class _Cp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
swap(__bit_reference<_Cp> __x, __bit_reference<_Cp> __y) throw()
{
    bool __t = __x;
    __x = __y;
    __y = __t;
}

template <class _Cp, class _Dp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
swap(__bit_reference<_Cp> __x, __bit_reference<_Dp> __y) throw()
{
    bool __t = __x;
    __x = __y;
    __y = __t;
}

template <class _Cp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
swap(__bit_reference<_Cp> __x, bool& __y) throw()
{
    bool __t = __x;
    __x = __y;
    __y = __t;
}

template <class _Cp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
swap(bool& __x, __bit_reference<_Cp> __y) throw()
{
    bool __t = __x;
    __x = __y;
    __y = __t;
}

template <class _Cp>
class __bit_const_reference
{
    typedef typename _Cp::__storage_type __storage_type;
    typedef typename _Cp::__const_storage_pointer __storage_pointer;

    __storage_pointer __seg_;
    __storage_type __mask_;


    friend typename _Cp::__self;



    friend class __bit_iterator<_Cp, true>;
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    __bit_const_reference(const __bit_reference<_Cp>& __x) throw()
        : __seg_(__x.__seg_), __mask_(__x.__mask_) {}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) operator bool() const throw()
        {return static_cast<bool>(*__seg_ & __mask_);}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) __bit_iterator<_Cp, true> operator&() const throw()
        {return __bit_iterator<_Cp, true>(__seg_, static_cast<unsigned>(__ctz(__mask_)));}
private:
    __attribute__ ((__visibility__("hidden"), __always_inline__))

    __bit_const_reference(__storage_pointer __s, __storage_type __m) throw()
        : __seg_(__s), __mask_(__m) {}

    __bit_const_reference& operator=(const __bit_const_reference& __x);
};

// find

template <class _Cp, bool _IsConst>
__bit_iterator<_Cp, _IsConst>
__find_bool_true(__bit_iterator<_Cp, _IsConst> __first, typename _Cp::size_type __n)
{
    typedef __bit_iterator<_Cp, _IsConst> _It;
    typedef typename _It::__storage_type __storage_type;
    static const unsigned __bits_per_word = _It::__bits_per_word;
    // do first partial word
    if (__first.__ctz_ != 0)
    {
        __storage_type __clz_f = static_cast<__storage_type>(__bits_per_word - __first.__ctz_);
        __storage_type __dn = std::__1::min(__clz_f, __n);
        __storage_type __m = (~__storage_type(0) << __first.__ctz_) & (~__storage_type(0) >> (__clz_f - __dn));
        __storage_type __b = *__first.__seg_ & __m;
        if (__b)
            return _It(__first.__seg_, static_cast<unsigned>(std::__1::__ctz(__b)));
        if (__n == __dn)
            return __first + __n;
        __n -= __dn;
        ++__first.__seg_;
    }
    // do middle whole words
    for (; __n >= __bits_per_word; ++__first.__seg_, __n -= __bits_per_word)
        if (*__first.__seg_)
            return _It(__first.__seg_, static_cast<unsigned>(std::__1::__ctz(*__first.__seg_)));
    // do last partial word
    if (__n > 0)
    {
        __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
        __storage_type __b = *__first.__seg_ & __m;
        if (__b)
            return _It(__first.__seg_, static_cast<unsigned>(std::__1::__ctz(__b)));
    }
    return _It(__first.__seg_, static_cast<unsigned>(__n));
}

template <class _Cp, bool _IsConst>
__bit_iterator<_Cp, _IsConst>
__find_bool_false(__bit_iterator<_Cp, _IsConst> __first, typename _Cp::size_type __n)
{
    typedef __bit_iterator<_Cp, _IsConst> _It;
    typedef typename _It::__storage_type __storage_type;
    static const unsigned __bits_per_word = _It::__bits_per_word;
    // do first partial word
    if (__first.__ctz_ != 0)
    {
        __storage_type __clz_f = static_cast<__storage_type>(__bits_per_word - __first.__ctz_);
        __storage_type __dn = std::__1::min(__clz_f, __n);
        __storage_type __m = (~__storage_type(0) << __first.__ctz_) & (~__storage_type(0) >> (__clz_f - __dn));
        __storage_type __b = ~*__first.__seg_ & __m;
        if (__b)
            return _It(__first.__seg_, static_cast<unsigned>(std::__1::__ctz(__b)));
        if (__n == __dn)
            return __first + __n;
        __n -= __dn;
        ++__first.__seg_;
    }
    // do middle whole words
    for (; __n >= __bits_per_word; ++__first.__seg_, __n -= __bits_per_word)
    {
        __storage_type __b = ~*__first.__seg_;
        if (__b)
            return _It(__first.__seg_, static_cast<unsigned>(std::__1::__ctz(__b)));
    }
    // do last partial word
    if (__n > 0)
    {
        __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
        __storage_type __b = ~*__first.__seg_ & __m;
        if (__b)
            return _It(__first.__seg_, static_cast<unsigned>(std::__1::__ctz(__b)));
    }
    return _It(__first.__seg_, static_cast<unsigned>(__n));
}

template <class _Cp, bool _IsConst, class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
__bit_iterator<_Cp, _IsConst>
find(__bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last, const _Tp& __value_)
{
    if (static_cast<bool>(__value_))
        return __find_bool_true(__first, static_cast<typename _Cp::size_type>(__last - __first));
    return __find_bool_false(__first, static_cast<typename _Cp::size_type>(__last - __first));
}

// count

template <class _Cp, bool _IsConst>
typename __bit_iterator<_Cp, _IsConst>::difference_type
__count_bool_true(__bit_iterator<_Cp, _IsConst> __first, typename _Cp::size_type __n)
{
    typedef __bit_iterator<_Cp, _IsConst> _It;
    typedef typename _It::__storage_type __storage_type;
    typedef typename _It::difference_type difference_type;
    static const unsigned __bits_per_word = _It::__bits_per_word;
    difference_type __r = 0;
    // do first partial word
    if (__first.__ctz_ != 0)
    {
        __storage_type __clz_f = static_cast<__storage_type>(__bits_per_word - __first.__ctz_);
        __storage_type __dn = std::__1::min(__clz_f, __n);
        __storage_type __m = (~__storage_type(0) << __first.__ctz_) & (~__storage_type(0) >> (__clz_f - __dn));
        __r = std::__1::__pop_count(*__first.__seg_ & __m);
        __n -= __dn;
        ++__first.__seg_;
    }
    // do middle whole words
    for (; __n >= __bits_per_word; ++__first.__seg_, __n -= __bits_per_word)
        __r += std::__1::__pop_count(*__first.__seg_);
    // do last partial word
    if (__n > 0)
    {
        __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
        __r += std::__1::__pop_count(*__first.__seg_ & __m);
    }
    return __r;
}

template <class _Cp, bool _IsConst>
typename __bit_iterator<_Cp, _IsConst>::difference_type
__count_bool_false(__bit_iterator<_Cp, _IsConst> __first, typename _Cp::size_type __n)
{
    typedef __bit_iterator<_Cp, _IsConst> _It;
    typedef typename _It::__storage_type __storage_type;
    typedef typename _It::difference_type difference_type;
    static const unsigned __bits_per_word = _It::__bits_per_word;
    difference_type __r = 0;
    // do first partial word
    if (__first.__ctz_ != 0)
    {
        __storage_type __clz_f = static_cast<__storage_type>(__bits_per_word - __first.__ctz_);
        __storage_type __dn = std::__1::min(__clz_f, __n);
        __storage_type __m = (~__storage_type(0) << __first.__ctz_) & (~__storage_type(0) >> (__clz_f - __dn));
        __r = std::__1::__pop_count(~*__first.__seg_ & __m);
        __n -= __dn;
        ++__first.__seg_;
    }
    // do middle whole words
    for (; __n >= __bits_per_word; ++__first.__seg_, __n -= __bits_per_word)
        __r += std::__1::__pop_count(~*__first.__seg_);
    // do last partial word
    if (__n > 0)
    {
        __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
        __r += std::__1::__pop_count(~*__first.__seg_ & __m);
    }
    return __r;
}

template <class _Cp, bool _IsConst, class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename __bit_iterator<_Cp, _IsConst>::difference_type
count(__bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last, const _Tp& __value_)
{
    if (static_cast<bool>(__value_))
        return __count_bool_true(__first, static_cast<typename _Cp::size_type>(__last - __first));
    return __count_bool_false(__first, static_cast<typename _Cp::size_type>(__last - __first));
}

// fill_n

template <class _Cp>
void
__fill_n_false(__bit_iterator<_Cp, false> __first, typename _Cp::size_type __n)
{
    typedef __bit_iterator<_Cp, false> _It;
    typedef typename _It::__storage_type __storage_type;
    static const unsigned __bits_per_word = _It::__bits_per_word;
    // do first partial word
    if (__first.__ctz_ != 0)
    {
        __storage_type __clz_f = static_cast<__storage_type>(__bits_per_word - __first.__ctz_);
        __storage_type __dn = std::__1::min(__clz_f, __n);
        __storage_type __m = (~__storage_type(0) << __first.__ctz_) & (~__storage_type(0) >> (__clz_f - __dn));
        *__first.__seg_ &= ~__m;
        __n -= __dn;
        ++__first.__seg_;
    }
    // do middle whole words
    __storage_type __nw = __n / __bits_per_word;
    std::__1::memset(std::__1::__to_raw_pointer(__first.__seg_), 0, __nw * sizeof(__storage_type));
    __n -= __nw * __bits_per_word;
    // do last partial word
    if (__n > 0)
    {
        __first.__seg_ += __nw;
        __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
        *__first.__seg_ &= ~__m;
    }
}

template <class _Cp>
void
__fill_n_true(__bit_iterator<_Cp, false> __first, typename _Cp::size_type __n)
{
    typedef __bit_iterator<_Cp, false> _It;
    typedef typename _It::__storage_type __storage_type;
    static const unsigned __bits_per_word = _It::__bits_per_word;
    // do first partial word
    if (__first.__ctz_ != 0)
    {
        __storage_type __clz_f = static_cast<__storage_type>(__bits_per_word - __first.__ctz_);
        __storage_type __dn = std::__1::min(__clz_f, __n);
        __storage_type __m = (~__storage_type(0) << __first.__ctz_) & (~__storage_type(0) >> (__clz_f - __dn));
        *__first.__seg_ |= __m;
        __n -= __dn;
        ++__first.__seg_;
    }
    // do middle whole words
    __storage_type __nw = __n / __bits_per_word;
    std::__1::memset(std::__1::__to_raw_pointer(__first.__seg_), -1, __nw * sizeof(__storage_type));
    __n -= __nw * __bits_per_word;
    // do last partial word
    if (__n > 0)
    {
        __first.__seg_ += __nw;
        __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
        *__first.__seg_ |= __m;
    }
}

template <class _Cp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
fill_n(__bit_iterator<_Cp, false> __first, typename _Cp::size_type __n, bool __value_)
{
    if (__n > 0)
    {
        if (__value_)
            __fill_n_true(__first, __n);
        else
            __fill_n_false(__first, __n);
    }
}

// fill

template <class _Cp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
fill(__bit_iterator<_Cp, false> __first, __bit_iterator<_Cp, false> __last, bool __value_)
{
    std::__1::fill_n(__first, static_cast<typename _Cp::size_type>(__last - __first), __value_);
}

// copy

template <class _Cp, bool _IsConst>
__bit_iterator<_Cp, false>
__copy_aligned(__bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last,
                                                     __bit_iterator<_Cp, false> __result)
{
    typedef __bit_iterator<_Cp, _IsConst> _In;
    typedef typename _In::difference_type difference_type;
    typedef typename _In::__storage_type __storage_type;
    static const unsigned __bits_per_word = _In::__bits_per_word;
    difference_type __n = __last - __first;
    if (__n > 0)
    {
        // do first word
        if (__first.__ctz_ != 0)
        {
            unsigned __clz = __bits_per_word - __first.__ctz_;
            difference_type __dn = std::__1::min(static_cast<difference_type>(__clz), __n);
            __n -= __dn;
            __storage_type __m = (~__storage_type(0) << __first.__ctz_) & (~__storage_type(0) >> (__clz - __dn));
            __storage_type __b = *__first.__seg_ & __m;
            *__result.__seg_ &= ~__m;
            *__result.__seg_ |= __b;
            __result.__seg_ += (__dn + __result.__ctz_) / __bits_per_word;
            __result.__ctz_ = static_cast<unsigned>((__dn + __result.__ctz_) % __bits_per_word);
            ++__first.__seg_;
            // __first.__ctz_ = 0;
        }
        // __first.__ctz_ == 0;
        // do middle words
        __storage_type __nw = __n / __bits_per_word;
        std::__1::memmove(std::__1::__to_raw_pointer(__result.__seg_),
                       std::__1::__to_raw_pointer(__first.__seg_),
                       __nw * sizeof(__storage_type));
        __n -= __nw * __bits_per_word;
        __result.__seg_ += __nw;
        // do last word
        if (__n > 0)
        {
            __first.__seg_ += __nw;
            __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
            __storage_type __b = *__first.__seg_ & __m;
            *__result.__seg_ &= ~__m;
            *__result.__seg_ |= __b;
            __result.__ctz_ = static_cast<unsigned>(__n);
        }
    }
    return __result;
}

template <class _Cp, bool _IsConst>
__bit_iterator<_Cp, false>
__copy_unaligned(__bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last,
                                                       __bit_iterator<_Cp, false> __result)
{
    typedef __bit_iterator<_Cp, _IsConst> _In;
    typedef typename _In::difference_type difference_type;
    typedef typename _In::__storage_type __storage_type;
    static const unsigned __bits_per_word = _In::__bits_per_word;
    difference_type __n = __last - __first;
    if (__n > 0)
    {
        // do first word
        if (__first.__ctz_ != 0)
        {
            unsigned __clz_f = __bits_per_word - __first.__ctz_;
            difference_type __dn = std::__1::min(static_cast<difference_type>(__clz_f), __n);
            __n -= __dn;
            __storage_type __m = (~__storage_type(0) << __first.__ctz_) & (~__storage_type(0) >> (__clz_f - __dn));
            __storage_type __b = *__first.__seg_ & __m;
            unsigned __clz_r = __bits_per_word - __result.__ctz_;
            __storage_type __ddn = std::__1::min<__storage_type>(__dn, __clz_r);
            __m = (~__storage_type(0) << __result.__ctz_) & (~__storage_type(0) >> (__clz_r - __ddn));
            *__result.__seg_ &= ~__m;
            if (__result.__ctz_ > __first.__ctz_)
                *__result.__seg_ |= __b << (__result.__ctz_ - __first.__ctz_);
            else
                *__result.__seg_ |= __b >> (__first.__ctz_ - __result.__ctz_);
            __result.__seg_ += (__ddn + __result.__ctz_) / __bits_per_word;
            __result.__ctz_ = static_cast<unsigned>((__ddn + __result.__ctz_) % __bits_per_word);
            __dn -= __ddn;
            if (__dn > 0)
            {
                __m = ~__storage_type(0) >> (__bits_per_word - __dn);
                *__result.__seg_ &= ~__m;
                *__result.__seg_ |= __b >> (__first.__ctz_ + __ddn);
                __result.__ctz_ = static_cast<unsigned>(__dn);
            }
            ++__first.__seg_;
            // __first.__ctz_ = 0;
        }
        // __first.__ctz_ == 0;
        // do middle words
        unsigned __clz_r = __bits_per_word - __result.__ctz_;
        __storage_type __m = ~__storage_type(0) << __result.__ctz_;
        for (; __n >= __bits_per_word; __n -= __bits_per_word, ++__first.__seg_)
        {
            __storage_type __b = *__first.__seg_;
            *__result.__seg_ &= ~__m;
            *__result.__seg_ |= __b << __result.__ctz_;
            ++__result.__seg_;
            *__result.__seg_ &= __m;
            *__result.__seg_ |= __b >> __clz_r;
        }
        // do last word
        if (__n > 0)
        {
            __m = ~__storage_type(0) >> (__bits_per_word - __n);
            __storage_type __b = *__first.__seg_ & __m;
            __storage_type __dn = std::__1::min(__n, static_cast<difference_type>(__clz_r));
            __m = (~__storage_type(0) << __result.__ctz_) & (~__storage_type(0) >> (__clz_r - __dn));
            *__result.__seg_ &= ~__m;
            *__result.__seg_ |= __b << __result.__ctz_;
            __result.__seg_ += (__dn + __result.__ctz_) / __bits_per_word;
            __result.__ctz_ = static_cast<unsigned>((__dn + __result.__ctz_) % __bits_per_word);
            __n -= __dn;
            if (__n > 0)
            {
                __m = ~__storage_type(0) >> (__bits_per_word - __n);
                *__result.__seg_ &= ~__m;
                *__result.__seg_ |= __b >> __dn;
                __result.__ctz_ = static_cast<unsigned>(__n);
            }
        }
    }
    return __result;
}

template <class _Cp, bool _IsConst>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
__bit_iterator<_Cp, false>
copy(__bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last, __bit_iterator<_Cp, false> __result)
{
    if (__first.__ctz_ == __result.__ctz_)
        return __copy_aligned(__first, __last, __result);
    return __copy_unaligned(__first, __last, __result);
}

// copy_backward

template <class _Cp, bool _IsConst>
__bit_iterator<_Cp, false>
__copy_backward_aligned(__bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last,
                                                     __bit_iterator<_Cp, false> __result)
{
    typedef __bit_iterator<_Cp, _IsConst> _In;
    typedef typename _In::difference_type difference_type;
    typedef typename _In::__storage_type __storage_type;
    static const unsigned __bits_per_word = _In::__bits_per_word;
    difference_type __n = __last - __first;
    if (__n > 0)
    {
        // do first word
        if (__last.__ctz_ != 0)
        {
            difference_type __dn = std::__1::min(static_cast<difference_type>(__last.__ctz_), __n);
            __n -= __dn;
            unsigned __clz = __bits_per_word - __last.__ctz_;
            __storage_type __m = (~__storage_type(0) << (__last.__ctz_ - __dn)) & (~__storage_type(0) >> __clz);
            __storage_type __b = *__last.__seg_ & __m;
            *__result.__seg_ &= ~__m;
            *__result.__seg_ |= __b;
            __result.__ctz_ = static_cast<unsigned>(((-__dn & (__bits_per_word - 1)) +
                                                       __result.__ctz_) % __bits_per_word);
            // __last.__ctz_ = 0
         }
        // __last.__ctz_ == 0 || __n == 0
        // __result.__ctz_ == 0 || __n == 0
        // do middle words
        __storage_type __nw = __n / __bits_per_word;
        __result.__seg_ -= __nw;
        __last.__seg_ -= __nw;
        std::__1::memmove(std::__1::__to_raw_pointer(__result.__seg_),
                       std::__1::__to_raw_pointer(__last.__seg_),
                       __nw * sizeof(__storage_type));
        __n -= __nw * __bits_per_word;
        // do last word
        if (__n > 0)
        {
            __storage_type __m = ~__storage_type(0) << (__bits_per_word - __n);
            __storage_type __b = *--__last.__seg_ & __m;
            *--__result.__seg_ &= ~__m;
            *__result.__seg_ |= __b;
            __result.__ctz_ = static_cast<unsigned>(-__n & (__bits_per_word - 1));
        }
    }
    return __result;
}

template <class _Cp, bool _IsConst>
__bit_iterator<_Cp, false>
__copy_backward_unaligned(__bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last,
                                                       __bit_iterator<_Cp, false> __result)
{
    typedef __bit_iterator<_Cp, _IsConst> _In;
    typedef typename _In::difference_type difference_type;
    typedef typename _In::__storage_type __storage_type;
    static const unsigned __bits_per_word = _In::__bits_per_word;
    difference_type __n = __last - __first;
    if (__n > 0)
    {
        // do first word
        if (__last.__ctz_ != 0)
        {
            difference_type __dn = std::__1::min(static_cast<difference_type>(__last.__ctz_), __n);
            __n -= __dn;
            unsigned __clz_l = __bits_per_word - __last.__ctz_;
            __storage_type __m = (~__storage_type(0) << (__last.__ctz_ - __dn)) & (~__storage_type(0) >> __clz_l);
            __storage_type __b = *__last.__seg_ & __m;
            unsigned __clz_r = __bits_per_word - __result.__ctz_;
            __storage_type __ddn = std::__1::min(__dn, static_cast<difference_type>(__result.__ctz_));
            if (__ddn > 0)
            {
                __m = (~__storage_type(0) << (__result.__ctz_ - __ddn)) & (~__storage_type(0) >> __clz_r);
                *__result.__seg_ &= ~__m;
                if (__result.__ctz_ > __last.__ctz_)
                    *__result.__seg_ |= __b << (__result.__ctz_ - __last.__ctz_);
                else
                    *__result.__seg_ |= __b >> (__last.__ctz_ - __result.__ctz_);
                __result.__ctz_ = static_cast<unsigned>(((-__ddn & (__bits_per_word - 1)) +
                                                         __result.__ctz_) % __bits_per_word);
                __dn -= __ddn;
            }
            if (__dn > 0)
            {
                // __result.__ctz_ == 0
                --__result.__seg_;
                __result.__ctz_ = static_cast<unsigned>(-__dn & (__bits_per_word - 1));
                __m = ~__storage_type(0) << __result.__ctz_;
                *__result.__seg_ &= ~__m;
                __last.__ctz_ -= __dn + __ddn;
                *__result.__seg_ |= __b << (__result.__ctz_ - __last.__ctz_);
            }
            // __last.__ctz_ = 0
         }
        // __last.__ctz_ == 0 || __n == 0
        // __result.__ctz_ != 0 || __n == 0
        // do middle words
        unsigned __clz_r = __bits_per_word - __result.__ctz_;
        __storage_type __m = ~__storage_type(0) >> __clz_r;
        for (; __n >= __bits_per_word; __n -= __bits_per_word)
        {
            __storage_type __b = *--__last.__seg_;
            *__result.__seg_ &= ~__m;
            *__result.__seg_ |= __b >> __clz_r;
            *--__result.__seg_ &= __m;
            *__result.__seg_ |= __b << __result.__ctz_;
        }
        // do last word
        if (__n > 0)
        {
            __m = ~__storage_type(0) << (__bits_per_word - __n);
            __storage_type __b = *--__last.__seg_ & __m;
            __clz_r = __bits_per_word - __result.__ctz_;
            __storage_type __dn = std::__1::min(__n, static_cast<difference_type>(__result.__ctz_));
            __m = (~__storage_type(0) << (__result.__ctz_ - __dn)) & (~__storage_type(0) >> __clz_r);
            *__result.__seg_ &= ~__m;
            *__result.__seg_ |= __b >> (__bits_per_word - __result.__ctz_);
            __result.__ctz_ = static_cast<unsigned>(((-__dn & (__bits_per_word - 1)) +
                                                     __result.__ctz_) % __bits_per_word);
            __n -= __dn;
            if (__n > 0)
            {
                // __result.__ctz_ == 0
                --__result.__seg_;
                __result.__ctz_ = static_cast<unsigned>(-__n & (__bits_per_word - 1));
                __m = ~__storage_type(0) << __result.__ctz_;
                *__result.__seg_ &= ~__m;
                *__result.__seg_ |= __b << (__result.__ctz_ - (__bits_per_word - __n - __dn));
            }
        }
    }
    return __result;
}

template <class _Cp, bool _IsConst>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
__bit_iterator<_Cp, false>
copy_backward(__bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last, __bit_iterator<_Cp, false> __result)
{
    if (__last.__ctz_ == __result.__ctz_)
        return __copy_backward_aligned(__first, __last, __result);
    return __copy_backward_unaligned(__first, __last, __result);
}

// move

template <class _Cp, bool _IsConst>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
__bit_iterator<_Cp, false>
move(__bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last, __bit_iterator<_Cp, false> __result)
{
    return std::__1::copy(__first, __last, __result);
}

// move_backward

template <class _Cp, bool _IsConst>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
__bit_iterator<_Cp, false>
move_backward(__bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last, __bit_iterator<_Cp, false> __result)
{
    return std::__1::copy(__first, __last, __result);
}

// swap_ranges

template <class __C1, class __C2>
__bit_iterator<__C2, false>
__swap_ranges_aligned(__bit_iterator<__C1, false> __first, __bit_iterator<__C1, false> __last,
                      __bit_iterator<__C2, false> __result)
{
    typedef __bit_iterator<__C1, false> _I1;
    typedef typename _I1::difference_type difference_type;
    typedef typename _I1::__storage_type __storage_type;
    static const unsigned __bits_per_word = _I1::__bits_per_word;
    difference_type __n = __last - __first;
    if (__n > 0)
    {
        // do first word
        if (__first.__ctz_ != 0)
        {
            unsigned __clz = __bits_per_word - __first.__ctz_;
            difference_type __dn = std::__1::min(static_cast<difference_type>(__clz), __n);
            __n -= __dn;
            __storage_type __m = (~__storage_type(0) << __first.__ctz_) & (~__storage_type(0) >> (__clz - __dn));
            __storage_type __b1 = *__first.__seg_ & __m;
            *__first.__seg_ &= ~__m;
            __storage_type __b2 = *__result.__seg_ & __m;
            *__result.__seg_ &= ~__m;
            *__result.__seg_ |= __b1;
            *__first.__seg_ |= __b2;
            __result.__seg_ += (__dn + __result.__ctz_) / __bits_per_word;
            __result.__ctz_ = static_cast<unsigned>((__dn + __result.__ctz_) % __bits_per_word);
            ++__first.__seg_;
            // __first.__ctz_ = 0;
        }
        // __first.__ctz_ == 0;
        // do middle words
        for (; __n >= __bits_per_word; __n -= __bits_per_word, ++__first.__seg_, ++__result.__seg_)
            swap(*__first.__seg_, *__result.__seg_);
        // do last word
        if (__n > 0)
        {
            __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
            __storage_type __b1 = *__first.__seg_ & __m;
            *__first.__seg_ &= ~__m;
            __storage_type __b2 = *__result.__seg_ & __m;
            *__result.__seg_ &= ~__m;
            *__result.__seg_ |= __b1;
            *__first.__seg_ |= __b2;
            __result.__ctz_ = static_cast<unsigned>(__n);
        }
    }
    return __result;
}

template <class __C1, class __C2>
__bit_iterator<__C2, false>
__swap_ranges_unaligned(__bit_iterator<__C1, false> __first, __bit_iterator<__C1, false> __last,
                        __bit_iterator<__C2, false> __result)
{
    typedef __bit_iterator<__C1, false> _I1;
    typedef typename _I1::difference_type difference_type;
    typedef typename _I1::__storage_type __storage_type;
    static const unsigned __bits_per_word = _I1::__bits_per_word;
    difference_type __n = __last - __first;
    if (__n > 0)
    {
        // do first word
        if (__first.__ctz_ != 0)
        {
            unsigned __clz_f = __bits_per_word - __first.__ctz_;
            difference_type __dn = std::__1::min(static_cast<difference_type>(__clz_f), __n);
            __n -= __dn;
            __storage_type __m = (~__storage_type(0) << __first.__ctz_) & (~__storage_type(0) >> (__clz_f - __dn));
            __storage_type __b1 = *__first.__seg_ & __m;
            *__first.__seg_ &= ~__m;
            unsigned __clz_r = __bits_per_word - __result.__ctz_;
            __storage_type __ddn = std::__1::min<__storage_type>(__dn, __clz_r);
            __m = (~__storage_type(0) << __result.__ctz_) & (~__storage_type(0) >> (__clz_r - __ddn));
            __storage_type __b2 = *__result.__seg_ & __m;
            *__result.__seg_ &= ~__m;
            if (__result.__ctz_ > __first.__ctz_)
            {
                unsigned __s = __result.__ctz_ - __first.__ctz_;
                *__result.__seg_ |= __b1 << __s;
                *__first.__seg_ |= __b2 >> __s;
            }
            else
            {
                unsigned __s = __first.__ctz_ - __result.__ctz_;
                *__result.__seg_ |= __b1 >> __s;
                *__first.__seg_ |= __b2 << __s;
            }
            __result.__seg_ += (__ddn + __result.__ctz_) / __bits_per_word;
            __result.__ctz_ = static_cast<unsigned>((__ddn + __result.__ctz_) % __bits_per_word);
            __dn -= __ddn;
            if (__dn > 0)
            {
                __m = ~__storage_type(0) >> (__bits_per_word - __dn);
                __b2 = *__result.__seg_ & __m;
                *__result.__seg_ &= ~__m;
                unsigned __s = __first.__ctz_ + __ddn;
                *__result.__seg_ |= __b1 >> __s;
                *__first.__seg_ |= __b2 << __s;
                __result.__ctz_ = static_cast<unsigned>(__dn);
            }
            ++__first.__seg_;
            // __first.__ctz_ = 0;
        }
        // __first.__ctz_ == 0;
        // do middle words
        __storage_type __m = ~__storage_type(0) << __result.__ctz_;
        unsigned __clz_r = __bits_per_word - __result.__ctz_;
        for (; __n >= __bits_per_word; __n -= __bits_per_word, ++__first.__seg_)
        {
            __storage_type __b1 = *__first.__seg_;
            __storage_type __b2 = *__result.__seg_ & __m;
            *__result.__seg_ &= ~__m;
            *__result.__seg_ |= __b1 << __result.__ctz_;
            *__first.__seg_ = __b2 >> __result.__ctz_;
            ++__result.__seg_;
            __b2 = *__result.__seg_ & ~__m;
            *__result.__seg_ &= __m;
            *__result.__seg_ |= __b1 >> __clz_r;
            *__first.__seg_ |= __b2 << __clz_r;
        }
        // do last word
        if (__n > 0)
        {
            __m = ~__storage_type(0) >> (__bits_per_word - __n);
            __storage_type __b1 = *__first.__seg_ & __m;
            *__first.__seg_ &= ~__m;
            __storage_type __dn = std::__1::min<__storage_type>(__n, __clz_r);
            __m = (~__storage_type(0) << __result.__ctz_) & (~__storage_type(0) >> (__clz_r - __dn));
            __storage_type __b2 = *__result.__seg_ & __m;
            *__result.__seg_ &= ~__m;
            *__result.__seg_ |= __b1 << __result.__ctz_;
            *__first.__seg_ |= __b2 >> __result.__ctz_;
            __result.__seg_ += (__dn + __result.__ctz_) / __bits_per_word;
            __result.__ctz_ = static_cast<unsigned>((__dn + __result.__ctz_) % __bits_per_word);
            __n -= __dn;
            if (__n > 0)
            {
                __m = ~__storage_type(0) >> (__bits_per_word - __n);
                __b2 = *__result.__seg_ & __m;
                *__result.__seg_ &= ~__m;
                *__result.__seg_ |= __b1 >> __dn;
                *__first.__seg_ |= __b2 << __dn;
                __result.__ctz_ = static_cast<unsigned>(__n);
            }
        }
    }
    return __result;
}

template <class __C1, class __C2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
__bit_iterator<__C2, false>
swap_ranges(__bit_iterator<__C1, false> __first1, __bit_iterator<__C1, false> __last1,
            __bit_iterator<__C2, false> __first2)
{
    if (__first1.__ctz_ == __first2.__ctz_)
        return __swap_ranges_aligned(__first1, __last1, __first2);
    return __swap_ranges_unaligned(__first1, __last1, __first2);
}

// rotate

template <class _Cp>
struct __bit_array
{
    typedef typename _Cp::difference_type difference_type;
    typedef typename _Cp::__storage_type __storage_type;
    typedef typename _Cp::__storage_pointer __storage_pointer;
    typedef typename _Cp::iterator iterator;
    static const unsigned __bits_per_word = _Cp::__bits_per_word;
    static const unsigned _Np = 4;

    difference_type __size_;
    __storage_type __word_[_Np];

    __attribute__ ((__visibility__("hidden"), __always_inline__)) static difference_type capacity()
        {return static_cast<difference_type>(_Np * __bits_per_word);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit __bit_array(difference_type __s) : __size_(__s) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) iterator begin()
    {
        return iterator(pointer_traits<__storage_pointer>::pointer_to(__word_[0]), 0);
    }
    __attribute__ ((__visibility__("hidden"), __always_inline__)) iterator end()
    {
        return iterator(pointer_traits<__storage_pointer>::pointer_to(__word_[0]) + __size_ / __bits_per_word,
                                                  static_cast<unsigned>(__size_ % __bits_per_word));
    }
};

template <class _Cp>
__bit_iterator<_Cp, false>
rotate(__bit_iterator<_Cp, false> __first, __bit_iterator<_Cp, false> __middle, __bit_iterator<_Cp, false> __last)
{
    typedef __bit_iterator<_Cp, false> _I1;
    typedef typename _I1::difference_type difference_type;
    typedef typename _I1::__storage_type __storage_type;
    difference_type __d1 = __middle - __first;
    difference_type __d2 = __last - __middle;
    _I1 __r = __first + __d2;
    while (__d1 != 0 && __d2 != 0)
    {
        if (__d1 <= __d2)
        {
            if (__d1 <= __bit_array<_Cp>::capacity())
            {
                __bit_array<_Cp> __b(__d1);
                std::__1::copy(__first, __middle, __b.begin());
                std::__1::copy(__b.begin(), __b.end(), std::__1::copy(__middle, __last, __first));
                break;
            }
            else
            {
                __bit_iterator<_Cp, false> __mp = std::__1::swap_ranges(__first, __middle, __middle);
                __first = __middle;
                __middle = __mp;
                __d2 -= __d1;
            }
        }
        else
        {
            if (__d2 <= __bit_array<_Cp>::capacity())
            {
                __bit_array<_Cp> __b(__d2);
                std::__1::copy(__middle, __last, __b.begin());
                std::__1::copy_backward(__b.begin(), __b.end(), std::__1::copy_backward(__first, __middle, __last));
                break;
            }
            else
            {
                __bit_iterator<_Cp, false> __mp = __first + __d2;
                std::__1::swap_ranges(__first, __mp, __middle);
                __first = __mp;
                __d1 -= __d2;
            }
        }
    }
    return __r;
}

// equal

template <class _Cp, bool _IC1, bool _IC2>
bool
__equal_unaligned(__bit_iterator<_Cp, _IC1> __first1, __bit_iterator<_Cp, _IC1> __last1,
                  __bit_iterator<_Cp, _IC2> __first2)
{
    typedef __bit_iterator<_Cp, _IC1> _It;
    typedef typename _It::difference_type difference_type;
    typedef typename _It::__storage_type __storage_type;
    static const unsigned __bits_per_word = _It::__bits_per_word;
    difference_type __n = __last1 - __first1;
    if (__n > 0)
    {
        // do first word
        if (__first1.__ctz_ != 0)
        {
            unsigned __clz_f = __bits_per_word - __first1.__ctz_;
            difference_type __dn = std::__1::min(static_cast<difference_type>(__clz_f), __n);
            __n -= __dn;
            __storage_type __m = (~__storage_type(0) << __first1.__ctz_) & (~__storage_type(0) >> (__clz_f - __dn));
            __storage_type __b = *__first1.__seg_ & __m;
            unsigned __clz_r = __bits_per_word - __first2.__ctz_;
            __storage_type __ddn = std::__1::min<__storage_type>(__dn, __clz_r);
            __m = (~__storage_type(0) << __first2.__ctz_) & (~__storage_type(0) >> (__clz_r - __ddn));
            if (__first2.__ctz_ > __first1.__ctz_)
            {
                if ((*__first2.__seg_ & __m) != (__b << (__first2.__ctz_ - __first1.__ctz_)))
                    return false;
            }
            else
            {
                if ((*__first2.__seg_ & __m) != (__b >> (__first1.__ctz_ - __first2.__ctz_)))
                    return false;
            }
            __first2.__seg_ += (__ddn + __first2.__ctz_) / __bits_per_word;
            __first2.__ctz_ = static_cast<unsigned>((__ddn + __first2.__ctz_) % __bits_per_word);
            __dn -= __ddn;
            if (__dn > 0)
            {
                __m = ~__storage_type(0) >> (__bits_per_word - __dn);
                if ((*__first2.__seg_ & __m) != (__b >> (__first1.__ctz_ + __ddn)))
                    return false;
                __first2.__ctz_ = static_cast<unsigned>(__dn);
            }
            ++__first1.__seg_;
            // __first1.__ctz_ = 0;
        }
        // __first1.__ctz_ == 0;
        // do middle words
        unsigned __clz_r = __bits_per_word - __first2.__ctz_;
        __storage_type __m = ~__storage_type(0) << __first2.__ctz_;
        for (; __n >= __bits_per_word; __n -= __bits_per_word, ++__first1.__seg_)
        {
            __storage_type __b = *__first1.__seg_;
            if ((*__first2.__seg_ & __m) != (__b << __first2.__ctz_))
                return false;
            ++__first2.__seg_;
            if ((*__first2.__seg_ & ~__m) != (__b >> __clz_r))
                return false;
        }
        // do last word
        if (__n > 0)
        {
            __m = ~__storage_type(0) >> (__bits_per_word - __n);
            __storage_type __b = *__first1.__seg_ & __m;
            __storage_type __dn = std::__1::min(__n, static_cast<difference_type>(__clz_r));
            __m = (~__storage_type(0) << __first2.__ctz_) & (~__storage_type(0) >> (__clz_r - __dn));
            if ((*__first2.__seg_ & __m) != (__b << __first2.__ctz_))
                return false;
            __first2.__seg_ += (__dn + __first2.__ctz_) / __bits_per_word;
            __first2.__ctz_ = static_cast<unsigned>((__dn + __first2.__ctz_) % __bits_per_word);
            __n -= __dn;
            if (__n > 0)
            {
                __m = ~__storage_type(0) >> (__bits_per_word - __n);
                if ((*__first2.__seg_ & __m) != (__b >> __dn))
                    return false;
            }
        }
    }
    return true;
}

template <class _Cp, bool _IC1, bool _IC2>
bool
__equal_aligned(__bit_iterator<_Cp, _IC1> __first1, __bit_iterator<_Cp, _IC1> __last1,
                __bit_iterator<_Cp, _IC2> __first2)
{
    typedef __bit_iterator<_Cp, _IC1> _It;
    typedef typename _It::difference_type difference_type;
    typedef typename _It::__storage_type __storage_type;
    static const unsigned __bits_per_word = _It::__bits_per_word;
    difference_type __n = __last1 - __first1;
    if (__n > 0)
    {
        // do first word
        if (__first1.__ctz_ != 0)
        {
            unsigned __clz = __bits_per_word - __first1.__ctz_;
            difference_type __dn = std::__1::min(static_cast<difference_type>(__clz), __n);
            __n -= __dn;
            __storage_type __m = (~__storage_type(0) << __first1.__ctz_) & (~__storage_type(0) >> (__clz - __dn));
            if ((*__first2.__seg_ & __m) != (*__first1.__seg_ & __m))
                return false;
            ++__first2.__seg_;
            ++__first1.__seg_;
            // __first1.__ctz_ = 0;
            // __first2.__ctz_ = 0;
        }
        // __first1.__ctz_ == 0;
        // __first2.__ctz_ == 0;
        // do middle words
        for (; __n >= __bits_per_word; __n -= __bits_per_word, ++__first1.__seg_, ++__first2.__seg_)
            if (*__first2.__seg_ != *__first1.__seg_)
                return false;
        // do last word
        if (__n > 0)
        {
            __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
            if ((*__first2.__seg_ & __m) != (*__first1.__seg_ & __m))
                return false;
        }
    }
    return true;
}

template <class _Cp, bool _IC1, bool _IC2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
equal(__bit_iterator<_Cp, _IC1> __first1, __bit_iterator<_Cp, _IC1> __last1, __bit_iterator<_Cp, _IC2> __first2)
{
    if (__first1.__ctz_ == __first2.__ctz_)
        return __equal_aligned(__first1, __last1, __first2);
    return __equal_unaligned(__first1, __last1, __first2);
}

template <class _Cp, bool _IsConst,
          typename _Cp::__storage_type>
class __bit_iterator
{
public:
    typedef typename _Cp::difference_type difference_type;
    typedef bool value_type;
    typedef __bit_iterator pointer;
    typedef typename conditional<_IsConst, __bit_const_reference<_Cp>, __bit_reference<_Cp> >::type reference;
    typedef random_access_iterator_tag iterator_category;

private:
    typedef typename _Cp::__storage_type __storage_type;
    typedef typename conditional<_IsConst, typename _Cp::__const_storage_pointer,
                                           typename _Cp::__storage_pointer>::type __storage_pointer;
    static const unsigned __bits_per_word = _Cp::__bits_per_word;

    __storage_pointer __seg_;
    unsigned __ctz_;

public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) __bit_iterator() throw()



    {}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    __bit_iterator(const __bit_iterator<_Cp, false>& __it) throw()
        : __seg_(__it.__seg_), __ctz_(__it.__ctz_) {}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) reference operator*() const throw()
        {return reference(__seg_, __storage_type(1) << __ctz_);}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) __bit_iterator& operator++()
    {
        if (__ctz_ != __bits_per_word-1)
            ++__ctz_;
        else
        {
            __ctz_ = 0;
            ++__seg_;
        }
        return *this;
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__)) __bit_iterator operator++(int)
    {
        __bit_iterator __tmp = *this;
        ++(*this);
        return __tmp;
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__)) __bit_iterator& operator--()
    {
        if (__ctz_ != 0)
            --__ctz_;
        else
        {
            __ctz_ = __bits_per_word - 1;
            --__seg_;
        }
        return *this;
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__)) __bit_iterator operator--(int)
    {
        __bit_iterator __tmp = *this;
        --(*this);
        return __tmp;
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__)) __bit_iterator& operator+=(difference_type __n)
    {
        if (__n >= 0)
            __seg_ += (__n + __ctz_) / __bits_per_word;
        else
            __seg_ += static_cast<difference_type>(__n - __bits_per_word + __ctz_ + 1)
                    / static_cast<difference_type>(__bits_per_word);
        __n &= (__bits_per_word - 1);
        __ctz_ = static_cast<unsigned>((__n + __ctz_) % __bits_per_word);
        return *this;
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__)) __bit_iterator& operator-=(difference_type __n)
    {
        return *this += -__n;
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__)) __bit_iterator operator+(difference_type __n) const
    {
        __bit_iterator __t(*this);
        __t += __n;
        return __t;
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__)) __bit_iterator operator-(difference_type __n) const
    {
        __bit_iterator __t(*this);
        __t -= __n;
        return __t;
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    friend __bit_iterator operator+(difference_type __n, const __bit_iterator& __it) {return __it + __n;}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    friend difference_type operator-(const __bit_iterator& __x, const __bit_iterator& __y)
        {return (__x.__seg_ - __y.__seg_) * __bits_per_word + __x.__ctz_ - __y.__ctz_;}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) reference operator[](difference_type __n) const {return *(*this + __n);}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) friend bool operator==(const __bit_iterator& __x, const __bit_iterator& __y)
        {return __x.__seg_ == __y.__seg_ && __x.__ctz_ == __y.__ctz_;}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) friend bool operator!=(const __bit_iterator& __x, const __bit_iterator& __y)
        {return !(__x == __y);}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) friend bool operator<(const __bit_iterator& __x, const __bit_iterator& __y)
        {return __x.__seg_ < __y.__seg_ || (__x.__seg_ == __y.__seg_ && __x.__ctz_ < __y.__ctz_);}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) friend bool operator>(const __bit_iterator& __x, const __bit_iterator& __y)
        {return __y < __x;}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) friend bool operator<=(const __bit_iterator& __x, const __bit_iterator& __y)
        {return !(__y < __x);}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) friend bool operator>=(const __bit_iterator& __x, const __bit_iterator& __y)
        {return !(__x < __y);}

private:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    __bit_iterator(__storage_pointer __s, unsigned __ctz) throw()
        : __seg_(__s), __ctz_(__ctz) {}


    friend typename _Cp::__self;



    friend class __bit_reference<_Cp>;
    friend class __bit_const_reference<_Cp>;
    friend class __bit_iterator<_Cp, true>;
    template <class _Dp> friend struct __bit_array;
    template <class _Dp> friend void __fill_n_false(__bit_iterator<_Dp, false> __first, typename _Dp::size_type __n);
    template <class _Dp> friend void __fill_n_true(__bit_iterator<_Dp, false> __first, typename _Dp::size_type __n);
    template <class _Dp, bool _IC> friend __bit_iterator<_Dp, false> __copy_aligned(__bit_iterator<_Dp, _IC> __first,
                                                                                  __bit_iterator<_Dp, _IC> __last,
                                                                                  __bit_iterator<_Dp, false> __result);
    template <class _Dp, bool _IC> friend __bit_iterator<_Dp, false> __copy_unaligned(__bit_iterator<_Dp, _IC> __first,
                                                                                    __bit_iterator<_Dp, _IC> __last,
                                                                                    __bit_iterator<_Dp, false> __result);
    template <class _Dp, bool _IC> friend __bit_iterator<_Dp, false> copy(__bit_iterator<_Dp, _IC> __first,
                                                                        __bit_iterator<_Dp, _IC> __last,
                                                                        __bit_iterator<_Dp, false> __result);
    template <class _Dp, bool _IC> friend __bit_iterator<_Dp, false> __copy_backward_aligned(__bit_iterator<_Dp, _IC> __first,
                                                                                           __bit_iterator<_Dp, _IC> __last,
                                                                                           __bit_iterator<_Dp, false> __result);
    template <class _Dp, bool _IC> friend __bit_iterator<_Dp, false> __copy_backward_unaligned(__bit_iterator<_Dp, _IC> __first,
                                                                                             __bit_iterator<_Dp, _IC> __last,
                                                                                             __bit_iterator<_Dp, false> __result);
    template <class _Dp, bool _IC> friend __bit_iterator<_Dp, false> copy_backward(__bit_iterator<_Dp, _IC> __first,
                                                                                 __bit_iterator<_Dp, _IC> __last,
                                                                                 __bit_iterator<_Dp, false> __result);
    template <class __C1, class __C2>friend __bit_iterator<__C2, false> __swap_ranges_aligned(__bit_iterator<__C1, false>,
                                                                                           __bit_iterator<__C1, false>,
                                                                                           __bit_iterator<__C2, false>);
    template <class __C1, class __C2>friend __bit_iterator<__C2, false> __swap_ranges_unaligned(__bit_iterator<__C1, false>,
                                                                                             __bit_iterator<__C1, false>,
                                                                                             __bit_iterator<__C2, false>);
    template <class __C1, class __C2>friend __bit_iterator<__C2, false> swap_ranges(__bit_iterator<__C1, false>,
                                                                                 __bit_iterator<__C1, false>,
                                                                                 __bit_iterator<__C2, false>);
    template <class _Dp> friend __bit_iterator<_Dp, false> rotate(__bit_iterator<_Dp, false>,
                                                                __bit_iterator<_Dp, false>,
                                                                __bit_iterator<_Dp, false>);
    template <class _Dp, bool _IC1, bool _IC2> friend bool __equal_aligned(__bit_iterator<_Dp, _IC1>,
                                                    __bit_iterator<_Dp, _IC1>,
                                                    __bit_iterator<_Dp, _IC2>);
    template <class _Dp, bool _IC1, bool _IC2> friend bool __equal_unaligned(__bit_iterator<_Dp, _IC1>,
                                                      __bit_iterator<_Dp, _IC1>,
                                                      __bit_iterator<_Dp, _IC2>);
    template <class _Dp, bool _IC1, bool _IC2> friend bool equal(__bit_iterator<_Dp, _IC1>,
                                                                __bit_iterator<_Dp, _IC1>,
                                                                __bit_iterator<_Dp, _IC2>);
    template <class _Dp, bool _IC> friend __bit_iterator<_Dp, _IC> __find_bool_true(__bit_iterator<_Dp, _IC>,
                                                                          typename _Dp::size_type);
    template <class _Dp, bool _IC> friend __bit_iterator<_Dp, _IC> __find_bool_false(__bit_iterator<_Dp, _IC>,
                                                                           typename _Dp::size_type);
    template <class _Dp, bool _IC> friend typename __bit_iterator<_Dp, _IC>::difference_type
                   __count_bool_true(__bit_iterator<_Dp, _IC>, typename _Dp::size_type);
    template <class _Dp, bool _IC> friend typename __bit_iterator<_Dp, _IC>::difference_type
                   __count_bool_false(__bit_iterator<_Dp, _IC>, typename _Dp::size_type);
};

} }
# 122 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/bitset" 2 3
# 132 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/bitset" 3
# 1 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/__undef_min_max" 1 3
// -*- C++ -*-
//===----------------------------------------------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is dual licensed under the MIT and the University of Illinois Open
// Source Licenses. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
# 133 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/bitset" 2 3

namespace std {inline namespace __1 {

template <size_t _N_words, size_t _Size>
class __bitset;

template <size_t _N_words, size_t _Size>
struct __has_storage_type<__bitset<_N_words, _Size> >
{
    static const bool value = true;
};

template <size_t _N_words, size_t _Size>
class __bitset
{
public:
    typedef ptrdiff_t difference_type;
    typedef size_t size_type;
    typedef size_type __storage_type;
protected:
    typedef __bitset __self;
    typedef __storage_type* __storage_pointer;
    typedef const __storage_type* __const_storage_pointer;
    static const unsigned __bits_per_word = static_cast<unsigned>(sizeof(__storage_type) * 8);

    friend class __bit_reference<__bitset>;
    friend class __bit_const_reference<__bitset>;
    friend class __bit_iterator<__bitset, false>;
    friend class __bit_iterator<__bitset, true>;
    friend struct __bit_array<__bitset>;

    __storage_type __first_[_N_words];

    typedef __bit_reference<__bitset> reference;
    typedef __bit_const_reference<__bitset> const_reference;
    typedef __bit_iterator<__bitset, false> iterator;
    typedef __bit_iterator<__bitset, true> const_iterator;

                      __bitset() throw();
    explicit __bitset(unsigned long long __v) throw();

    __attribute__ ((__visibility__("hidden"), __always_inline__)) reference __make_ref(size_t __pos) throw()
        {return reference(__first_ + __pos / __bits_per_word, __storage_type(1) << __pos % __bits_per_word);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) const_reference __make_ref(size_t __pos) const throw()
        {return const_reference(__first_ + __pos / __bits_per_word, __storage_type(1) << __pos % __bits_per_word);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) iterator __make_iter(size_t __pos) throw()
        {return iterator(__first_ + __pos / __bits_per_word, __pos % __bits_per_word);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) const_iterator __make_iter(size_t __pos) const throw()
        {return const_iterator(__first_ + __pos / __bits_per_word, __pos % __bits_per_word);}

    void operator&=(const __bitset& __v) throw();
    void operator|=(const __bitset& __v) throw();
    void operator^=(const __bitset& __v) throw();

    void flip() throw();
    __attribute__ ((__visibility__("hidden"), __always_inline__)) unsigned long to_ulong() const
        {return to_ulong(integral_constant<bool, _Size < sizeof(unsigned long) * 8>());}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) unsigned long long to_ullong() const
        {return to_ullong(integral_constant<bool, _Size < sizeof(unsigned long long) * 8>());}

    bool all() const throw();
    bool any() const throw();
    size_t __hash_code() const throw();
private:

    void __init(unsigned long long __v, false_type) throw();
    void __init(unsigned long long __v, true_type) throw();

    unsigned long to_ulong(false_type) const;
    unsigned long to_ulong(true_type) const;
    unsigned long long to_ullong(false_type) const;
    unsigned long long to_ullong(true_type) const;
    unsigned long long to_ullong(true_type, false_type) const;
    unsigned long long to_ullong(true_type, true_type) const;
};

template <size_t _N_words, size_t _Size>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))

__bitset<_N_words, _Size>::__bitset() throw()



{

    std::__1::fill_n(__first_, _N_words, __storage_type(0));

}



template <size_t _N_words, size_t _Size>
void
__bitset<_N_words, _Size>::__init(unsigned long long __v, false_type) throw()
{
    __storage_type __t[sizeof(unsigned long long) / sizeof(__storage_type)];
    for (size_t __i = 0; __i < sizeof(__t)/sizeof(__t[0]); ++__i, __v >>= __bits_per_word)
        __t[__i] = static_cast<__storage_type>(__v);
    std::__1::copy(__t, __t + sizeof(__t)/sizeof(__t[0]), __first_);
    std::__1::fill(__first_ + sizeof(__t)/sizeof(__t[0]), __first_ + sizeof(__first_)/sizeof(__first_[0]),
               __storage_type(0));
}

template <size_t _N_words, size_t _Size>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
__bitset<_N_words, _Size>::__init(unsigned long long __v, true_type) throw()
{
    __first_[0] = __v;
    std::__1::fill(__first_ + 1, __first_ + sizeof(__first_)/sizeof(__first_[0]), __storage_type(0));
}



template <size_t _N_words, size_t _Size>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))

__bitset<_N_words, _Size>::__bitset(unsigned long long __v) throw()
# 260 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/bitset" 3
{

    __init(__v, integral_constant<bool, sizeof(unsigned long long) == sizeof(__storage_type)>());

}

template <size_t _N_words, size_t _Size>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
__bitset<_N_words, _Size>::operator&=(const __bitset& __v) throw()
{
    for (size_type __i = 0; __i < _N_words; ++__i)
        __first_[__i] &= __v.__first_[__i];
}

template <size_t _N_words, size_t _Size>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
__bitset<_N_words, _Size>::operator|=(const __bitset& __v) throw()
{
    for (size_type __i = 0; __i < _N_words; ++__i)
        __first_[__i] |= __v.__first_[__i];
}

template <size_t _N_words, size_t _Size>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
__bitset<_N_words, _Size>::operator^=(const __bitset& __v) throw()
{
    for (size_type __i = 0; __i < _N_words; ++__i)
        __first_[__i] ^= __v.__first_[__i];
}

template <size_t _N_words, size_t _Size>
void
__bitset<_N_words, _Size>::flip() throw()
{
    // do middle whole words
    size_type __n = _Size;
    __storage_pointer __p = __first_;
    for (; __n >= __bits_per_word; ++__p, __n -= __bits_per_word)
        *__p = ~*__p;
    // do last partial word
    if (__n > 0)
    {
        __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
        __storage_type __b = *__p & __m;
        *__p &= ~__m;
        *__p |= ~__b & __m;
    }
}

template <size_t _N_words, size_t _Size>
unsigned long
__bitset<_N_words, _Size>::to_ulong(false_type) const
{
    const_iterator __e = __make_iter(_Size);
    const_iterator __i = std::__1::find(__make_iter(sizeof(unsigned long) * 8), __e, true);
    if (__i != __e)

        throw overflow_error("bitset to_ulong overflow error");



    return __first_[0];
}

template <size_t _N_words, size_t _Size>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
unsigned long
__bitset<_N_words, _Size>::to_ulong(true_type) const
{
    return __first_[0];
}

template <size_t _N_words, size_t _Size>
unsigned long long
__bitset<_N_words, _Size>::to_ullong(false_type) const
{
    const_iterator __e = __make_iter(_Size);
    const_iterator __i = std::__1::find(__make_iter(sizeof(unsigned long long) * 8), __e, true);
    if (__i != __e)

        throw overflow_error("bitset to_ullong overflow error");



    return to_ullong(true_type());
}

template <size_t _N_words, size_t _Size>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
unsigned long long
__bitset<_N_words, _Size>::to_ullong(true_type) const
{
    return to_ullong(true_type(), integral_constant<bool, sizeof(__storage_type) < sizeof(unsigned long long)>());
}

template <size_t _N_words, size_t _Size>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
unsigned long long
__bitset<_N_words, _Size>::to_ullong(true_type, false_type) const
{
    return __first_[0];
}

template <size_t _N_words, size_t _Size>
unsigned long long
__bitset<_N_words, _Size>::to_ullong(true_type, true_type) const
{
    unsigned long long __r = __first_[0];
    for (std::size_t __i = 1; __i < sizeof(unsigned long long) / sizeof(__storage_type); ++__i)
        __r |= static_cast<unsigned long long>(__first_[__i]) << (sizeof(__storage_type) * 8);
    return __r;
}

template <size_t _N_words, size_t _Size>
bool
__bitset<_N_words, _Size>::all() const throw()
{
    // do middle whole words
    size_type __n = _Size;
    __const_storage_pointer __p = __first_;
    for (; __n >= __bits_per_word; ++__p, __n -= __bits_per_word)
        if (~*__p)
            return false;
    // do last partial word
    if (__n > 0)
    {
        __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
        if (~*__p & __m)
            return false;
    }
    return true;
}

template <size_t _N_words, size_t _Size>
bool
__bitset<_N_words, _Size>::any() const throw()
{
    // do middle whole words
    size_type __n = _Size;
    __const_storage_pointer __p = __first_;
    for (; __n >= __bits_per_word; ++__p, __n -= __bits_per_word)
        if (*__p)
            return true;
    // do last partial word
    if (__n > 0)
    {
        __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
        if (*__p & __m)
            return true;
    }
    return false;
}

template <size_t _N_words, size_t _Size>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
size_t
__bitset<_N_words, _Size>::__hash_code() const throw()
{
    size_t __h = 0;
    for (size_type __i = 0; __i < _N_words; ++__i)
        __h ^= __first_[__i];
    return __h;
}

template <size_t _Size>
class __bitset<1, _Size>
{
public:
    typedef ptrdiff_t difference_type;
    typedef size_t size_type;
    typedef size_type __storage_type;
protected:
    typedef __bitset __self;
    typedef __storage_type* __storage_pointer;
    typedef const __storage_type* __const_storage_pointer;
    static const unsigned __bits_per_word = static_cast<unsigned>(sizeof(__storage_type) * 8);

    friend class __bit_reference<__bitset>;
    friend class __bit_const_reference<__bitset>;
    friend class __bit_iterator<__bitset, false>;
    friend class __bit_iterator<__bitset, true>;
    friend struct __bit_array<__bitset>;

    __storage_type __first_;

    typedef __bit_reference<__bitset> reference;
    typedef __bit_const_reference<__bitset> const_reference;
    typedef __bit_iterator<__bitset, false> iterator;
    typedef __bit_iterator<__bitset, true> const_iterator;

                      __bitset() throw();
    explicit __bitset(unsigned long long __v) throw();

    __attribute__ ((__visibility__("hidden"), __always_inline__)) reference __make_ref(size_t __pos) throw()
        {return reference(&__first_, __storage_type(1) << __pos);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) const_reference __make_ref(size_t __pos) const throw()
        {return const_reference(&__first_, __storage_type(1) << __pos);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) iterator __make_iter(size_t __pos) throw()
        {return iterator(&__first_ + __pos / __bits_per_word, __pos % __bits_per_word);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) const_iterator __make_iter(size_t __pos) const throw()
        {return const_iterator(&__first_ + __pos / __bits_per_word, __pos % __bits_per_word);}

    void operator&=(const __bitset& __v) throw();
    void operator|=(const __bitset& __v) throw();
    void operator^=(const __bitset& __v) throw();

    void flip() throw();

    unsigned long to_ulong() const;
    unsigned long long to_ullong() const;

    bool all() const throw();
    bool any() const throw();

    size_t __hash_code() const throw();
};

template <size_t _Size>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))

__bitset<1, _Size>::__bitset() throw()
    : __first_(0)
{
}

template <size_t _Size>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))

__bitset<1, _Size>::__bitset(unsigned long long __v) throw()
    : __first_(static_cast<__storage_type>(__v))
{
}

template <size_t _Size>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
__bitset<1, _Size>::operator&=(const __bitset& __v) throw()
{
    __first_ &= __v.__first_;
}

template <size_t _Size>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
__bitset<1, _Size>::operator|=(const __bitset& __v) throw()
{
    __first_ |= __v.__first_;
}

template <size_t _Size>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
__bitset<1, _Size>::operator^=(const __bitset& __v) throw()
{
    __first_ ^= __v.__first_;
}

template <size_t _Size>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
__bitset<1, _Size>::flip() throw()
{
    __storage_type __m = ~__storage_type(0) >> (__bits_per_word - _Size);
    __first_ = ~__first_;
    __first_ &= __m;
}

template <size_t _Size>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
unsigned long
__bitset<1, _Size>::to_ulong() const
{
    return __first_;
}

template <size_t _Size>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
unsigned long long
__bitset<1, _Size>::to_ullong() const
{
    return __first_;
}

template <size_t _Size>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
__bitset<1, _Size>::all() const throw()
{
    __storage_type __m = ~__storage_type(0) >> (__bits_per_word - _Size);
    return !(~__first_ & __m);
}

template <size_t _Size>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
__bitset<1, _Size>::any() const throw()
{
    __storage_type __m = ~__storage_type(0) >> (__bits_per_word - _Size);
    return __first_ & __m;
}

template <size_t _Size>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
size_t
__bitset<1, _Size>::__hash_code() const throw()
{
    return __first_;
}

template <>
class __bitset<0, 0>
{
public:
    typedef ptrdiff_t difference_type;
    typedef size_t size_type;
    typedef size_type __storage_type;
protected:
    typedef __bitset __self;
    typedef __storage_type* __storage_pointer;
    typedef const __storage_type* __const_storage_pointer;
    static const unsigned __bits_per_word = static_cast<unsigned>(sizeof(__storage_type) * 8);

    friend class __bit_reference<__bitset>;
    friend class __bit_const_reference<__bitset>;
    friend class __bit_iterator<__bitset, false>;
    friend class __bit_iterator<__bitset, true>;
    friend struct __bit_array<__bitset>;

    typedef __bit_reference<__bitset> reference;
    typedef __bit_const_reference<__bitset> const_reference;
    typedef __bit_iterator<__bitset, false> iterator;
    typedef __bit_iterator<__bitset, true> const_iterator;

                      __bitset() throw();
    explicit __bitset(unsigned long long) throw();

    __attribute__ ((__visibility__("hidden"), __always_inline__)) reference __make_ref(size_t) throw()
        {return reference(0, 1);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) const_reference __make_ref(size_t) const throw()
        {return const_reference(0, 1);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) iterator __make_iter(size_t) throw()
        {return iterator(0, 0);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) const_iterator __make_iter(size_t) const throw()
        {return const_iterator(0, 0);}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) void operator&=(const __bitset&) throw() {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) void operator|=(const __bitset&) throw() {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) void operator^=(const __bitset&) throw() {}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) void flip() throw() {}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) unsigned long to_ulong() const {return 0;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) unsigned long long to_ullong() const {return 0;}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) bool all() const throw() {return true;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) bool any() const throw() {return false;}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) size_t __hash_code() const throw() {return 0;}
};

inline __attribute__ ((__visibility__("hidden"), __always_inline__))

__bitset<0, 0>::__bitset() throw()
{
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))

__bitset<0, 0>::__bitset(unsigned long long) throw()
{
}

template <size_t _Size> class __attribute__ ((__type_visibility__("default"))) bitset;
template <size_t _Size> struct __attribute__ ((__type_visibility__("default"))) hash<bitset<_Size> >;

template <size_t _Size>
class __attribute__ ((__type_visibility__("default"))) bitset
    : private __bitset<_Size == 0 ? 0 : (_Size - 1) / (sizeof(size_t) * 8) + 1, _Size>
{
public:
    static const unsigned __n_words = _Size == 0 ? 0 : (_Size - 1) / (sizeof(size_t) * 8) + 1;
    typedef __bitset<__n_words, _Size> base;

public:
    typedef typename base::reference reference;
    typedef typename base::const_reference const_reference;

    // 23.3.5.1 constructors:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) bitset() throw() {}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
        bitset(unsigned long long __v) throw() : base(__v) {}
    template<class _CharT>
        explicit bitset(const _CharT* __str,
                        typename basic_string<_CharT>::size_type __n = basic_string<_CharT>::npos,
                        _CharT __zero = _CharT('0'), _CharT __one = _CharT('1'));
    template<class _CharT, class _Traits, class _Allocator>
        explicit bitset(const basic_string<_CharT,_Traits,_Allocator>& __str,
                        typename basic_string<_CharT,_Traits,_Allocator>::size_type __pos = 0,
                        typename basic_string<_CharT,_Traits,_Allocator>::size_type __n =
                                (basic_string<_CharT,_Traits,_Allocator>::npos),
                        _CharT __zero = _CharT('0'), _CharT __one = _CharT('1'));

    // 23.3.5.2 bitset operations:
    bitset& operator&=(const bitset& __rhs) throw();
    bitset& operator|=(const bitset& __rhs) throw();
    bitset& operator^=(const bitset& __rhs) throw();
    bitset& operator<<=(size_t __pos) throw();
    bitset& operator>>=(size_t __pos) throw();
    bitset& set() throw();
    bitset& set(size_t __pos, bool __val = true);
    bitset& reset() throw();
    bitset& reset(size_t __pos);
    bitset operator~() const throw();
    bitset& flip() throw();
    bitset& flip(size_t __pos);

    // element access:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
                              const_reference operator[](size_t __p) const {return base::__make_ref(__p);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) reference operator[](size_t __p) {return base::__make_ref(__p);}
    unsigned long to_ulong() const;
    unsigned long long to_ullong() const;
    template <class _CharT, class _Traits, class _Allocator>
        basic_string<_CharT, _Traits, _Allocator> to_string(_CharT __zero = _CharT('0'),
                                                            _CharT __one = _CharT('1')) const;
    template <class _CharT, class _Traits>
        basic_string<_CharT, _Traits, allocator<_CharT> > to_string(_CharT __zero = _CharT('0'),
                                                                    _CharT __one = _CharT('1')) const;
    template <class _CharT>
        basic_string<_CharT, char_traits<_CharT>, allocator<_CharT> > to_string(_CharT __zero = _CharT('0'),
                                                                                _CharT __one = _CharT('1')) const;
    basic_string<char, char_traits<char>, allocator<char> > to_string(char __zero = '0',
                                                                      char __one = '1') const;
    size_t count() const throw();
    __attribute__ ((__visibility__("hidden"), __always_inline__)) size_t size() const throw() {return _Size;}
    bool operator==(const bitset& __rhs) const throw();
    bool operator!=(const bitset& __rhs) const throw();
    bool test(size_t __pos) const;
    bool all() const throw();
    bool any() const throw();
    __attribute__ ((__visibility__("hidden"), __always_inline__)) bool none() const throw() {return !any();}
    bitset operator<<(size_t __pos) const throw();
    bitset operator>>(size_t __pos) const throw();

private:

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_t __hash_code() const throw() {return base::__hash_code();}

    friend struct hash<bitset>;
};

template <size_t _Size>
template<class _CharT>
bitset<_Size>::bitset(const _CharT* __str,
                      typename basic_string<_CharT>::size_type __n,
                      _CharT __zero, _CharT __one)
{
    size_t __rlen = std::__1::min(__n, char_traits<_CharT>::length(__str));
    for (size_t __i = 0; __i < __rlen; ++__i)
        if (__str[__i] != __zero && __str[__i] != __one)

            throw invalid_argument("bitset string ctor has invalid argument");



    size_t _Mp = std::__1::min(__rlen, _Size);
    size_t __i = 0;
    for (; __i < _Mp; ++__i)
    {
        _CharT __c = __str[_Mp - 1 - __i];
        if (__c == __zero)
            (*this)[__i] = false;
        else
            (*this)[__i] = true;
    }
    std::__1::fill(base::__make_iter(__i), base::__make_iter(_Size), false);
}

template <size_t _Size>
template<class _CharT, class _Traits, class _Allocator>
bitset<_Size>::bitset(const basic_string<_CharT,_Traits,_Allocator>& __str,
       typename basic_string<_CharT,_Traits,_Allocator>::size_type __pos,
       typename basic_string<_CharT,_Traits,_Allocator>::size_type __n,
       _CharT __zero, _CharT __one)
{
    if (__pos > __str.size())

        throw out_of_range("bitset string pos out of range");



    size_t __rlen = std::__1::min(__n, __str.size() - __pos);
    for (size_t __i = __pos; __i < __pos + __rlen; ++__i)
        if (!_Traits::eq(__str[__i], __zero) && !_Traits::eq(__str[__i], __one))

            throw invalid_argument("bitset string ctor has invalid argument");



    size_t _Mp = std::__1::min(__rlen, _Size);
    size_t __i = 0;
    for (; __i < _Mp; ++__i)
    {
        _CharT __c = __str[__pos + _Mp - 1 - __i];
        if (_Traits::eq(__c, __zero))
            (*this)[__i] = false;
        else
            (*this)[__i] = true;
    }
    std::__1::fill(base::__make_iter(__i), base::__make_iter(_Size), false);
}

template <size_t _Size>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bitset<_Size>&
bitset<_Size>::operator&=(const bitset& __rhs) throw()
{
    base::operator&=(__rhs);
    return *this;
}

template <size_t _Size>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bitset<_Size>&
bitset<_Size>::operator|=(const bitset& __rhs) throw()
{
    base::operator|=(__rhs);
    return *this;
}

template <size_t _Size>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bitset<_Size>&
bitset<_Size>::operator^=(const bitset& __rhs) throw()
{
    base::operator^=(__rhs);
    return *this;
}

template <size_t _Size>
bitset<_Size>&
bitset<_Size>::operator<<=(size_t __pos) throw()
{
    __pos = std::__1::min(__pos, _Size);
    std::__1::copy_backward(base::__make_iter(0), base::__make_iter(_Size - __pos), base::__make_iter(_Size));
    std::__1::fill_n(base::__make_iter(0), __pos, false);
    return *this;
}

template <size_t _Size>
bitset<_Size>&
bitset<_Size>::operator>>=(size_t __pos) throw()
{
    __pos = std::__1::min(__pos, _Size);
    std::__1::copy(base::__make_iter(__pos), base::__make_iter(_Size), base::__make_iter(0));
    std::__1::fill_n(base::__make_iter(_Size - __pos), __pos, false);
    return *this;
}

template <size_t _Size>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bitset<_Size>&
bitset<_Size>::set() throw()
{
    std::__1::fill_n(base::__make_iter(0), _Size, true);
    return *this;
}

template <size_t _Size>
bitset<_Size>&
bitset<_Size>::set(size_t __pos, bool __val)
{
    if (__pos >= _Size)

        throw out_of_range("bitset set argument out of range");



    (*this)[__pos] = __val;
    return *this;
}

template <size_t _Size>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bitset<_Size>&
bitset<_Size>::reset() throw()
{
    std::__1::fill_n(base::__make_iter(0), _Size, false);
    return *this;
}

template <size_t _Size>
bitset<_Size>&
bitset<_Size>::reset(size_t __pos)
{
    if (__pos >= _Size)

        throw out_of_range("bitset reset argument out of range");



    (*this)[__pos] = false;
    return *this;
}

template <size_t _Size>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bitset<_Size>
bitset<_Size>::operator~() const throw()
{
    bitset __x(*this);
    __x.flip();
    return __x;
}

template <size_t _Size>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bitset<_Size>&
bitset<_Size>::flip() throw()
{
    base::flip();
    return *this;
}

template <size_t _Size>
bitset<_Size>&
bitset<_Size>::flip(size_t __pos)
{
    if (__pos >= _Size)

        throw out_of_range("bitset flip argument out of range");



    reference r = base::__make_ref(__pos);
    r = ~r;
    return *this;
}

template <size_t _Size>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
unsigned long
bitset<_Size>::to_ulong() const
{
    return base::to_ulong();
}

template <size_t _Size>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
unsigned long long
bitset<_Size>::to_ullong() const
{
    return base::to_ullong();
}

template <size_t _Size>
template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>
bitset<_Size>::to_string(_CharT __zero, _CharT __one) const
{
    basic_string<_CharT, _Traits, _Allocator> __r(_Size, __zero);
    for (size_t __i = 0; __i < _Size; ++__i)
    {
        if ((*this)[__i])
            __r[_Size - 1 - __i] = __one;
    }
    return __r;
}

template <size_t _Size>
template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_string<_CharT, _Traits, allocator<_CharT> >
bitset<_Size>::to_string(_CharT __zero, _CharT __one) const
{
    return to_string<_CharT, _Traits, allocator<_CharT> >(__zero, __one);
}

template <size_t _Size>
template <class _CharT>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_string<_CharT, char_traits<_CharT>, allocator<_CharT> >
bitset<_Size>::to_string(_CharT __zero, _CharT __one) const
{
    return to_string<_CharT, char_traits<_CharT>, allocator<_CharT> >(__zero, __one);
}

template <size_t _Size>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_string<char, char_traits<char>, allocator<char> >
bitset<_Size>::to_string(char __zero, char __one) const
{
    return to_string<char, char_traits<char>, allocator<char> >(__zero, __one);
}

template <size_t _Size>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
size_t
bitset<_Size>::count() const throw()
{
    return static_cast<size_t>(std::__1::count(base::__make_iter(0), base::__make_iter(_Size), true));
}

template <size_t _Size>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
bitset<_Size>::operator==(const bitset& __rhs) const throw()
{
    return std::__1::equal(base::__make_iter(0), base::__make_iter(_Size), __rhs.__make_iter(0));
}

template <size_t _Size>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
bitset<_Size>::operator!=(const bitset& __rhs) const throw()
{
    return !(*this == __rhs);
}

template <size_t _Size>
bool
bitset<_Size>::test(size_t __pos) const
{
    if (__pos >= _Size)

        throw out_of_range("bitset test argument out of range");



    return (*this)[__pos];
}

template <size_t _Size>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
bitset<_Size>::all() const throw()
{
    return base::all();
}

template <size_t _Size>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
bitset<_Size>::any() const throw()
{
    return base::any();
}

template <size_t _Size>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bitset<_Size>
bitset<_Size>::operator<<(size_t __pos) const throw()
{
    bitset __r = *this;
    __r <<= __pos;
    return __r;
}

template <size_t _Size>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bitset<_Size>
bitset<_Size>::operator>>(size_t __pos) const throw()
{
    bitset __r = *this;
    __r >>= __pos;
    return __r;
}

template <size_t _Size>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bitset<_Size>
operator&(const bitset<_Size>& __x, const bitset<_Size>& __y) throw()
{
    bitset<_Size> __r = __x;
    __r &= __y;
    return __r;
}

template <size_t _Size>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bitset<_Size>
operator|(const bitset<_Size>& __x, const bitset<_Size>& __y) throw()
{
    bitset<_Size> __r = __x;
    __r |= __y;
    return __r;
}

template <size_t _Size>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bitset<_Size>
operator^(const bitset<_Size>& __x, const bitset<_Size>& __y) throw()
{
    bitset<_Size> __r = __x;
    __r ^= __y;
    return __r;
}

template <size_t _Size>
struct __attribute__ ((__type_visibility__("default"))) hash<bitset<_Size> >
    : public unary_function<bitset<_Size>, size_t>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_t operator()(const bitset<_Size>& __bs) const throw()
        {return __bs.__hash_code();}
};

template <class _CharT, class _Traits, size_t _Size>
basic_istream<_CharT, _Traits>&
operator>>(basic_istream<_CharT, _Traits>& __is, bitset<_Size>& __x);

template <class _CharT, class _Traits, size_t _Size>
basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os, const bitset<_Size>& __x);

} }
# 136 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/ostream" 2 3
# 139 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/ostream" 3


namespace std {inline namespace __1 {

template <class _CharT, class _Traits>
class __attribute__ ((__type_visibility__("default"))) basic_ostream
    : virtual public basic_ios<_CharT, _Traits>
{
public:
    // types (inherited from basic_ios (27.5.4)):
    typedef _CharT char_type;
    typedef _Traits traits_type;
    typedef typename traits_type::int_type int_type;
    typedef typename traits_type::pos_type pos_type;
    typedef typename traits_type::off_type off_type;

    // 27.7.2.2 Constructor/destructor:
    explicit basic_ostream(basic_streambuf<char_type, traits_type>* __sb);
    virtual ~basic_ostream();
protected:





    // 27.7.2.3 Assign/swap







    void swap(basic_ostream& __rhs);
public:

    // 27.7.2.4 Prefix/suffix:
    class __attribute__ ((__type_visibility__("default"))) sentry;

    // 27.7.2.6 Formatted output:
    basic_ostream& operator<<(basic_ostream& (*__pf)(basic_ostream&));
    basic_ostream& operator<<(basic_ios<char_type, traits_type>&
                              (*__pf)(basic_ios<char_type,traits_type>&));
    basic_ostream& operator<<(ios_base& (*__pf)(ios_base&));
    basic_ostream& operator<<(bool __n);
    basic_ostream& operator<<(short __n);
    basic_ostream& operator<<(unsigned short __n);
    basic_ostream& operator<<(int __n);
    basic_ostream& operator<<(unsigned int __n);
    basic_ostream& operator<<(long __n);
    basic_ostream& operator<<(unsigned long __n);
    basic_ostream& operator<<(long long __n);
    basic_ostream& operator<<(unsigned long long __n);
    basic_ostream& operator<<(float __f);
    basic_ostream& operator<<(double __f);
    basic_ostream& operator<<(long double __f);
    basic_ostream& operator<<(const void* __p);
    basic_ostream& operator<<(basic_streambuf<char_type, traits_type>* __sb);

    // 27.7.2.7 Unformatted output:
    basic_ostream& put(char_type __c);
    basic_ostream& write(const char_type* __s, streamsize __n);
    basic_ostream& flush();

    // 27.7.2.5 seeks:
    pos_type tellp();
    basic_ostream& seekp(pos_type __pos);
    basic_ostream& seekp(off_type __off, ios_base::seekdir __dir);

protected:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    basic_ostream() {} // extension, intentially does not initialize
};

template <class _CharT, class _Traits>
class __attribute__ ((__type_visibility__("default"))) basic_ostream<_CharT, _Traits>::sentry
{
    bool __ok_;
    basic_ostream<_CharT, _Traits>& __os_;

    sentry(const sentry&); // = delete;
    sentry& operator=(const sentry&); // = delete;

public:
    explicit sentry(basic_ostream<_CharT, _Traits>& __os);
    ~sentry();

    __attribute__ ((__visibility__("hidden"), __always_inline__))

        operator bool() const {return __ok_;}
};

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>::sentry::sentry(basic_ostream<_CharT, _Traits>& __os)
    : __ok_(false),
      __os_(__os)
{
    if (__os.good())
    {
        if (__os.tie())
            __os.tie()->flush();
        __ok_ = true;
    }
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>::sentry::~sentry()
{
    if (__os_.rdbuf() && __os_.good() && (__os_.flags() & ios_base::unitbuf)
                      && !uncaught_exception())
    {

        try
        {

            if (__os_.rdbuf()->pubsync() == -1)
                __os_.setstate(ios_base::badbit);

        }
        catch (...)
        {
        }

    }
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_ostream<_CharT, _Traits>::basic_ostream(basic_streambuf<char_type, traits_type>* __sb)
{
    this->init(__sb);
}
# 292 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/ostream" 3
template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>::~basic_ostream()
{
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
basic_ostream<_CharT, _Traits>::swap(basic_ostream& __rhs)
{
    basic_ios<char_type, traits_type>::swap(__rhs);
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::operator<<(basic_ostream& (*__pf)(basic_ostream&))
{
    return __pf(*this);
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::operator<<(basic_ios<char_type, traits_type>&
                                           (*__pf)(basic_ios<char_type,traits_type>&))
{
    __pf(*this);
    return *this;
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::operator<<(ios_base& (*__pf)(ios_base&))
{
    __pf(*this);
    return *this;
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::operator<<(basic_streambuf<char_type, traits_type>* __sb)
{

    try
    {

        sentry __s(*this);
        if (__s)
        {
            if (__sb)
            {

                try
                {

                    typedef istreambuf_iterator<_CharT, _Traits> _Ip;
                    typedef ostreambuf_iterator<_CharT, _Traits> _Op;
                    _Ip __i(__sb);
                    _Ip __eof;
                    _Op __o(*this);
                    size_t __c = 0;
                    for (; __i != __eof; ++__i, ++__o, ++__c)
                    {
                        *__o = *__i;
                        if (__o.failed())
                            break;
                    }
                    if (__c == 0)
                        this->setstate(ios_base::failbit);

                }
                catch (...)
                {
                    this->__set_failbit_and_consider_rethrow();
                }

            }
            else
                this->setstate(ios_base::badbit);
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::operator<<(bool __n)
{

    try
    {

        sentry __s(*this);
        if (__s)
        {
            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;
            const _Fp& __f = use_facet<_Fp>(this->getloc());
            if (__f.put(*this, *this, this->fill(), __n).failed())
                this->setstate(ios_base::badbit | ios_base::failbit);
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::operator<<(short __n)
{

    try
    {

        sentry __s(*this);
        if (__s)
        {
            ios_base::fmtflags __flags = ios_base::flags() & ios_base::basefield;
            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;
            const _Fp& __f = use_facet<_Fp>(this->getloc());
            if (__f.put(*this, *this, this->fill(),
                        __flags == ios_base::oct || __flags == ios_base::hex ?
                        static_cast<long>(static_cast<unsigned short>(__n)) :
                        static_cast<long>(__n)).failed())
                this->setstate(ios_base::badbit | ios_base::failbit);
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::operator<<(unsigned short __n)
{

    try
    {

        sentry __s(*this);
        if (__s)
        {
            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;
            const _Fp& __f = use_facet<_Fp>(this->getloc());
            if (__f.put(*this, *this, this->fill(), static_cast<unsigned long>(__n)).failed())
                this->setstate(ios_base::badbit | ios_base::failbit);
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::operator<<(int __n)
{

    try
    {

        sentry __s(*this);
        if (__s)
        {
            ios_base::fmtflags __flags = ios_base::flags() & ios_base::basefield;
            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;
            const _Fp& __f = use_facet<_Fp>(this->getloc());
            if (__f.put(*this, *this, this->fill(),
                        __flags == ios_base::oct || __flags == ios_base::hex ?
                        static_cast<long>(static_cast<unsigned int>(__n)) :
                        static_cast<long>(__n)).failed())
                this->setstate(ios_base::badbit | ios_base::failbit);
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::operator<<(unsigned int __n)
{

    try
    {

        sentry __s(*this);
        if (__s)
        {
            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;
            const _Fp& __f = use_facet<_Fp>(this->getloc());
            if (__f.put(*this, *this, this->fill(), static_cast<unsigned long>(__n)).failed())
                this->setstate(ios_base::badbit | ios_base::failbit);
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::operator<<(long __n)
{

    try
    {

        sentry __s(*this);
        if (__s)
        {
            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;
            const _Fp& __f = use_facet<_Fp>(this->getloc());
            if (__f.put(*this, *this, this->fill(), __n).failed())
                this->setstate(ios_base::badbit | ios_base::failbit);
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::operator<<(unsigned long __n)
{

    try
    {

        sentry __s(*this);
        if (__s)
        {
            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;
            const _Fp& __f = use_facet<_Fp>(this->getloc());
            if (__f.put(*this, *this, this->fill(), __n).failed())
                this->setstate(ios_base::badbit | ios_base::failbit);
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::operator<<(long long __n)
{

    try
    {

        sentry __s(*this);
        if (__s)
        {
            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;
            const _Fp& __f = use_facet<_Fp>(this->getloc());
            if (__f.put(*this, *this, this->fill(), __n).failed())
                this->setstate(ios_base::badbit | ios_base::failbit);
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::operator<<(unsigned long long __n)
{

    try
    {

        sentry __s(*this);
        if (__s)
        {
            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;
            const _Fp& __f = use_facet<_Fp>(this->getloc());
            if (__f.put(*this, *this, this->fill(), __n).failed())
                this->setstate(ios_base::badbit | ios_base::failbit);
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::operator<<(float __n)
{

    try
    {

        sentry __s(*this);
        if (__s)
        {
            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;
            const _Fp& __f = use_facet<_Fp>(this->getloc());
            if (__f.put(*this, *this, this->fill(), static_cast<double>(__n)).failed())
                this->setstate(ios_base::badbit | ios_base::failbit);
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::operator<<(double __n)
{

    try
    {

        sentry __s(*this);
        if (__s)
        {
            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;
            const _Fp& __f = use_facet<_Fp>(this->getloc());
            if (__f.put(*this, *this, this->fill(), __n).failed())
                this->setstate(ios_base::badbit | ios_base::failbit);
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::operator<<(long double __n)
{

    try
    {

        sentry __s(*this);
        if (__s)
        {
            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;
            const _Fp& __f = use_facet<_Fp>(this->getloc());
            if (__f.put(*this, *this, this->fill(), __n).failed())
                this->setstate(ios_base::badbit | ios_base::failbit);
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::operator<<(const void* __n)
{

    try
    {

        sentry __s(*this);
        if (__s)
        {
            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;
            const _Fp& __f = use_facet<_Fp>(this->getloc());
            if (__f.put(*this, *this, this->fill(), __n).failed())
                this->setstate(ios_base::badbit | ios_base::failbit);
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template<class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
__put_character_sequence(basic_ostream<_CharT, _Traits>& __os,
                          const _CharT* __str, size_t __len)
{

    try
    {

        typename basic_ostream<_CharT, _Traits>::sentry __s(__os);
        if (__s)
        {
            typedef ostreambuf_iterator<_CharT, _Traits> _Ip;
            if (__pad_and_output(_Ip(__os),
                                 __str,
                                 (__os.flags() & ios_base::adjustfield) == ios_base::left ?
                                     __str + __len :
                                     __str,
                                 __str + __len,
                                 __os,
                                 __os.fill()).failed())
                __os.setstate(ios_base::badbit | ios_base::failbit);
        }

    }
    catch (...)
    {
        __os.__set_badbit_and_consider_rethrow();
    }

    return __os;
}


template<class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os, _CharT __c)
{
    return std::__1::__put_character_sequence(__os, &__c, 1);
}

template<class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os, char __cn)
{

    try
    {

        typename basic_ostream<_CharT, _Traits>::sentry __s(__os);
        if (__s)
        {
            _CharT __c = __os.widen(__cn);
            typedef ostreambuf_iterator<_CharT, _Traits> _Ip;
            if (__pad_and_output(_Ip(__os),
                                 &__c,
                                 (__os.flags() & ios_base::adjustfield) == ios_base::left ?
                                     &__c + 1 :
                                     &__c,
                                 &__c + 1,
                                 __os,
                                 __os.fill()).failed())
                __os.setstate(ios_base::badbit | ios_base::failbit);
        }

    }
    catch (...)
    {
        __os.__set_badbit_and_consider_rethrow();
    }

    return __os;
}

template<class _Traits>
basic_ostream<char, _Traits>&
operator<<(basic_ostream<char, _Traits>& __os, char __c)
{
    return std::__1::__put_character_sequence(__os, &__c, 1);
}

template<class _Traits>
basic_ostream<char, _Traits>&
operator<<(basic_ostream<char, _Traits>& __os, signed char __c)
{
    return std::__1::__put_character_sequence(__os, (char *) &__c, 1);
}

template<class _Traits>
basic_ostream<char, _Traits>&
operator<<(basic_ostream<char, _Traits>& __os, unsigned char __c)
{
    return std::__1::__put_character_sequence(__os, (char *) &__c, 1);
}

template<class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os, const _CharT* __str)
{
    return std::__1::__put_character_sequence(__os, __str, _Traits::length(__str));
}

template<class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os, const char* __strn)
{

    try
    {

        typename basic_ostream<_CharT, _Traits>::sentry __s(__os);
        if (__s)
        {
            typedef ostreambuf_iterator<_CharT, _Traits> _Ip;
            size_t __len = char_traits<char>::length(__strn);
            const int __bs = 100;
            _CharT __wbb[__bs];
            _CharT* __wb = __wbb;
            unique_ptr<_CharT, void(*)(void*)> __h(0, free);
            if (__len > __bs)
            {
                __wb = (_CharT*)malloc(__len*sizeof(_CharT));
                if (__wb == 0)
                    __throw_bad_alloc();
                __h.reset(__wb);
            }
            for (_CharT* __p = __wb; *__strn != '\0'; ++__strn, ++__p)
                *__p = __os.widen(*__strn);
            if (__pad_and_output(_Ip(__os),
                                 __wb,
                                 (__os.flags() & ios_base::adjustfield) == ios_base::left ?
                                     __wb + __len :
                                     __wb,
                                 __wb + __len,
                                 __os,
                                 __os.fill()).failed())
                __os.setstate(ios_base::badbit | ios_base::failbit);
        }

    }
    catch (...)
    {
        __os.__set_badbit_and_consider_rethrow();
    }

    return __os;
}

template<class _Traits>
basic_ostream<char, _Traits>&
operator<<(basic_ostream<char, _Traits>& __os, const char* __str)
{
    return std::__1::__put_character_sequence(__os, __str, _Traits::length(__str));
}

template<class _Traits>
basic_ostream<char, _Traits>&
operator<<(basic_ostream<char, _Traits>& __os, const signed char* __str)
{
    const char *__s = (const char *) __str;
    return std::__1::__put_character_sequence(__os, __s, _Traits::length(__s));
}

template<class _Traits>
basic_ostream<char, _Traits>&
operator<<(basic_ostream<char, _Traits>& __os, const unsigned char* __str)
{
    const char *__s = (const char *) __str;
    return std::__1::__put_character_sequence(__os, __s, _Traits::length(__s));
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::put(char_type __c)
{

    try
    {

        sentry __s(*this);
        if (__s)
        {
            typedef ostreambuf_iterator<_CharT, _Traits> _Op;
            _Op __o(*this);
            *__o = __c;
            if (__o.failed())
                this->setstate(ios_base::badbit);
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::write(const char_type* __s, streamsize __n)
{

    try
    {

        sentry __sen(*this);
        if (__sen && __n)
        {
            if (this->rdbuf()->sputn(__s, __n) != __n)
                this->setstate(ios_base::badbit);
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::flush()
{

    try
    {

        if (this->rdbuf())
        {
            sentry __s(*this);
            if (__s)
            {
                if (this->rdbuf()->pubsync() == -1)
                    this->setstate(ios_base::badbit);
            }
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename basic_ostream<_CharT, _Traits>::pos_type
basic_ostream<_CharT, _Traits>::tellp()
{
    if (this->fail())
        return pos_type(-1);
    return this->rdbuf()->pubseekoff(0, ios_base::cur, ios_base::out);
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::seekp(pos_type __pos)
{
    sentry __s(*this);
    if (__s)
    {
        if (this->rdbuf()->pubseekpos(__pos, ios_base::out) == pos_type(-1))
            this->setstate(ios_base::failbit);
    }
    return *this;
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::seekp(off_type __off, ios_base::seekdir __dir)
{
    sentry __s(*this);
    if (__s)
    {
        if (this->rdbuf()->pubseekoff(__off, __dir, ios_base::out) == pos_type(-1))
            this->setstate(ios_base::failbit);
    }
    return *this;
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_ostream<_CharT, _Traits>&
endl(basic_ostream<_CharT, _Traits>& __os)
{
    __os.put(__os.widen('\n'));
    __os.flush();
    return __os;
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_ostream<_CharT, _Traits>&
ends(basic_ostream<_CharT, _Traits>& __os)
{
    __os.put(_CharT());
    return __os;
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_ostream<_CharT, _Traits>&
flush(basic_ostream<_CharT, _Traits>& __os)
{
    __os.flush();
    return __os;
}
# 1063 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/ostream" 3
template<class _CharT, class _Traits, class _Allocator>
basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os,
           const basic_string<_CharT, _Traits, _Allocator>& __str)
{
    return std::__1::__put_character_sequence(__os, __str.data(), __str.size());
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os, const error_code& __ec)
{
    return __os << __ec.category().name() << ':' << __ec.value();
}

template<class _CharT, class _Traits, class _Yp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os, shared_ptr<_Yp> const& __p)
{
    return __os << __p.get();
}

template <class _CharT, class _Traits, size_t _Size>
basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os, const bitset<_Size>& __x)
{
    return __os << __x.template to_string<_CharT, _Traits>
                        (use_facet<ctype<_CharT> >(__os.getloc()).widen('0'),
                         use_facet<ctype<_CharT> >(__os.getloc()).widen('1'));
}




} }
# 157 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/istream" 2 3

# 1 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/__undef_min_max" 1 3
// -*- C++ -*-
//===----------------------------------------------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is dual licensed under the MIT and the University of Illinois Open
// Source Licenses. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
# 159 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/istream" 2 3
# 162 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/istream" 3


namespace std {inline namespace __1 {

template <class _CharT, class _Traits>
class __attribute__ ((__type_visibility__("default"))) basic_istream
    : virtual public basic_ios<_CharT, _Traits>
{
    streamsize __gc_;
public:
    // types (inherited from basic_ios (27.5.4)):
    typedef _CharT char_type;
    typedef _Traits traits_type;
    typedef typename traits_type::int_type int_type;
    typedef typename traits_type::pos_type pos_type;
    typedef typename traits_type::off_type off_type;

    // 27.7.1.1.1 Constructor/destructor:
    explicit basic_istream(basic_streambuf<char_type, traits_type>* __sb);
    virtual ~basic_istream();
protected:





    // 27.7.1.1.2 Assign/swap:




    void swap(basic_istream& __rhs);
public:

    // 27.7.1.1.3 Prefix/suffix:
    class __attribute__ ((__type_visibility__("default"))) sentry;

    // 27.7.1.2 Formatted input:
    basic_istream& operator>>(basic_istream& (*__pf)(basic_istream&));
    basic_istream& operator>>(basic_ios<char_type, traits_type>&
                              (*__pf)(basic_ios<char_type, traits_type>&));
    basic_istream& operator>>(ios_base& (*__pf)(ios_base&));
    basic_istream& operator>>(basic_streambuf<char_type, traits_type>* __sb);
    basic_istream& operator>>(bool& __n);
    basic_istream& operator>>(short& __n);
    basic_istream& operator>>(unsigned short& __n);
    basic_istream& operator>>(int& __n);
    basic_istream& operator>>(unsigned int& __n);
    basic_istream& operator>>(long& __n);
    basic_istream& operator>>(unsigned long& __n);
    basic_istream& operator>>(long long& __n);
    basic_istream& operator>>(unsigned long long& __n);
    basic_istream& operator>>(float& __f);
    basic_istream& operator>>(double& __f);
    basic_istream& operator>>(long double& __f);
    basic_istream& operator>>(void*& __p);

    // 27.7.1.3 Unformatted input:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    streamsize gcount() const {return __gc_;}
    int_type get();
    basic_istream& get(char_type& __c);
    basic_istream& get(char_type* __s, streamsize __n);
    basic_istream& get(char_type* __s, streamsize __n, char_type __dlm);
    basic_istream& get(basic_streambuf<char_type, traits_type>& __sb);
    basic_istream& get(basic_streambuf<char_type, traits_type>& __sb, char_type __dlm);

    basic_istream& getline(char_type* __s, streamsize __n);
    basic_istream& getline(char_type* __s, streamsize __n, char_type __dlm);

    basic_istream& ignore(streamsize __n = 1, int_type __dlm = traits_type::eof());
    int_type peek();
    basic_istream& read (char_type* __s, streamsize __n);
    streamsize readsome(char_type* __s, streamsize __n);

    basic_istream& putback(char_type __c);
    basic_istream& unget();
    int sync();

    pos_type tellg();
    basic_istream& seekg(pos_type __pos);
    basic_istream& seekg(off_type __off, ios_base::seekdir __dir);
};

template <class _CharT, class _Traits>
class __attribute__ ((__type_visibility__("default"))) basic_istream<_CharT, _Traits>::sentry
{
    bool __ok_;

    sentry(const sentry&); // = delete;
    sentry& operator=(const sentry&); // = delete;

public:
    explicit sentry(basic_istream<_CharT, _Traits>& __is, bool __noskipws = false);
//    ~sentry() = default;

    __attribute__ ((__visibility__("hidden"), __always_inline__))

        operator bool() const {return __ok_;}
};

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>::sentry::sentry(basic_istream<_CharT, _Traits>& __is,
                                               bool __noskipws)
    : __ok_(false)
{
    if (__is.good())
    {
        if (__is.tie())
            __is.tie()->flush();
        if (!__noskipws && (__is.flags() & ios_base::skipws))
        {
            typedef istreambuf_iterator<_CharT, _Traits> _Ip;
            const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__is.getloc());
            _Ip __i(__is);
            _Ip __eof;
            for (; __i != __eof; ++__i)
                if (!__ct.is(__ct.space, *__i))
                    break;
            if (__i == __eof)
                __is.setstate(ios_base::failbit | ios_base::eofbit);
        }
        __ok_ = __is.good();
    }
    else
        __is.setstate(ios_base::failbit);
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_istream<_CharT, _Traits>::basic_istream(basic_streambuf<char_type, traits_type>* __sb)
    : __gc_(0)
{
    this->init(__sb);
}
# 320 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/istream" 3
template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>::~basic_istream()
{
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
basic_istream<_CharT, _Traits>::swap(basic_istream& __rhs)
{
    std::__1::swap(__gc_, __rhs.__gc_);
    basic_ios<char_type, traits_type>::swap(__rhs);
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::operator>>(unsigned short& __n)
{

    try
    {

        sentry __s(*this);
        if (__s)
        {
            typedef istreambuf_iterator<char_type, traits_type> _Ip;
            typedef num_get<char_type, _Ip> _Fp;
            ios_base::iostate __err = ios_base::goodbit;
            use_facet<_Fp>(this->getloc()).get(_Ip(*this), _Ip(), *this, __err, __n);
            this->setstate(__err);
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::operator>>(unsigned int& __n)
{

    try
    {

        sentry __s(*this);
        if (__s)
        {
            typedef istreambuf_iterator<char_type, traits_type> _Ip;
            typedef num_get<char_type, _Ip> _Fp;
            ios_base::iostate __err = ios_base::goodbit;
            use_facet<_Fp>(this->getloc()).get(_Ip(*this), _Ip(), *this, __err, __n);
            this->setstate(__err);
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::operator>>(long& __n)
{

    try
    {

        sentry __s(*this);
        if (__s)
        {
            typedef istreambuf_iterator<char_type, traits_type> _Ip;
            typedef num_get<char_type, _Ip> _Fp;
            ios_base::iostate __err = ios_base::goodbit;
            use_facet<_Fp>(this->getloc()).get(_Ip(*this), _Ip(), *this, __err, __n);
            this->setstate(__err);
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::operator>>(unsigned long& __n)
{

    try
    {

        sentry __s(*this);
        if (__s)
        {
            typedef istreambuf_iterator<char_type, traits_type> _Ip;
            typedef num_get<char_type, _Ip> _Fp;
            ios_base::iostate __err = ios_base::goodbit;
            use_facet<_Fp>(this->getloc()).get(_Ip(*this), _Ip(), *this, __err, __n);
            this->setstate(__err);
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::operator>>(long long& __n)
{

    try
    {

        sentry __s(*this);
        if (__s)
        {
            typedef istreambuf_iterator<char_type, traits_type> _Ip;
            typedef num_get<char_type, _Ip> _Fp;
            ios_base::iostate __err = ios_base::goodbit;
            use_facet<_Fp>(this->getloc()).get(_Ip(*this), _Ip(), *this, __err, __n);
            this->setstate(__err);
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::operator>>(unsigned long long& __n)
{

    try
    {

        sentry __s(*this);
        if (__s)
        {
            typedef istreambuf_iterator<char_type, traits_type> _Ip;
            typedef num_get<char_type, _Ip> _Fp;
            ios_base::iostate __err = ios_base::goodbit;
            use_facet<_Fp>(this->getloc()).get(_Ip(*this), _Ip(), *this, __err, __n);
            this->setstate(__err);
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::operator>>(float& __n)
{

    try
    {

        sentry __s(*this);
        if (__s)
        {
            typedef istreambuf_iterator<char_type, traits_type> _Ip;
            typedef num_get<char_type, _Ip> _Fp;
            ios_base::iostate __err = ios_base::goodbit;
            use_facet<_Fp>(this->getloc()).get(_Ip(*this), _Ip(), *this, __err, __n);
            this->setstate(__err);
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::operator>>(double& __n)
{

    try
    {

        sentry __s(*this);
        if (__s)
        {
            typedef istreambuf_iterator<char_type, traits_type> _Ip;
            typedef num_get<char_type, _Ip> _Fp;
            ios_base::iostate __err = ios_base::goodbit;
            use_facet<_Fp>(this->getloc()).get(_Ip(*this), _Ip(), *this, __err, __n);
            this->setstate(__err);
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::operator>>(long double& __n)
{

    try
    {

        sentry __s(*this);
        if (__s)
        {
            typedef istreambuf_iterator<char_type, traits_type> _Ip;
            typedef num_get<char_type, _Ip> _Fp;
            ios_base::iostate __err = ios_base::goodbit;
            use_facet<_Fp>(this->getloc()).get(_Ip(*this), _Ip(), *this, __err, __n);
            this->setstate(__err);
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::operator>>(bool& __n)
{

    try
    {

        sentry __s(*this);
        if (__s)
        {
            typedef istreambuf_iterator<char_type, traits_type> _Ip;
            typedef num_get<char_type, _Ip> _Fp;
            ios_base::iostate __err = ios_base::goodbit;
            use_facet<_Fp>(this->getloc()).get(_Ip(*this), _Ip(), *this, __err, __n);
            this->setstate(__err);
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::operator>>(void*& __n)
{

    try
    {

        sentry __s(*this);
        if (__s)
        {
            typedef istreambuf_iterator<char_type, traits_type> _Ip;
            typedef num_get<char_type, _Ip> _Fp;
            ios_base::iostate __err = ios_base::goodbit;
            use_facet<_Fp>(this->getloc()).get(_Ip(*this), _Ip(), *this, __err, __n);
            this->setstate(__err);
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::operator>>(short& __n)
{

    try
    {

        sentry __s(*this);
        if (__s)
        {
            typedef istreambuf_iterator<char_type, traits_type> _Ip;
            typedef num_get<char_type, _Ip> _Fp;
            ios_base::iostate __err = ios_base::goodbit;
            long __temp;
            use_facet<_Fp>(this->getloc()).get(_Ip(*this), _Ip(), *this, __err, __temp);
            if (__temp < numeric_limits<short>::min())
            {
                __err |= ios_base::failbit;
                __n = numeric_limits<short>::min();
            }
            else if (__temp > numeric_limits<short>::max())
            {
                __err |= ios_base::failbit;
                __n = numeric_limits<short>::max();
            }
            else
                __n = static_cast<short>(__temp);
            this->setstate(__err);
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::operator>>(int& __n)
{

    try
    {

        sentry __s(*this);
        if (__s)
        {
            typedef istreambuf_iterator<char_type, traits_type> _Ip;
            typedef num_get<char_type, _Ip> _Fp;
            ios_base::iostate __err = ios_base::goodbit;
            long __temp;
            use_facet<_Fp>(this->getloc()).get(_Ip(*this), _Ip(), *this, __err, __temp);
            if (__temp < numeric_limits<int>::min())
            {
                __err |= ios_base::failbit;
                __n = numeric_limits<int>::min();
            }
            else if (__temp > numeric_limits<int>::max())
            {
                __err |= ios_base::failbit;
                __n = numeric_limits<int>::max();
            }
            else
                __n = static_cast<int>(__temp);
            this->setstate(__err);
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::operator>>(basic_istream& (*__pf)(basic_istream&))
{
    return __pf(*this);
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::operator>>(basic_ios<char_type, traits_type>&
                                           (*__pf)(basic_ios<char_type, traits_type>&))
{
    __pf(*this);
    return *this;
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::operator>>(ios_base& (*__pf)(ios_base&))
{
    __pf(*this);
    return *this;
}

template<class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
operator>>(basic_istream<_CharT, _Traits>& __is, _CharT* __s)
{

    try
    {

        typename basic_istream<_CharT, _Traits>::sentry __sen(__is);
        if (__sen)
        {
            streamsize __n = __is.width();
            if (__n <= 0)
                __n = numeric_limits<streamsize>::max() / sizeof(_CharT) - 1;
            streamsize __c = 0;
            const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__is.getloc());
            ios_base::iostate __err = ios_base::goodbit;
            while (__c < __n-1)
            {
                typename _Traits::int_type __i = __is.rdbuf()->sgetc();
                if (_Traits::eq_int_type(__i, _Traits::eof()))
                {
                   __err |= ios_base::eofbit;
                   break;
                }
                _CharT __ch = _Traits::to_char_type(__i);
                if (__ct.is(__ct.space, __ch))
                    break;
                *__s++ = __ch;
                ++__c;
                 __is.rdbuf()->sbumpc();
            }
            *__s = _CharT();
            __is.width(0);
            if (__c == 0)
               __err |= ios_base::failbit;
            __is.setstate(__err);
        }

    }
    catch (...)
    {
        __is.__set_badbit_and_consider_rethrow();
    }

    return __is;
}

template<class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_istream<char, _Traits>&
operator>>(basic_istream<char, _Traits>& __is, unsigned char* __s)
{
    return __is >> (char*)__s;
}

template<class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_istream<char, _Traits>&
operator>>(basic_istream<char, _Traits>& __is, signed char* __s)
{
    return __is >> (char*)__s;
}

template<class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
operator>>(basic_istream<_CharT, _Traits>& __is, _CharT& __c)
{

    try
    {

        typename basic_istream<_CharT, _Traits>::sentry __sen(__is);
        if (__sen)
        {
            typename _Traits::int_type __i = __is.rdbuf()->sbumpc();
            if (_Traits::eq_int_type(__i, _Traits::eof()))
                __is.setstate(ios_base::eofbit | ios_base::failbit);
            else
                __c = _Traits::to_char_type(__i);
        }

    }
    catch (...)
    {
        __is.__set_badbit_and_consider_rethrow();
    }

    return __is;
}

template<class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_istream<char, _Traits>&
operator>>(basic_istream<char, _Traits>& __is, unsigned char& __c)
{
    return __is >> (char&)__c;
}

template<class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_istream<char, _Traits>&
operator>>(basic_istream<char, _Traits>& __is, signed char& __c)
{
    return __is >> (char&)__c;
}

template<class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::operator>>(basic_streambuf<char_type, traits_type>* __sb)
{
    __gc_ = 0;

    try
    {

        sentry __s(*this, true);
        if (__s)
        {
            if (__sb)
            {

                try
                {

                    ios_base::iostate __err = ios_base::goodbit;
                    while (true)
                    {
                        typename traits_type::int_type __i = this->rdbuf()->sgetc();
                        if (traits_type::eq_int_type(__i, _Traits::eof()))
                        {
                           __err |= ios_base::eofbit;
                           break;
                        }
                        if (traits_type::eq_int_type(
                                __sb->sputc(traits_type::to_char_type(__i)),
                                traits_type::eof()))
                            break;
                        ++__gc_;
                        this->rdbuf()->sbumpc();
                    }
                    if (__gc_ == 0)
                       __err |= ios_base::failbit;
                    this->setstate(__err);

                }
                catch (...)
                {
                    if (__gc_ == 0)
                        this->__set_failbit_and_consider_rethrow();
                }

            }
            else
                this->setstate(ios_base::failbit);
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template<class _CharT, class _Traits>
typename basic_istream<_CharT, _Traits>::int_type
basic_istream<_CharT, _Traits>::get()
{
    __gc_ = 0;
    int_type __r = traits_type::eof();

    try
    {

        sentry __s(*this, true);
        if (__s)
        {
            __r = this->rdbuf()->sbumpc();
            if (traits_type::eq_int_type(__r, traits_type::eof()))
               this->setstate(ios_base::failbit | ios_base::eofbit);
            else
                __gc_ = 1;
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return __r;
}

template<class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::get(char_type& __c)
{
    int_type __ch = get();
    if (__ch != traits_type::eof())
        __c = traits_type::to_char_type(__ch);
    return *this;
}

template<class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::get(char_type* __s, streamsize __n, char_type __dlm)
{
    __gc_ = 0;

    try
    {

        sentry __sen(*this, true);
        if (__sen)
        {
            if (__n > 0)
            {
                ios_base::iostate __err = ios_base::goodbit;
                while (__gc_ < __n-1)
                {
                    int_type __i = this->rdbuf()->sgetc();
                    if (traits_type::eq_int_type(__i, traits_type::eof()))
                    {
                       __err |= ios_base::eofbit;
                       break;
                    }
                    char_type __ch = traits_type::to_char_type(__i);
                    if (traits_type::eq(__ch, __dlm))
                        break;
                    *__s++ = __ch;
                    ++__gc_;
                     this->rdbuf()->sbumpc();
                }
                *__s = char_type();
                if (__gc_ == 0)
                   __err |= ios_base::failbit;
                this->setstate(__err);
            }
            else
                this->setstate(ios_base::failbit);
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template<class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::get(char_type* __s, streamsize __n)
{
    return get(__s, __n, this->widen('\n'));
}

template<class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::get(basic_streambuf<char_type, traits_type>& __sb,
                                    char_type __dlm)
{
    __gc_ = 0;

    try
    {

        sentry __sen(*this, true);
        if (__sen)
        {
            ios_base::iostate __err = ios_base::goodbit;

            try
            {

                while (true)
                {
                    typename traits_type::int_type __i = this->rdbuf()->sgetc();
                    if (traits_type::eq_int_type(__i, traits_type::eof()))
                    {
                       __err |= ios_base::eofbit;
                       break;
                    }
                    char_type __ch = traits_type::to_char_type(__i);
                    if (traits_type::eq(__ch, __dlm))
                        break;
                    if (traits_type::eq_int_type(__sb.sputc(__ch), traits_type::eof()))
                        break;
                    ++__gc_;
                    this->rdbuf()->sbumpc();
                }

            }
            catch (...)
            {
            }

            if (__gc_ == 0)
               __err |= ios_base::failbit;
            this->setstate(__err);
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template<class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::get(basic_streambuf<char_type, traits_type>& __sb)
{
    return get(__sb, this->widen('\n'));
}

template<class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::getline(char_type* __s, streamsize __n, char_type __dlm)
{
    __gc_ = 0;

    try
    {

        sentry __sen(*this, true);
        if (__sen)
        {
            ios_base::iostate __err = ios_base::goodbit;
            while (true)
            {
                typename traits_type::int_type __i = this->rdbuf()->sgetc();
                if (traits_type::eq_int_type(__i, traits_type::eof()))
                {
                   __err |= ios_base::eofbit;
                   break;
                }
                char_type __ch = traits_type::to_char_type(__i);
                if (traits_type::eq(__ch, __dlm))
                {
                    this->rdbuf()->sbumpc();
                    ++__gc_;
                    break;
                }
                if (__gc_ >= __n-1)
                {
                    __err |= ios_base::failbit;
                    break;
                }
                *__s++ = __ch;
                this->rdbuf()->sbumpc();
                ++__gc_;
            }
            if (__n > 0)
                *__s = char_type();
            if (__gc_ == 0)
               __err |= ios_base::failbit;
            this->setstate(__err);
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template<class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::getline(char_type* __s, streamsize __n)
{
    return getline(__s, __n, this->widen('\n'));
}

template<class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::ignore(streamsize __n, int_type __dlm)
{
    __gc_ = 0;

    try
    {

        sentry __sen(*this, true);
        if (__sen)
        {
            ios_base::iostate __err = ios_base::goodbit;
            if (__n == numeric_limits<streamsize>::max())
            {
                while (true)
                {
                    typename traits_type::int_type __i = this->rdbuf()->sbumpc();
                    if (traits_type::eq_int_type(__i, traits_type::eof()))
                    {
                       __err |= ios_base::eofbit;
                       break;
                    }
                    ++__gc_;
                    if (traits_type::eq_int_type(__i, __dlm))
                        break;
                }
            }
            else
            {
                while (__gc_ < __n)
                {
                    typename traits_type::int_type __i = this->rdbuf()->sbumpc();
                    if (traits_type::eq_int_type(__i, traits_type::eof()))
                    {
                       __err |= ios_base::eofbit;
                       break;
                    }
                    ++__gc_;
                    if (traits_type::eq_int_type(__i, __dlm))
                        break;
                }
            }
            this->setstate(__err);
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template<class _CharT, class _Traits>
typename basic_istream<_CharT, _Traits>::int_type
basic_istream<_CharT, _Traits>::peek()
{
    __gc_ = 0;
    int_type __r = traits_type::eof();

    try
    {

        sentry __sen(*this, true);
        if (__sen)
        {
            __r = this->rdbuf()->sgetc();
            if (traits_type::eq_int_type(__r, traits_type::eof()))
                this->setstate(ios_base::eofbit);
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return __r;
}

template<class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::read(char_type* __s, streamsize __n)
{
    __gc_ = 0;

    try
    {

        sentry __sen(*this, true);
        if (__sen)
        {
            __gc_ = this->rdbuf()->sgetn(__s, __n);
            if (__gc_ != __n)
                this->setstate(ios_base::failbit | ios_base::eofbit);
        }
        else
            this->setstate(ios_base::failbit);

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template<class _CharT, class _Traits>
streamsize
basic_istream<_CharT, _Traits>::readsome(char_type* __s, streamsize __n)
{
    __gc_ = 0;
    streamsize __c = this->rdbuf()->in_avail();
    switch (__c)
    {
    case -1:
        this->setstate(ios_base::eofbit);
        break;
    case 0:
        break;
    default:
        read(__s, std::__1::min(__c, __n));
        break;
    }
    return __gc_;
}

template<class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::putback(char_type __c)
{
    __gc_ = 0;

    try
    {

        this->clear(this->rdstate() & ~ios_base::eofbit);
        sentry __sen(*this, true);
        if (__sen)
        {
            if (this->rdbuf() == 0 || this->rdbuf()->sputbackc(__c) == traits_type::eof())
                this->setstate(ios_base::badbit);
        }
        else
            this->setstate(ios_base::failbit);

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template<class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::unget()
{
    __gc_ = 0;

    try
    {

        this->clear(this->rdstate() & ~ios_base::eofbit);
        sentry __sen(*this, true);
        if (__sen)
        {
            if (this->rdbuf() == 0 || this->rdbuf()->sungetc() == traits_type::eof())
                this->setstate(ios_base::badbit);
        }
        else
            this->setstate(ios_base::failbit);

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template<class _CharT, class _Traits>
int
basic_istream<_CharT, _Traits>::sync()
{
    int __r = 0;

    try
    {

        sentry __sen(*this, true);
        if (__sen)
        {
            if (this->rdbuf() == 0)
                return -1;
            if (this->rdbuf()->pubsync() == -1)
            {
                this->setstate(ios_base::badbit);
                return -1;
            }
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return __r;
}

template<class _CharT, class _Traits>
typename basic_istream<_CharT, _Traits>::pos_type
basic_istream<_CharT, _Traits>::tellg()
{
    pos_type __r(-1);

    try
    {

        sentry __sen(*this, true);
        if (__sen)
            __r = this->rdbuf()->pubseekoff(0, ios_base::cur, ios_base::in);

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return __r;
}

template<class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::seekg(pos_type __pos)
{

    try
    {

        this->clear(this->rdstate() & ~ios_base::eofbit);
        sentry __sen(*this, true);
        if (__sen)
        {
            if (this->rdbuf()->pubseekpos(__pos, ios_base::in) == pos_type(-1))
                this->setstate(ios_base::failbit);
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template<class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::seekg(off_type __off, ios_base::seekdir __dir)
{

    try
    {

        sentry __sen(*this, true);
        if (__sen)
        {
            if (this->rdbuf()->pubseekoff(__off, __dir, ios_base::in) == pos_type(-1))
                this->setstate(ios_base::failbit);
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
ws(basic_istream<_CharT, _Traits>& __is)
{

    try
    {

        typename basic_istream<_CharT, _Traits>::sentry __sen(__is, true);
        if (__sen)
        {
            const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__is.getloc());
            while (true)
            {
                typename _Traits::int_type __i = __is.rdbuf()->sgetc();
                if (_Traits::eq_int_type(__i, _Traits::eof()))
                {
                   __is.setstate(ios_base::eofbit);
                   break;
                }
                if (!__ct.is(__ct.space, _Traits::to_char_type(__i)))
                    break;
                __is.rdbuf()->sbumpc();
            }
        }

    }
    catch (...)
    {
        __is.__set_badbit_and_consider_rethrow();
    }

    return __is;
}
# 1458 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/istream" 3
template <class _CharT, class _Traits>
class __attribute__ ((__type_visibility__("default"))) basic_iostream
    : public basic_istream<_CharT, _Traits>,
      public basic_ostream<_CharT, _Traits>
{
public:
    // types:
    typedef _CharT char_type;
    typedef _Traits traits_type;
    typedef typename traits_type::int_type int_type;
    typedef typename traits_type::pos_type pos_type;
    typedef typename traits_type::off_type off_type;

    // constructor/destructor
    explicit basic_iostream(basic_streambuf<char_type, traits_type>* __sb);
    virtual ~basic_iostream();
protected:





    // assign/swap




    void swap(basic_iostream& __rhs);
public:
};

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_iostream<_CharT, _Traits>::basic_iostream(basic_streambuf<char_type, traits_type>* __sb)
    : basic_istream<_CharT, _Traits>(__sb)
{
}
# 1516 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/istream" 3
template <class _CharT, class _Traits>
basic_iostream<_CharT, _Traits>::~basic_iostream()
{
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
basic_iostream<_CharT, _Traits>::swap(basic_iostream& __rhs)
{
    basic_istream<char_type, traits_type>::swap(__rhs);
}

template<class _CharT, class _Traits, class _Allocator>
basic_istream<_CharT, _Traits>&
operator>>(basic_istream<_CharT, _Traits>& __is,
           basic_string<_CharT, _Traits, _Allocator>& __str)
{

    try
    {

        typename basic_istream<_CharT, _Traits>::sentry __sen(__is);
        if (__sen)
        {
            __str.clear();
            streamsize __n = __is.width();
            if (__n <= 0)
                __n = __str.max_size();
            if (__n <= 0)
                __n = numeric_limits<streamsize>::max();
            streamsize __c = 0;
            const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__is.getloc());
            ios_base::iostate __err = ios_base::goodbit;
            while (__c < __n)
            {
                typename _Traits::int_type __i = __is.rdbuf()->sgetc();
                if (_Traits::eq_int_type(__i, _Traits::eof()))
                {
                   __err |= ios_base::eofbit;
                   break;
                }
                _CharT __ch = _Traits::to_char_type(__i);
                if (__ct.is(__ct.space, __ch))
                    break;
                __str.push_back(__ch);
                ++__c;
                 __is.rdbuf()->sbumpc();
            }
            __is.width(0);
            if (__c == 0)
               __err |= ios_base::failbit;
            __is.setstate(__err);
        }
        else
            __is.setstate(ios_base::failbit);

    }
    catch (...)
    {
        __is.__set_badbit_and_consider_rethrow();
    }

    return __is;
}

template<class _CharT, class _Traits, class _Allocator>
basic_istream<_CharT, _Traits>&
getline(basic_istream<_CharT, _Traits>& __is,
        basic_string<_CharT, _Traits, _Allocator>& __str, _CharT __dlm)
{

    try
    {

        typename basic_istream<_CharT, _Traits>::sentry __sen(__is, true);
        if (__sen)
        {
            __str.clear();
            ios_base::iostate __err = ios_base::goodbit;
            streamsize __extr = 0;
            while (true)
            {
                typename _Traits::int_type __i = __is.rdbuf()->sbumpc();
                if (_Traits::eq_int_type(__i, _Traits::eof()))
                {
                   __err |= ios_base::eofbit;
                   break;
                }
                ++__extr;
                _CharT __ch = _Traits::to_char_type(__i);
                if (_Traits::eq(__ch, __dlm))
                    break;
                __str.push_back(__ch);
                if (__str.size() == __str.max_size())
                {
                    __err |= ios_base::failbit;
                    break;
                }
            }
            if (__extr == 0)
               __err |= ios_base::failbit;
            __is.setstate(__err);
        }

    }
    catch (...)
    {
        __is.__set_badbit_and_consider_rethrow();
    }

    return __is;
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_istream<_CharT, _Traits>&
getline(basic_istream<_CharT, _Traits>& __is,
        basic_string<_CharT, _Traits, _Allocator>& __str)
{
    return getline(__is, __str, __is.widen('\n'));
}
# 1661 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/istream" 3
template <class _CharT, class _Traits, size_t _Size>
basic_istream<_CharT, _Traits>&
operator>>(basic_istream<_CharT, _Traits>& __is, bitset<_Size>& __x)
{

    try
    {

        typename basic_istream<_CharT, _Traits>::sentry __sen(__is);
        if (__sen)
        {
            basic_string<_CharT, _Traits> __str;
            const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__is.getloc());
            streamsize __c = 0;
            ios_base::iostate __err = ios_base::goodbit;
            _CharT __zero = __ct.widen('0');
            _CharT __one = __ct.widen('1');
            while (__c < _Size)
            {
                typename _Traits::int_type __i = __is.rdbuf()->sgetc();
                if (_Traits::eq_int_type(__i, _Traits::eof()))
                {
                   __err |= ios_base::eofbit;
                   break;
                }
                _CharT __ch = _Traits::to_char_type(__i);
                if (!_Traits::eq(__ch, __zero) && !_Traits::eq(__ch, __one))
                    break;
                __str.push_back(__ch);
                ++__c;
                 __is.rdbuf()->sbumpc();
            }
            __x = bitset<_Size>(__str);
            if (__c == 0)
               __err |= ios_base::failbit;
            __is.setstate(__err);
        }
        else
            __is.setstate(ios_base::failbit);

    }
    catch (...)
    {
        __is.__set_badbit_and_consider_rethrow();
    }

    return __is;
}





} }
# 41 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/iostream" 2 3
# 45 "/usr/local/Cellar/clang-omp/2015-04-01/libexec/bin/../include/c++/v1/iostream" 3


namespace std {inline namespace __1 {

extern __attribute__ ((__visibility__("default"))) istream cin;
extern __attribute__ ((__visibility__("default"))) ostream cout;
extern __attribute__ ((__visibility__("default"))) ostream cerr;
extern __attribute__ ((__visibility__("default"))) ostream clog;
extern __attribute__ ((__visibility__("default"))) wistream wcin;
extern __attribute__ ((__visibility__("default"))) wostream wcout;
extern __attribute__ ((__visibility__("default"))) wostream wcerr;
extern __attribute__ ((__visibility__("default"))) wostream wclog;

} }
# 3 "tessapi-quality.cpp" 2
//#include </usr/local/include/leptonica/allheaders.h>

# 1 "/usr/local/Cellar/leptonica/1.71_1/include/leptonica/allheaders.h" 1
/*====================================================================*
 -  Copyright (C) 2001 Leptonica.  All rights reserved.
 -
 -  Redistribution and use in source and binary forms, with or without
 -  modification, are permitted provided that the following conditions
 -  are met:
 -  1. Redistributions of source code must retain the above copyright
 -     notice, this list of conditions and the following disclaimer.
 -  2. Redistributions in binary form must reproduce the above
 -     copyright notice, this list of conditions and the following
 -     disclaimer in the documentation and/or other materials
 -     provided with the distribution.
 -
 -  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 -  ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 -  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 -  A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL ANY
 -  CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 -  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 -  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 -  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 -  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 -  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 -  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *====================================================================*/
# 34 "/usr/local/Cellar/leptonica/1.71_1/include/leptonica/allheaders.h"
# 1 "/usr/local/Cellar/leptonica/1.71_1/include/leptonica/alltypes.h" 1
/*====================================================================*
 -  Copyright (C) 2001 Leptonica.  All rights reserved.
 -
 -  Redistribution and use in source and binary forms, with or without
 -  modification, are permitted provided that the following conditions
 -  are met:
 -  1. Redistributions of source code must retain the above copyright
 -     notice, this list of conditions and the following disclaimer.
 -  2. Redistributions in binary form must reproduce the above
 -     copyright notice, this list of conditions and the following
 -     disclaimer in the documentation and/or other materials
 -     provided with the distribution.
 -
 -  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 -  ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 -  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 -  A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL ANY
 -  CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 -  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 -  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 -  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 -  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 -  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 -  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *====================================================================*/




    /* Standard */




    /* General and configuration defs */

# 1 "/usr/local/Cellar/leptonica/1.71_1/include/leptonica/environ.h" 1
/*====================================================================*
 -  Copyright (C) 2001 Leptonica.  All rights reserved.
 -
 -  Redistribution and use in source and binary forms, with or without
 -  modification, are permitted provided that the following conditions
 -  are met:
 -  1. Redistributions of source code must retain the above copyright
 -     notice, this list of conditions and the following disclaimer.
 -  2. Redistributions in binary form must reproduce the above
 -     copyright notice, this list of conditions and the following
 -     disclaimer in the documentation and/or other materials
 -     provided with the distribution.
 -
 -  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 -  ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 -  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 -  A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL ANY
 -  CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 -  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 -  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 -  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 -  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 -  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 -  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *====================================================================*/




/*------------------------------------------------------------------------*
 *  Defines and includes differ for Unix and Windows.  Also for Windows,  *
 *  differentiate between conditionals based on platform and compiler.    *
 *      For platforms:                                                    *
 *          _WIN32       =>     Windows, 32- or 64-bit                    *
 *          _WIN64       =>     Windows, 64-bit only                      *
 *          __CYGWIN__   =>     Cygwin                                    *
 *      For compilers:                                                    *
 *          __GNUC__     =>     gcc                                       *
 *          _MSC_VER     =>     msvc                                      *
 *------------------------------------------------------------------------*/

/* MS VC++ does not provide stdint.h, so define the missing types here */
# 68 "/usr/local/Cellar/leptonica/1.71_1/include/leptonica/environ.h"
/* Windows specifics */
# 83 "/usr/local/Cellar/leptonica/1.71_1/include/leptonica/environ.h"
typedef intptr_t l_intptr_t;
typedef uintptr_t l_uintptr_t;
typedef void *L_TIMER;


/*--------------------------------------------------------------------*
 * !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*
 *                          USER CONFIGURABLE                         *
 * !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*
 *               Environment variables with I/O libraries             *
 *               Manual Configuration Only: NOT AUTO_CONF             *
 *--------------------------------------------------------------------*/
/*
 *  Leptonica provides interfaces to link to several external image
 *  I/O libraries, plus zlib.  Setting any of these to 0 here causes
 *  non-functioning stubs to be linked.
 */
# 111 "/usr/local/Cellar/leptonica/1.71_1/include/leptonica/environ.h"
/*
 * On linux systems, you can do I/O between Pix and memory.  Specifically,
 * you can compress (write compressed data to memory from a Pix) and
 * uncompress (read from compressed data in memory to a Pix).
 * For jpeg, png, pnm and bmp, these use the non-posix GNU functions
 * fmemopen() and open_memstream().  These functions are not
 * available on other systems.  To use these functions in linux,
 * you must define HAVE_FMEMOPEN to be 1 here.
 */





/*--------------------------------------------------------------------*
 * !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*
 *                          USER CONFIGURABLE                         *
 * !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*
 *     Environ variables for image I/O without external libraries     *
 *--------------------------------------------------------------------*/
/*
 *  Leptonica supplies I/O support without using external libraries for:
 *     * image read/write for bmp, pnm
 *     * header read for jp2k
 *     * image wrapping write for pdf and ps.
 *  Setting any of these to 0 causes non-functioning stubs to be linked.
 */







/*--------------------------------------------------------------------*
 *                          Built-in types                            *
 *--------------------------------------------------------------------*/
typedef signed char l_int8;
typedef unsigned char l_uint8;
typedef short l_int16;
typedef unsigned short l_uint16;
typedef int l_int32;
typedef unsigned int l_uint32;
typedef float l_float32;
typedef double l_float64;




typedef long long l_int64;
typedef unsigned long long l_uint64;



/*------------------------------------------------------------------------*
 *                            Standard macros                             *
 *------------------------------------------------------------------------*/
# 201 "/usr/local/Cellar/leptonica/1.71_1/include/leptonica/environ.h"
/*--------------------------------------------------------------------*
 *            Environment variables for endian dependence             *
 *--------------------------------------------------------------------*/
/*
 *  To control conditional compilation, one of two variables
 *
 *       L_LITTLE_ENDIAN  (e.g., for Intel X86)
 *       L_BIG_ENDIAN     (e.g., for Sun SPARC, Mac Power PC)
 *
 *  is defined when the GCC compiler is invoked.
 *  All code should compile properly for both hardware architectures.
 */


/*------------------------------------------------------------------------*
 *                    Simple search state variables                       *
 *------------------------------------------------------------------------*/
enum {
    L_NOT_FOUND = 0,
    L_FOUND = 1
};


/*------------------------------------------------------------------------*
 *                     Path separator conversion                          *
 *------------------------------------------------------------------------*/
enum {
    UNIX_PATH_SEPCHAR = 0,
    WIN_PATH_SEPCHAR = 1
};


/*------------------------------------------------------------------------*
 *                      Standard memory allocation                        *
 *                                                                        *
 *  These specify the memory management functions that are used           *
 *  on all heap data except for Pix.  Memory management for Pix           *
 *  also defaults to malloc and free.  See pix1.c for details.            *
 *------------------------------------------------------------------------*/






/*------------------------------------------------------------------------*
 *         Control printing of error, warning, and info messages          *
 *                                                                        *
 *  To omit all messages to stderr, simply define NO_CONSOLE_IO on the    *
 *  command line.  For finer grained control, we have a mechanism         *
 *  based on the message severity level.  The following assumes that      *
 *  NO_CONSOLE_IO is not defined.                                         *
 *                                                                        *
 *  Messages are printed if the message severity is greater than or equal *
 *  to the current severity threshold.  The current severity threshold    *
 *  is the greater of the compile-time severity, which is the minimum     *
 *  severity that can be reported, and the run-time severity, which is    *
 *  the severity threshold at the moment.                                 *
 *                                                                        *
 *  The compile-time threshold determines which messages are compiled     *
 *  into the library for potential printing.  Messages below the          *
 *  compile-time threshold are omitted and can never be printed.  The     *
 *  default compile-time threshold is L_SEVERITY_INFO, but this may be    *
 *  overridden by defining MINIMUM_SEVERITY to the desired enumeration    *
 *  identifier on the compiler command line.  Defining NO_CONSOLE_IO on   *
 *  the command line is the same as setting MINIMUM_SEVERITY to           *
 *  L_SEVERITY_NONE.                                                      *
 *                                                                        *
 *  The run-time threshold determines which messages are printed during   *
 *  library execution.  It defaults to the compile-time threshold but     *
 *  may be changed either statically by defining DEFAULT_SEVERITY to      *
 *  the desired enumeration identifier on the compiler command line, or   *
 *  dynamically by calling setMsgSeverity() to specify a new threshold.   *
 *  The run-time threshold may also be set from the value of the          *
 *  environment variable LEPT_MSG_SEVERITY by calling setMsgSeverity()   *
 *  and specifying L_SEVERITY_EXTERNAL.                                   *
 *                                                                        *
 *  In effect, the compile-time threshold setting says, "Generate code    *
 *  to permit messages of equal or greater severity than this to be       *
 *  printed, if desired," whereas the run-time threshold setting says,    *
 *  "Print messages that have an equal or greater severity than this."    *
 *------------------------------------------------------------------------*/
enum {
    L_SEVERITY_EXTERNAL = 0, /* Get the severity from the environment   */
    L_SEVERITY_ALL = 1, /* Lowest severity: print all messages     */
    L_SEVERITY_DEBUG = 2, /* Print debugging and higher messages     */
    L_SEVERITY_INFO = 3, /* Print informational and higher messages */
    L_SEVERITY_WARNING = 4, /* Print warning and higher messages       */
    L_SEVERITY_ERROR = 5, /* Print error and higher messages         */
    L_SEVERITY_NONE = 6 /* Highest severity: print no messages     */
};

/*  No message less than the compile-time threshold will ever be
 *  reported, regardless of the current run-time threshold.  This allows
 *  selection of the set of messages to include in the library.  For
 *  example, setting the threshold to L_SEVERITY_WARNING eliminates all
 *  informational messages from the library.  With that setting, both
 *  warning and error messages would be printed unless setMsgSeverity()
 *  was called, or DEFAULT_SEVERITY was redefined, to set the run-time
 *  severity to L_SEVERITY_ERROR.  In that case, only error messages
 *  would be printed.
 *
 *  This mechanism makes the library smaller and faster, by eliminating
 *  undesired message reporting and the associated run-time overhead for
 *  message threshold checking, because code for messages whose severity
 *  is lower than MINIMUM_SEVERITY won't be generated.
 *
 *  A production library might typically permit WARNING and higher
 *  messages to be generated, and a development library might permit
 *  DEBUG and higher.  The actual messages printed (as opposed to
 *  generated) would depend on the current run-time severity threshold.
 */
# 332 "/usr/local/Cellar/leptonica/1.71_1/include/leptonica/environ.h"
/*  The run-time message severity threshold is defined in utils.c.  */
         extern l_int32 LeptMsgSeverity;

/*
 *  Usage
 *  =====
 *  Messages are of two types.
 *
 *  (1) The messages
 *      ERROR_INT(a,b,c)       : returns l_int32
 *      ERROR_FLOAT(a,b,c)     : returns l_float32
 *      ERROR_PTR(a,b,c)       : returns void*
 *  are used to return from functions and take a fixed set of parameters:
 *      a : <message string>
 *      b : procName
 *      c : <return value from function>
 *  where procName is the name of the local variable naming the function.
 *
 *  (2) The purely informational L_* messages
 *      L_ERROR(a,...)
 *      L_WARNING(a,...)
 *      L_INFO(a,...)
 *  do not take a return value, but they take at least two parameters:
 *      a  :  <message string> with optional format conversions
 *      v1 : procName    (this must be included as the first vararg)
 *      v2, ... :  optional varargs to match format converters in the message
 *
 *  To return an error from a function that returns void, use:
 *      L_ERROR(<message string>, procName, [...])
 *      return;
 *
 *  Implementation details
 *  ======================
 *  Messages are defined with the IF_SEV macro.  The first parameter is
 *  the message severity, the second is the function to call if the
 *  message is to be printed, and the third is the return value if the
 *  message is to be suppressed.  For example, we might have an
 *  informational message defined as:
 *
 *    IF_SEV(L_SEVERITY_INFO, fprintf(.......), 0)
 *
 *  The macro expands into a conditional.  Because the first comparison
 *  is between two constants, an optimizing compiler will remove either
 *  the comparison (if it's true) or the entire macro expansion (if it
 *  is false).  This means that there is no run-time overhead for
 *  messages whose severity falls below the minimum specified at compile
 *  time, and for others the overhead is one (not two) comparisons.
 *
 *  The L_nnn() macros below do not return a value, but because the
 *  conditional operator requires one for the false condition, we
 *  specify a void expression.
 */
# 442 "/usr/local/Cellar/leptonica/1.71_1/include/leptonica/environ.h"
/*------------------------------------------------------------------------*
 *                        snprintf() renamed in MSVC                      *
 *------------------------------------------------------------------------*/
# 37 "/usr/local/Cellar/leptonica/1.71_1/include/leptonica/alltypes.h" 2

    /* Generic and non-image-specific containers */

# 1 "/usr/local/Cellar/leptonica/1.71_1/include/leptonica/array.h" 1
/*====================================================================*
 -  Copyright (C) 2001 Leptonica.  All rights reserved.
 -
 -  Redistribution and use in source and binary forms, with or without
 -  modification, are permitted provided that the following conditions
 -  are met:
 -  1. Redistributions of source code must retain the above copyright
 -     notice, this list of conditions and the following disclaimer.
 -  2. Redistributions in binary form must reproduce the above
 -     copyright notice, this list of conditions and the following
 -     disclaimer in the documentation and/or other materials
 -     provided with the distribution.
 -
 -  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 -  ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 -  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 -  A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL ANY
 -  CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 -  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 -  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 -  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 -  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 -  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 -  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *====================================================================*/




/*
 *  Contains the following structs:
 *      struct Numa
 *      struct Numaa
 *      struct Numa2d
 *      struct NumaHash
 *      struct L_Dna
 *      struct L_Dnaa
 *      struct Sarray
 *      struct L_Bytea
 *
 *  Contains definitions for:
 *      Numa interpolation flags
 *      Numa and FPix border flags
 *      Numa data type conversion to string
 */


/*------------------------------------------------------------------------*
 *                             Array Structs                              *
 *------------------------------------------------------------------------*/



    /* Number array: an array of floats */
struct Numa
{
    l_int32 nalloc; /* size of allocated number array      */
    l_int32 n; /* number of numbers saved             */
    l_int32 refcount; /* reference count (1 if no clones)    */
    l_float32 startx; /* x value assigned to array[0]        */
    l_float32 delx; /* change in x value as i --> i + 1    */
    l_float32 *array; /* number array                        */
};
typedef struct Numa NUMA;


    /* Array of number arrays */
struct Numaa
{
    l_int32 nalloc; /* size of allocated ptr array          */
    l_int32 n; /* number of Numa saved                 */
    struct Numa **numa; /* array of Numa                        */
};
typedef struct Numaa NUMAA;


    /* Sparse 2-dimensional array of number arrays */
struct Numa2d
{
    l_int32 nrows; /* number of rows allocated for ptr array  */
    l_int32 ncols; /* number of cols allocated for ptr array  */
    l_int32 initsize; /* initial size of each numa that is made  */
    struct Numa ***numa; /* 2D array of Numa                        */
};
typedef struct Numa2d NUMA2D;


    /* A hash table of Numas */
struct NumaHash
{
    l_int32 nbuckets;
    l_int32 initsize; /* initial size of each numa that is made  */
    struct Numa **numa;
};
typedef struct NumaHash NUMAHASH;




    /* Double number array: an array of doubles */
struct L_Dna
{
    l_int32 nalloc; /* size of allocated number array      */
    l_int32 n; /* number of numbers saved             */
    l_int32 refcount; /* reference count (1 if no clones)    */
    l_float64 startx; /* x value assigned to array[0]        */
    l_float64 delx; /* change in x value as i --> i + 1    */
    l_float64 *array; /* number array                        */
};
typedef struct L_Dna L_DNA;


    /* Array of double number arrays */
struct L_Dnaa
{
    l_int32 nalloc; /* size of allocated ptr array          */
    l_int32 n; /* number of L_Dna saved                */
    struct L_Dna **dna; /* array of L_Dna                       */
};
typedef struct L_Dnaa L_DNAA;




    /* String array: an array of C strings */
struct Sarray
{
    l_int32 nalloc; /* size of allocated ptr array         */
    l_int32 n; /* number of strings allocated         */
    l_int32 refcount; /* reference count (1 if no clones)    */
    char **array; /* string array                        */
};
typedef struct Sarray SARRAY;


    /* Byte array (analogous to C++ "string") */
struct L_Bytea
{
    size_t nalloc; /* number of bytes allocated in data array  */
    size_t size; /* number of bytes presently used           */
    l_int32 refcount; /* reference count (1 if no clones)         */
    l_uint8 *data; /* data array                               */
};
typedef struct L_Bytea L_BYTEA;


/*------------------------------------------------------------------------*
 *                              Array flags                               *
 *------------------------------------------------------------------------*/
    /* Flags for interpolation in Numa */
enum {
    L_LINEAR_INTERP = 1, /* linear     */
    L_QUADRATIC_INTERP = 2 /* quadratic  */
};

    /* Flags for added borders in Numa and Fpix */
enum {
    L_CONTINUED_BORDER = 1, /* extended with same value                  */
    L_SLOPE_BORDER = 2, /* extended with constant normal derivative  */
    L_MIRRORED_BORDER = 3 /* mirrored                                  */
};

    /* Flags for data type converted from Numa */
enum {
    L_INTEGER_VALUE = 1, /* convert to integer  */
    L_FLOAT_VALUE = 2 /* convert to float    */
};
# 40 "/usr/local/Cellar/leptonica/1.71_1/include/leptonica/alltypes.h" 2
# 1 "/usr/local/Cellar/leptonica/1.71_1/include/leptonica/bbuffer.h" 1
/*====================================================================*
 -  Copyright (C) 2001 Leptonica.  All rights reserved.
 -
 -  Redistribution and use in source and binary forms, with or without
 -  modification, are permitted provided that the following conditions
 -  are met:
 -  1. Redistributions of source code must retain the above copyright
 -     notice, this list of conditions and the following disclaimer.
 -  2. Redistributions in binary form must reproduce the above
 -     copyright notice, this list of conditions and the following
 -     disclaimer in the documentation and/or other materials
 -     provided with the distribution.
 -
 -  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 -  ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 -  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 -  A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL ANY
 -  CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 -  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 -  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 -  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 -  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 -  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 -  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *====================================================================*/




/*
 *  bbuffer.h
 *
 *      Expandable byte buffer for reading data in from memory and
 *      writing data out to other memory.
 *
 *      This implements a queue of bytes, so data read in is put
 *      on the "back" of the queue (i.e., the end of the byte array)
 *      and data written out is taken from the "front" of the queue
 *      (i.e., from an index marker "nwritten" that is initially set at
 *      the beginning of the array.)  As usual with expandable
 *      arrays, we keep the size of the allocated array and the
 *      number of bytes that have been read into the array.
 *
 *      For implementation details, see bbuffer.c.
 */

struct ByteBuffer
{
    l_int32 nalloc; /* size of allocated byte array            */
    l_int32 n; /* number of bytes read into to the array  */
    l_int32 nwritten; /* number of bytes written from the array  */
    l_uint8 *array; /* byte array                              */
};
typedef struct ByteBuffer BBUFFER;
# 41 "/usr/local/Cellar/leptonica/1.71_1/include/leptonica/alltypes.h" 2
# 1 "/usr/local/Cellar/leptonica/1.71_1/include/leptonica/heap.h" 1
/*====================================================================*
 -  Copyright (C) 2001 Leptonica.  All rights reserved.
 -
 -  Redistribution and use in source and binary forms, with or without
 -  modification, are permitted provided that the following conditions
 -  are met:
 -  1. Redistributions of source code must retain the above copyright
 -     notice, this list of conditions and the following disclaimer.
 -  2. Redistributions in binary form must reproduce the above
 -     copyright notice, this list of conditions and the following
 -     disclaimer in the documentation and/or other materials
 -     provided with the distribution.
 - 
 -  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 -  ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 -  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 -  A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL ANY
 -  CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 -  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 -  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 -  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 -  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 -  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 -  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *====================================================================*/




/*
 *  heap.h
 *
 *      Expandable priority queue configured as a heap for arbitrary void* data
 *
 *      The L_Heap is used to implement a priority queue.  The elements
 *      in the heap are ordered in either increasing or decreasing key value.
 *      The key is a float field 'keyval' that is required to be
 *      contained in the elements of the queue.
 * 
 *      The heap is a simple binary tree with the following constraints:
 *         - the key of each node is >= the keys of the two children
 *         - the tree is complete, meaning that each level (1, 2, 4, ...)
 *           is filled and the last level is filled from left to right
 *
 *      The tree structure is implicit in the queue array, with the
 *      array elements numbered as a breadth-first search of the tree
 *      from left to right.  It is thus guaranteed that the largest
 *      (or smallest) key belongs to the first element in the array.
 *
 *      Heap sort is used to sort the array.  Once an array has been
 *      sorted as a heap, it is convenient to use it as a priority queue,
 *      because the min (or max) elements are always at the root of
 *      the tree (element 0), and once removed, the heap can be
 *      resorted in not more than log[n] steps, where n is the number
 *      of elements on the heap.  Likewise, if an arbitrary element is
 *      added to the end of the array A, the sorted heap can be restored
 *      in not more than log[n] steps.
 *
 *      A L_Heap differs from a L_Queue in that the elements in the former
 *      are sorted by a key.  Internally, the array is maintained
 *      as a queue, with a pointer to the end of the array.  The
 *      head of the array always remains at array[0].  The array is
 *      maintained (sorted) as a heap.  When an item is removed from
 *      the head, the last item takes its place (thus reducing the
 *      array length by 1), and this is followed by array element
 *      swaps to restore the heap property.   When an item is added,
 *      it goes at the end of the array, and is swapped up to restore
 *      the heap.  If the ptr array is full, adding another item causes
 *      the ptr array size to double.
 *      
 *      For further implementation details, see heap.c.
 */

struct L_Heap
{
    l_int32 nalloc; /* size of allocated ptr array                 */
    l_int32 n; /* number of elements stored in the heap       */
    void **array; /* ptr array                                   */
    l_int32 direction; /* L_SORT_INCREASING or L_SORT_DECREASING      */
};
typedef struct L_Heap L_HEAP;
# 42 "/usr/local/Cellar/leptonica/1.71_1/include/leptonica/alltypes.h" 2
# 1 "/usr/local/Cellar/leptonica/1.71_1/include/leptonica/list.h" 1
/*====================================================================*
 -  Copyright (C) 2001 Leptonica.  All rights reserved.
 -
 -  Redistribution and use in source and binary forms, with or without
 -  modification, are permitted provided that the following conditions
 -  are met:
 -  1. Redistributions of source code must retain the above copyright
 -     notice, this list of conditions and the following disclaimer.
 -  2. Redistributions in binary form must reproduce the above
 -     copyright notice, this list of conditions and the following
 -     disclaimer in the documentation and/or other materials
 -     provided with the distribution.
 - 
 -  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 -  ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 -  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 -  A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL ANY
 -  CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 -  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 -  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 -  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 -  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 -  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 -  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *====================================================================*/





/*
 *   list.h
 *
 *       Cell for double-linked lists
 *
 *       This allows composition of a list of cells with 
 *           prev, next and data pointers.  Generic data
 *           structures hang on the list cell data pointers.
 *
 *       The list is not circular because that would add much
 *           complexity in traversing the list under general
 *           conditions where list cells can be added and removed.
 *           The only disadvantage of not having the head point to
 *           the last cell is that the list must be traversed to
 *           find its tail.  However, this traversal is fast, and
 *           the listRemoveFromTail() function updates the tail
 *           so there is no searching overhead with repeated use.
 *
 *       The list macros are used to run through a list, and their
 *       use is encouraged.  They are invoked, e.g., as
 *
 *             DLLIST  *head, *elem;
 *             ...
 *             L_BEGIN_LIST_FORWARD(head, elem)
 *                 <do something with elem and/or elem->data >
 *             L_END_LIST
 *
 */

struct DoubleLinkedList
{
    struct DoubleLinkedList *prev;
    struct DoubleLinkedList *next;
    void *data;
};
typedef struct DoubleLinkedList DLLIST;


    /*  Simple list traverse macros */
# 43 "/usr/local/Cellar/leptonica/1.71_1/include/leptonica/alltypes.h" 2
# 1 "/usr/local/Cellar/leptonica/1.71_1/include/leptonica/ptra.h" 1
/*====================================================================*
 -  Copyright (C) 2001 Leptonica.  All rights reserved.
 -
 -  Redistribution and use in source and binary forms, with or without
 -  modification, are permitted provided that the following conditions
 -  are met:
 -  1. Redistributions of source code must retain the above copyright
 -     notice, this list of conditions and the following disclaimer.
 -  2. Redistributions in binary form must reproduce the above
 -     copyright notice, this list of conditions and the following
 -     disclaimer in the documentation and/or other materials
 -     provided with the distribution.
 - 
 -  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 -  ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 -  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 -  A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL ANY
 -  CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 -  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 -  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 -  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 -  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 -  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 -  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *====================================================================*/




/*
 *  Contains the following structs:
 *      struct L_Ptra
 *      struct L_Ptraa
 *
 *  Contains definitions for:
 *      L_Ptra compaction flags for removal
 *      L_Ptra shifting flags for insert
 *      L_Ptraa accessor flags
 */


/*------------------------------------------------------------------------* 
 *                     Generic Ptr Array Structs                          *
 *------------------------------------------------------------------------*/

    /* Generic pointer array */
struct L_Ptra
{
    l_int32 nalloc; /* size of allocated ptr array         */
    l_int32 imax; /* greatest valid index                */
    l_int32 nactual; /* actual number of stored elements    */
    void **array; /* ptr array                           */
};
typedef struct L_Ptra L_PTRA;


    /* Array of generic pointer arrays */
struct L_Ptraa
{
    l_int32 nalloc; /* size of allocated ptr array         */
    struct L_Ptra **ptra; /* array of ptra                       */
};
typedef struct L_Ptraa L_PTRAA;



/*------------------------------------------------------------------------* 
 *                              Array flags                               *
 *------------------------------------------------------------------------*/

    /* Flags for removal from L_Ptra */
enum {
    L_NO_COMPACTION = 1, /* null the pointer only  */
    L_COMPACTION = 2 /* compact the array      */
};

    /* Flags for insertion into L_Ptra */
enum {
    L_AUTO_DOWNSHIFT = 0, /* choose based on number of holes        */
    L_MIN_DOWNSHIFT = 1, /* downshifts min # of ptrs below insert  */
    L_FULL_DOWNSHIFT = 2 /* downshifts all ptrs below insert       */
};

    /* Accessor flags for L_Ptraa */
enum {
    L_HANDLE_ONLY = 0, /* ptr to L_Ptra; caller can inspect only    */
    L_REMOVE = 1 /* caller owns; destroy or save in L_Ptraa   */
};
# 44 "/usr/local/Cellar/leptonica/1.71_1/include/leptonica/alltypes.h" 2
# 1 "/usr/local/Cellar/leptonica/1.71_1/include/leptonica/queue.h" 1
/*====================================================================*
 -  Copyright (C) 2001 Leptonica.  All rights reserved.
 -
 -  Redistribution and use in source and binary forms, with or without
 -  modification, are permitted provided that the following conditions
 -  are met:
 -  1. Redistributions of source code must retain the above copyright
 -     notice, this list of conditions and the following disclaimer.
 -  2. Redistributions in binary form must reproduce the above
 -     copyright notice, this list of conditions and the following
 -     disclaimer in the documentation and/or other materials
 -     provided with the distribution.
 - 
 -  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 -  ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 -  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 -  A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL ANY
 -  CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 -  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 -  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 -  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 -  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 -  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 -  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *====================================================================*/




/*
 *  queue.h
 *
 *      Expandable pointer queue for arbitrary void* data.
 *
 *      The L_Queue is a fifo that implements a queue of void* pointers.
 *      It can be used to hold a queue of any type of struct.
 *
 *      Internally, it maintains two counters:
 *          nhead:  location of head (in ptrs) from the beginning
 *                  of the array.
 *          nelem:  number of ptr elements stored in the queue.
 *
 *      The element at the head of the queue, which is the next to
 *      be removed, is array[nhead].  The location at the tail of the
 *      queue to which the next element will be added is
 *      array[nhead + nelem].
 *               
 *      As items are added to the queue, nelem increases.
 *      As items are removed, nhead increases and nelem decreases.
 *      Any time the tail reaches the end of the allocated array,
 *      all the pointers are shifted to the left, so that the head
 *      is at the beginning of the array.
 *      If the array becomes more than 3/4 full, it doubles in size.
 *
 *      The auxiliary stack can be used in a wrapper for re-using
 *      items popped from the queue.  It is not made by default.
 *
 *      For further implementation details, see queue.c.
 */

struct L_Queue
{
    l_int32 nalloc; /* size of allocated ptr array            */
    l_int32 nhead; /* location of head (in ptrs) from the    */
                                 /* beginning of the array                 */
    l_int32 nelem; /* number of elements stored in the queue */
    void **array; /* ptr array                              */
    struct L_Stack *stack; /* auxiliary stack                        */

};
typedef struct L_Queue L_QUEUE;
# 45 "/usr/local/Cellar/leptonica/1.71_1/include/leptonica/alltypes.h" 2
# 1 "/usr/local/Cellar/leptonica/1.71_1/include/leptonica/stack.h" 1
/*====================================================================*
 -  Copyright (C) 2001 Leptonica.  All rights reserved.
 -
 -  Redistribution and use in source and binary forms, with or without
 -  modification, are permitted provided that the following conditions
 -  are met:
 -  1. Redistributions of source code must retain the above copyright
 -     notice, this list of conditions and the following disclaimer.
 -  2. Redistributions in binary form must reproduce the above
 -     copyright notice, this list of conditions and the following
 -     disclaimer in the documentation and/or other materials
 -     provided with the distribution.
 - 
 -  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 -  ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 -  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 -  A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL ANY
 -  CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 -  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 -  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 -  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 -  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 -  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 -  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *====================================================================*/




/*
 *  stack.h
 *
 *       Expandable pointer stack for arbitrary void* data.
 *
 *       The L_Stack is an array of void * ptrs, onto which arbitrary
 *       objects can be stored.  At any time, the number of
 *       stored objects is stack->n.  The object at the bottom
 *       of the stack is at array[0]; the object at the top of
 *       the stack is at array[n-1].  New objects are added
 *       to the top of the stack, at the first available location,
 *       which is array[n].  Objects are removed from the top of the
 *       stack.  When an attempt is made to remove an object from an
 *       empty stack, the result is null.   When the stack becomes
 *       filled, so that n = nalloc, the size is doubled.
 *
 *       The auxiliary stack can be used to store and remove
 *       objects for re-use.  It must be created by a separate
 *       call to pstackCreate().  [Just imagine the chaos if
 *       pstackCreate() created the auxiliary stack!]   
 *       pstackDestroy() checks for the auxiliary stack and removes it.
 */


    /* Note that array[n] is the first null ptr in the array */
struct L_Stack
{
    l_int32 nalloc; /* size of ptr array              */
    l_int32 n; /* number of stored elements      */
    void **array; /* ptr array                      */
    struct L_Stack *auxstack; /* auxiliary stack                */
};
typedef struct L_Stack L_STACK;
# 46 "/usr/local/Cellar/leptonica/1.71_1/include/leptonica/alltypes.h" 2

    /* Imaging */

# 1 "/usr/local/Cellar/leptonica/1.71_1/include/leptonica/arrayaccess.h" 1
/*====================================================================*
 -  Copyright (C) 2001 Leptonica.  All rights reserved.
 -
 -  Redistribution and use in source and binary forms, with or without
 -  modification, are permitted provided that the following conditions
 -  are met:
 -  1. Redistributions of source code must retain the above copyright
 -     notice, this list of conditions and the following disclaimer.
 -  2. Redistributions in binary form must reproduce the above
 -     copyright notice, this list of conditions and the following
 -     disclaimer in the documentation and/or other materials
 -     provided with the distribution.
 - 
 -  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 -  ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 -  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 -  A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL ANY
 -  CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 -  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 -  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 -  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 -  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 -  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 -  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *====================================================================*/




/*
 *  arrayaccess.h
 *
 *  1, 2, 4, 8, 16 and 32 bit data access within an array of 32-bit words
 *
 *  This is used primarily to access 1, 2, 4, 8, 16 and 32 bit pixels
 *  in a line of image data, represented as an array of 32-bit words.
 *
 *     pdata:  pointer to first 32-bit word in the array
 *     n:      index of the pixel in the array
 *
 *  Function calls for these accessors are defined in arrayaccess.c.
 *
 *  However, for efficiency we use the inline macros for all accesses.
 *  Even though the 2 and 4 bit set* accessors are more complicated,
 *  they are about 10% faster than the function calls.
 *
 *  The 32 bit access is just a cast and ptr arithmetic.  We include
 *  it so that the input ptr can be void*.
 *
 *  At the end of this file is code for invoking the function calls
 *  instead of inlining.
 *
 *  The macro SET_DATA_BIT_VAL(pdata, n, val) is a bit slower than
 *      if (val == 0)
 *          CLEAR_DATA_BIT(pdata, n);
 *      else
 *          SET_DATA_BIT(pdata, n);
 */


    /* Use the inline accessors (except with _MSC_VER), because they
     * are faster.  */





    /*--------------------------------------------------*
     *                     1 bit access                 *
     *--------------------------------------------------*/
# 88 "/usr/local/Cellar/leptonica/1.71_1/include/leptonica/arrayaccess.h"
    /*--------------------------------------------------*
     *                     2 bit access                 *
     *--------------------------------------------------*/
# 105 "/usr/local/Cellar/leptonica/1.71_1/include/leptonica/arrayaccess.h"
    /*--------------------------------------------------*
     *                     4 bit access                 *
     *--------------------------------------------------*/
# 122 "/usr/local/Cellar/leptonica/1.71_1/include/leptonica/arrayaccess.h"
    /*--------------------------------------------------*
     *                     8 bit access                 *
     *--------------------------------------------------*/
# 142 "/usr/local/Cellar/leptonica/1.71_1/include/leptonica/arrayaccess.h"
    /*--------------------------------------------------*
     *                    16 bit access                 *
     *--------------------------------------------------*/
# 162 "/usr/local/Cellar/leptonica/1.71_1/include/leptonica/arrayaccess.h"
    /*--------------------------------------------------*
     *                    32 bit access                 *
     *--------------------------------------------------*/
# 177 "/usr/local/Cellar/leptonica/1.71_1/include/leptonica/arrayaccess.h"
    /*--------------------------------------------------*
     *  Slower, using function calls for all accessors  *
     *--------------------------------------------------*/
# 49 "/usr/local/Cellar/leptonica/1.71_1/include/leptonica/alltypes.h" 2
# 1 "/usr/local/Cellar/leptonica/1.71_1/include/leptonica/bmf.h" 1
/*====================================================================*
 -  Copyright (C) 2001 Leptonica.  All rights reserved.
 -
 -  Redistribution and use in source and binary forms, with or without
 -  modification, are permitted provided that the following conditions
 -  are met:
 -  1. Redistributions of source code must retain the above copyright
 -     notice, this list of conditions and the following disclaimer.
 -  2. Redistributions in binary form must reproduce the above
 -     copyright notice, this list of conditions and the following
 -     disclaimer in the documentation and/or other materials
 -     provided with the distribution.
 -
 -  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 -  ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 -  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 -  A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL ANY
 -  CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 -  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 -  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 -  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 -  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 -  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 -  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *====================================================================*/




/*
 *  bmf.h
 *
 *     Simple data structure to hold bitmap fonts and related data
 */

    /* Constants for deciding when text block is divided into paragraphs */
enum {
    SPLIT_ON_LEADING_WHITE = 1, /* tab or space at beginning of line   */
    SPLIT_ON_BLANK_LINE = 2, /* newline with optional white space   */
    SPLIT_ON_BOTH = 3 /* leading white space or newline      */
};


struct L_Bmf
{
    struct Pixa *pixa; /* pixa of bitmaps for 93 characters        */
    l_int32 size; /* font size (in points at 300 ppi)         */
    char *directory; /* directory containing font bitmaps        */
    l_int32 baseline1; /* baseline offset for ascii 33 - 57        */
    l_int32 baseline2; /* baseline offset for ascii 58 - 91        */
    l_int32 baseline3; /* baseline offset for ascii 93 - 126       */
    l_int32 lineheight; /* max height of line of chars              */
    l_int32 kernwidth; /* pixel dist between char bitmaps          */
    l_int32 spacewidth; /* pixel dist between word bitmaps          */
    l_int32 vertlinesep; /* extra vertical space between text lines  */
    l_int32 *fonttab; /* table mapping ascii --> font index       */
    l_int32 *baselinetab; /* table mapping ascii --> baseline offset  */
    l_int32 *widthtab; /* table mapping ascii --> char width       */
};
typedef struct L_Bmf L_BMF;
# 50 "/usr/local/Cellar/leptonica/1.71_1/include/leptonica/alltypes.h" 2
# 1 "/usr/local/Cellar/leptonica/1.71_1/include/leptonica/ccbord.h" 1
/*====================================================================*
 -  Copyright (C) 2001 Leptonica.  All rights reserved.
 -
 -  Redistribution and use in source and binary forms, with or without
 -  modification, are permitted provided that the following conditions
 -  are met:
 -  1. Redistributions of source code must retain the above copyright
 -     notice, this list of conditions and the following disclaimer.
 -  2. Redistributions in binary form must reproduce the above
 -     copyright notice, this list of conditions and the following
 -     disclaimer in the documentation and/or other materials
 -     provided with the distribution.
 -
 -  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 -  ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 -  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 -  A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL ANY
 -  CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 -  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 -  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 -  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 -  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 -  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 -  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *====================================================================*/




/*
 *  ccbord.h
 *
 *           CCBord:   represents a single connected component
 *           CCBorda:  an array of CCBord
 */

    /* Use in ccbaStepChainsToPixCoords() */
enum {
      CCB_LOCAL_COORDS = 1,
      CCB_GLOBAL_COORDS = 2
};

    /* Use in ccbaGenerateSPGlobalLocs() */
enum {
      CCB_SAVE_ALL_PTS = 1,
      CCB_SAVE_TURNING_PTS = 2
};


    /* CCBord contains:
     *
     *    (1) a minimally-clipped bitmap of the component (pix),
     *    (2) a boxa consisting of:
     *          for the primary component:
     *                (xul, yul) pixel location in global coords
     *                (w, h) of the bitmap
     *          for the hole components:
     *                (x, y) in relative coordinates in primary component
     *                (w, h) of the hole border (which is 2 pixels
     *                       larger in each direction than the hole itself)
     *    (3) a pta ('start') of the initial border pixel location for each
     *        closed curve, all in relative coordinates of the primary
     *        component.  This is given for the primary component,
     *        followed by the hole components, if any.
     *    (4) a refcount of the ccbord; used internally when a ccbord
     *        is accessed from a ccborda (array of ccbord)
     *    (5) a ptaa for the chain code for the border in relative
     *        coordinates, where the first pta is the exterior border
     *        and all other pta are for interior borders (holes)
     *    (6) a ptaa for the global pixel loc rendition of the border,
     *        where the first pta is the exterior border and all other
     *        pta are for interior borders (holes).
     *        This is derived from the local or step chain code.
     *    (7) a numaa for the chain code for the border as orientation
     *        directions between successive border pixels, where
     *        the first numa is the exterior border and all other
     *        numa are for interior borders (holes).  This is derived
     *        from the local chain code.  The 8 directions are 0 - 7.
     *    (8) a pta for a single chain for each c.c., comprised of outer
     *        and hole borders, plus cut paths between them, all in
     *        local coords.
     *    (9) a pta for a single chain for each c.c., comprised of outer
     *        and hole borders, plus cut paths between them, all in
     *        global coords.
     */
struct CCBord
{
    struct Pix *pix; /* component bitmap (min size)      */
    struct Boxa *boxa; /* regions of each closed curve     */
    struct Pta *start; /* initial border pixel locations   */
    l_int32 refcount; /* number of handles; start at 1    */
    struct Ptaa *local; /* ptaa of chain pixels (local)     */
    struct Ptaa *global; /* ptaa of chain pixels (global)    */
    struct Numaa *step; /* numaa of chain code (step dir)   */
    struct Pta *splocal; /* pta of single chain (local)      */
    struct Pta *spglobal; /* pta of single chain (global)     */
};
typedef struct CCBord CCBORD;


struct CCBorda
{
    struct Pix *pix; /* input pix (may be null)          */
    l_int32 w; /* width of pix                     */
    l_int32 h; /* height of pix                    */
    l_int32 n; /* number of ccbord in ptr array    */
    l_int32 nalloc; /* number of ccbord ptrs allocated  */
    struct CCBord **ccb; /* ccb ptr array                    */
};
typedef struct CCBorda CCBORDA;
# 51 "/usr/local/Cellar/leptonica/1.71_1/include/leptonica/alltypes.h" 2
# 1 "/usr/local/Cellar/leptonica/1.71_1/include/leptonica/dewarp.h" 1
/*====================================================================*
 -  Copyright (C) 2001 Leptonica.  All rights reserved.
 -
 -  Redistribution and use in source and binary forms, with or without
 -  modification, are permitted provided that the following conditions
 -  are met:
 -  1. Redistributions of source code must retain the above copyright
 -     notice, this list of conditions and the following disclaimer.
 -  2. Redistributions in binary form must reproduce the above
 -     copyright notice, this list of conditions and the following
 -     disclaimer in the documentation and/or other materials
 -     provided with the distribution.
 -
 -  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 -  ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 -  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 -  A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL ANY
 -  CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 -  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 -  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 -  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 -  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 -  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 -  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *====================================================================*/




/*
 *  dewarp.h
 *
 *     Data structure to hold arrays and results for generating
 *     horizontal and vertical disparity arrays based on textlines.
 *     Each disparity array is two-dimensional.  The vertical disparity
 *     array gives a vertical displacement, relative to the lowest point
 *     in the textlines.  The horizontal disparty array gives a horizontal
 *     displacement, relative to the minimum values (for even pages)
 *     or maximum values (for odd pages) of the left and right ends of
 *     full textlines.  Horizontal alignment always involves translations
 *     away from the book gutter.
 *
 *     We have intentionally separated the process of building models
 *     from the rendering process that uses the models.  For any page,
 *     the building operation either creates an actual model (that is,
 *     a model with at least the vertical disparity being computed, and
 *     for which the 'success' flag is set) or fails to create a model.
 *     However, at rendering time, a page can have one of two different
 *     types of models.
 *     (1) A valid model is an actual model that meets the rendering
 *         constraints, which are limits on model curvature parameters.
 *         See dewarpaTestForValidModel() for details.
 *         Valid models are identified by dewarpaInsertRefModels(),
 *         which sets the 'vvalid' and 'hvalid' fields.  Only valid
 *         models are used for rendering.
 *     (2) A reference model is used by a page that doesn't have
 *         a valid model, but has a nearby valid model of the same
 *         parity (even/odd page) that it can use.  The range in pages
 *         to search for a valid model is given by the 'maxdist' field.
 *
 *     If a valid vertical disparity model (VDM) is not available,
 *     just use the input image.  Otherwise, assuming the VDM is available:
 *       (a) with useboth == 0, we use only the VDM.
 *       (b) with useboth == 1, we require using the VDM and, if a valid
 *           horizontal disparity model (HDM) is available, we also use it.
 *
 *     The 'maxdist' parameter is input when the dewarpa is created.
 *     The other rendering parameters have default values given in dewarp.c.
 *     All parameters used by rendering can be set (or reset) using accessors.
 *
 *     After dewarping, use of the VDM will cause all points on each
 *     altered curve to have a y-value equal to the minimum.  Use of
 *     the HDA will cause the left and right edges of the textlines
 *     to be vertically aligned if they had been typeset flush-left
 *     and flush-right, respectively.
 *
 *     The sampled disparity arrays are expanded to full resolution,
 *     using linear interpolation, and this is further expanded
 *     by slope continuation to the right and below if the image
 *     is larger than the full resolution disparity arrays.  Then
 *     the disparity correction can be applied to the input image.
 *     If the input pix are 2x reduced, the expansion from sampled
 *     to full res uses the product of (sampling) * (redfactor).
 *
 *     The most accurate results are produced at full resolution, and
 *     this is generally recommended.
 */

    /* Note on versioning of the serialization of this data structure:
     * The dewarping utility and the stored data can be expected to change.
     * In most situations, the serialized version is ephemeral -- it is
     * not needed after being used.  No functions will be provided to
     * convert between different versions. */


struct L_Dewarpa
{
    l_int32 nalloc; /* size of dewarp ptr array            */
    l_int32 maxpage; /* maximum page number in array        */
    struct L_Dewarp **dewarp; /* array of ptrs to page dewarp        */
    struct L_Dewarp **dewarpcache; /* array of ptrs to cached dewarps     */
    struct Numa *namodels; /* list of page numbers for pages      */
                                      /* with page models                    */
    struct Numa *napages; /* list of page numbers with either    */
                                      /* page models or ref page models      */
    l_int32 redfactor; /* reduction factor of input: 1 or 2   */
    l_int32 sampling; /* disparity arrays sampling factor    */
    l_int32 minlines; /* min number of long lines required   */
    l_int32 maxdist; /* max distance for getting ref pages  */
    l_int32 max_linecurv; /* maximum abs line curvature,         */
                                      /* in micro-units                      */
    l_int32 min_diff_linecurv; /* minimum abs diff line curvature */
                                      /* in micro-units                      */
    l_int32 max_diff_linecurv; /* maximum abs diff line curvature */
                                      /* in micro-units                      */
    l_int32 max_edgeslope; /* maximum abs left or right edge      */
                                      /* slope, in milli-units               */
    l_int32 max_edgecurv; /* maximum abs left or right edge      */
                                      /* curvature, in micro-units           */
    l_int32 max_diff_edgecurv; /* maximum abs diff left-right     */
                                      /* edge curvature, in micro-units      */
    l_int32 useboth; /* use both disparity arrays if        */
                                      /* available; just vertical otherwise  */
    l_int32 modelsready; /* invalid models have been removed    */
                                      /* and refs built against valid set    */
};
typedef struct L_Dewarpa L_DEWARPA;


struct L_Dewarp
{
    struct L_Dewarpa *dewa; /* ptr to parent (not owned)            */
    struct Pix *pixs; /* source pix, 1 bpp                    */
    struct FPix *sampvdispar; /* sampled vert disparity array         */
    struct FPix *samphdispar; /* sampled horiz disparity array        */
    struct FPix *fullvdispar; /* full vert disparity array            */
    struct FPix *fullhdispar; /* full horiz disparity array           */
    struct Numa *namidys; /* sorted y val of midpoint each line   */
    struct Numa *nacurves; /* sorted curvature of each line        */
    l_int32 w; /* width of source image                */
    l_int32 h; /* height of source image               */
    l_int32 pageno; /* page number; important for reuse     */
    l_int32 sampling; /* sampling factor of disparity arrays  */
    l_int32 redfactor; /* reduction factor of pixs: 1 or 2     */
    l_int32 minlines; /* min number of long lines required    */
    l_int32 nlines; /* number of long lines found           */
    l_int32 mincurv; /* min line curvature in micro-units    */
    l_int32 maxcurv; /* max line curvature in micro-units    */
    l_int32 leftslope; /* left edge slope in milli-units       */
    l_int32 rightslope; /* right edge slope in milli-units      */
    l_int32 leftcurv; /* left edge curvature in micro-units   */
    l_int32 rightcurv; /* right edge curvature in micro-units  */
    l_int32 nx; /* number of sampling pts in x-dir      */
    l_int32 ny; /* number of sampling pts in y-dir      */
    l_int32 hasref; /* 0 if normal; 1 if has a refpage      */
    l_int32 refpage; /* page with disparity model to use     */
    l_int32 vsuccess; /* sets to 1 if vert disparity builds   */
    l_int32 hsuccess; /* sets to 1 if horiz disparity builds  */
    l_int32 vvalid; /* sets to 1 if valid vert disparity    */
    l_int32 hvalid; /* sets to 1 if valid horiz disparity   */
    l_int32 debug; /* sets to 1 if debug output requested  */
};
typedef struct L_Dewarp L_DEWARP;
# 52 "/usr/local/Cellar/leptonica/1.71_1/include/leptonica/alltypes.h" 2
# 1 "/usr/local/Cellar/leptonica/1.71_1/include/leptonica/gplot.h" 1
/*====================================================================*
 -  Copyright (C) 2001 Leptonica.  All rights reserved.
 -
 -  Redistribution and use in source and binary forms, with or without
 -  modification, are permitted provided that the following conditions
 -  are met:
 -  1. Redistributions of source code must retain the above copyright
 -     notice, this list of conditions and the following disclaimer.
 -  2. Redistributions in binary form must reproduce the above
 -     copyright notice, this list of conditions and the following
 -     disclaimer in the documentation and/or other materials
 -     provided with the distribution.
 - 
 -  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 -  ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 -  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 -  A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL ANY
 -  CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 -  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 -  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 -  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 -  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 -  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 -  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *====================================================================*/




/*
 *   gplot.h
 *
 *       Data structures and parameters for generating gnuplot files
 */




enum GPLOT_STYLE {
    GPLOT_LINES = 0,
    GPLOT_POINTS = 1,
    GPLOT_IMPULSES = 2,
    GPLOT_LINESPOINTS = 3,
    GPLOT_DOTS = 4
};


enum GPLOT_OUTPUT {
    GPLOT_NONE = 0,
    GPLOT_PNG = 1,
    GPLOT_PS = 2,
    GPLOT_EPS = 3,
    GPLOT_X11 = 4,
    GPLOT_LATEX = 5
};

enum GPLOT_SCALING {
    GPLOT_LINEAR_SCALE = 0, /* default */
    GPLOT_LOG_SCALE_X = 1,
    GPLOT_LOG_SCALE_Y = 2,
    GPLOT_LOG_SCALE_X_Y = 3
};

extern const char *gplotstylenames[]; /* used in gnuplot cmd file */
extern const char *gplotfilestyles[]; /* used in simple file input */
extern const char *gplotfileoutputs[]; /* used in simple file input */

struct GPlot
{
    char *rootname; /* for cmd, data, output            */
    char *cmdname; /* command file name                */
    struct Sarray *cmddata; /* command file contents            */
    struct Sarray *datanames; /* data file names                  */
    struct Sarray *plotdata; /* plot data (1 string/file)        */
    struct Sarray *plottitles; /* title for each individual plot   */
    struct Numa *plotstyles; /* plot style for individual plots  */
    l_int32 nplots; /* current number of plots          */
    char *outname; /* output file name                 */
    l_int32 outformat; /* GPLOT_OUTPUT values              */
    l_int32 scaling; /* GPLOT_SCALING values             */
    char *title; /* optional                         */
    char *xlabel; /* optional x axis label            */
    char *ylabel; /* optional y axis label            */
};
typedef struct GPlot GPLOT;
# 53 "/usr/local/Cellar/leptonica/1.71_1/include/leptonica/alltypes.h" 2
# 1 "/usr/local/Cellar/leptonica/1.71_1/include/leptonica/imageio.h" 1
/*====================================================================*
 -  Copyright (C) 2001 Leptonica.  All rights reserved.
 -
 -  Redistribution and use in source and binary forms, with or without
 -  modification, are permitted provided that the following conditions
 -  are met:
 -  1. Redistributions of source code must retain the above copyright
 -     notice, this list of conditions and the following disclaimer.
 -  2. Redistributions in binary form must reproduce the above
 -     copyright notice, this list of conditions and the following
 -     disclaimer in the documentation and/or other materials
 -     provided with the distribution.
 -
 -  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 -  ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 -  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 -  A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL ANY
 -  CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 -  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 -  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 -  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 -  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 -  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 -  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *====================================================================*/

/*
 *  General features of image I/O in leptonica
 *
 *  At present, there are 9 file formats for images that can be read
 *  and written:
 *      png (requires libpng, libz)
 *      jpeg (requires libjpeg)
 *      tiff (requires libtiff, libz)
 *      gif (requires libgif)
 *      webp (requires libwebp)
 *      jp2 (requires libopenjp2)
 *      bmp (no library required)
 *      pnm (no library required)
 *      spix (no library required)
 *  Additionally, there are two file formats for writing (only) images:
 *      PostScript (requires libpng, libz, libjpeg, libtiff)
 *      pdf (requires libpng, libz, libjpeg, libtiff)
 *
 *  For all 9 read/write formats, leptonica provides interconversion
 *  between pix (with raster data) and formatted image data:
 *      Conversion from pix (typically compression):
 *          pixWrite():        pix --> file
 *          pixWriteStream():  pix --> filestream (aka FILE*)
 *          pixWriteMem():     pix --> memory buffer
 *      Conversion to pix (typically decompression):
 *          pixRead():         file --> pix
 *          pixReadStream():   filestream --> pix
 *          pixReadMem():      memory buffer --> pix
 *
 *  Conversions for which the image data is not compressed are:
 *     * uncompressed tiff   (IFF_TIFF)
 *     * bmp
 *     * pnm
 *     * spix (fast serialization that copies the pix raster data)
 *
 *  The image header (metadata) information can be read from either
 *  the compressed file or a memory buffer, for all 9 formats.
 */




/* ------------------ Image file format types -------------- */
/*
 *  The IFF_DEFAULT flag is used to write the file out in the
 *  same (input) file format that the pix was read from.  If the pix
 *  was not read from file, the input format field will be
 *  IFF_UNKNOWN and the output file format will be chosen to
 *  be compressed and lossless; namely, IFF_TIFF_G4 for d = 1
 *  and IFF_PNG for everything else.   IFF_JP2 is for jpeg2000, which
 *  is not supported in leptonica.
 *
 *  In the future, new format types that have defined extensions
 *  will be added before IFF_DEFAULT, and will be kept in sync with
 *  the file format extensions in writefile.c.  The positions of
 *  file formats before IFF_DEFAULT will remain invariant.
 */
enum {
    IFF_UNKNOWN = 0,
    IFF_BMP = 1,
    IFF_JFIF_JPEG = 2,
    IFF_PNG = 3,
    IFF_TIFF = 4,
    IFF_TIFF_PACKBITS = 5,
    IFF_TIFF_RLE = 6,
    IFF_TIFF_G3 = 7,
    IFF_TIFF_G4 = 8,
    IFF_TIFF_LZW = 9,
    IFF_TIFF_ZIP = 10,
    IFF_PNM = 11,
    IFF_PS = 12,
    IFF_GIF = 13,
    IFF_JP2 = 14,
    IFF_WEBP = 15,
    IFF_LPDF = 16,
    IFF_DEFAULT = 17,
    IFF_SPIX = 18
};


/* ---------------------- Format header ids --------------------- */
enum {
    BMP_ID = 0x4d42,
    TIFF_BIGEND_ID = 0x4d4d, /* MM - for 'motorola' */
    TIFF_LITTLEEND_ID = 0x4949 /* II - for 'intel'    */
};


/* ------------- Hinting bit flags in jpeg reader --------------- */
enum {
    L_JPEG_READ_LUMINANCE = 1, /* only want luminance data; no chroma */
    L_JPEG_FAIL_ON_BAD_DATA = 2 /* don't return possibly damaged pix */
};


/* ------------------ Pdf formated encoding types --------------- */
enum {
    L_JPEG_ENCODE = 1, /* use dct encoding: 8 and 32 bpp, no cmap     */
    L_G4_ENCODE = 2, /* use ccitt g4 fax encoding: 1 bpp            */
    L_FLATE_ENCODE = 3, /* use flate encoding: any depth, cmap ok      */
    L_JP2K_ENCODE = 4 /* use jp2k encoding: 8 and 32 bpp, no cmap    */
};


/* ------------------ Compressed image data --------------------- */
/*
 *  In use, either datacomp or data85 will be produced, depending
 *  on whether the data needs to be ascii85 encoded.  PostScript
 *  requires ascii85 encoding; pdf does not.
 *
 *  For the colormap (flate compression only), PostScript uses ascii85
 *  encoding and pdf uses a bracketed array of space-separated
 *  hex-encoded rgb triples.  Only tiff g4 (type == L_G4_ENCODE) uses
 *  the minisblack field.
 */
struct L_Compressed_Data
{
    l_int32 type; /* encoding type: L_JPEG_ENCODE, etc  */
    l_uint8 *datacomp; /* gzipped raster data                 */
    size_t nbytescomp; /* number of compressed bytes          */
    char *data85; /* ascii85-encoded gzipped raster data */
    size_t nbytes85; /* number of ascii85 encoded bytes     */
    char *cmapdata85; /* ascii85-encoded uncompressed cmap   */
    char *cmapdatahex; /* hex pdf array for the cmap          */
    l_int32 ncolors; /* number of colors in cmap            */
    l_int32 w; /* image width                         */
    l_int32 h; /* image height                        */
    l_int32 bps; /* bits/sample; typ. 1, 2, 4 or 8      */
    l_int32 spp; /* samples/pixel; typ. 1 or 3          */
    l_int32 minisblack; /* tiff g4 photometry                  */
    l_int32 predictor; /* flate data has PNG predictors       */
    size_t nbytes; /* number of uncompressed raster bytes */
    l_int32 res; /* resolution (ppi)                    */
};
typedef struct L_Compressed_Data L_COMP_DATA;


/* ------------------------ Pdf multi-image flags ------------------------ */
enum {
    L_FIRST_IMAGE = 1, /* first image to be used                      */
    L_NEXT_IMAGE = 2, /* intermediate image; not first or last       */
    L_LAST_IMAGE = 3 /* last image to be used                       */
};


/* ------------------ Intermediate pdf generation data -------------------- */
/*
 *  This accumulates data for generating a pdf of a single page consisting
 *  of an arbitrary number of images.
 *
 *  None of the strings have a trailing newline.
 */
struct L_Pdf_Data
{
    char *title; /* optional title for pdf              */
    l_int32 n; /* number of images                    */
    l_int32 ncmap; /* number of colormaps                 */
    struct L_Ptra *cida; /* array of compressed image data      */
    char *id; /* %PDF-1.2 id string                  */
    char *obj1; /* catalog string                      */
    char *obj2; /* metadata string                     */
    char *obj3; /* pages string                        */
    char *obj4; /* page string (variable data)         */
    char *obj5; /* content string (variable data)      */
    char *poststream; /* post-binary-stream string           */
    char *trailer; /* trailer string (variable data)      */
    struct Pta *xy; /* store (xpt, ypt) array              */
    struct Pta *wh; /* store (wpt, hpt) array              */
    struct Box *mediabox; /* bounding region for all images      */
    struct Sarray *saprex; /* pre-binary-stream xobject strings   */
    struct Sarray *sacmap; /* colormap pdf object strings         */
    struct L_Dna *objsize; /* sizes of each pdf string object     */
    struct L_Dna *objloc; /* location of each pdf string object  */
    l_int32 xrefloc; /* location of xref                    */
};
typedef struct L_Pdf_Data L_PDF_DATA;
# 54 "/usr/local/Cellar/leptonica/1.71_1/include/leptonica/alltypes.h" 2
# 1 "/usr/local/Cellar/leptonica/1.71_1/include/leptonica/jbclass.h" 1
/*====================================================================*
 -  Copyright (C) 2001 Leptonica.  All rights reserved.
 -
 -  Redistribution and use in source and binary forms, with or without
 -  modification, are permitted provided that the following conditions
 -  are met:
 -  1. Redistributions of source code must retain the above copyright
 -     notice, this list of conditions and the following disclaimer.
 -  2. Redistributions in binary form must reproduce the above
 -     copyright notice, this list of conditions and the following
 -     disclaimer in the documentation and/or other materials
 -     provided with the distribution.
 -
 -  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 -  ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 -  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 -  A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL ANY
 -  CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 -  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 -  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 -  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 -  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 -  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 -  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *====================================================================*/




/*
 * jbclass.h
 *
 *       JbClasser
 *       JbData
 */


    /* The JbClasser struct holds all the data accumulated during the
     * classification process that can be used for a compressed
     * jbig2-type representation of a set of images.  This is created
     * in an initialization process and added to as the selected components
     * on each successive page are analyzed.   */
struct JbClasser
{
    struct Sarray *safiles; /* input page image file names            */
    l_int32 method; /* JB_RANKHAUS, JB_CORRELATION            */
    l_int32 components; /* JB_CONN_COMPS, JB_CHARACTERS or        */
                                   /* JB_WORDS                               */
    l_int32 maxwidth; /* max component width allowed            */
    l_int32 maxheight; /* max component height allowed           */
    l_int32 npages; /* number of pages already processed      */
    l_int32 baseindex; /* number of components already processed */
                                   /* on fully processed pages               */
    struct Numa *nacomps; /* number of components on each page      */
    l_int32 sizehaus; /* size of square struct element for haus */
    l_float32 rankhaus; /* rank val of haus match, each way       */
    l_float32 thresh; /* thresh value for correlation score     */
    l_float32 weightfactor; /* corrects thresh value for heaver       */
                                   /* components; use 0 for no correction    */
    struct Numa *naarea; /* w * h of each template, without extra  */
                                   /* border pixels                          */
    l_int32 w; /* max width of original src images       */
    l_int32 h; /* max height of original src images      */
    l_int32 nclass; /* current number of classes              */
    l_int32 keep_pixaa; /* If zero, pixaa isn't filled            */
    struct Pixaa *pixaa; /* instances for each class; unbordered   */
    struct Pixa *pixat; /* templates for each class; bordered     */
                                   /* and not dilated                        */
    struct Pixa *pixatd; /* templates for each class; bordered     */
                                   /* and dilated                            */
    struct NumaHash *nahash; /* Hash table to find templates by size   */
    struct Numa *nafgt; /* fg areas of undilated templates;       */
                                   /* only used for rank < 1.0               */
    struct Pta *ptac; /* centroids of all bordered cc           */
    struct Pta *ptact; /* centroids of all bordered template cc  */
    struct Numa *naclass; /* array of class ids for each component  */
    struct Numa *napage; /* array of page nums for each component  */
    struct Pta *ptaul; /* array of UL corners at which the       */
                                   /* template is to be placed for each      */
                                   /* component                              */
    struct Pta *ptall; /* similar to ptaul, but for LL corners   */
};
typedef struct JbClasser JBCLASSER;


    /* The JbData struct holds all the data required for
     * the compressed jbig-type representation of a set of images.
     * The data can be written to file, read back, and used
     * to regenerate an approximate version of the original,
     * which differs in two ways from the original:
     *   (1) It uses a template image for each c.c. instead of the
     *       original instance, for each occurrence on each page.
     *   (2) It discards components with either a height or width larger
     *       than the maximuma, given here by the lattice dimensions
     *       used for storing the templates.   */
struct JbData
{
    struct Pix *pix; /* template composite for all classes    */
    l_int32 npages; /* number of pages                       */
    l_int32 w; /* max width of original page images     */
    l_int32 h; /* max height of original page images    */
    l_int32 nclass; /* number of classes                     */
    l_int32 latticew; /* lattice width for template composite  */
    l_int32 latticeh; /* lattice height for template composite */
    struct Numa *naclass; /* array of class ids for each component */
    struct Numa *napage; /* array of page nums for each component */
    struct Pta *ptaul; /* array of UL corners at which the      */
                                    /* template is to be placed for each     */
                                    /* component                             */
};
typedef struct JbData JBDATA;


    /* Classifier methods */
enum {
   JB_RANKHAUS = 0,
   JB_CORRELATION = 1
};

    /* For jbGetComponents(): type of component to extract from images */
enum {
   JB_CONN_COMPS = 0,
   JB_CHARACTERS = 1,
   JB_WORDS = 2
};

    /* These parameters are used for naming the two files
     * in which the jbig2-like compressed data is stored.  */
# 55 "/usr/local/Cellar/leptonica/1.71_1/include/leptonica/alltypes.h" 2
# 1 "/usr/local/Cellar/leptonica/1.71_1/include/leptonica/morph.h" 1
/*====================================================================*
 -  Copyright (C) 2001 Leptonica.  All rights reserved.
 -
 -  Redistribution and use in source and binary forms, with or without
 -  modification, are permitted provided that the following conditions
 -  are met:
 -  1. Redistributions of source code must retain the above copyright
 -     notice, this list of conditions and the following disclaimer.
 -  2. Redistributions in binary form must reproduce the above
 -     copyright notice, this list of conditions and the following
 -     disclaimer in the documentation and/or other materials
 -     provided with the distribution.
 - 
 -  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 -  ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 -  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 -  A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL ANY
 -  CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 -  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 -  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 -  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 -  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 -  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 -  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *====================================================================*/




/* 
 *  morph.h
 *
 *  Contains the following structs:
 *      struct Sel
 *      struct Sela
 *      struct Kernel
 *
 *  Contains definitions for:
 *      morphological b.c. flags
 *      structuring element types
 *      runlength flags for granulometry
 *      direction flags for grayscale morphology
 *      morphological operation flags
 *      standard border size
 *      grayscale intensity scaling flags
 *      morphological tophat flags
 *      arithmetic and logical operator flags
 *      grayscale morphology selection flags
 *      distance function b.c. flags
 *      image comparison flags
 *      color content flags
 */

/*-------------------------------------------------------------------------*
 *                             Sel and Sel array                           *
 *-------------------------------------------------------------------------*/


struct Sel
{
    l_int32 sy; /* sel height                               */
    l_int32 sx; /* sel width                                */
    l_int32 cy; /* y location of sel origin                 */
    l_int32 cx; /* x location of sel origin                 */
    l_int32 **data; /* {0,1,2}; data[i][j] in [row][col] order  */
    char *name; /* used to find sel by name                 */
};
typedef struct Sel SEL;

struct Sela
{
    l_int32 n; /* number of sel actually stored           */
    l_int32 nalloc; /* size of allocated ptr array             */
    struct Sel **sel; /* sel ptr array                           */
};
typedef struct Sela SELA;


/*-------------------------------------------------------------------------*
 *                                 Kernel                                  *
 *-------------------------------------------------------------------------*/


struct L_Kernel
{
    l_int32 sy; /* kernel height                            */
    l_int32 sx; /* kernel width                             */
    l_int32 cy; /* y location of kernel origin              */
    l_int32 cx; /* x location of kernel origin              */
    l_float32 **data; /* data[i][j] in [row][col] order           */
};
typedef struct L_Kernel L_KERNEL;


/*-------------------------------------------------------------------------*
 *                 Morphological boundary condition flags                  *
 *
 *  Two types of boundary condition for erosion.
 *  The global variable MORPH_BC takes on one of these two values.
 *  See notes in morph.c for usage.
 *-------------------------------------------------------------------------*/
enum {
    SYMMETRIC_MORPH_BC = 0,
    ASYMMETRIC_MORPH_BC = 1
};


/*-------------------------------------------------------------------------*
 *                        Structuring element types                        *
 *-------------------------------------------------------------------------*/
enum {
    SEL_DONT_CARE = 0,
    SEL_HIT = 1,
    SEL_MISS = 2
};


/*-------------------------------------------------------------------------*
 *                  Runlength flags for granulometry                       *
 *-------------------------------------------------------------------------*/
enum {
    L_RUN_OFF = 0,
    L_RUN_ON = 1
};


/*-------------------------------------------------------------------------*
 *         Direction flags for grayscale morphology, granulometry,         *
 *                   composable Sels, and convolution                      *
 *-------------------------------------------------------------------------*/
enum {
    L_HORIZ = 1,
    L_VERT = 2,
    L_BOTH_DIRECTIONS = 3
};


/*-------------------------------------------------------------------------*
 *                   Morphological operation flags                         *
 *-------------------------------------------------------------------------*/
enum {
    L_MORPH_DILATE = 1,
    L_MORPH_ERODE = 2,
    L_MORPH_OPEN = 3,
    L_MORPH_CLOSE = 4,
    L_MORPH_HMT = 5
};


/*-------------------------------------------------------------------------*
 *                    Grayscale intensity scaling flags                    *
 *-------------------------------------------------------------------------*/
enum {
    L_LINEAR_SCALE = 1,
    L_LOG_SCALE = 2
};


/*-------------------------------------------------------------------------*
 *                      Morphological tophat flags                         *
 *-------------------------------------------------------------------------*/
enum {
    L_TOPHAT_WHITE = 0,
    L_TOPHAT_BLACK = 1
};


/*-------------------------------------------------------------------------*
 *                Arithmetic and logical operator flags                    *
 *                 (use on grayscale images and Numas)                     *
 *-------------------------------------------------------------------------*/
enum {
    L_ARITH_ADD = 1,
    L_ARITH_SUBTRACT = 2,
    L_ARITH_MULTIPLY = 3, /* on numas only */
    L_ARITH_DIVIDE = 4, /* on numas only */
    L_UNION = 5, /* on numas only */
    L_INTERSECTION = 6, /* on numas only */
    L_SUBTRACTION = 7, /* on numas only */
    L_EXCLUSIVE_OR = 8 /* on numas only */
};


/*-------------------------------------------------------------------------*
 *                        Min/max selection flags                          *
 *-------------------------------------------------------------------------*/
enum {
    L_CHOOSE_MIN = 1, /* useful in a downscaling "erosion"  */
    L_CHOOSE_MAX = 2, /* useful in a downscaling "dilation" */
    L_CHOOSE_MAX_MIN_DIFF = 3 /* useful in a downscaling contrast   */
};


/*-------------------------------------------------------------------------*
 *                    Distance function b.c. flags                         *
 *-------------------------------------------------------------------------*/
enum {
    L_BOUNDARY_BG = 1, /* assume bg outside image */
    L_BOUNDARY_FG = 2 /* assume fg outside image */
};


/*-------------------------------------------------------------------------*
 *                         Image comparison flags                          *
 *-------------------------------------------------------------------------*/
enum {
    L_COMPARE_XOR = 1,
    L_COMPARE_SUBTRACT = 2,
    L_COMPARE_ABS_DIFF = 3
};


/*-------------------------------------------------------------------------*
 *                          Color content flags                            *
 *-------------------------------------------------------------------------*/
enum {
    L_MAX_DIFF_FROM_AVERAGE_2 = 1,
    L_MAX_MIN_DIFF_FROM_2 = 2,
    L_MAX_DIFF = 3
};


/*-------------------------------------------------------------------------*
 *    Standard size of border added around images for special processing   *
 *-------------------------------------------------------------------------*/
static const l_int32 ADDED_BORDER = 32; /* pixels, not bits */
# 56 "/usr/local/Cellar/leptonica/1.71_1/include/leptonica/alltypes.h" 2
# 1 "/usr/local/Cellar/leptonica/1.71_1/include/leptonica/pix.h" 1
/*====================================================================*
 -  Copyright (C) 2001 Leptonica.  All rights reserved.
 -
 -  Redistribution and use in source and binary forms, with or without
 -  modification, are permitted provided that the following conditions
 -  are met:
 -  1. Redistributions of source code must retain the above copyright
 -     notice, this list of conditions and the following disclaimer.
 -  2. Redistributions in binary form must reproduce the above
 -     copyright notice, this list of conditions and the following
 -     disclaimer in the documentation and/or other materials
 -     provided with the distribution.
 -
 -  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 -  ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 -  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 -  A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL ANY
 -  CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 -  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 -  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 -  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 -  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 -  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 -  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *====================================================================*/




/*
 *   pix.h
 *
 *   Valid image types in leptonica:
 *       Pix: 1 bpp, with and without colormap
 *       Pix: 2 bpp, with and without colormap
 *       Pix: 4 bpp, with and without colormap
 *       Pix: 8 bpp, with and without colormap
 *       Pix: 16 bpp (1 spp)
 *       Pix: 32 bpp (rgb, 3 spp)
 *       Pix: 32 bpp (rgba, 4 spp)
 *       FPix: 32 bpp float
 *       DPix: 64 bpp double
 *       Notes:
 *          (1) The only valid Pix image type with alpha is rgba.
 *              In particular, the alpha component is not used in
 *              cmapped images.
 *          (2) PixComp can hold any Pix with IFF_PNG encoding.
 *
 *   This file defines most of the image-related structs used in leptonica:
 *       struct Pix
 *       struct PixColormap
 *       struct RGBA_Quad
 *       struct Pixa
 *       struct Pixaa
 *       struct Box
 *       struct Boxa
 *       struct Boxaa
 *       struct Pta
 *       struct Ptaa
 *       struct Pixacc
 *       struct PixTiling
 *       struct FPix
 *       struct FPixa
 *       struct DPix
 *       struct PixComp
 *       struct PixaComp
 *
 *   This file has definitions for:
 *       Colors for RGB
 *       Perceptual color weights
 *       Colormap conversion flags
 *       Rasterop bit flags
 *       Structure access flags (for insert, copy, clone, copy-clone)
 *       Sorting flags (by type and direction)
 *       Blending flags
 *       Graphics pixel setting flags
 *       Size filtering flags
 *       Color component selection flags
 *       16-bit conversion flags
 *       Rotation and shear flags
 *       Affine transform order flags
 *       Grayscale filling flags
 *       Flags for setting to white or black
 *       Flags for getting white or black pixel value
 *       Flags for 8 and 16 bit pixel sums
 *       Dithering flags
 *       Distance flags
 *       Statistical measures
 *       Set selection flags
 *       Text orientation flags
 *       Edge orientation flags
 *       Line orientation flags
 *       Scan direction flags
 *       Box size adjustment flags
 *       Flags for selecting box boundaries from two choices
 *       Handling overlapping bounding boxes in boxa
 *       Horizontal warp
 *       Pixel selection for resampling
 *       Thinning flags
 *       Runlength flags
 *       Edge filter flags
 *       Subpixel color component ordering in LCD display
 *       HSV histogram flags
 *       Region flags (inclusion, exclusion)
 *       Flags for adding text to a pix
 *       Flags for plotting on a pix
 *       Flags for selecting display program
 *       Flags in the 'special' pix field for non-default operations
 *       Handling negative values in conversion to unsigned int
 *       Relative to zero flags
 *       Flags for adding or removing traling slash from string                *
 */


/*-------------------------------------------------------------------------*
 *                              Basic Pix                                  *
 *-------------------------------------------------------------------------*/
    /* The 'special' field is by default 0, but it can hold integers
     * that direct non-default actions, e.g., in png and jpeg I/O. */
struct Pix
{
    l_uint32 w; /* width in pixels                   */
    l_uint32 h; /* height in pixels                  */
    l_uint32 d; /* depth in bits (bpp)               */
    l_uint32 spp; /* number of samples per pixel       */
    l_uint32 wpl; /* 32-bit words/line                 */
    l_uint32 refcount; /* reference count (1 if no clones)  */
    l_int32 xres; /* image res (ppi) in x direction    */
                                      /* (use 0 if unknown)                */
    l_int32 yres; /* image res (ppi) in y direction    */
                                      /* (use 0 if unknown)                */
    l_int32 informat; /* input file format, IFF_*          */
    l_int32 special; /* special instructions for I/O, etc */
    char *text; /* text string associated with pix   */
    struct PixColormap *colormap; /* colormap (may be null)            */
    l_uint32 *data; /* the image data                    */
};
typedef struct Pix PIX;


struct PixColormap
{
    void *array; /* colormap table (array of RGBA_QUAD)     */
    l_int32 depth; /* of pix (1, 2, 4 or 8 bpp)               */
    l_int32 nalloc; /* number of color entries allocated       */
    l_int32 n; /* number of color entries used            */
};
typedef struct PixColormap PIXCMAP;


    /* Colormap table entry (after the BMP version).
     * Note that the BMP format stores the colormap table exactly
     * as it appears here, with color samples being stored sequentially,
     * in the order (b,g,r,a). */
struct RGBA_Quad
{
    l_uint8 blue;
    l_uint8 green;
    l_uint8 red;
    l_uint8 alpha;
};
typedef struct RGBA_Quad RGBA_QUAD;



/*-------------------------------------------------------------------------*
 *                             Colors for 32 bpp                           *
 *-------------------------------------------------------------------------*/
/*  Notes:
 *      (1) These are the byte indices for colors in 32 bpp images.
 *          They are used through the GET/SET_DATA_BYTE accessors.
 *          The 4th byte, typically known as the "alpha channel" and used
 *          for blending, is used to a small extent in leptonica.
 *      (2) Do not change these values!  If you redefine them, functions
 *          that have the shifts hardcoded for efficiency and conciseness
 *          (instead of using the constants below) will break.  These
 *          functions are labelled with "***"  next to their names at
 *          the top of the files in which they are defined.
 *      (3) The shifts to extract the red, green, blue and alpha components
 *          from a 32 bit pixel are defined here.
 */
enum {
    COLOR_RED = 0,
    COLOR_GREEN = 1,
    COLOR_BLUE = 2,
    L_ALPHA_CHANNEL = 3
};

static const l_int32 L_RED_SHIFT =
       8 * (sizeof(l_uint32) - 1 - COLOR_RED); /* 24 */
static const l_int32 L_GREEN_SHIFT =
       8 * (sizeof(l_uint32) - 1 - COLOR_GREEN); /* 16 */
static const l_int32 L_BLUE_SHIFT =
       8 * (sizeof(l_uint32) - 1 - COLOR_BLUE); /*  8 */
static const l_int32 L_ALPHA_SHIFT =
       8 * (sizeof(l_uint32) - 1 - L_ALPHA_CHANNEL); /*  0 */


/*-------------------------------------------------------------------------*
 *                       Perceptual color weights                          *
 *-------------------------------------------------------------------------*/
/*  Notes:
 *      (1) These numbers are ad-hoc, but they do add up to 1.
 *          Unlike, for example, the weighting factor for conversion
 *          of RGB to luminance, or more specifically to Y in the
 *          YUV colorspace.  Those numbers come from the
 *          International Telecommunications Union, via ITU-R.
 */
static const l_float32 L_RED_WEIGHT = 0.3;
static const l_float32 L_GREEN_WEIGHT = 0.5;
static const l_float32 L_BLUE_WEIGHT = 0.2;


/*-------------------------------------------------------------------------*
 *                        Flags for colormap conversion                    *
 *-------------------------------------------------------------------------*/
enum {
    REMOVE_CMAP_TO_BINARY = 0,
    REMOVE_CMAP_TO_GRAYSCALE = 1,
    REMOVE_CMAP_TO_FULL_COLOR = 2,
    REMOVE_CMAP_WITH_ALPHA = 3,
    REMOVE_CMAP_BASED_ON_SRC = 4
};


/*-------------------------------------------------------------------------*
 *
 * The following operation bit flags have been modified from
 * Sun's pixrect.h.
 *
 * The 'op' in 'rasterop' is represented by an integer
 * composed with Boolean functions using the set of five integers
 * given below.  The integers, and the op codes resulting from
 * boolean expressions on them, need only be in the range from 0 to 15.
 * The function is applied on a per-pixel basis.
 *
 * Examples: the op code representing ORing the src and dest
 * is computed using the bit OR, as PIX_SRC | PIX_DST;  the op
 * code representing XORing src and dest is found from
 * PIX_SRC ^ PIX_DST;  the op code representing ANDing src and dest
 * is found from PIX_SRC & PIX_DST.  Note that
 * PIX_NOT(PIX_CLR) = PIX_SET, and v.v., as they must be.
 *
 * We would like to use the following set of definitions:
 *
 *      #define   PIX_SRC      0xc
 *      #define   PIX_DST      0xa
 *      #define   PIX_NOT(op)  ((op) ^ 0xf)
 *      #define   PIX_CLR      0x0
 *      #define   PIX_SET      0xf
 *
 * Now, these definitions differ from Sun's, in that Sun
 * left-shifted each value by 1 pixel, and used the least
 * significant bit as a flag for the "pseudo-operation" of
 * clipping.  We don't need this bit, because it is both
 * efficient and safe ALWAYS to clip the rectangles to the src
 * and dest images, which is what we do.  See the notes in rop.h
 * on the general choice of these bit flags.
 *
 * However, if you include Sun's xview package, you will get their
 * definitions, and because I like using these flags, we will
 * adopt the original Sun definitions to avoid redefinition conflicts.
 *
 * Then we have, for reference, the following 16 unique op flags:
 *
 *      PIX_CLR                           00000             0x0
 *      PIX_SET                           11110             0x1e
 *      PIX_SRC                           11000             0x18
 *      PIX_DST                           10100             0x14
 *      PIX_NOT(PIX_SRC)                  00110             0x06
 *      PIX_NOT(PIX_DST)                  01010             0x0a
 *      PIX_SRC | PIX_DST                 11100             0x1c
 *      PIX_SRC & PIX_DST                 10000             0x10
 *      PIX_SRC ^ PIX_DST                 01100             0x0c
 *      PIX_NOT(PIX_SRC) | PIX_DST        10110             0x16
 *      PIX_NOT(PIX_SRC) & PIX_DST        00100             0x04
 *      PIX_SRC | PIX_NOT(PIX_DST)        11010             0x1a
 *      PIX_SRC & PIX_NOT(PIX_DST)        01000             0x08
 *      PIX_NOT(PIX_SRC | PIX_DST)        00010             0x02
 *      PIX_NOT(PIX_SRC & PIX_DST)        01110             0x0e
 *      PIX_NOT(PIX_SRC ^ PIX_DST)        10010             0x12
 *
 *-------------------------------------------------------------------------*/
# 296 "/usr/local/Cellar/leptonica/1.71_1/include/leptonica/pix.h"
/*-------------------------------------------------------------------------*
 *
 *   Important Notes:
 *
 *       (1) The image data is stored in a single contiguous
 *           array of l_uint32, into which the pixels are packed.
 *           By "packed" we mean that there are no unused bits
 *           between pixels, except for end-of-line padding to
 *           satisfy item (2) below.
 *
 *       (2) Every image raster line begins on a 32-bit word
 *           boundary within this array.
 *
 *       (3) Pix image data is stored in 32-bit units, with the
 *           pixels ordered from left to right in the image being
 *           stored in order from the MSB to LSB within the word,
 *           for both big-endian and little-endian machines.
 *           This is the natural ordering for big-endian machines,
 *           as successive bytes are stored and fetched progressively
 *           to the right.  However, for little-endians, when storing
 *           we re-order the bytes from this byte stream order, and
 *           reshuffle again for byte access on 32-bit entities.
 *           So if the bytes come in sequence from left to right, we
 *           store them on little-endians in byte order:
 *                3 2 1 0 7 6 5 4 ...
 *           This MSB to LSB ordering allows left and right shift
 *           operations on 32 bit words to move the pixels properly.
 *
 *       (4) We use 32 bit pixels for both RGB and RGBA color images.
 *           The A (alpha) byte is ignored in most leptonica functions
 *           operating on color images.  Within each 4 byte pixel, the
 *           colors are ordered from MSB to LSB, as follows:
 *
 *                |  MSB  |  2nd MSB  |  3rd MSB  |  LSB  |
 *                   red      green       blue      alpha
 *                    0         1           2         3   (big-endian)
 *                    3         2           1         0   (little-endian)
 *
 *           Because we use MSB to LSB ordering within the 32-bit word,
 *           the individual 8-bit samples can be accessed with
 *           GET_DATA_BYTE and SET_DATA_BYTE macros, using the
 *           (implicitly big-ending) ordering
 *                 red:    byte 0  (MSB)
 *                 green:  byte 1  (2nd MSB)
 *                 blue:   byte 2  (3rd MSB)
 *                 alpha:  byte 3  (LSB)
 *
 *           The specific color assignment is made in this file,
 *           through the definitions of COLOR_RED, etc.  Then the R, G
 *           B and A sample values can be retrieved using
 *                 redval = GET_DATA_BYTE(&pixel, COLOR_RED);
 *                 greenval = GET_DATA_BYTE(&pixel, COLOR_GREEN);
 *                 blueval = GET_DATA_BYTE(&pixel, COLOR_BLUE);
 *                 alphaval = GET_DATA_BYTE(&pixel, L_ALPHA_CHANNEL);
 *           and they can be set with
 *                 SET_DATA_BYTE(&pixel, COLOR_RED, redval);
 *                 SET_DATA_BYTE(&pixel, COLOR_GREEN, greenval);
 *                 SET_DATA_BYTE(&pixel, COLOR_BLUE, blueval);
 *                 SET_DATA_BYTE(&pixel, L_ALPHA_CHANNEL, alphaval);
 *
 *           For extra speed we extract these components directly
 *           by shifting and masking, explicitly using the values in
 *           L_RED_SHIFT, etc.:
 *                 (pixel32 >> L_RED_SHIFT) & 0xff;         (red)
 *                 (pixel32 >> L_GREEN_SHIFT) & 0xff;       (green)
 *                 (pixel32 >> L_BLUE_SHIFT) & 0xff;        (blue)
 *                 (pixel32 >> L_ALPHA_SHIFT) & 0xff;       (alpha)
 *           All these operations work properly on both big- and little-endians.
 *
 *           For a few situations, these color shift values are hard-coded.
 *           Changing the RGB color component ordering through the assignments
 *           in this file will cause functions marked with "***" to fail.
 *
 *       (5) A reference count is held within each pix, giving the
 *           number of ptrs to the pix.  When a pixClone() call
 *           is made, the ref count is increased by 1, and
 *           when a pixDestroy() call is made, the reference count
 *           of the pix is decremented.  The pix is only destroyed
 *           when the reference count goes to zero.
 *
 *       (6) The version numbers (below) are used in the serialization
 *           of these data structures.  They are placed in the files,
 *           and rarely (if ever) change.  Provision is currently made for
 *           backward compatibility in reading from boxaa version 2.
 *
 *       (7) The serialization dependencies are as follows:
 *               pixaa  :  pixa  :  boxa
 *               boxaa  :  boxa
 *           So, for example, pixaa and boxaa can be changed without
 *           forcing a change in pixa or boxa.  However, if pixa is
 *           changed, it forces a change in pixaa, and if boxa is
 *           changed, if forces a change in the other three.
 *           We define four version numbers:
 *               PIXAA_VERSION_NUMBER
 *               PIXA_VERSION_NUMBER
 *               BOXAA_VERSION_NUMBER
 *               BOXA_VERSION_NUMBER
 *
 *-------------------------------------------------------------------------*/



/*-------------------------------------------------------------------------*
 *                              Array of pix                               *
 *-------------------------------------------------------------------------*/

    /*  Serialization for primary data structures */






struct Pixa
{
    l_int32 n; /* number of Pix in ptr array        */
    l_int32 nalloc; /* number of Pix ptrs allocated      */
    l_uint32 refcount; /* reference count (1 if no clones)  */
    struct Pix **pix; /* the array of ptrs to pix          */
    struct Boxa *boxa; /* array of boxes                    */
};
typedef struct Pixa PIXA;


struct Pixaa
{
    l_int32 n; /* number of Pixa in ptr array       */
    l_int32 nalloc; /* number of Pixa ptrs allocated     */
    struct Pixa **pixa; /* array of ptrs to pixa             */
    struct Boxa *boxa; /* array of boxes                    */
};
typedef struct Pixaa PIXAA;


/*-------------------------------------------------------------------------*
 *                    Basic rectangle and rectangle arrays                 *
 *-------------------------------------------------------------------------*/
struct Box
{
    l_int32 x;
    l_int32 y;
    l_int32 w;
    l_int32 h;
    l_uint32 refcount; /* reference count (1 if no clones)  */

};
typedef struct Box BOX;

struct Boxa
{
    l_int32 n; /* number of box in ptr array        */
    l_int32 nalloc; /* number of box ptrs allocated      */
    l_uint32 refcount; /* reference count (1 if no clones)  */
    struct Box **box; /* box ptr array                     */
};
typedef struct Boxa BOXA;

struct Boxaa
{
    l_int32 n; /* number of boxa in ptr array       */
    l_int32 nalloc; /* number of boxa ptrs allocated     */
    struct Boxa **boxa; /* boxa ptr array                    */
};
typedef struct Boxaa BOXAA;


/*-------------------------------------------------------------------------*
 *                               Array of points                           *
 *-------------------------------------------------------------------------*/


struct Pta
{
    l_int32 n; /* actual number of pts              */
    l_int32 nalloc; /* size of allocated arrays          */
    l_uint32 refcount; /* reference count (1 if no clones)  */
    l_float32 *x, *y; /* arrays of floats                  */
};
typedef struct Pta PTA;


/*-------------------------------------------------------------------------*
 *                              Array of Pta                               *
 *-------------------------------------------------------------------------*/
struct Ptaa
{
    l_int32 n; /* number of pta in ptr array        */
    l_int32 nalloc; /* number of pta ptrs allocated      */
    struct Pta **pta; /* pta ptr array                     */
};
typedef struct Ptaa PTAA;


/*-------------------------------------------------------------------------*
 *                       Pix accumulator container                         *
 *-------------------------------------------------------------------------*/
struct Pixacc
{
    l_int32 w; /* array width                       */
    l_int32 h; /* array height                      */
    l_int32 offset; /* used to allow negative            */
                                      /* intermediate results              */
    struct Pix *pix; /* the 32 bit accumulator pix        */
};
typedef struct Pixacc PIXACC;


/*-------------------------------------------------------------------------*
 *                              Pix tiling                                 *
 *-------------------------------------------------------------------------*/
struct PixTiling
{
    struct Pix *pix; /* input pix (a clone)               */
    l_int32 nx; /* number of tiles horizontally      */
    l_int32 ny; /* number of tiles vertically        */
    l_int32 w; /* tile width                        */
    l_int32 h; /* tile height                       */
    l_int32 xoverlap; /* overlap on left and right         */
    l_int32 yoverlap; /* overlap on top and bottom         */
    l_int32 strip; /* strip for paint; default is TRUE  */
};
typedef struct PixTiling PIXTILING;


/*-------------------------------------------------------------------------*
 *                       FPix: pix with float array                        *
 *-------------------------------------------------------------------------*/


struct FPix
{
    l_int32 w; /* width in pixels                   */
    l_int32 h; /* height in pixels                  */
    l_int32 wpl; /* 32-bit words/line                 */
    l_uint32 refcount; /* reference count (1 if no clones)  */
    l_int32 xres; /* image res (ppi) in x direction    */
                                      /* (use 0 if unknown)                */
    l_int32 yres; /* image res (ppi) in y direction    */
                                      /* (use 0 if unknown)                */
    l_float32 *data; /* the float image data              */
};
typedef struct FPix FPIX;


struct FPixa
{
    l_int32 n; /* number of fpix in ptr array       */
    l_int32 nalloc; /* number of fpix ptrs allocated     */
    l_uint32 refcount; /* reference count (1 if no clones)  */
    struct FPix **fpix; /* the array of ptrs to fpix         */
};
typedef struct FPixa FPIXA;


/*-------------------------------------------------------------------------*
 *                       DPix: pix with double array                       *
 *-------------------------------------------------------------------------*/


struct DPix
{
    l_int32 w; /* width in pixels                   */
    l_int32 h; /* height in pixels                  */
    l_int32 wpl; /* 32-bit words/line                 */
    l_uint32 refcount; /* reference count (1 if no clones)  */
    l_int32 xres; /* image res (ppi) in x direction    */
                                      /* (use 0 if unknown)                */
    l_int32 yres; /* image res (ppi) in y direction    */
                                      /* (use 0 if unknown)                */
    l_float64 *data; /* the double image data             */
};
typedef struct DPix DPIX;


/*-------------------------------------------------------------------------*
 *                        PixComp: compressed pix                          *
 *-------------------------------------------------------------------------*/
struct PixComp
{
    l_int32 w; /* width in pixels                   */
    l_int32 h; /* height in pixels                  */
    l_int32 d; /* depth in bits                     */
    l_int32 xres; /* image res (ppi) in x direction    */
                                      /*   (use 0 if unknown)              */
    l_int32 yres; /* image res (ppi) in y direction    */
                                      /*   (use 0 if unknown)              */
    l_int32 comptype; /* compressed format (IFF_TIFF_G4,   */
                                      /*   IFF_PNG, IFF_JFIF_JPEG)         */
    char *text; /* text string associated with pix   */
    l_int32 cmapflag; /* flag (1 for cmap, 0 otherwise)    */
    l_uint8 *data; /* the compressed image data         */
    size_t size; /* size of the data array            */
};
typedef struct PixComp PIXC;


/*-------------------------------------------------------------------------*
 *                     PixaComp: array of compressed pix                   *
 *-------------------------------------------------------------------------*/


struct PixaComp
{
    l_int32 n; /* number of PixComp in ptr array    */
    l_int32 nalloc; /* number of PixComp ptrs allocated  */
    l_int32 offset; /* indexing offset into ptr array    */
    struct PixComp **pixc; /* the array of ptrs to PixComp      */
    struct Boxa *boxa; /* array of boxes                    */
};
typedef struct PixaComp PIXAC;


/*-------------------------------------------------------------------------*
 *                         Access and storage flags                        *
 *-------------------------------------------------------------------------*/
/*
 *  For Pix, Box, Pta and Numa, there are 3 standard methods for handling
 *  the retrieval or insertion of a struct:
 *     (1) direct insertion (Don't do this if there is another handle
 *                           somewhere to this same struct!)
 *     (2) copy (Always safe, sets up a refcount of 1 on the new object.
 *               Can be undesirable if very large, such as an image or
 *               an array of images.)
 *     (3) clone (Makes another handle to the same struct, and bumps the
 *                refcount up by 1.  Safe to do unless you're changing
 *                data through one of the handles but don't want those
 *                changes to be seen by the other handle.)
 *
 *  For Pixa and Boxa, which are structs that hold an array of clonable
 *  structs, there is an additional method:
 *     (4) copy-clone (Makes a new higher-level struct with a refcount
 *                     of 1, but clones all the structs in the array.)
 *
 *  Unlike the other structs, when retrieving a string from an Sarray,
 *  you are allowed to get a handle without a copy or clone (i.e., that
 *  you don't own!).  You must not free or insert such a string!
 *  Specifically, for an Sarray, the copyflag for retrieval is either:
 *         TRUE (or 1 or L_COPY)
 *  or
 *         FALSE (or 0 or L_NOCOPY)
 *  For insertion, the copyflag is either:
 *         TRUE (or 1 or L_COPY)
 *  or
 *         FALSE (or 0 or L_INSERT)
 *  Note that L_COPY is always 1, and L_INSERT and L_NOCOPY are always 0.
 */
enum {
    L_INSERT = 0, /* stuff it in; no copy, clone or copy-clone    */
    L_COPY = 1, /* make/use a copy of the object                */
    L_CLONE = 2, /* make/use clone (ref count) of the object     */
    L_COPY_CLONE = 3 /* make a new object and fill with with clones  */
                      /* of each object in the array(s)               */
};
static const l_int32 L_NOCOPY = 0; /* copyflag value in sarrayGetString() */


/*--------------------------------------------------------------------------*
 *                              Sort flags                                  *
 *--------------------------------------------------------------------------*/
enum {
    L_SHELL_SORT = 1, /* use shell sort                         */
    L_BIN_SORT = 2 /* use bin sort                           */
};

enum {
    L_SORT_INCREASING = 1, /* sort in increasing order               */
    L_SORT_DECREASING = 2 /* sort in decreasing order               */
};

enum {
    L_SORT_BY_X = 1, /* sort box or c.c. by left edge location  */
    L_SORT_BY_Y = 2, /* sort box or c.c. by top edge location   */
    L_SORT_BY_RIGHT = 3, /* sort box or c.c. by right edge location */
    L_SORT_BY_BOT = 4, /* sort box or c.c. by bot edge location   */
    L_SORT_BY_WIDTH = 5, /* sort box or c.c. by width               */
    L_SORT_BY_HEIGHT = 6, /* sort box or c.c. by height              */
    L_SORT_BY_MIN_DIMENSION = 7, /* sort box or c.c. by min dimension       */
    L_SORT_BY_MAX_DIMENSION = 8, /* sort box or c.c. by max dimension       */
    L_SORT_BY_PERIMETER = 9, /* sort box or c.c. by perimeter           */
    L_SORT_BY_AREA = 10, /* sort box or c.c. by area                */
    L_SORT_BY_ASPECT_RATIO = 11 /* sort box or c.c. by width/height ratio  */
};


/*-------------------------------------------------------------------------*
 *                             Blend flags                                 *
 *-------------------------------------------------------------------------*/
enum {
    L_BLEND_WITH_INVERSE = 1, /* add some of src inverse to itself     */
    L_BLEND_TO_WHITE = 2, /* shift src colors towards white        */
    L_BLEND_TO_BLACK = 3, /* shift src colors towards black        */
    L_BLEND_GRAY = 4, /* blend src directly with blender       */
    L_BLEND_GRAY_WITH_INVERSE = 5 /* add amount of src inverse to itself,  */
                                  /* based on blender pix value            */
};

enum {
    L_PAINT_LIGHT = 1, /* colorize non-black pixels             */
    L_PAINT_DARK = 2 /* colorize non-white pixels             */
};


/*-------------------------------------------------------------------------*
 *                        Graphics pixel setting                           *
 *-------------------------------------------------------------------------*/
enum {
    L_SET_PIXELS = 1, /* set all bits in each pixel to 1       */
    L_CLEAR_PIXELS = 2, /* set all bits in each pixel to 0       */
    L_FLIP_PIXELS = 3 /* flip all bits in each pixel           */
};


/*-------------------------------------------------------------------------*
 *                           Size filter flags                             *
 *-------------------------------------------------------------------------*/
enum {
    L_SELECT_WIDTH = 1, /* width must satisfy constraint         */
    L_SELECT_HEIGHT = 2, /* height must satisfy constraint        */
    L_SELECT_IF_EITHER = 3, /* either width or height can satisfy    */
    L_SELECT_IF_BOTH = 4 /* both width and height must satisfy    */
};

enum {
    L_SELECT_IF_LT = 1, /* save if value is less than threshold  */
    L_SELECT_IF_GT = 2, /* save if value is more than threshold  */
    L_SELECT_IF_LTE = 3, /* save if value is <= to the threshold  */
    L_SELECT_IF_GTE = 4 /* save if value is >= to the threshold  */
};


/*-------------------------------------------------------------------------*
 *                     Color component selection flags                     *
 *-------------------------------------------------------------------------*/
enum {
    L_SELECT_RED = 1, /* use red component                     */
    L_SELECT_GREEN = 2, /* use green component                   */
    L_SELECT_BLUE = 3, /* use blue component                    */
    L_SELECT_MIN = 4, /* use min color component               */
    L_SELECT_MAX = 5, /* use max color component               */
    L_SELECT_AVERAGE = 6 /* use average of color components       */
};


/*-------------------------------------------------------------------------*
 *                         16-bit conversion flags                         *
 *-------------------------------------------------------------------------*/
enum {
    L_LS_BYTE = 0, /* use LSB                               */
    L_MS_BYTE = 1, /* use MSB                               */
    L_CLIP_TO_255 = 2 /* use max(val, 255)                     */
};


/*-------------------------------------------------------------------------*
 *                        Rotate and shear flags                           *
 *-------------------------------------------------------------------------*/
enum {
    L_ROTATE_AREA_MAP = 1, /* use area map rotation, if possible     */
    L_ROTATE_SHEAR = 2, /* use shear rotation                     */
    L_ROTATE_SAMPLING = 3 /* use sampling                           */
};

enum {
    L_BRING_IN_WHITE = 1, /* bring in white pixels from the outside */
    L_BRING_IN_BLACK = 2 /* bring in black pixels from the outside */
};

enum {
    L_SHEAR_ABOUT_CORNER = 1, /* shear image about UL corner            */
    L_SHEAR_ABOUT_CENTER = 2 /* shear image about center               */
};


/*-------------------------------------------------------------------------*
 *                     Affine transform order flags                        *
 *-------------------------------------------------------------------------*/
enum {
    L_TR_SC_RO = 1, /* translate, scale, rotate               */
    L_SC_RO_TR = 2, /* scale, rotate, translate               */
    L_RO_TR_SC = 3, /* rotate, translate, scale               */
    L_TR_RO_SC = 4, /* translate, rotate, scale               */
    L_RO_SC_TR = 5, /* rotate, scale, translate               */
    L_SC_TR_RO = 6 /* scale, translate, rotate               */
};


/*-------------------------------------------------------------------------*
 *                       Grayscale filling flags                           *
 *-------------------------------------------------------------------------*/
enum {
    L_FILL_WHITE = 1, /* fill white pixels (e.g, in fg map)      */
    L_FILL_BLACK = 2 /* fill black pixels (e.g., in bg map)     */
};


/*-------------------------------------------------------------------------*
 *                   Flags for setting to white or black                   *
 *-------------------------------------------------------------------------*/
enum {
    L_SET_WHITE = 1, /* set pixels to white                      */
    L_SET_BLACK = 2 /* set pixels to black                      */
};


/*-------------------------------------------------------------------------*
 *                  Flags for getting white or black value                 *
 *-------------------------------------------------------------------------*/
enum {
    L_GET_WHITE_VAL = 1, /* get white pixel value                    */
    L_GET_BLACK_VAL = 2 /* get black pixel value                    */
};


/*-------------------------------------------------------------------------*
 *                  Flags for 8 bit and 16 bit pixel sums                  *
 *-------------------------------------------------------------------------*/
enum {
    L_WHITE_IS_MAX = 1, /* white pixels are 0xff or 0xffff; black are 0  */
    L_BLACK_IS_MAX = 2 /* black pixels are 0xff or 0xffff; white are 0  */
};


/*-------------------------------------------------------------------------*
 *                           Dither parameters                             *
 *         If within this grayscale distance from black or white,          *
 *         do not propagate excess or deficit to neighboring pixels.       *
 *-------------------------------------------------------------------------*/
enum {
    DEFAULT_CLIP_LOWER_1 = 10, /* dist to black with no prop; 1 bpp      */
    DEFAULT_CLIP_UPPER_1 = 10, /* dist to black with no prop; 1 bpp      */
    DEFAULT_CLIP_LOWER_2 = 5, /* dist to black with no prop; 2 bpp      */
    DEFAULT_CLIP_UPPER_2 = 5 /* dist to black with no prop; 2 bpp      */
};


/*-------------------------------------------------------------------------*
 *                             Distance flags                              *
 *-------------------------------------------------------------------------*/
enum {
    L_MANHATTAN_DISTANCE = 1, /* L1 distance (e.g., in color space)     */
    L_EUCLIDEAN_DISTANCE = 2 /* L2 distance                            */
};


/*-------------------------------------------------------------------------*
 *                         Statistical measures                            *
 *-------------------------------------------------------------------------*/
enum {
    L_MEAN_ABSVAL = 1, /* average of abs values                  */
    L_MEDIAN_VAL = 2, /* median value of set                    */
    L_MODE_VAL = 3, /* mode value of set                      */
    L_MODE_COUNT = 4, /* mode count of set                      */
    L_ROOT_MEAN_SQUARE = 5, /* rms of values                          */
    L_STANDARD_DEVIATION = 6, /* standard deviation from mean           */
    L_VARIANCE = 7 /* variance of values                     */
};


/*-------------------------------------------------------------------------*
 *                          Set selection flags                            *
 *-------------------------------------------------------------------------*/
enum {
    L_CHOOSE_CONSECUTIVE = 1, /* select 'n' consecutive                 */
    L_CHOOSE_SKIP_BY = 2 /* select at intervals of 'n'             */
};


/*-------------------------------------------------------------------------*
 *                         Text orientation flags                          *
 *-------------------------------------------------------------------------*/
enum {
    L_TEXT_ORIENT_UNKNOWN = 0, /* low confidence on text orientation     */
    L_TEXT_ORIENT_UP = 1, /* portrait, text rightside-up            */
    L_TEXT_ORIENT_LEFT = 2, /* landscape, text up to left             */
    L_TEXT_ORIENT_DOWN = 3, /* portrait, text upside-down             */
    L_TEXT_ORIENT_RIGHT = 4 /* landscape, text up to right            */
};


/*-------------------------------------------------------------------------*
 *                         Edge orientation flags                          *
 *-------------------------------------------------------------------------*/
enum {
    L_HORIZONTAL_EDGES = 0, /* filters for horizontal edges            */
    L_VERTICAL_EDGES = 1, /* filters for vertical edges              */
    L_ALL_EDGES = 2 /* filters for all edges                   */
};


/*-------------------------------------------------------------------------*
 *                         Line orientation flags                          *
 *-------------------------------------------------------------------------*/
enum {
    L_HORIZONTAL_LINE = 0, /* horizontal line                          */
    L_POS_SLOPE_LINE = 1, /* 45 degree line with positive slope       */
    L_VERTICAL_LINE = 2, /* vertical line                            */
    L_NEG_SLOPE_LINE = 3, /* 45 degree line with negative slope       */
    L_OBLIQUE_LINE = 4 /* neither horizontal nor vertical */
};


/*-------------------------------------------------------------------------*
 *                           Scan direction flags                          *
 *-------------------------------------------------------------------------*/
enum {
    L_FROM_LEFT = 0, /* scan from left                           */
    L_FROM_RIGHT = 1, /* scan from right                          */
    L_FROM_TOP = 2, /* scan from top                            */
    L_FROM_BOT = 3, /* scan from bottom                         */
    L_SCAN_NEGATIVE = 4, /* scan in negative direction               */
    L_SCAN_POSITIVE = 5, /* scan in positive direction               */
    L_SCAN_BOTH = 6, /* scan in both directions                  */
    L_SCAN_HORIZONTAL = 7, /* horizontal scan (direction unimportant)  */
    L_SCAN_VERTICAL = 8 /* vertical scan (direction unimportant)    */
};


/*-------------------------------------------------------------------------*
 *                Box size adjustment and location flags                   *
 *-------------------------------------------------------------------------*/
enum {
    L_ADJUST_SKIP = 0, /* do not adjust                        */
    L_ADJUST_LEFT = 1, /* adjust left edge                     */
    L_ADJUST_RIGHT = 2, /* adjust right edge                    */
    L_ADJUST_LEFT_AND_RIGHT = 3, /* adjust both left and right edges     */
    L_ADJUST_TOP = 4, /* adjust top edge                      */
    L_ADJUST_BOT = 5, /* adjust bottom edge                   */
    L_ADJUST_TOP_AND_BOT = 6, /* adjust both top and bottom edges     */
    L_ADJUST_CHOOSE_MIN = 7, /* choose the min median value          */
    L_ADJUST_CHOOSE_MAX = 8, /* choose the max median value          */
    L_SET_LEFT = 9, /* set left side to a given value       */
    L_SET_RIGHT = 10, /* set right side to a given value      */
    L_SET_TOP = 11, /* set top side to a given value        */
    L_SET_BOT = 12, /* set bottom side to a given value     */
    L_GET_LEFT = 13, /* get left side location               */
    L_GET_RIGHT = 14, /* get right side location              */
    L_GET_TOP = 15, /* get top side location                */
    L_GET_BOT = 16 /* get bottom side location             */
};


/*-------------------------------------------------------------------------*
 *          Flags for selecting box boundaries from two choices            *
 *-------------------------------------------------------------------------*/
enum {
    L_USE_MINSIZE = 1, /* use boundaries giving min size       */
    L_USE_MAXSIZE = 2, /* use boundaries giving max size       */
    L_SUB_ON_BIG_DIFF = 3 /* substitute boundary if big abs diff  */
};

/*-------------------------------------------------------------------------*
 *              Handling overlapping bounding boxes in boxa                *
 *-------------------------------------------------------------------------*/
enum {
    L_COMBINE = 1, /* resize to bounding region; remove smaller  */
    L_REMOVE_SMALL = 2 /* only remove smaller                        */
};

/*-------------------------------------------------------------------------*
 *                            Horizontal warp                              *
 *-------------------------------------------------------------------------*/
enum {
    L_WARP_TO_LEFT = 1, /* increasing stretch or contraction to left  */
    L_WARP_TO_RIGHT = 2 /* increasing stretch or contraction to right */
};

enum {
    L_LINEAR_WARP = 1, /* stretch or contraction grows linearly      */
    L_QUADRATIC_WARP = 2 /* stretch or contraction grows quadratically */
};


/*-------------------------------------------------------------------------*
 *                      Pixel selection for resampling                     *
 *-------------------------------------------------------------------------*/
enum {
    L_INTERPOLATED = 1, /* linear interpolation from src pixels       */
    L_SAMPLED = 2 /* nearest src pixel sampling only            */
};


/*-------------------------------------------------------------------------*
 *                             Thinning flags                              *
 *-------------------------------------------------------------------------*/
enum {
    L_THIN_FG = 1, /* thin foreground of 1 bpp image         */
    L_THIN_BG = 2 /* thin background of 1 bpp image         */
};


/*-------------------------------------------------------------------------*
 *                            Runlength flags                              *
 *-------------------------------------------------------------------------*/
enum {
    L_HORIZONTAL_RUNS = 0, /* determine runlengths of horizontal runs  */
    L_VERTICAL_RUNS = 1 /* determine runlengths of vertical runs    */
};


/*-------------------------------------------------------------------------*
 *                          Edge filter flags                              *
 *-------------------------------------------------------------------------*/
enum {
    L_SOBEL_EDGE = 1, /* Sobel edge filter                        */
    L_TWO_SIDED_EDGE = 2 /* Two-sided edge filter                    */
};


/*-------------------------------------------------------------------------*
 *             Subpixel color component ordering in LCD display            *
 *-------------------------------------------------------------------------*/
enum {
    L_SUBPIXEL_ORDER_RGB = 1, /* sensor order left-to-right RGB          */
    L_SUBPIXEL_ORDER_BGR = 2, /* sensor order left-to-right BGR          */
    L_SUBPIXEL_ORDER_VRGB = 3, /* sensor order top-to-bottom RGB          */
    L_SUBPIXEL_ORDER_VBGR = 4 /* sensor order top-to-bottom BGR          */
};


/*-------------------------------------------------------------------------*
 *                          HSV histogram flags                            *
 *-------------------------------------------------------------------------*/
enum {
    L_HS_HISTO = 1, /* Use hue-saturation histogram             */
    L_HV_HISTO = 2, /* Use hue-value histogram                  */
    L_SV_HISTO = 3 /* Use saturation-value histogram           */
};


/*-------------------------------------------------------------------------*
 *                    Region flags (inclusion, exclusion)                  *
 *-------------------------------------------------------------------------*/
enum {
    L_INCLUDE_REGION = 1, /* Use hue-saturation histogram             */
    L_EXCLUDE_REGION = 2 /* Use hue-value histogram                  */
};


/*-------------------------------------------------------------------------*
 *                    Flags for adding text to a pix                       *
 *-------------------------------------------------------------------------*/
enum {
    L_ADD_ABOVE = 1, /* Add text above the image                 */
    L_ADD_BELOW = 2, /* Add text below the image                 */
    L_ADD_LEFT = 3, /* Add text to the left of the image        */
    L_ADD_RIGHT = 4, /* Add text to the right of the image       */
    L_ADD_AT_TOP = 5, /* Add text over the top of the image       */
    L_ADD_AT_BOT = 6, /* Add text over the bottom of the image    */
    L_ADD_AT_LEFT = 7, /* Add text over left side of the image     */
    L_ADD_AT_RIGHT = 8 /* Add text over right side of the image    */
};


/*-------------------------------------------------------------------------*
 *                       Flags for plotting on a pix                       *
 *-------------------------------------------------------------------------*/
enum {
    L_PLOT_AT_TOP = 1, /* Plot horizontally at top                 */
    L_PLOT_AT_MID_HORIZ = 2, /* Plot horizontally at middle              */
    L_PLOT_AT_BOT = 3, /* Plot horizontally at bottom              */
    L_PLOT_AT_LEFT = 4, /* Plot vertically at left                  */
    L_PLOT_AT_MID_VERT = 5, /* Plot vertically at middle                */
    L_PLOT_AT_RIGHT = 6 /* Plot vertically at right                 */
};


/*-------------------------------------------------------------------------*
 *                   Flags for selecting display program                   *
 *-------------------------------------------------------------------------*/
enum {
    L_DISPLAY_WITH_XZGV = 1, /* Use xzgv with pixDisplay()              */
    L_DISPLAY_WITH_XLI = 2, /* Use xli with pixDisplay()               */
    L_DISPLAY_WITH_XV = 3, /* Use xv with pixDisplay()                */
    L_DISPLAY_WITH_IV = 4, /* Use irfvanview (win) with pixDisplay()  */
    L_DISPLAY_WITH_OPEN = 5 /* Use open (apple) with pixDisplay()      */
};

/*-------------------------------------------------------------------------*
 *    Flag(s) used in the 'special' pix field for non-default operations   *
 *      - 0 is default                                                     *
 *      - 10-19 are reserved for zlib compression in png write             *
 *-------------------------------------------------------------------------*/
enum {
    L_NO_CHROMA_SAMPLING_JPEG = 1 /* Write full resolution chroma      */
};


/*-------------------------------------------------------------------------*
 *          Handling negative values in conversion to unsigned int         *
 *-------------------------------------------------------------------------*/
enum {
    L_CLIP_TO_ZERO = 1, /* Clip negative values to 0                */
    L_TAKE_ABSVAL = 2 /* Convert to positive using L_ABS()        */
};


/*-------------------------------------------------------------------------*
 *                        Relative to zero flags                           *
 *-------------------------------------------------------------------------*/
enum {
    L_LESS_THAN_ZERO = 1, /* Choose values less than zero             */
    L_EQUAL_TO_ZERO = 2, /* Choose values equal to zero              */
    L_GREATER_THAN_ZERO = 3 /* Choose values greater than zero          */
};


/*-------------------------------------------------------------------------*
 *         Flags for adding or removing traling slash from string          *
 *-------------------------------------------------------------------------*/
enum {
    L_ADD_TRAIL_SLASH = 1, /* Add trailing slash to string             */
    L_REMOVE_TRAIL_SLASH = 2 /* Remove trailing slash from string        */
};
# 57 "/usr/local/Cellar/leptonica/1.71_1/include/leptonica/alltypes.h" 2
# 1 "/usr/local/Cellar/leptonica/1.71_1/include/leptonica/recog.h" 1
/*====================================================================*
 -  Copyright (C) 2001 Leptonica.  All rights reserved.
 -
 -  Redistribution and use in source and binary forms, with or without
 -  modification, are permitted provided that the following conditions
 -  are met:
 -  1. Redistributions of source code must retain the above copyright
 -     notice, this list of conditions and the following disclaimer.
 -  2. Redistributions in binary form must reproduce the above
 -     copyright notice, this list of conditions and the following
 -     disclaimer in the documentation and/or other materials
 -     provided with the distribution.
 -
 -  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 -  ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 -  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 -  A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL ANY
 -  CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 -  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 -  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 -  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 -  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 -  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 -  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *====================================================================*/




/*
 *  recog.h
 *
 *     A simple utility for training and recognizing individual
 *     machine-printed text characters.  In an application, one can
 *     envision using a number of these, one for each trained set.
 *
 *     In training mode, a set of labelled bitmaps is presented, either
 *     one at a time, or in a directory, or in a pixa.  If in a directory,
 *     or a pixa, the labelling text string must be embedded in the
 *     text field of the image file.
 *
 *     Any number of recognizers (L_Recog) can be trained and then used
 *     together in an array (L_Recoga).  All these trained structures
 *     can be serialized to file and read back.  The serialized version
 *     holds all the bitmaps used for training, plus, for arbitrary
 *     character sets, the UTF8 representation and the lookup table
 *     mapping from the character representation to index.
 *
 *     There are three levels of "sets" here:
 *
 *       (1) Example set: the examples representing a character that
 *           were printed in the same way, so that they can be combined
 *           without scaling to form an "average" template for the character.
 *           In the recognition phase, we use either this aligned average,
 *           or the individual bitmaps.  All examples in the set are given
 *           the same character label.   Example: the letter 'a' in the
 *           predominant font in a book.
 *
 *       (2) Character set (represented by L_Recog, a single recognizer):
 *           The set of different characters, each of which is described
 *           by (1).  Each element of the set has a different character
 *           label.  Example: the digits '0' through '9' that are used for
 *           page numbering in a book.
 *
 *       (3) Recognizer set (represented by L_Recoga, an array of recogs):
 *           A set of recognizers, each of which is described by (2).
 *           In general, we do not want to combine the character sets
 *           with the same labels within different recognizer sets,
 *           because the bitmaps can differ in font type, style or size.
 *           Example 1: the letter 'a' can be printed in two very different
 *           ways (either with a large loop or with a smaller loop in
 *           the lower half); both share the same label but need to be
 *           distinguished so that they are not mixed when averaging.
 *           Example 2: a recognizer trained for a book may be missing
 *           some characters, so we need to supplement it with another
 *           "generic" or "bootstrap" recognizer that has the additional
 *           characters from a variety of sources.  Bootstrap recognizers
 *           must be run in a mode where all characters are scaled.
 *
 *     In the recognition process, for each component in an input image,
 *     each recognizer (L_Recog) records the best match (highest
 *     correlation score).  If there is more than one recognizer, these
 *     results are aggregated to find the best match for each character
 *     for all the recognizers, and this is stored in L_Recoga.
 */



struct L_Recoga {
    l_int32 n; /* number of recogs                         */
    l_int32 nalloc; /* number of recog ptrs allocated           */
    struct L_Recog **recog; /* recog ptr array                          */
    struct L_Rcha *rcha; /* stores the array of best chars           */
};
typedef struct L_Recoga L_RECOGA;


struct L_Recog {
    l_int32 scalew; /* scale all examples to this width;        */
                                 /* use 0 prevent horizontal scaling         */
    l_int32 scaleh; /* scale all examples to this height;       */
                                 /* use 0 prevent vertical scaling           */
    l_int32 templ_type; /* template type: either an average of      */
                                 /* examples (L_USE_AVERAGE) or the set      */
                                 /* of all examples (L_USE_ALL)              */
    l_int32 maxarraysize; /* initialize container arrays to this      */
    l_int32 setsize; /* size of character set                    */
    l_int32 threshold; /* for binarizing if depth > 1              */
    l_int32 maxyshift; /* vertical jiggle on nominal centroid      */
                                 /* alignment; typically 0 or 1              */
    l_float32 asperity_fr; /* +- allowed fractional asperity ratio     */
    l_int32 charset_type; /* one of L_ARABIC_NUMERALS, etc.           */
    l_int32 charset_size; /* expected number of classes in charset    */
    char *bootdir; /* dir with bootstrap pixa charsets         */
    char *bootpattern; /* file pattern for bootstrap pixa charsets */
    char *bootpath; /* path for single bootstrap pixa charset   */
    l_int32 min_nopad; /* min number of samples without padding    */
    l_int32 max_afterpad; /* max number of samples after padding      */
    l_int32 samplenum; /* keep track of number of training samples */
    l_int32 minwidth_u; /* min width of averaged unscaled templates */
    l_int32 maxwidth_u; /* max width of averaged unscaled templates */
    l_int32 minheight_u; /* min height of averaged unscaled templates */
    l_int32 maxheight_u; /* max height of averaged unscaled templates */
    l_int32 minwidth; /* min width of averaged scaled templates   */
    l_int32 maxwidth; /* max width of averaged scaled templates   */
    l_int32 ave_done; /* set to 1 when averaged bitmaps are made  */
    l_int32 train_done; /* set to 1 when training is complete or    */
                                 /* identification has started               */
    l_int32 min_splitw; /* min component width kept in splitting    */
    l_int32 min_splith; /* min component height kept in splitting   */
    l_int32 max_splith; /* max component height kept in splitting   */
    struct Sarray *sa_text; /* text array for arbitrary char set        */
    struct L_Dna *dna_tochar; /* index-to-char lut for arbitrary char set */
    l_int32 *centtab; /* table for finding centroids              */
    l_int32 *sumtab; /* table for finding pixel sums             */
    char *fname; /* serialized filename (if read)            */
    struct Pixaa *pixaa_u; /* all unscaled bitmaps for each class      */
    struct Pixa *pixa_u; /* averaged unscaled bitmaps for each class */
    struct Ptaa *ptaa_u; /* centroids of all unscaled bitmaps        */
    struct Pta *pta_u; /* centroids of unscaled averaged bitmaps   */
    struct Numaa *naasum_u; /* area of all unscaled bitmap examples     */
    struct Numa *nasum_u; /* area of unscaled averaged bitmaps        */
    struct Pixaa *pixaa; /* all bitmap examples for each class       */
    struct Pixa *pixa; /* averaged bitmaps for each class          */
    struct Ptaa *ptaa; /* centroids of all bitmap examples         */
    struct Pta *pta; /* centroids of averaged bitmaps            */
    struct Numaa *naasum; /* area of all bitmap examples              */
    struct Numa *nasum; /* area of averaged bitmaps                 */
    struct Pixa *pixa_tr; /* input training images                    */
    struct Pixa *pixadb_ave; /* unscaled and scaled averaged bitmaps     */
    struct Pixa *pixa_id; /* input images for identifying             */
    struct Pix *pixdb_ave; /* debug: best match of input against ave.  */
    struct Pix *pixdb_range; /* debug: best matches within range         */
    struct Pixa *pixadb_boot; /* debug: bootstrap training results        */
    struct Pixa *pixadb_split; /* debug: splitting results                 */
    char *fontdir; /* directory for bitmapped fonts            */
    struct L_Bmf *bmf; /* bmf fonts                                */
    l_int32 bmf_size; /* font size of bmf; default is 6 pt        */
    struct L_Rdid *did; /* temp data used for image decoding        */
    struct L_Rch *rch; /* temp data used for holding best char     */
    struct L_Rcha *rcha; /* temp data used for array of best chars   */
    l_int32 bootrecog; /* 1 if using bootstrap samples; else 0     */
    l_int32 index; /* recog index in recoga; -1 if no parent   */
    struct L_Recoga *parent; /* ptr to parent array; can be null         */

};
typedef struct L_Recog L_RECOG;

/*
 *  Data returned from correlation matching on a single character
 */
struct L_Rch {
    l_int32 index; /* index of best template                   */
    l_float32 score; /* correlation score of best template       */
    char *text; /* character string of best template        */
    l_int32 sample; /* index of best sample (within the best    */
                                 /* template class, if all samples are used) */
    l_int32 xloc; /* x-location of template (delx + shiftx)   */
    l_int32 yloc; /* y-location of template (dely + shifty)   */
    l_int32 width; /* width of best template                   */
};
typedef struct L_Rch L_RCH;

/*
 *  Data returned from correlation matching on an array of characters
 */
struct L_Rcha {
    struct Numa *naindex; /* indices of best templates                */
    struct Numa *nascore; /* correlation scores of best templates     */
    struct Sarray *satext; /* character strings of best templates      */
    struct Numa *nasample; /* indices of best samples                  */
    struct Numa *naxloc; /* x-locations of templates (delx + shiftx) */
    struct Numa *nayloc; /* y-locations of templates (dely + shifty) */
    struct Numa *nawidth; /* widths of best templates                 */
};
typedef struct L_Rcha L_RCHA;

/*
 *  Data used for decoding a line of characters.
 */
struct L_Rdid {
    struct Pix *pixs; /* clone of pix to be decoded               */
    l_int32 **counta; /* count array for each averaged template   */
    l_int32 **delya; /* best y-shift array per averaged template */
    l_int32 narray; /* number of averaged templates             */
    l_int32 size; /* size of count array (width of pixs)      */
    l_int32 *setwidth; /* setwidths for each template              */
    struct Numa *nasum; /* pixel count in pixs by column            */
    struct Numa *namoment; /* first moment of pixels in pixs by column */
    l_int32 fullarrays; /* 1 if full arrays are made; 0 otherwise   */
    l_float32 *beta; /* channel coeffs for template fg term      */
    l_float32 *gamma; /* channel coeffs for bit-and term          */
    l_float32 *trellisscore; /* score on trellis                         */
    l_int32 *trellistempl; /* template on trellis (for backtrack)      */
    struct Numa *natempl; /* indices of best path templates           */
    struct Numa *naxloc; /* x locations of best path templates       */
    struct Numa *nadely; /* y locations of best path templates       */
    struct Numa *nawidth; /* widths of best path templates            */
    struct Numa *nascore; /* correlation scores: best path templates  */
    struct Numa *natempl_r; /* indices of best rescored templates       */
    struct Numa *naxloc_r; /* x locations of best rescoredtemplates    */
    struct Numa *nadely_r; /* y locations of best rescoredtemplates    */
    struct Numa *nawidth_r; /* widths of best rescoredtemplates         */
    struct Numa *nascore_r; /* correlation scores: rescored templates   */
};
typedef struct L_Rdid L_RDID;


/*-------------------------------------------------------------------------*
 *                    Flags for selecting processing                       *
 *-------------------------------------------------------------------------*/
enum {
    L_SELECT_UNSCALED = 0, /* select the unscaled bitmaps            */
    L_SELECT_SCALED = 1, /* select the scaled bitmaps              */
    L_SELECT_BOTH = 2 /* select both unscaled and scaled        */
};

/*-------------------------------------------------------------------------*
 *                Flags for determining what to test against               *
 *-------------------------------------------------------------------------*/
enum {
    L_USE_AVERAGE = 0, /* form template from class average         */
    L_USE_ALL = 1 /* match against all elements of each class */
};

/*-------------------------------------------------------------------------*
 *             Flags for describing limited character sets                 *
 *-------------------------------------------------------------------------*/
enum {
    L_UNKNOWN = 0, /* character set type is not specified      */
    L_ARABIC_NUMERALS = 1, /* 10 digits                                */
    L_LC_ROMAN_NUMERALS = 2, /* 7 lower-case letters (i,v,x,l,c,d,m)     */
    L_UC_ROMAN_NUMERALS = 3, /* 7 upper-case letters (I,V,X,L,C,D,M)     */
    L_LC_ALPHA = 4, /* 26 lower-case letters                    */
    L_UC_ALPHA = 5 /* 26 upper-case letters                    */
};
# 58 "/usr/local/Cellar/leptonica/1.71_1/include/leptonica/alltypes.h" 2
# 1 "/usr/local/Cellar/leptonica/1.71_1/include/leptonica/regutils.h" 1
/*====================================================================*
 -  Copyright (C) 2001 Leptonica.  All rights reserved.
 -
 -  Redistribution and use in source and binary forms, with or without
 -  modification, are permitted provided that the following conditions
 -  are met:
 -  1. Redistributions of source code must retain the above copyright
 -     notice, this list of conditions and the following disclaimer.
 -  2. Redistributions in binary form must reproduce the above
 -     copyright notice, this list of conditions and the following
 -     disclaimer in the documentation and/or other materials
 -     provided with the distribution.
 - 
 -  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 -  ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 -  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 -  A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL ANY
 -  CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 -  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 -  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 -  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 -  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 -  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 -  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *====================================================================*/




/*
 *   regutils.h
 *
 *   Contains this regression test parameter packaging struct
 *       struct L_RegParams
 *
 *   The regression test utility allows you to write regression tests
 *   that compare results with existing "golden files" and with
 *   compiled in data.
 *
 *   Regression tests can be called in three ways.
 *   For example, for distance_reg:
 *
 *       Case 1: distance_reg [generate]
 *           This generates golden files in /tmp for the reg test.
 *
 *       Case 2: distance_reg compare
 *           This runs the test against the set of golden files.  It
 *           appends to 'outfile.txt' either "SUCCESS" or "FAILURE",
 *           as well as the details of any parts of the test that failed.
 *           It writes to a temporary file stream (fp)
 *
 *       Case 3: distance_reg display
 *           This runs the test but makes no comparison of the output
 *           against the set of golden files.  In addition, this displays
 *           images and plots that are specified in the test under
 *           control of the display variable.  Display is enabled only
 *           for this case.  Using 'display' on the command line is optional.
 *
 *   Regression tests follow the pattern given below.  Tests are
 *   automatically numbered sequentially, and it is convenient to
 *   comment each with a number to keep track (for comparison tests
 *   and for debugging).  In an actual case, comparisons of pix and
 *   of files can occur in any order.  We give a specific order here
 *   for clarity.
 *
 *       L_REGPARAMS  *rp;  // holds data required by the test functions
 *
 *       // Setup variables; optionally open stream
 *       if (regTestSetup(argc, argv, &rp))
 *           return 1;
 *
 *       // Test pairs of generated pix for identity.  This compares
 *       // two pix; no golden file is generated.
 *       regTestComparePix(rp, pix1, pix2);  // 0
 *
 *       // Test pairs of generated pix for similarity.  This compares
 *       // two pix; no golden file is generated.  The last arg determines
 *       // if stats are to be written to stderr.
 *       regTestCompareSimilarPix(rp, pix1, pix2, 15, 0.001, 0);  // 1
 *
 *       // Generation of <newfile*> outputs and testing for identity
 *       // These files can be anything, of course.
 *       regTestCheckFile(rp, <newfile0>);  // 2
 *       regTestCheckFile(rp, <newfile1>);  // 3
 *
 *       // Test pairs of output golden files for identity.  Here we
 *       // are comparing golden files 2 and 3.
 *       regTestCompareFiles(rp, 2, 3);  // 4
 *
 *       // "Write and check".  This writes a pix using a canonical
 *       // formulation for the local filename and either:
 *       //     case 1: generates a golden file
 *       //     case 2: compares the local file with a golden file
 *       //     case 3: generates local files and displays
 *       // Here we write the pix compressed with png and jpeg, respectively;
 *       // Then check against the golden file.  The internal @index
 *       // is incremented; it is embedded in the local filename and,
 *       // if generating, in the golden file as well.
 *       regTestWritePixAndCheck(rp, pix1, IFF_PNG);  // 5
 *       regTestWritePixAndCheck(rp, pix2, IFF_JFIF_JPEG);  // 6
 *
 *       // Display if reg test was called in 'display' mode
 *       pixDisplayWithTitle(pix1, 100, 100, NULL, rp->display);
 *
 *       // Clean up and output result
 *       regTestCleanup(rp);
 */

/*-------------------------------------------------------------------------*
 *                     Regression test parameter packer                    *
 *-------------------------------------------------------------------------*/
struct L_RegParams
{
    FILE *fp; /* stream to temporary output file for compare mode */
    char *testname; /* name of test, without '_reg'                     */
    char *tempfile; /* name of temp file for compare mode output        */
    l_int32 mode; /* generate, compare or display                     */
    l_int32 index; /* index into saved files for this test; 0-based    */
    l_int32 success; /* overall result of the test                       */
    l_int32 display; /* 1 if in display mode; 0 otherwise                */
    L_TIMER tstart; /* marks beginning of the reg test                  */
};
typedef struct L_RegParams L_REGPARAMS;


    /* Running modes for the test */
enum {
    L_REG_GENERATE = 0,
    L_REG_COMPARE = 1,
    L_REG_DISPLAY = 2
};
# 59 "/usr/local/Cellar/leptonica/1.71_1/include/leptonica/alltypes.h" 2
# 1 "/usr/local/Cellar/leptonica/1.71_1/include/leptonica/sudoku.h" 1
/*====================================================================*
 -  Copyright (C) 2001 Leptonica.  All rights reserved.
 -
 -  Redistribution and use in source and binary forms, with or without
 -  modification, are permitted provided that the following conditions
 -  are met:
 -  1. Redistributions of source code must retain the above copyright
 -     notice, this list of conditions and the following disclaimer.
 -  2. Redistributions in binary form must reproduce the above
 -     copyright notice, this list of conditions and the following
 -     disclaimer in the documentation and/or other materials
 -     provided with the distribution.
 -
 -  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 -  ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 -  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 -  A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL ANY
 -  CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 -  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 -  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 -  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 -  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 -  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 -  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *====================================================================*/




/*
 *  sudoku.h
 *
 *    The L_Sudoku holds all the information of the current state.
 *
 *    The input to sudokuCreate() is a file with any number of lines
 *    starting with '#', followed by 9 lines consisting of 9 numbers
 *    in each line.  These have the known values and use 0 for the unknowns.
 *    Blank lines are ignored.
 *
 *    The @locs array holds the indices of the unknowns, numbered
 *    left-to-right and top-to-bottom from 0 to 80.  The array size
 *    is initialized to @num.  @current is the index into the @locs
 *    array of the current guess: locs[current].
 *
 *    The @state array is used to determine the validity of each guess.
 *    It is of size 81, and is initialized by setting the unknowns to 0
 *    and the knowns to their input values.
 */
struct L_Sudoku
{
    l_int32 num; /* number of unknowns                     */
    l_int32 *locs; /* location of unknowns                   */
    l_int32 current; /* index into @locs of current location   */
    l_int32 *init; /* initial state, with 0 representing     */
                                /* the unknowns                           */
    l_int32 *state; /* present state, including inits and     */
                                /* guesses of unknowns up to @current     */
    l_int32 nguess; /* shows current number of guesses        */
    l_int32 finished; /* set to 1 when solved                   */
    l_int32 failure; /* set to 1 if no solution is possible    */
};
typedef struct L_Sudoku L_SUDOKU;


    /* For printing out array data */
enum {
    L_SUDOKU_INIT = 0,
    L_SUDOKU_STATE = 1
};
# 60 "/usr/local/Cellar/leptonica/1.71_1/include/leptonica/alltypes.h" 2
# 1 "/usr/local/Cellar/leptonica/1.71_1/include/leptonica/watershed.h" 1
/*====================================================================*
 -  Copyright (C) 2001 Leptonica.  All rights reserved.
 -
 -  Redistribution and use in source and binary forms, with or without
 -  modification, are permitted provided that the following conditions
 -  are met:
 -  1. Redistributions of source code must retain the above copyright
 -     notice, this list of conditions and the following disclaimer.
 -  2. Redistributions in binary form must reproduce the above
 -     copyright notice, this list of conditions and the following
 -     disclaimer in the documentation and/or other materials
 -     provided with the distribution.
 -
 -  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 -  ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 -  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 -  A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL ANY
 -  CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 -  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 -  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 -  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 -  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 -  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 -  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *====================================================================*/




/*
 *  watershed.h
 *
 *     Simple data structure to hold watershed data.
 *     All data here is owned by the L_WShed and must be freed.
 */

struct L_WShed
{
    struct Pix *pixs; /* clone of input 8 bpp pixs                */
    struct Pix *pixm; /* clone of input 1 bpp seed (marker) pixm  */
    l_int32 mindepth; /* minimum depth allowed for a watershed    */
    struct Pix *pixlab; /* 16 bpp label pix                         */
    struct Pix *pixt; /* scratch pix for computing wshed regions  */
    void **lines8; /* line ptrs for pixs                       */
    void **linem1; /* line ptrs for pixm                       */
    void **linelab32; /* line ptrs for pixlab                     */
    void **linet1; /* line ptrs for pixt                       */
    struct Pixa *pixad; /* result: 1 bpp pixa of watersheds         */
    struct Pta *ptas; /* pta of initial seed pixels               */
    struct Numa *nasi; /* numa of seed indicators; 0 if completed  */
    struct Numa *nash; /* numa of initial seed heights             */
    struct Numa *namh; /* numa of initial minima heights           */
    struct Numa *nalevels; /* result: numa of watershed levels         */
    l_int32 nseeds; /* number of seeds (markers)                */
    l_int32 nother; /* number of minima different from seeds    */
    l_int32 *lut; /* lut for pixel indices                    */
    struct Numa **links; /* back-links into lut, for updates         */
    l_int32 arraysize; /* size of links array                      */
    l_int32 debug; /* set to 1 for debug output                */
};
typedef struct L_WShed L_WSHED;
# 61 "/usr/local/Cellar/leptonica/1.71_1/include/leptonica/alltypes.h" 2
# 35 "/usr/local/Cellar/leptonica/1.71_1/include/leptonica/allheaders.h" 2


/*
 *  These prototypes were autogen'd by xtractprotos, v. 1.5
 */

extern "C" {


         extern PIX * pixBackgroundNormSimple ( PIX *pixs, PIX *pixim, PIX *pixg );
         extern PIX * pixBackgroundNorm ( PIX *pixs, PIX *pixim, PIX *pixg, l_int32 sx, l_int32 sy, l_int32 thresh, l_int32 mincount, l_int32 bgval, l_int32 smoothx, l_int32 smoothy );
         extern PIX * pixBackgroundNormMorph ( PIX *pixs, PIX *pixim, l_int32 reduction, l_int32 size, l_int32 bgval );
         extern l_int32 pixBackgroundNormGrayArray ( PIX *pixs, PIX *pixim, l_int32 sx, l_int32 sy, l_int32 thresh, l_int32 mincount, l_int32 bgval, l_int32 smoothx, l_int32 smoothy, PIX **ppixd );
         extern l_int32 pixBackgroundNormRGBArrays ( PIX *pixs, PIX *pixim, PIX *pixg, l_int32 sx, l_int32 sy, l_int32 thresh, l_int32 mincount, l_int32 bgval, l_int32 smoothx, l_int32 smoothy, PIX **ppixr, PIX **ppixg, PIX **ppixb );
         extern l_int32 pixBackgroundNormGrayArrayMorph ( PIX *pixs, PIX *pixim, l_int32 reduction, l_int32 size, l_int32 bgval, PIX **ppixd );
         extern l_int32 pixBackgroundNormRGBArraysMorph ( PIX *pixs, PIX *pixim, l_int32 reduction, l_int32 size, l_int32 bgval, PIX **ppixr, PIX **ppixg, PIX **ppixb );
         extern l_int32 pixGetBackgroundGrayMap ( PIX *pixs, PIX *pixim, l_int32 sx, l_int32 sy, l_int32 thresh, l_int32 mincount, PIX **ppixd );
         extern l_int32 pixGetBackgroundRGBMap ( PIX *pixs, PIX *pixim, PIX *pixg, l_int32 sx, l_int32 sy, l_int32 thresh, l_int32 mincount, PIX **ppixmr, PIX **ppixmg, PIX **ppixmb );
         extern l_int32 pixGetBackgroundGrayMapMorph ( PIX *pixs, PIX *pixim, l_int32 reduction, l_int32 size, PIX **ppixm );
         extern l_int32 pixGetBackgroundRGBMapMorph ( PIX *pixs, PIX *pixim, l_int32 reduction, l_int32 size, PIX **ppixmr, PIX **ppixmg, PIX **ppixmb );
         extern l_int32 pixFillMapHoles ( PIX *pix, l_int32 nx, l_int32 ny, l_int32 filltype );
         extern PIX * pixExtendByReplication ( PIX *pixs, l_int32 addw, l_int32 addh );
         extern l_int32 pixSmoothConnectedRegions ( PIX *pixs, PIX *pixm, l_int32 factor );
         extern PIX * pixGetInvBackgroundMap ( PIX *pixs, l_int32 bgval, l_int32 smoothx, l_int32 smoothy );
         extern PIX * pixApplyInvBackgroundGrayMap ( PIX *pixs, PIX *pixm, l_int32 sx, l_int32 sy );
         extern PIX * pixApplyInvBackgroundRGBMap ( PIX *pixs, PIX *pixmr, PIX *pixmg, PIX *pixmb, l_int32 sx, l_int32 sy );
         extern PIX * pixApplyVariableGrayMap ( PIX *pixs, PIX *pixg, l_int32 target );
         extern PIX * pixGlobalNormRGB ( PIX *pixd, PIX *pixs, l_int32 rval, l_int32 gval, l_int32 bval, l_int32 mapval );
         extern PIX * pixGlobalNormNoSatRGB ( PIX *pixd, PIX *pixs, l_int32 rval, l_int32 gval, l_int32 bval, l_int32 factor, l_float32 rank );
         extern l_int32 pixThresholdSpreadNorm ( PIX *pixs, l_int32 filtertype, l_int32 edgethresh, l_int32 smoothx, l_int32 smoothy, l_float32 gamma, l_int32 minval, l_int32 maxval, l_int32 targetthresh, PIX **ppixth, PIX **ppixb, PIX **ppixd );
         extern PIX * pixBackgroundNormFlex ( PIX *pixs, l_int32 sx, l_int32 sy, l_int32 smoothx, l_int32 smoothy, l_int32 delta );
         extern PIX * pixContrastNorm ( PIX *pixd, PIX *pixs, l_int32 sx, l_int32 sy, l_int32 mindiff, l_int32 smoothx, l_int32 smoothy );
         extern l_int32 pixMinMaxTiles ( PIX *pixs, l_int32 sx, l_int32 sy, l_int32 mindiff, l_int32 smoothx, l_int32 smoothy, PIX **ppixmin, PIX **ppixmax );
         extern l_int32 pixSetLowContrast ( PIX *pixs1, PIX *pixs2, l_int32 mindiff );
         extern PIX * pixLinearTRCTiled ( PIX *pixd, PIX *pixs, l_int32 sx, l_int32 sy, PIX *pixmin, PIX *pixmax );
         extern PIX * pixAffineSampledPta ( PIX *pixs, PTA *ptad, PTA *ptas, l_int32 incolor );
         extern PIX * pixAffineSampled ( PIX *pixs, l_float32 *vc, l_int32 incolor );
         extern PIX * pixAffinePta ( PIX *pixs, PTA *ptad, PTA *ptas, l_int32 incolor );
         extern PIX * pixAffine ( PIX *pixs, l_float32 *vc, l_int32 incolor );
         extern PIX * pixAffinePtaColor ( PIX *pixs, PTA *ptad, PTA *ptas, l_uint32 colorval );
         extern PIX * pixAffineColor ( PIX *pixs, l_float32 *vc, l_uint32 colorval );
         extern PIX * pixAffinePtaGray ( PIX *pixs, PTA *ptad, PTA *ptas, l_uint8 grayval );
         extern PIX * pixAffineGray ( PIX *pixs, l_float32 *vc, l_uint8 grayval );
         extern PIX * pixAffinePtaWithAlpha ( PIX *pixs, PTA *ptad, PTA *ptas, PIX *pixg, l_float32 fract, l_int32 border );
         extern l_int32 getAffineXformCoeffs ( PTA *ptas, PTA *ptad, l_float32 **pvc );
         extern l_int32 affineInvertXform ( l_float32 *vc, l_float32 **pvci );
         extern l_int32 affineXformSampledPt ( l_float32 *vc, l_int32 x, l_int32 y, l_int32 *pxp, l_int32 *pyp );
         extern l_int32 affineXformPt ( l_float32 *vc, l_int32 x, l_int32 y, l_float32 *pxp, l_float32 *pyp );
         extern l_int32 linearInterpolatePixelColor ( l_uint32 *datas, l_int32 wpls, l_int32 w, l_int32 h, l_float32 x, l_float32 y, l_uint32 colorval, l_uint32 *pval );
         extern l_int32 linearInterpolatePixelGray ( l_uint32 *datas, l_int32 wpls, l_int32 w, l_int32 h, l_float32 x, l_float32 y, l_int32 grayval, l_int32 *pval );
         extern l_int32 gaussjordan ( l_float32 **a, l_float32 *b, l_int32 n );
         extern PIX * pixAffineSequential ( PIX *pixs, PTA *ptad, PTA *ptas, l_int32 bw, l_int32 bh );
         extern l_float32 * createMatrix2dTranslate ( l_float32 transx, l_float32 transy );
         extern l_float32 * createMatrix2dScale ( l_float32 scalex, l_float32 scaley );
         extern l_float32 * createMatrix2dRotate ( l_float32 xc, l_float32 yc, l_float32 angle );
         extern PTA * ptaTranslate ( PTA *ptas, l_float32 transx, l_float32 transy );
         extern PTA * ptaScale ( PTA *ptas, l_float32 scalex, l_float32 scaley );
         extern PTA * ptaRotate ( PTA *ptas, l_float32 xc, l_float32 yc, l_float32 angle );
         extern BOXA * boxaTranslate ( BOXA *boxas, l_float32 transx, l_float32 transy );
         extern BOXA * boxaScale ( BOXA *boxas, l_float32 scalex, l_float32 scaley );
         extern BOXA * boxaRotate ( BOXA *boxas, l_float32 xc, l_float32 yc, l_float32 angle );
         extern PTA * ptaAffineTransform ( PTA *ptas, l_float32 *mat );
         extern BOXA * boxaAffineTransform ( BOXA *boxas, l_float32 *mat );
         extern l_int32 l_productMatVec ( l_float32 *mat, l_float32 *vecs, l_float32 *vecd, l_int32 size );
         extern l_int32 l_productMat2 ( l_float32 *mat1, l_float32 *mat2, l_float32 *matd, l_int32 size );
         extern l_int32 l_productMat3 ( l_float32 *mat1, l_float32 *mat2, l_float32 *mat3, l_float32 *matd, l_int32 size );
         extern l_int32 l_productMat4 ( l_float32 *mat1, l_float32 *mat2, l_float32 *mat3, l_float32 *mat4, l_float32 *matd, l_int32 size );
         extern l_int32 l_getDataBit ( void *line, l_int32 n );
         extern void l_setDataBit ( void *line, l_int32 n );
         extern void l_clearDataBit ( void *line, l_int32 n );
         extern void l_setDataBitVal ( void *line, l_int32 n, l_int32 val );
         extern l_int32 l_getDataDibit ( void *line, l_int32 n );
         extern void l_setDataDibit ( void *line, l_int32 n, l_int32 val );
         extern void l_clearDataDibit ( void *line, l_int32 n );
         extern l_int32 l_getDataQbit ( void *line, l_int32 n );
         extern void l_setDataQbit ( void *line, l_int32 n, l_int32 val );
         extern void l_clearDataQbit ( void *line, l_int32 n );
         extern l_int32 l_getDataByte ( void *line, l_int32 n );
         extern void l_setDataByte ( void *line, l_int32 n, l_int32 val );
         extern l_int32 l_getDataTwoBytes ( void *line, l_int32 n );
         extern void l_setDataTwoBytes ( void *line, l_int32 n, l_int32 val );
         extern l_int32 l_getDataFourBytes ( void *line, l_int32 n );
         extern void l_setDataFourBytes ( void *line, l_int32 n, l_int32 val );
         extern char * barcodeDispatchDecoder ( char *barstr, l_int32 format, l_int32 debugflag );
         extern l_int32 barcodeFormatIsSupported ( l_int32 format );
         extern NUMA * pixFindBaselines ( PIX *pixs, PTA **ppta, l_int32 debug );
         extern PIX * pixDeskewLocal ( PIX *pixs, l_int32 nslices, l_int32 redsweep, l_int32 redsearch, l_float32 sweeprange, l_float32 sweepdelta, l_float32 minbsdelta );
         extern l_int32 pixGetLocalSkewTransform ( PIX *pixs, l_int32 nslices, l_int32 redsweep, l_int32 redsearch, l_float32 sweeprange, l_float32 sweepdelta, l_float32 minbsdelta, PTA **pptas, PTA **pptad );
         extern NUMA * pixGetLocalSkewAngles ( PIX *pixs, l_int32 nslices, l_int32 redsweep, l_int32 redsearch, l_float32 sweeprange, l_float32 sweepdelta, l_float32 minbsdelta, l_float32 *pa, l_float32 *pb );
         extern BBUFFER * bbufferCreate ( l_uint8 *indata, l_int32 nalloc );
         extern void bbufferDestroy ( BBUFFER **pbb );
         extern l_uint8 * bbufferDestroyAndSaveData ( BBUFFER **pbb, size_t *pnbytes );
         extern l_int32 bbufferRead ( BBUFFER *bb, l_uint8 *src, l_int32 nbytes );
         extern l_int32 bbufferReadStream ( BBUFFER *bb, FILE *fp, l_int32 nbytes );
         extern l_int32 bbufferExtendArray ( BBUFFER *bb, l_int32 nbytes );
         extern l_int32 bbufferWrite ( BBUFFER *bb, l_uint8 *dest, size_t nbytes, size_t *pnout );
         extern l_int32 bbufferWriteStream ( BBUFFER *bb, FILE *fp, size_t nbytes, size_t *pnout );
         extern l_int32 bbufferBytesToWrite ( BBUFFER *bb, size_t *pnbytes );
         extern PIX * pixBilateral ( PIX *pixs, l_float32 spatial_stdev, l_float32 range_stdev, l_int32 ncomps, l_int32 reduction );
         extern PIX * pixBilateralGray ( PIX *pixs, l_float32 spatial_stdev, l_float32 range_stdev, l_int32 ncomps, l_int32 reduction );
         extern PIX * pixBilateralExact ( PIX *pixs, L_KERNEL *spatial_kel, L_KERNEL *range_kel );
         extern PIX * pixBilateralGrayExact ( PIX *pixs, L_KERNEL *spatial_kel, L_KERNEL *range_kel );
         extern PIX* pixBlockBilateralExact ( PIX *pixs, l_float32 spatial_stdev, l_float32 range_stdev );
         extern L_KERNEL * makeRangeKernel ( l_float32 range_stdev );
         extern PIX * pixBilinearSampledPta ( PIX *pixs, PTA *ptad, PTA *ptas, l_int32 incolor );
         extern PIX * pixBilinearSampled ( PIX *pixs, l_float32 *vc, l_int32 incolor );
         extern PIX * pixBilinearPta ( PIX *pixs, PTA *ptad, PTA *ptas, l_int32 incolor );
         extern PIX * pixBilinear ( PIX *pixs, l_float32 *vc, l_int32 incolor );
         extern PIX * pixBilinearPtaColor ( PIX *pixs, PTA *ptad, PTA *ptas, l_uint32 colorval );
         extern PIX * pixBilinearColor ( PIX *pixs, l_float32 *vc, l_uint32 colorval );
         extern PIX * pixBilinearPtaGray ( PIX *pixs, PTA *ptad, PTA *ptas, l_uint8 grayval );
         extern PIX * pixBilinearGray ( PIX *pixs, l_float32 *vc, l_uint8 grayval );
         extern PIX * pixBilinearPtaWithAlpha ( PIX *pixs, PTA *ptad, PTA *ptas, PIX *pixg, l_float32 fract, l_int32 border );
         extern l_int32 getBilinearXformCoeffs ( PTA *ptas, PTA *ptad, l_float32 **pvc );
         extern l_int32 bilinearXformSampledPt ( l_float32 *vc, l_int32 x, l_int32 y, l_int32 *pxp, l_int32 *pyp );
         extern l_int32 bilinearXformPt ( l_float32 *vc, l_int32 x, l_int32 y, l_float32 *pxp, l_float32 *pyp );
         extern l_int32 pixOtsuAdaptiveThreshold ( PIX *pixs, l_int32 sx, l_int32 sy, l_int32 smoothx, l_int32 smoothy, l_float32 scorefract, PIX **ppixth, PIX **ppixd );
         extern PIX * pixOtsuThreshOnBackgroundNorm ( PIX *pixs, PIX *pixim, l_int32 sx, l_int32 sy, l_int32 thresh, l_int32 mincount, l_int32 bgval, l_int32 smoothx, l_int32 smoothy, l_float32 scorefract, l_int32 *pthresh );
         extern PIX * pixMaskedThreshOnBackgroundNorm ( PIX *pixs, PIX *pixim, l_int32 sx, l_int32 sy, l_int32 thresh, l_int32 mincount, l_int32 smoothx, l_int32 smoothy, l_float32 scorefract, l_int32 *pthresh );
         extern l_int32 pixSauvolaBinarizeTiled ( PIX *pixs, l_int32 whsize, l_float32 factor, l_int32 nx, l_int32 ny, PIX **ppixth, PIX **ppixd );
         extern l_int32 pixSauvolaBinarize ( PIX *pixs, l_int32 whsize, l_float32 factor, l_int32 addborder, PIX **ppixm, PIX **ppixsd, PIX **ppixth, PIX **ppixd );
         extern PIX * pixSauvolaGetThreshold ( PIX *pixm, PIX *pixms, l_float32 factor, PIX **ppixsd );
         extern PIX * pixApplyLocalThreshold ( PIX *pixs, PIX *pixth, l_int32 redfactor );
         extern l_int32 pixThresholdByConnComp ( PIX *pixs, PIX *pixm, l_int32 start, l_int32 end, l_int32 incr, l_float32 thresh48, l_float32 threshdiff, l_int32 *pglobthresh, PIX **ppixd, l_int32 debugflag );
         extern PIX * pixExpandBinaryReplicate ( PIX *pixs, l_int32 factor );
         extern PIX * pixExpandBinaryPower2 ( PIX *pixs, l_int32 factor );
         extern PIX * pixReduceBinary2 ( PIX *pixs, l_uint8 *intab );
         extern PIX * pixReduceRankBinaryCascade ( PIX *pixs, l_int32 level1, l_int32 level2, l_int32 level3, l_int32 level4 );
         extern PIX * pixReduceRankBinary2 ( PIX *pixs, l_int32 level, l_uint8 *intab );
         extern l_uint8 * makeSubsampleTab2x ( void );
         extern PIX * pixBlend ( PIX *pixs1, PIX *pixs2, l_int32 x, l_int32 y, l_float32 fract );
         extern PIX * pixBlendMask ( PIX *pixd, PIX *pixs1, PIX *pixs2, l_int32 x, l_int32 y, l_float32 fract, l_int32 type );
         extern PIX * pixBlendGray ( PIX *pixd, PIX *pixs1, PIX *pixs2, l_int32 x, l_int32 y, l_float32 fract, l_int32 type, l_int32 transparent, l_uint32 transpix );
         extern PIX * pixBlendGrayInverse ( PIX *pixd, PIX *pixs1, PIX *pixs2, l_int32 x, l_int32 y, l_float32 fract );
         extern PIX * pixBlendColor ( PIX *pixd, PIX *pixs1, PIX *pixs2, l_int32 x, l_int32 y, l_float32 fract, l_int32 transparent, l_uint32 transpix );
         extern PIX * pixBlendColorByChannel ( PIX *pixd, PIX *pixs1, PIX *pixs2, l_int32 x, l_int32 y, l_float32 rfract, l_float32 gfract, l_float32 bfract, l_int32 transparent, l_uint32 transpix );
         extern PIX * pixBlendGrayAdapt ( PIX *pixd, PIX *pixs1, PIX *pixs2, l_int32 x, l_int32 y, l_float32 fract, l_int32 shift );
         extern PIX * pixFadeWithGray ( PIX *pixs, PIX *pixb, l_float32 factor, l_int32 type );
         extern PIX * pixBlendHardLight ( PIX *pixd, PIX *pixs1, PIX *pixs2, l_int32 x, l_int32 y, l_float32 fract );
         extern l_int32 pixBlendCmap ( PIX *pixs, PIX *pixb, l_int32 x, l_int32 y, l_int32 sindex );
         extern PIX * pixBlendWithGrayMask ( PIX *pixs1, PIX *pixs2, PIX *pixg, l_int32 x, l_int32 y );
         extern PIX * pixBlendBackgroundToColor ( PIX *pixd, PIX *pixs, BOX *box, l_uint32 color, l_float32 gamma, l_int32 minval, l_int32 maxval );
         extern PIX * pixMultiplyByColor ( PIX *pixd, PIX *pixs, BOX *box, l_uint32 color );
         extern PIX * pixAlphaBlendUniform ( PIX *pixs, l_uint32 color );
         extern PIX * pixAddAlphaToBlend ( PIX *pixs, l_float32 fract, l_int32 invert );
         extern PIX * pixSetAlphaOverWhite ( PIX *pixs );
         extern L_BMF * bmfCreate ( const char *dir, l_int32 size );
         extern void bmfDestroy ( L_BMF **pbmf );
         extern PIX * bmfGetPix ( L_BMF *bmf, char chr );
         extern l_int32 bmfGetWidth ( L_BMF *bmf, char chr, l_int32 *pw );
         extern l_int32 bmfGetBaseline ( L_BMF *bmf, char chr, l_int32 *pbaseline );
         extern PIXA * pixaGetFont ( const char *dir, l_int32 size, l_int32 *pbl0, l_int32 *pbl1, l_int32 *pbl2 );
         extern l_int32 pixaSaveFont ( const char *indir, const char *outdir, l_int32 size );
         extern PIXA * pixaGenerateFont ( const char *dir, l_int32 size, l_int32 *pbl0, l_int32 *pbl1, l_int32 *pbl2 );
         extern PIX * pixReadStreamBmp ( FILE *fp );
         extern l_int32 pixWriteStreamBmp ( FILE *fp, PIX *pix );
         extern PIX * pixReadMemBmp ( const l_uint8 *cdata, size_t size );
         extern l_int32 pixWriteMemBmp ( l_uint8 **pdata, size_t *psize, PIX *pix );
         extern BOX * boxCreate ( l_int32 x, l_int32 y, l_int32 w, l_int32 h );
         extern BOX * boxCreateValid ( l_int32 x, l_int32 y, l_int32 w, l_int32 h );
         extern BOX * boxCopy ( BOX *box );
         extern BOX * boxClone ( BOX *box );
         extern void boxDestroy ( BOX **pbox );
         extern l_int32 boxGetGeometry ( BOX *box, l_int32 *px, l_int32 *py, l_int32 *pw, l_int32 *ph );
         extern l_int32 boxSetGeometry ( BOX *box, l_int32 x, l_int32 y, l_int32 w, l_int32 h );
         extern l_int32 boxGetSideLocation ( BOX *box, l_int32 side, l_int32 *ploc );
         extern l_int32 boxGetRefcount ( BOX *box );
         extern l_int32 boxChangeRefcount ( BOX *box, l_int32 delta );
         extern l_int32 boxIsValid ( BOX *box, l_int32 *pvalid );
         extern BOXA * boxaCreate ( l_int32 n );
         extern BOXA * boxaCopy ( BOXA *boxa, l_int32 copyflag );
         extern void boxaDestroy ( BOXA **pboxa );
         extern l_int32 boxaAddBox ( BOXA *boxa, BOX *box, l_int32 copyflag );
         extern l_int32 boxaExtendArray ( BOXA *boxa );
         extern l_int32 boxaExtendArrayToSize ( BOXA *boxa, l_int32 size );
         extern l_int32 boxaGetCount ( BOXA *boxa );
         extern l_int32 boxaGetValidCount ( BOXA *boxa );
         extern BOX * boxaGetBox ( BOXA *boxa, l_int32 index, l_int32 accessflag );
         extern BOX * boxaGetValidBox ( BOXA *boxa, l_int32 index, l_int32 accessflag );
         extern l_int32 boxaGetBoxGeometry ( BOXA *boxa, l_int32 index, l_int32 *px, l_int32 *py, l_int32 *pw, l_int32 *ph );
         extern l_int32 boxaIsFull ( BOXA *boxa, l_int32 *pfull );
         extern l_int32 boxaReplaceBox ( BOXA *boxa, l_int32 index, BOX *box );
         extern l_int32 boxaInsertBox ( BOXA *boxa, l_int32 index, BOX *box );
         extern l_int32 boxaRemoveBox ( BOXA *boxa, l_int32 index );
         extern l_int32 boxaRemoveBoxAndSave ( BOXA *boxa, l_int32 index, BOX **pbox );
         extern BOXA * boxaSaveValid ( BOXA *boxas, l_int32 copyflag );
         extern l_int32 boxaInitFull ( BOXA *boxa, BOX *box );
         extern l_int32 boxaClear ( BOXA *boxa );
         extern BOXAA * boxaaCreate ( l_int32 n );
         extern BOXAA * boxaaCopy ( BOXAA *baas, l_int32 copyflag );
         extern void boxaaDestroy ( BOXAA **pbaa );
         extern l_int32 boxaaAddBoxa ( BOXAA *baa, BOXA *ba, l_int32 copyflag );
         extern l_int32 boxaaExtendArray ( BOXAA *baa );
         extern l_int32 boxaaExtendArrayToSize ( BOXAA *baa, l_int32 size );
         extern l_int32 boxaaGetCount ( BOXAA *baa );
         extern l_int32 boxaaGetBoxCount ( BOXAA *baa );
         extern BOXA * boxaaGetBoxa ( BOXAA *baa, l_int32 index, l_int32 accessflag );
         extern BOX * boxaaGetBox ( BOXAA *baa, l_int32 iboxa, l_int32 ibox, l_int32 accessflag );
         extern l_int32 boxaaInitFull ( BOXAA *baa, BOXA *boxa );
         extern l_int32 boxaaExtendWithInit ( BOXAA *baa, l_int32 maxindex, BOXA *boxa );
         extern l_int32 boxaaReplaceBoxa ( BOXAA *baa, l_int32 index, BOXA *boxa );
         extern l_int32 boxaaInsertBoxa ( BOXAA *baa, l_int32 index, BOXA *boxa );
         extern l_int32 boxaaRemoveBoxa ( BOXAA *baa, l_int32 index );
         extern l_int32 boxaaAddBox ( BOXAA *baa, l_int32 index, BOX *box, l_int32 accessflag );
         extern BOXAA * boxaaReadFromFiles ( const char *dirname, const char *substr, l_int32 first, l_int32 nfiles );
         extern BOXAA * boxaaRead ( const char *filename );
         extern BOXAA * boxaaReadStream ( FILE *fp );
         extern l_int32 boxaaWrite ( const char *filename, BOXAA *baa );
         extern l_int32 boxaaWriteStream ( FILE *fp, BOXAA *baa );
         extern BOXA * boxaRead ( const char *filename );
         extern BOXA * boxaReadStream ( FILE *fp );
         extern BOXA * boxaReadMem ( const l_uint8 *data, size_t size );
         extern l_int32 boxaWrite ( const char *filename, BOXA *boxa );
         extern l_int32 boxaWriteStream ( FILE *fp, BOXA *boxa );
         extern l_int32 boxaWriteMem ( l_uint8 **pdata, size_t *psize, BOXA *boxa );
         extern l_int32 boxPrintStreamInfo ( FILE *fp, BOX *box );
         extern l_int32 boxContains ( BOX *box1, BOX *box2, l_int32 *presult );
         extern l_int32 boxIntersects ( BOX *box1, BOX *box2, l_int32 *presult );
         extern BOXA * boxaContainedInBox ( BOXA *boxas, BOX *box );
         extern BOXA * boxaIntersectsBox ( BOXA *boxas, BOX *box );
         extern BOXA * boxaClipToBox ( BOXA *boxas, BOX *box );
         extern BOXA * boxaCombineOverlaps ( BOXA *boxas );
         extern BOX * boxOverlapRegion ( BOX *box1, BOX *box2 );
         extern BOX * boxBoundingRegion ( BOX *box1, BOX *box2 );
         extern l_int32 boxOverlapFraction ( BOX *box1, BOX *box2, l_float32 *pfract );
         extern l_int32 boxOverlapArea ( BOX *box1, BOX *box2, l_int32 *parea );
         extern BOXA * boxaHandleOverlaps ( BOXA *boxas, l_int32 op, l_int32 range, l_float32 min_overlap, l_float32 max_ratio, NUMA **pnamap );
         extern l_int32 boxSeparationDistance ( BOX *box1, BOX *box2, l_int32 *ph_sep, l_int32 *pv_sep );
         extern l_int32 boxContainsPt ( BOX *box, l_float32 x, l_float32 y, l_int32 *pcontains );
         extern BOX * boxaGetNearestToPt ( BOXA *boxa, l_int32 x, l_int32 y );
         extern l_int32 boxGetCenter ( BOX *box, l_float32 *pcx, l_float32 *pcy );
         extern l_int32 boxIntersectByLine ( BOX *box, l_int32 x, l_int32 y, l_float32 slope, l_int32 *px1, l_int32 *py1, l_int32 *px2, l_int32 *py2, l_int32 *pn );
         extern BOX * boxClipToRectangle ( BOX *box, l_int32 wi, l_int32 hi );
         extern l_int32 boxClipToRectangleParams ( BOX *box, l_int32 w, l_int32 h, l_int32 *pxstart, l_int32 *pystart, l_int32 *pxend, l_int32 *pyend, l_int32 *pbw, l_int32 *pbh );
         extern BOX * boxRelocateOneSide ( BOX *boxd, BOX *boxs, l_int32 loc, l_int32 sideflag );
         extern BOX * boxAdjustSides ( BOX *boxd, BOX *boxs, l_int32 delleft, l_int32 delright, l_int32 deltop, l_int32 delbot );
         extern BOXA * boxaSetSide ( BOXA *boxad, BOXA *boxas, l_int32 side, l_int32 val, l_int32 thresh );
         extern BOXA * boxaAdjustWidthToTarget ( BOXA *boxad, BOXA *boxas, l_int32 sides, l_int32 target, l_int32 thresh );
         extern BOXA * boxaAdjustHeightToTarget ( BOXA *boxad, BOXA *boxas, l_int32 sides, l_int32 target, l_int32 thresh );
         extern l_int32 boxEqual ( BOX *box1, BOX *box2, l_int32 *psame );
         extern l_int32 boxaEqual ( BOXA *boxa1, BOXA *boxa2, l_int32 maxdist, NUMA **pnaindex, l_int32 *psame );
         extern l_int32 boxSimilar ( BOX *box1, BOX *box2, l_int32 leftdiff, l_int32 rightdiff, l_int32 topdiff, l_int32 botdiff, l_int32 *psimilar );
         extern l_int32 boxaSimilar ( BOXA *boxa1, BOXA *boxa2, l_int32 leftdiff, l_int32 rightdiff, l_int32 topdiff, l_int32 botdiff, l_int32 debugflag, l_int32 *psimilar );
         extern l_int32 boxaJoin ( BOXA *boxad, BOXA *boxas, l_int32 istart, l_int32 iend );
         extern l_int32 boxaaJoin ( BOXAA *baad, BOXAA *baas, l_int32 istart, l_int32 iend );
         extern l_int32 boxaSplitEvenOdd ( BOXA *boxa, l_int32 fillflag, BOXA **pboxae, BOXA **pboxao );
         extern BOXA * boxaMergeEvenOdd ( BOXA *boxae, BOXA *boxao, l_int32 fillflag );
         extern BOXA * boxaTransform ( BOXA *boxas, l_int32 shiftx, l_int32 shifty, l_float32 scalex, l_float32 scaley );
         extern BOX * boxTransform ( BOX *box, l_int32 shiftx, l_int32 shifty, l_float32 scalex, l_float32 scaley );
         extern BOXA * boxaTransformOrdered ( BOXA *boxas, l_int32 shiftx, l_int32 shifty, l_float32 scalex, l_float32 scaley, l_int32 xcen, l_int32 ycen, l_float32 angle, l_int32 order );
         extern BOX * boxTransformOrdered ( BOX *boxs, l_int32 shiftx, l_int32 shifty, l_float32 scalex, l_float32 scaley, l_int32 xcen, l_int32 ycen, l_float32 angle, l_int32 order );
         extern BOXA * boxaRotateOrth ( BOXA *boxas, l_int32 w, l_int32 h, l_int32 rotation );
         extern BOX * boxRotateOrth ( BOX *box, l_int32 w, l_int32 h, l_int32 rotation );
         extern BOXA * boxaSort ( BOXA *boxas, l_int32 sorttype, l_int32 sortorder, NUMA **pnaindex );
         extern BOXA * boxaBinSort ( BOXA *boxas, l_int32 sorttype, l_int32 sortorder, NUMA **pnaindex );
         extern BOXA * boxaSortByIndex ( BOXA *boxas, NUMA *naindex );
         extern BOXAA * boxaSort2d ( BOXA *boxas, NUMAA **pnaad, l_int32 delta1, l_int32 delta2, l_int32 minh1 );
         extern BOXAA * boxaSort2dByIndex ( BOXA *boxas, NUMAA *naa );
         extern l_int32 boxaExtractAsNuma ( BOXA *boxa, NUMA **pnax, NUMA **pnay, NUMA **pnaw, NUMA **pnah, l_int32 keepinvalid );
         extern l_int32 boxaExtractAsPta ( BOXA *boxa, PTA **pptal, PTA **pptat, PTA **pptar, PTA **pptab, l_int32 keepinvalid );
         extern BOX * boxaGetRankSize ( BOXA *boxa, l_float32 fract );
         extern BOX * boxaGetMedian ( BOXA *boxa );
         extern l_int32 boxaGetAverageSize ( BOXA *boxa, l_float32 *pw, l_float32 *ph );
         extern l_int32 boxaaGetExtent ( BOXAA *baa, l_int32 *pw, l_int32 *ph, BOX **pbox, BOXA **pboxa );
         extern BOXA * boxaaFlattenToBoxa ( BOXAA *baa, NUMA **pnaindex, l_int32 copyflag );
         extern BOXA * boxaaFlattenAligned ( BOXAA *baa, l_int32 num, BOX *fillerbox, l_int32 copyflag );
         extern BOXAA * boxaEncapsulateAligned ( BOXA *boxa, l_int32 num, l_int32 copyflag );
         extern l_int32 boxaaAlignBox ( BOXAA *baa, BOX *box, l_int32 delta, l_int32 *pindex );
         extern PIX * pixMaskConnComp ( PIX *pixs, l_int32 connectivity, BOXA **pboxa );
         extern PIX * pixMaskBoxa ( PIX *pixd, PIX *pixs, BOXA *boxa, l_int32 op );
         extern PIX * pixPaintBoxa ( PIX *pixs, BOXA *boxa, l_uint32 val );
         extern PIX * pixSetBlackOrWhiteBoxa ( PIX *pixs, BOXA *boxa, l_int32 op );
         extern PIX * pixPaintBoxaRandom ( PIX *pixs, BOXA *boxa );
         extern PIX * pixBlendBoxaRandom ( PIX *pixs, BOXA *boxa, l_float32 fract );
         extern PIX * pixDrawBoxa ( PIX *pixs, BOXA *boxa, l_int32 width, l_uint32 val );
         extern PIX * pixDrawBoxaRandom ( PIX *pixs, BOXA *boxa, l_int32 width );
         extern PIX * boxaaDisplay ( BOXAA *baa, l_int32 linewba, l_int32 linewb, l_uint32 colorba, l_uint32 colorb, l_int32 w, l_int32 h );
         extern BOXA * pixSplitIntoBoxa ( PIX *pixs, l_int32 minsum, l_int32 skipdist, l_int32 delta, l_int32 maxbg, l_int32 maxcomps, l_int32 remainder );
         extern BOXA * pixSplitComponentIntoBoxa ( PIX *pix, BOX *box, l_int32 minsum, l_int32 skipdist, l_int32 delta, l_int32 maxbg, l_int32 maxcomps, l_int32 remainder );
         extern BOXA * makeMosaicStrips ( l_int32 w, l_int32 h, l_int32 direction, l_int32 size );
         extern l_int32 boxaCompareRegions ( BOXA *boxa1, BOXA *boxa2, l_int32 areathresh, l_int32 *pnsame, l_float32 *pdiffarea, l_float32 *pdiffxor, PIX **ppixdb );
         extern BOXA * boxaSelectRange ( BOXA *boxas, l_int32 first, l_int32 last, l_int32 copyflag );
         extern BOXAA * boxaaSelectRange ( BOXAA *baas, l_int32 first, l_int32 last, l_int32 copyflag );
         extern BOXA * boxaSelectBySize ( BOXA *boxas, l_int32 width, l_int32 height, l_int32 type, l_int32 relation, l_int32 *pchanged );
         extern NUMA * boxaMakeSizeIndicator ( BOXA *boxa, l_int32 width, l_int32 height, l_int32 type, l_int32 relation );
         extern BOXA * boxaSelectByArea ( BOXA *boxas, l_int32 area, l_int32 relation, l_int32 *pchanged );
         extern NUMA * boxaMakeAreaIndicator ( BOXA *boxa, l_int32 area, l_int32 relation );
         extern BOXA * boxaSelectWithIndicator ( BOXA *boxas, NUMA *na, l_int32 *pchanged );
         extern BOXA * boxaPermutePseudorandom ( BOXA *boxas );
         extern BOXA * boxaPermuteRandom ( BOXA *boxad, BOXA *boxas );
         extern l_int32 boxaSwapBoxes ( BOXA *boxa, l_int32 i, l_int32 j );
         extern PTA * boxaConvertToPta ( BOXA *boxa, l_int32 ncorners );
         extern BOXA * ptaConvertToBoxa ( PTA *pta, l_int32 ncorners );
         extern BOXA * boxaSmoothSequence ( BOXA *boxas, l_float32 factor, l_int32 subflag, l_int32 maxdiff, l_int32 debug );
         extern BOXA * boxaLinearFit ( BOXA *boxas, l_float32 factor, l_int32 debug );
         extern BOXA * boxaModifyWithBoxa ( BOXA *boxas, BOXA *boxam, l_int32 subflag, l_int32 maxdiff );
         extern BOXA * boxaConstrainSize ( BOXA *boxas, l_int32 width, l_int32 widthflag, l_int32 height, l_int32 heightflag );
         extern BOXA * boxaReconcileEvenOddHeight ( BOXA *boxas, l_int32 sides, l_int32 delh, l_int32 op, l_float32 factor );
         extern l_int32 boxaPlotSides ( BOXA *boxa, const char *plotname, NUMA **pnal, NUMA **pnat, NUMA **pnar, NUMA **pnab, l_int32 outformat );
         extern l_int32 boxaGetExtent ( BOXA *boxa, l_int32 *pw, l_int32 *ph, BOX **pbox );
         extern l_int32 boxaGetCoverage ( BOXA *boxa, l_int32 wc, l_int32 hc, l_int32 exactflag, l_float32 *pfract );
         extern l_int32 boxaaSizeRange ( BOXAA *baa, l_int32 *pminw, l_int32 *pminh, l_int32 *pmaxw, l_int32 *pmaxh );
         extern l_int32 boxaSizeRange ( BOXA *boxa, l_int32 *pminw, l_int32 *pminh, l_int32 *pmaxw, l_int32 *pmaxh );
         extern l_int32 boxaLocationRange ( BOXA *boxa, l_int32 *pminx, l_int32 *pminy, l_int32 *pmaxx, l_int32 *pmaxy );
         extern l_int32 boxaGetArea ( BOXA *boxa, l_int32 *parea );
         extern PIX * boxaDisplayTiled ( BOXA *boxas, PIXA *pixa, l_int32 maxwidth, l_int32 linewidth, l_float32 scalefactor, l_int32 background, l_int32 spacing, l_int32 border, const char *fontdir );
         extern L_BYTEA * l_byteaCreate ( size_t nbytes );
         extern L_BYTEA * l_byteaInitFromMem ( l_uint8 *data, size_t size );
         extern L_BYTEA * l_byteaInitFromFile ( const char *fname );
         extern L_BYTEA * l_byteaInitFromStream ( FILE *fp );
         extern L_BYTEA * l_byteaCopy ( L_BYTEA *bas, l_int32 copyflag );
         extern void l_byteaDestroy ( L_BYTEA **pba );
         extern size_t l_byteaGetSize ( L_BYTEA *ba );
         extern l_uint8 * l_byteaGetData ( L_BYTEA *ba, size_t *psize );
         extern l_uint8 * l_byteaCopyData ( L_BYTEA *ba, size_t *psize );
         extern l_int32 l_byteaAppendData ( L_BYTEA *ba, l_uint8 *newdata, size_t newbytes );
         extern l_int32 l_byteaAppendString ( L_BYTEA *ba, char *str );
         extern l_int32 l_byteaJoin ( L_BYTEA *ba1, L_BYTEA **pba2 );
         extern l_int32 l_byteaSplit ( L_BYTEA *ba1, size_t splitloc, L_BYTEA **pba2 );
         extern l_int32 l_byteaFindEachSequence ( L_BYTEA *ba, l_uint8 *sequence, l_int32 seqlen, L_DNA **pda );
         extern l_int32 l_byteaWrite ( const char *fname, L_BYTEA *ba, size_t startloc, size_t endloc );
         extern l_int32 l_byteaWriteStream ( FILE *fp, L_BYTEA *ba, size_t startloc, size_t endloc );
         extern CCBORDA * ccbaCreate ( PIX *pixs, l_int32 n );
         extern void ccbaDestroy ( CCBORDA **pccba );
         extern CCBORD * ccbCreate ( PIX *pixs );
         extern void ccbDestroy ( CCBORD **pccb );
         extern l_int32 ccbaAddCcb ( CCBORDA *ccba, CCBORD *ccb );
         extern l_int32 ccbaGetCount ( CCBORDA *ccba );
         extern CCBORD * ccbaGetCcb ( CCBORDA *ccba, l_int32 index );
         extern CCBORDA * pixGetAllCCBorders ( PIX *pixs );
         extern CCBORD * pixGetCCBorders ( PIX *pixs, BOX *box );
         extern PTAA * pixGetOuterBordersPtaa ( PIX *pixs );
         extern PTA * pixGetOuterBorderPta ( PIX *pixs, BOX *box );
         extern l_int32 pixGetOuterBorder ( CCBORD *ccb, PIX *pixs, BOX *box );
         extern l_int32 pixGetHoleBorder ( CCBORD *ccb, PIX *pixs, BOX *box, l_int32 xs, l_int32 ys );
         extern l_int32 findNextBorderPixel ( l_int32 w, l_int32 h, l_uint32 *data, l_int32 wpl, l_int32 px, l_int32 py, l_int32 *pqpos, l_int32 *pnpx, l_int32 *pnpy );
         extern void locateOutsideSeedPixel ( l_int32 fpx, l_int32 fpy, l_int32 spx, l_int32 spy, l_int32 *pxs, l_int32 *pys );
         extern l_int32 ccbaGenerateGlobalLocs ( CCBORDA *ccba );
         extern l_int32 ccbaGenerateStepChains ( CCBORDA *ccba );
         extern l_int32 ccbaStepChainsToPixCoords ( CCBORDA *ccba, l_int32 coordtype );
         extern l_int32 ccbaGenerateSPGlobalLocs ( CCBORDA *ccba, l_int32 ptsflag );
         extern l_int32 ccbaGenerateSinglePath ( CCBORDA *ccba );
         extern PTA * getCutPathForHole ( PIX *pix, PTA *pta, BOX *boxinner, l_int32 *pdir, l_int32 *plen );
         extern PIX * ccbaDisplayBorder ( CCBORDA *ccba );
         extern PIX * ccbaDisplaySPBorder ( CCBORDA *ccba );
         extern PIX * ccbaDisplayImage1 ( CCBORDA *ccba );
         extern PIX * ccbaDisplayImage2 ( CCBORDA *ccba );
         extern l_int32 ccbaWrite ( const char *filename, CCBORDA *ccba );
         extern l_int32 ccbaWriteStream ( FILE *fp, CCBORDA *ccba );
         extern CCBORDA * ccbaRead ( const char *filename );
         extern CCBORDA * ccbaReadStream ( FILE *fp );
         extern l_int32 ccbaWriteSVG ( const char *filename, CCBORDA *ccba );
         extern char * ccbaWriteSVGString ( const char *filename, CCBORDA *ccba );
         extern PIX * pixThin ( PIX *pixs, l_int32 type, l_int32 connectivity, l_int32 maxiters );
         extern PIX * pixThinGeneral ( PIX *pixs, l_int32 type, SELA *sela, l_int32 maxiters );
         extern PIX * pixThinExamples ( PIX *pixs, l_int32 type, l_int32 index, l_int32 maxiters, const char *selfile );
         extern l_int32 jbCorrelation ( const char *dirin, l_float32 thresh, l_float32 weight, l_int32 components, const char *rootname, l_int32 firstpage, l_int32 npages, l_int32 renderflag );
         extern l_int32 jbRankHaus ( const char *dirin, l_int32 size, l_float32 rank, l_int32 components, const char *rootname, l_int32 firstpage, l_int32 npages, l_int32 renderflag );
         extern JBCLASSER * jbWordsInTextlines ( const char *dirin, l_int32 reduction, l_int32 maxwidth, l_int32 maxheight, l_float32 thresh, l_float32 weight, NUMA **pnatl, l_int32 firstpage, l_int32 npages );
         extern l_int32 pixGetWordsInTextlines ( PIX *pixs, l_int32 reduction, l_int32 minwidth, l_int32 minheight, l_int32 maxwidth, l_int32 maxheight, BOXA **pboxad, PIXA **ppixad, NUMA **pnai );
         extern l_int32 pixGetWordBoxesInTextlines ( PIX *pixs, l_int32 reduction, l_int32 minwidth, l_int32 minheight, l_int32 maxwidth, l_int32 maxheight, BOXA **pboxad, NUMA **pnai );
         extern NUMAA * boxaExtractSortedPattern ( BOXA *boxa, NUMA *na );
         extern l_int32 numaaCompareImagesByBoxes ( NUMAA *naa1, NUMAA *naa2, l_int32 nperline, l_int32 nreq, l_int32 maxshiftx, l_int32 maxshifty, l_int32 delx, l_int32 dely, l_int32 *psame, l_int32 debugflag );
         extern l_int32 pixColorContent ( PIX *pixs, l_int32 rwhite, l_int32 gwhite, l_int32 bwhite, l_int32 mingray, PIX **ppixr, PIX **ppixg, PIX **ppixb );
         extern PIX * pixColorMagnitude ( PIX *pixs, l_int32 rwhite, l_int32 gwhite, l_int32 bwhite, l_int32 type );
         extern PIX * pixMaskOverColorPixels ( PIX *pixs, l_int32 threshdiff, l_int32 mindist );
         extern l_int32 pixColorFraction ( PIX *pixs, l_int32 darkthresh, l_int32 lightthresh, l_int32 diffthresh, l_int32 factor, l_float32 *ppixfract, l_float32 *pcolorfract );
         extern l_int32 pixNumSignificantGrayColors ( PIX *pixs, l_int32 darkthresh, l_int32 lightthresh, l_float32 minfract, l_int32 factor, l_int32 *pncolors );
         extern l_int32 pixColorsForQuantization ( PIX *pixs, l_int32 thresh, l_int32 *pncolors, l_int32 *piscolor, l_int32 debug );
         extern l_int32 pixNumColors ( PIX *pixs, l_int32 factor, l_int32 *pncolors );
         extern l_int32 pixGetMostPopulatedColors ( PIX *pixs, l_int32 sigbits, l_int32 factor, l_int32 ncolors, l_uint32 **parray, PIXCMAP **pcmap );
         extern PIX * pixSimpleColorQuantize ( PIX *pixs, l_int32 sigbits, l_int32 factor, l_int32 ncolors );
         extern NUMA * pixGetRGBHistogram ( PIX *pixs, l_int32 sigbits, l_int32 factor );
         extern l_int32 makeRGBIndexTables ( l_uint32 **prtab, l_uint32 **pgtab, l_uint32 **pbtab, l_int32 sigbits );
         extern l_int32 getRGBFromIndex ( l_uint32 index, l_int32 sigbits, l_int32 *prval, l_int32 *pgval, l_int32 *pbval );
         extern l_int32 pixHasHighlightRed ( PIX *pixs, l_int32 factor, l_float32 fract, l_float32 fthresh, l_int32 *phasred, l_float32 *pratio, PIX **ppixdb );
         extern PIX * pixColorGrayRegions ( PIX *pixs, BOXA *boxa, l_int32 type, l_int32 thresh, l_int32 rval, l_int32 gval, l_int32 bval );
         extern l_int32 pixColorGray ( PIX *pixs, BOX *box, l_int32 type, l_int32 thresh, l_int32 rval, l_int32 gval, l_int32 bval );
         extern PIX * pixSnapColor ( PIX *pixd, PIX *pixs, l_uint32 srcval, l_uint32 dstval, l_int32 diff );
         extern PIX * pixSnapColorCmap ( PIX *pixd, PIX *pixs, l_uint32 srcval, l_uint32 dstval, l_int32 diff );
         extern PIX * pixLinearMapToTargetColor ( PIX *pixd, PIX *pixs, l_uint32 srcval, l_uint32 dstval );
         extern l_int32 pixelLinearMapToTargetColor ( l_uint32 scolor, l_uint32 srcmap, l_uint32 dstmap, l_uint32 *pdcolor );
         extern PIX * pixShiftByComponent ( PIX *pixd, PIX *pixs, l_uint32 srcval, l_uint32 dstval );
         extern l_int32 pixelShiftByComponent ( l_int32 rval, l_int32 gval, l_int32 bval, l_uint32 srcval, l_uint32 dstval, l_uint32 *ppixel );
         extern l_int32 pixelFractionalShift ( l_int32 rval, l_int32 gval, l_int32 bval, l_float32 fraction, l_uint32 *ppixel );
         extern PIXCMAP * pixcmapCreate ( l_int32 depth );
         extern PIXCMAP * pixcmapCreateRandom ( l_int32 depth, l_int32 hasblack, l_int32 haswhite );
         extern PIXCMAP * pixcmapCreateLinear ( l_int32 d, l_int32 nlevels );
         extern PIXCMAP * pixcmapCopy ( PIXCMAP *cmaps );
         extern void pixcmapDestroy ( PIXCMAP **pcmap );
         extern l_int32 pixcmapAddColor ( PIXCMAP *cmap, l_int32 rval, l_int32 gval, l_int32 bval );
         extern l_int32 pixcmapAddRGBA ( PIXCMAP *cmap, l_int32 rval, l_int32 gval, l_int32 bval, l_int32 aval );
         extern l_int32 pixcmapAddNewColor ( PIXCMAP *cmap, l_int32 rval, l_int32 gval, l_int32 bval, l_int32 *pindex );
         extern l_int32 pixcmapAddNearestColor ( PIXCMAP *cmap, l_int32 rval, l_int32 gval, l_int32 bval, l_int32 *pindex );
         extern l_int32 pixcmapUsableColor ( PIXCMAP *cmap, l_int32 rval, l_int32 gval, l_int32 bval, l_int32 *pusable );
         extern l_int32 pixcmapAddBlackOrWhite ( PIXCMAP *cmap, l_int32 color, l_int32 *pindex );
         extern l_int32 pixcmapSetBlackAndWhite ( PIXCMAP *cmap, l_int32 setblack, l_int32 setwhite );
         extern l_int32 pixcmapGetCount ( PIXCMAP *cmap );
         extern l_int32 pixcmapGetFreeCount ( PIXCMAP *cmap );
         extern l_int32 pixcmapGetDepth ( PIXCMAP *cmap );
         extern l_int32 pixcmapGetMinDepth ( PIXCMAP *cmap, l_int32 *pmindepth );
         extern l_int32 pixcmapClear ( PIXCMAP *cmap );
         extern l_int32 pixcmapGetColor ( PIXCMAP *cmap, l_int32 index, l_int32 *prval, l_int32 *pgval, l_int32 *pbval );
         extern l_int32 pixcmapGetColor32 ( PIXCMAP *cmap, l_int32 index, l_uint32 *pval32 );
         extern l_int32 pixcmapGetRGBA ( PIXCMAP *cmap, l_int32 index, l_int32 *prval, l_int32 *pgval, l_int32 *pbval, l_int32 *paval );
         extern l_int32 pixcmapGetRGBA32 ( PIXCMAP *cmap, l_int32 index, l_uint32 *pval32 );
         extern l_int32 pixcmapResetColor ( PIXCMAP *cmap, l_int32 index, l_int32 rval, l_int32 gval, l_int32 bval );
         extern l_int32 pixcmapGetIndex ( PIXCMAP *cmap, l_int32 rval, l_int32 gval, l_int32 bval, l_int32 *pindex );
         extern l_int32 pixcmapHasColor ( PIXCMAP *cmap, l_int32 *pcolor );
         extern l_int32 pixcmapIsOpaque ( PIXCMAP *cmap, l_int32 *popaque );
         extern l_int32 pixcmapCountGrayColors ( PIXCMAP *cmap, l_int32 *pngray );
         extern l_int32 pixcmapGetRankIntensity ( PIXCMAP *cmap, l_float32 rankval, l_int32 *pindex );
         extern l_int32 pixcmapGetNearestIndex ( PIXCMAP *cmap, l_int32 rval, l_int32 gval, l_int32 bval, l_int32 *pindex );
         extern l_int32 pixcmapGetNearestGrayIndex ( PIXCMAP *cmap, l_int32 val, l_int32 *pindex );
         extern l_int32 pixcmapGetComponentRange ( PIXCMAP *cmap, l_int32 color, l_int32 *pminval, l_int32 *pmaxval );
         extern l_int32 pixcmapGetExtremeValue ( PIXCMAP *cmap, l_int32 type, l_int32 *prval, l_int32 *pgval, l_int32 *pbval );
         extern PIXCMAP * pixcmapGrayToColor ( l_uint32 color );
         extern PIXCMAP * pixcmapColorToGray ( PIXCMAP *cmaps, l_float32 rwt, l_float32 gwt, l_float32 bwt );
         extern PIXCMAP * pixcmapReadStream ( FILE *fp );
         extern l_int32 pixcmapWriteStream ( FILE *fp, PIXCMAP *cmap );
         extern l_int32 pixcmapToArrays ( PIXCMAP *cmap, l_int32 **prmap, l_int32 **pgmap, l_int32 **pbmap, l_int32 **pamap );
         extern l_int32 pixcmapToRGBTable ( PIXCMAP *cmap, l_uint32 **ptab, l_int32 *pncolors );
         extern l_int32 pixcmapSerializeToMemory ( PIXCMAP *cmap, l_int32 cpc, l_int32 *pncolors, l_uint8 **pdata );
         extern PIXCMAP * pixcmapDeserializeFromMemory ( l_uint8 *data, l_int32 cpc, l_int32 ncolors );
         extern char * pixcmapConvertToHex ( l_uint8 *data, l_int32 ncolors );
         extern l_int32 pixcmapGammaTRC ( PIXCMAP *cmap, l_float32 gamma, l_int32 minval, l_int32 maxval );
         extern l_int32 pixcmapContrastTRC ( PIXCMAP *cmap, l_float32 factor );
         extern l_int32 pixcmapShiftIntensity ( PIXCMAP *cmap, l_float32 fraction );
         extern l_int32 pixcmapShiftByComponent ( PIXCMAP *cmap, l_uint32 srcval, l_uint32 dstval );
         extern PIX * pixColorMorph ( PIX *pixs, l_int32 type, l_int32 hsize, l_int32 vsize );
         extern PIX * pixOctreeColorQuant ( PIX *pixs, l_int32 colors, l_int32 ditherflag );
         extern PIX * pixOctreeColorQuantGeneral ( PIX *pixs, l_int32 colors, l_int32 ditherflag, l_float32 validthresh, l_float32 colorthresh );
         extern l_int32 makeRGBToIndexTables ( l_uint32 **prtab, l_uint32 **pgtab, l_uint32 **pbtab, l_int32 cqlevels );
         extern void getOctcubeIndexFromRGB ( l_int32 rval, l_int32 gval, l_int32 bval, l_uint32 *rtab, l_uint32 *gtab, l_uint32 *btab, l_uint32 *pindex );
         extern PIX * pixOctreeQuantByPopulation ( PIX *pixs, l_int32 level, l_int32 ditherflag );
         extern PIX * pixOctreeQuantNumColors ( PIX *pixs, l_int32 maxcolors, l_int32 subsample );
         extern PIX * pixOctcubeQuantMixedWithGray ( PIX *pixs, l_int32 depth, l_int32 graylevels, l_int32 delta );
         extern PIX * pixFixedOctcubeQuant256 ( PIX *pixs, l_int32 ditherflag );
         extern PIX * pixFewColorsOctcubeQuant1 ( PIX *pixs, l_int32 level );
         extern PIX * pixFewColorsOctcubeQuant2 ( PIX *pixs, l_int32 level, NUMA *na, l_int32 ncolors, l_int32 *pnerrors );
         extern PIX * pixFewColorsOctcubeQuantMixed ( PIX *pixs, l_int32 level, l_int32 darkthresh, l_int32 lightthresh, l_int32 diffthresh, l_float32 minfract, l_int32 maxspan );
         extern PIX * pixFixedOctcubeQuantGenRGB ( PIX *pixs, l_int32 level );
         extern PIX * pixQuantFromCmap ( PIX *pixs, PIXCMAP *cmap, l_int32 mindepth, l_int32 level, l_int32 metric );
         extern PIX * pixOctcubeQuantFromCmap ( PIX *pixs, PIXCMAP *cmap, l_int32 mindepth, l_int32 level, l_int32 metric );
         extern PIX * pixOctcubeQuantFromCmapLUT ( PIX *pixs, PIXCMAP *cmap, l_int32 mindepth, l_int32 *cmaptab, l_uint32 *rtab, l_uint32 *gtab, l_uint32 *btab );
         extern NUMA * pixOctcubeHistogram ( PIX *pixs, l_int32 level, l_int32 *pncolors );
         extern l_int32 * pixcmapToOctcubeLUT ( PIXCMAP *cmap, l_int32 level, l_int32 metric );
         extern l_int32 pixRemoveUnusedColors ( PIX *pixs );
         extern l_int32 pixNumberOccupiedOctcubes ( PIX *pix, l_int32 level, l_int32 mincount, l_float32 minfract, l_int32 *pncolors );
         extern PIX * pixMedianCutQuant ( PIX *pixs, l_int32 ditherflag );
         extern PIX * pixMedianCutQuantGeneral ( PIX *pixs, l_int32 ditherflag, l_int32 outdepth, l_int32 maxcolors, l_int32 sigbits, l_int32 maxsub, l_int32 checkbw );
         extern PIX * pixMedianCutQuantMixed ( PIX *pixs, l_int32 ncolor, l_int32 ngray, l_int32 darkthresh, l_int32 lightthresh, l_int32 diffthresh );
         extern PIX * pixFewColorsMedianCutQuantMixed ( PIX *pixs, l_int32 ncolor, l_int32 ngray, l_int32 maxncolors, l_int32 darkthresh, l_int32 lightthresh, l_int32 diffthresh );
         extern l_int32 * pixMedianCutHisto ( PIX *pixs, l_int32 sigbits, l_int32 subsample );
         extern PIX * pixColorSegment ( PIX *pixs, l_int32 maxdist, l_int32 maxcolors, l_int32 selsize, l_int32 finalcolors );
         extern PIX * pixColorSegmentCluster ( PIX *pixs, l_int32 maxdist, l_int32 maxcolors );
         extern l_int32 pixAssignToNearestColor ( PIX *pixd, PIX *pixs, PIX *pixm, l_int32 level, l_int32 *countarray );
         extern l_int32 pixColorSegmentClean ( PIX *pixs, l_int32 selsize, l_int32 *countarray );
         extern l_int32 pixColorSegmentRemoveColors ( PIX *pixd, PIX *pixs, l_int32 finalcolors );
         extern PIX * pixConvertRGBToHSV ( PIX *pixd, PIX *pixs );
         extern PIX * pixConvertHSVToRGB ( PIX *pixd, PIX *pixs );
         extern l_int32 convertRGBToHSV ( l_int32 rval, l_int32 gval, l_int32 bval, l_int32 *phval, l_int32 *psval, l_int32 *pvval );
         extern l_int32 convertHSVToRGB ( l_int32 hval, l_int32 sval, l_int32 vval, l_int32 *prval, l_int32 *pgval, l_int32 *pbval );
         extern l_int32 pixcmapConvertRGBToHSV ( PIXCMAP *cmap );
         extern l_int32 pixcmapConvertHSVToRGB ( PIXCMAP *cmap );
         extern PIX * pixConvertRGBToHue ( PIX *pixs );
         extern PIX * pixConvertRGBToSaturation ( PIX *pixs );
         extern PIX * pixConvertRGBToValue ( PIX *pixs );
         extern PIX * pixMakeRangeMaskHS ( PIX *pixs, l_int32 huecenter, l_int32 huehw, l_int32 satcenter, l_int32 sathw, l_int32 regionflag );
         extern PIX * pixMakeRangeMaskHV ( PIX *pixs, l_int32 huecenter, l_int32 huehw, l_int32 valcenter, l_int32 valhw, l_int32 regionflag );
         extern PIX * pixMakeRangeMaskSV ( PIX *pixs, l_int32 satcenter, l_int32 sathw, l_int32 valcenter, l_int32 valhw, l_int32 regionflag );
         extern PIX * pixMakeHistoHS ( PIX *pixs, l_int32 factor, NUMA **pnahue, NUMA **pnasat );
         extern PIX * pixMakeHistoHV ( PIX *pixs, l_int32 factor, NUMA **pnahue, NUMA **pnaval );
         extern PIX * pixMakeHistoSV ( PIX *pixs, l_int32 factor, NUMA **pnasat, NUMA **pnaval );
         extern l_int32 pixFindHistoPeaksHSV ( PIX *pixs, l_int32 type, l_int32 width, l_int32 height, l_int32 npeaks, l_float32 erasefactor, PTA **ppta, NUMA **pnatot, PIXA **ppixa );
         extern PIX * displayHSVColorRange ( l_int32 hval, l_int32 sval, l_int32 vval, l_int32 huehw, l_int32 sathw, l_int32 nsamp, l_int32 factor );
         extern PIX * pixConvertRGBToYUV ( PIX *pixd, PIX *pixs );
         extern PIX * pixConvertYUVToRGB ( PIX *pixd, PIX *pixs );
         extern l_int32 convertRGBToYUV ( l_int32 rval, l_int32 gval, l_int32 bval, l_int32 *pyval, l_int32 *puval, l_int32 *pvval );
         extern l_int32 convertYUVToRGB ( l_int32 yval, l_int32 uval, l_int32 vval, l_int32 *prval, l_int32 *pgval, l_int32 *pbval );
         extern l_int32 pixcmapConvertRGBToYUV ( PIXCMAP *cmap );
         extern l_int32 pixcmapConvertYUVToRGB ( PIXCMAP *cmap );
         extern l_int32 pixEqual ( PIX *pix1, PIX *pix2, l_int32 *psame );
         extern l_int32 pixEqualWithAlpha ( PIX *pix1, PIX *pix2, l_int32 use_alpha, l_int32 *psame );
         extern l_int32 pixEqualWithCmap ( PIX *pix1, PIX *pix2, l_int32 *psame );
         extern l_int32 pixUsesCmapColor ( PIX *pixs, l_int32 *pcolor );
         extern l_int32 pixCorrelationBinary ( PIX *pix1, PIX *pix2, l_float32 *pval );
         extern PIX * pixDisplayDiffBinary ( PIX *pix1, PIX *pix2 );
         extern l_int32 pixCompareBinary ( PIX *pix1, PIX *pix2, l_int32 comptype, l_float32 *pfract, PIX **ppixdiff );
         extern l_int32 pixCompareGrayOrRGB ( PIX *pix1, PIX *pix2, l_int32 comptype, l_int32 plottype, l_int32 *psame, l_float32 *pdiff, l_float32 *prmsdiff, PIX **ppixdiff );
         extern l_int32 pixCompareGray ( PIX *pix1, PIX *pix2, l_int32 comptype, l_int32 plottype, l_int32 *psame, l_float32 *pdiff, l_float32 *prmsdiff, PIX **ppixdiff );
         extern l_int32 pixCompareRGB ( PIX *pix1, PIX *pix2, l_int32 comptype, l_int32 plottype, l_int32 *psame, l_float32 *pdiff, l_float32 *prmsdiff, PIX **ppixdiff );
         extern l_int32 pixCompareTiled ( PIX *pix1, PIX *pix2, l_int32 sx, l_int32 sy, l_int32 type, PIX **ppixdiff );
         extern NUMA * pixCompareRankDifference ( PIX *pix1, PIX *pix2, l_int32 factor );
         extern l_int32 pixTestForSimilarity ( PIX *pix1, PIX *pix2, l_int32 factor, l_int32 mindiff, l_float32 maxfract, l_float32 maxave, l_int32 *psimilar, l_int32 printstats );
         extern l_int32 pixGetDifferenceStats ( PIX *pix1, PIX *pix2, l_int32 factor, l_int32 mindiff, l_float32 *pfractdiff, l_float32 *pavediff, l_int32 printstats );
         extern NUMA * pixGetDifferenceHistogram ( PIX *pix1, PIX *pix2, l_int32 factor );
         extern l_int32 pixGetPerceptualDiff ( PIX *pixs1, PIX *pixs2, l_int32 sampling, l_int32 dilation, l_int32 mindiff, l_float32 *pfract, PIX **ppixdiff1, PIX **ppixdiff2 );
         extern l_int32 pixGetPSNR ( PIX *pix1, PIX *pix2, l_int32 factor, l_float32 *ppsnr );
         extern l_int32 pixCompareWithTranslation ( PIX *pix1, PIX *pix2, l_int32 thresh, l_int32 *pdelx, l_int32 *pdely, l_float32 *pscore, l_int32 debugflag );
         extern l_int32 pixBestCorrelation ( PIX *pix1, PIX *pix2, l_int32 area1, l_int32 area2, l_int32 etransx, l_int32 etransy, l_int32 maxshift, l_int32 *tab8, l_int32 *pdelx, l_int32 *pdely, l_float32 *pscore, l_int32 debugflag );
         extern BOXA * pixConnComp ( PIX *pixs, PIXA **ppixa, l_int32 connectivity );
         extern BOXA * pixConnCompPixa ( PIX *pixs, PIXA **ppixa, l_int32 connectivity );
         extern BOXA * pixConnCompBB ( PIX *pixs, l_int32 connectivity );
         extern l_int32 pixCountConnComp ( PIX *pixs, l_int32 connectivity, l_int32 *pcount );
         extern l_int32 nextOnPixelInRaster ( PIX *pixs, l_int32 xstart, l_int32 ystart, l_int32 *px, l_int32 *py );
         extern l_int32 nextOnPixelInRasterLow ( l_uint32 *data, l_int32 w, l_int32 h, l_int32 wpl, l_int32 xstart, l_int32 ystart, l_int32 *px, l_int32 *py );
         extern BOX * pixSeedfillBB ( PIX *pixs, L_STACK *stack, l_int32 x, l_int32 y, l_int32 connectivity );
         extern BOX * pixSeedfill4BB ( PIX *pixs, L_STACK *stack, l_int32 x, l_int32 y );
         extern BOX * pixSeedfill8BB ( PIX *pixs, L_STACK *stack, l_int32 x, l_int32 y );
         extern l_int32 pixSeedfill ( PIX *pixs, L_STACK *stack, l_int32 x, l_int32 y, l_int32 connectivity );
         extern l_int32 pixSeedfill4 ( PIX *pixs, L_STACK *stack, l_int32 x, l_int32 y );
         extern l_int32 pixSeedfill8 ( PIX *pixs, L_STACK *stack, l_int32 x, l_int32 y );
         extern l_int32 convertFilesTo1bpp ( const char *dirin, const char *substr, l_int32 upscaling, l_int32 thresh, l_int32 firstpage, l_int32 npages, const char *dirout, l_int32 outformat );
         extern PIX * pixBlockconv ( PIX *pix, l_int32 wc, l_int32 hc );
         extern PIX * pixBlockconvGray ( PIX *pixs, PIX *pixacc, l_int32 wc, l_int32 hc );
         extern PIX * pixBlockconvAccum ( PIX *pixs );
         extern PIX * pixBlockconvGrayUnnormalized ( PIX *pixs, l_int32 wc, l_int32 hc );
         extern PIX * pixBlockconvTiled ( PIX *pix, l_int32 wc, l_int32 hc, l_int32 nx, l_int32 ny );
         extern PIX * pixBlockconvGrayTile ( PIX *pixs, PIX *pixacc, l_int32 wc, l_int32 hc );
         extern l_int32 pixWindowedStats ( PIX *pixs, l_int32 wc, l_int32 hc, l_int32 hasborder, PIX **ppixm, PIX **ppixms, FPIX **pfpixv, FPIX **pfpixrv );
         extern PIX * pixWindowedMean ( PIX *pixs, l_int32 wc, l_int32 hc, l_int32 hasborder, l_int32 normflag );
         extern PIX * pixWindowedMeanSquare ( PIX *pixs, l_int32 wc, l_int32 hc, l_int32 hasborder );
         extern l_int32 pixWindowedVariance ( PIX *pixm, PIX *pixms, FPIX **pfpixv, FPIX **pfpixrv );
         extern DPIX * pixMeanSquareAccum ( PIX *pixs );
         extern PIX * pixBlockrank ( PIX *pixs, PIX *pixacc, l_int32 wc, l_int32 hc, l_float32 rank );
         extern PIX * pixBlocksum ( PIX *pixs, PIX *pixacc, l_int32 wc, l_int32 hc );
         extern PIX * pixCensusTransform ( PIX *pixs, l_int32 halfsize, PIX *pixacc );
         extern PIX * pixConvolve ( PIX *pixs, L_KERNEL *kel, l_int32 outdepth, l_int32 normflag );
         extern PIX * pixConvolveSep ( PIX *pixs, L_KERNEL *kelx, L_KERNEL *kely, l_int32 outdepth, l_int32 normflag );
         extern PIX * pixConvolveRGB ( PIX *pixs, L_KERNEL *kel );
         extern PIX * pixConvolveRGBSep ( PIX *pixs, L_KERNEL *kelx, L_KERNEL *kely );
         extern FPIX * fpixConvolve ( FPIX *fpixs, L_KERNEL *kel, l_int32 normflag );
         extern FPIX * fpixConvolveSep ( FPIX *fpixs, L_KERNEL *kelx, L_KERNEL *kely, l_int32 normflag );
         extern PIX * pixConvolveWithBias ( PIX *pixs, L_KERNEL *kel1, L_KERNEL *kel2, l_int32 force8, l_int32 *pbias );
         extern void l_setConvolveSampling ( l_int32 xfact, l_int32 yfact );
         extern PIX * pixAddGaussianNoise ( PIX *pixs, l_float32 stdev );
         extern l_float32 gaussDistribSampling ( );
         extern void blockconvLow ( l_uint32 *data, l_int32 w, l_int32 h, l_int32 wpl, l_uint32 *dataa, l_int32 wpla, l_int32 wc, l_int32 hc );
         extern void blockconvAccumLow ( l_uint32 *datad, l_int32 w, l_int32 h, l_int32 wpld, l_uint32 *datas, l_int32 d, l_int32 wpls );
         extern void blocksumLow ( l_uint32 *datad, l_int32 w, l_int32 h, l_int32 wpl, l_uint32 *dataa, l_int32 wpla, l_int32 wc, l_int32 hc );
         extern l_int32 pixCorrelationScore ( PIX *pix1, PIX *pix2, l_int32 area1, l_int32 area2, l_float32 delx, l_float32 dely, l_int32 maxdiffw, l_int32 maxdiffh, l_int32 *tab, l_float32 *pscore );
         extern l_int32 pixCorrelationScoreThresholded ( PIX *pix1, PIX *pix2, l_int32 area1, l_int32 area2, l_float32 delx, l_float32 dely, l_int32 maxdiffw, l_int32 maxdiffh, l_int32 *tab, l_int32 *downcount, l_float32 score_threshold );
         extern l_int32 pixCorrelationScoreSimple ( PIX *pix1, PIX *pix2, l_int32 area1, l_int32 area2, l_float32 delx, l_float32 dely, l_int32 maxdiffw, l_int32 maxdiffh, l_int32 *tab, l_float32 *pscore );
         extern l_int32 pixCorrelationScoreShifted ( PIX *pix1, PIX *pix2, l_int32 area1, l_int32 area2, l_int32 delx, l_int32 dely, l_int32 *tab, l_float32 *pscore );
         extern L_DEWARP * dewarpCreate ( PIX *pixs, l_int32 pageno );
         extern L_DEWARP * dewarpCreateRef ( l_int32 pageno, l_int32 refpage );
         extern void dewarpDestroy ( L_DEWARP **pdew );
         extern L_DEWARPA * dewarpaCreate ( l_int32 nptrs, l_int32 sampling, l_int32 redfactor, l_int32 minlines, l_int32 maxdist );
         extern L_DEWARPA * dewarpaCreateFromPixacomp ( PIXAC *pixac, l_int32 useboth, l_int32 sampling, l_int32 minlines, l_int32 maxdist );
         extern void dewarpaDestroy ( L_DEWARPA **pdewa );
         extern l_int32 dewarpaDestroyDewarp ( L_DEWARPA *dewa, l_int32 pageno );
         extern l_int32 dewarpaInsertDewarp ( L_DEWARPA *dewa, L_DEWARP *dew );
         extern L_DEWARP * dewarpaGetDewarp ( L_DEWARPA *dewa, l_int32 index );
         extern l_int32 dewarpaSetCurvatures ( L_DEWARPA *dewa, l_int32 max_linecurv, l_int32 min_diff_linecurv, l_int32 max_diff_linecurv, l_int32 max_edgecurv, l_int32 max_diff_edgecurv, l_int32 max_edgeslope );
         extern l_int32 dewarpaUseBothArrays ( L_DEWARPA *dewa, l_int32 useboth );
         extern l_int32 dewarpaSetMaxDistance ( L_DEWARPA *dewa, l_int32 maxdist );
         extern L_DEWARP * dewarpRead ( const char *filename );
         extern L_DEWARP * dewarpReadStream ( FILE *fp );
         extern l_int32 dewarpWrite ( const char *filename, L_DEWARP *dew );
         extern l_int32 dewarpWriteStream ( FILE *fp, L_DEWARP *dew );
         extern L_DEWARPA * dewarpaRead ( const char *filename );
         extern L_DEWARPA * dewarpaReadStream ( FILE *fp );
         extern l_int32 dewarpaWrite ( const char *filename, L_DEWARPA *dewa );
         extern l_int32 dewarpaWriteStream ( FILE *fp, L_DEWARPA *dewa );
         extern l_int32 dewarpBuildPageModel ( L_DEWARP *dew, const char *debugfile );
         extern l_int32 dewarpFindVertDisparity ( L_DEWARP *dew, PTAA *ptaa, l_int32 rotflag );
         extern l_int32 dewarpFindHorizDisparity ( L_DEWARP *dew, PTAA *ptaa );
         extern PTAA * dewarpGetTextlineCenters ( PIX *pixs, l_int32 debugflag );
         extern PTAA * dewarpRemoveShortLines ( PIX *pixs, PTAA *ptaas, l_float32 fract, l_int32 debugflag );
         extern l_int32 dewarpBuildLineModel ( L_DEWARP *dew, l_int32 opensize, const char *debugfile );
         extern l_int32 dewarpaModelStatus ( L_DEWARPA *dewa, l_int32 pageno, l_int32 *pvsuccess, l_int32 *phsuccess );
         extern l_int32 dewarpaApplyDisparity ( L_DEWARPA *dewa, l_int32 pageno, PIX *pixs, l_int32 grayin, l_int32 x, l_int32 y, PIX **ppixd, const char *debugfile );
         extern l_int32 dewarpMinimize ( L_DEWARP *dew );
         extern l_int32 dewarpPopulateFullRes ( L_DEWARP *dew, PIX *pix, l_int32 x, l_int32 y );
         extern l_int32 dewarpSinglePage ( PIX *pixs, l_int32 thresh, l_int32 adaptive, l_int32 use_both, PIX **ppixd, L_DEWARPA **pdewa, l_int32 debug );
         extern l_int32 dewarpaListPages ( L_DEWARPA *dewa );
         extern l_int32 dewarpaSetValidModels ( L_DEWARPA *dewa, l_int32 notests, l_int32 debug );
         extern l_int32 dewarpaInsertRefModels ( L_DEWARPA *dewa, l_int32 notests, l_int32 debug );
         extern l_int32 dewarpaStripRefModels ( L_DEWARPA *dewa );
         extern l_int32 dewarpaRestoreModels ( L_DEWARPA *dewa );
         extern l_int32 dewarpaInfo ( FILE *fp, L_DEWARPA *dewa );
         extern l_int32 dewarpaModelStats ( L_DEWARPA *dewa, l_int32 *pnnone, l_int32 *pnvsuccess, l_int32 *pnvvalid, l_int32 *pnhsuccess, l_int32 *pnhvalid, l_int32 *pnref );
         extern l_int32 dewarpaShowArrays ( L_DEWARPA *dewa, l_float32 scalefact, l_int32 first, l_int32 last, const char *fontdir );
         extern l_int32 dewarpDebug ( L_DEWARP *dew, const char *subdir, l_int32 index );
         extern l_int32 dewarpShowResults ( L_DEWARPA *dewa, SARRAY *sa, BOXA *boxa, l_int32 firstpage, l_int32 lastpage, const char *fontdir, const char *pdfout );
         extern L_DNA * l_dnaCreate ( l_int32 n );
         extern L_DNA * l_dnaCreateFromIArray ( l_int32 *iarray, l_int32 size );
         extern L_DNA * l_dnaCreateFromDArray ( l_float64 *darray, l_int32 size, l_int32 copyflag );
         extern L_DNA * l_dnaMakeSequence ( l_float64 startval, l_float64 increment, l_int32 size );
         extern void l_dnaDestroy ( L_DNA **pda );
         extern L_DNA * l_dnaCopy ( L_DNA *da );
         extern L_DNA * l_dnaClone ( L_DNA *da );
         extern l_int32 l_dnaEmpty ( L_DNA *da );
         extern l_int32 l_dnaAddNumber ( L_DNA *da, l_float64 val );
         extern l_int32 l_dnaInsertNumber ( L_DNA *da, l_int32 index, l_float64 val );
         extern l_int32 l_dnaRemoveNumber ( L_DNA *da, l_int32 index );
         extern l_int32 l_dnaReplaceNumber ( L_DNA *da, l_int32 index, l_float64 val );
         extern l_int32 l_dnaGetCount ( L_DNA *da );
         extern l_int32 l_dnaSetCount ( L_DNA *da, l_int32 newcount );
         extern l_int32 l_dnaGetDValue ( L_DNA *da, l_int32 index, l_float64 *pval );
         extern l_int32 l_dnaGetIValue ( L_DNA *da, l_int32 index, l_int32 *pival );
         extern l_int32 l_dnaSetValue ( L_DNA *da, l_int32 index, l_float64 val );
         extern l_int32 l_dnaShiftValue ( L_DNA *da, l_int32 index, l_float64 diff );
         extern l_int32 * l_dnaGetIArray ( L_DNA *da );
         extern l_float64 * l_dnaGetDArray ( L_DNA *da, l_int32 copyflag );
         extern l_int32 l_dnaGetRefcount ( L_DNA *da );
         extern l_int32 l_dnaChangeRefcount ( L_DNA *da, l_int32 delta );
         extern l_int32 l_dnaGetParameters ( L_DNA *da, l_float64 *pstartx, l_float64 *pdelx );
         extern l_int32 l_dnaSetParameters ( L_DNA *da, l_float64 startx, l_float64 delx );
         extern l_int32 l_dnaCopyParameters ( L_DNA *dad, L_DNA *das );
         extern L_DNA * l_dnaRead ( const char *filename );
         extern L_DNA * l_dnaReadStream ( FILE *fp );
         extern l_int32 l_dnaWrite ( const char *filename, L_DNA *da );
         extern l_int32 l_dnaWriteStream ( FILE *fp, L_DNA *da );
         extern L_DNAA * l_dnaaCreate ( l_int32 n );
         extern void l_dnaaDestroy ( L_DNAA **pdaa );
         extern l_int32 l_dnaaAddDna ( L_DNAA *daa, L_DNA *da, l_int32 copyflag );
         extern l_int32 l_dnaaGetCount ( L_DNAA *daa );
         extern l_int32 l_dnaaGetDnaCount ( L_DNAA *daa, l_int32 index );
         extern l_int32 l_dnaaGetNumberCount ( L_DNAA *daa );
         extern L_DNA * l_dnaaGetDna ( L_DNAA *daa, l_int32 index, l_int32 accessflag );
         extern l_int32 l_dnaaReplaceDna ( L_DNAA *daa, l_int32 index, L_DNA *da );
         extern l_int32 l_dnaaGetValue ( L_DNAA *daa, l_int32 i, l_int32 j, l_float64 *pval );
         extern l_int32 l_dnaaAddNumber ( L_DNAA *daa, l_int32 index, l_float64 val );
         extern L_DNAA * l_dnaaRead ( const char *filename );
         extern L_DNAA * l_dnaaReadStream ( FILE *fp );
         extern l_int32 l_dnaaWrite ( const char *filename, L_DNAA *daa );
         extern l_int32 l_dnaaWriteStream ( FILE *fp, L_DNAA *daa );
         extern L_DNA * l_dnaMakeDelta ( L_DNA *das );
         extern NUMA * l_dnaConvertToNuma ( L_DNA *da );
         extern L_DNA * numaConvertToDna ( NUMA *na );
         extern l_int32 l_dnaJoin ( L_DNA *dad, L_DNA *das, l_int32 istart, l_int32 iend );
         extern PIX * pixMorphDwa_2 ( PIX *pixd, PIX *pixs, l_int32 operation, char *selname );
         extern PIX * pixFMorphopGen_2 ( PIX *pixd, PIX *pixs, l_int32 operation, char *selname );
         extern l_int32 fmorphopgen_low_2 ( l_uint32 *datad, l_int32 w, l_int32 h, l_int32 wpld, l_uint32 *datas, l_int32 wpls, l_int32 index );
         extern PIX * pixSobelEdgeFilter ( PIX *pixs, l_int32 orientflag );
         extern PIX * pixTwoSidedEdgeFilter ( PIX *pixs, l_int32 orientflag );
         extern l_int32 pixMeasureEdgeSmoothness ( PIX *pixs, l_int32 side, l_int32 minjump, l_int32 minreversal, l_float32 *pjpl, l_float32 *pjspl, l_float32 *prpl, const char *debugfile );
         extern NUMA * pixGetEdgeProfile ( PIX *pixs, l_int32 side, const char *debugfile );
         extern l_int32 pixGetLastOffPixelInRun ( PIX *pixs, l_int32 x, l_int32 y, l_int32 direction, l_int32 *ploc );
         extern l_int32 pixGetLastOnPixelInRun ( PIX *pixs, l_int32 x, l_int32 y, l_int32 direction, l_int32 *ploc );
         extern PIX * pixGammaTRC ( PIX *pixd, PIX *pixs, l_float32 gamma, l_int32 minval, l_int32 maxval );
         extern PIX * pixGammaTRCMasked ( PIX *pixd, PIX *pixs, PIX *pixm, l_float32 gamma, l_int32 minval, l_int32 maxval );
         extern PIX * pixGammaTRCWithAlpha ( PIX *pixd, PIX *pixs, l_float32 gamma, l_int32 minval, l_int32 maxval );
         extern NUMA * numaGammaTRC ( l_float32 gamma, l_int32 minval, l_int32 maxval );
         extern PIX * pixContrastTRC ( PIX *pixd, PIX *pixs, l_float32 factor );
         extern PIX * pixContrastTRCMasked ( PIX *pixd, PIX *pixs, PIX *pixm, l_float32 factor );
         extern NUMA * numaContrastTRC ( l_float32 factor );
         extern PIX * pixEqualizeTRC ( PIX *pixd, PIX *pixs, l_float32 fract, l_int32 factor );
         extern NUMA * numaEqualizeTRC ( PIX *pix, l_float32 fract, l_int32 factor );
         extern l_int32 pixTRCMap ( PIX *pixs, PIX *pixm, NUMA *na );
         extern PIX * pixUnsharpMasking ( PIX *pixs, l_int32 halfwidth, l_float32 fract );
         extern PIX * pixUnsharpMaskingGray ( PIX *pixs, l_int32 halfwidth, l_float32 fract );
         extern PIX * pixUnsharpMaskingFast ( PIX *pixs, l_int32 halfwidth, l_float32 fract, l_int32 direction );
         extern PIX * pixUnsharpMaskingGrayFast ( PIX *pixs, l_int32 halfwidth, l_float32 fract, l_int32 direction );
         extern PIX * pixUnsharpMaskingGray1D ( PIX *pixs, l_int32 halfwidth, l_float32 fract, l_int32 direction );
         extern PIX * pixUnsharpMaskingGray2D ( PIX *pixs, l_int32 halfwidth, l_float32 fract );
         extern PIX * pixModifyHue ( PIX *pixd, PIX *pixs, l_float32 fract );
         extern PIX * pixModifySaturation ( PIX *pixd, PIX *pixs, l_float32 fract );
         extern l_int32 pixMeasureSaturation ( PIX *pixs, l_int32 factor, l_float32 *psat );
         extern PIX * pixModifyBrightness ( PIX *pixd, PIX *pixs, l_float32 fract );
         extern PIX * pixColorShiftRGB ( PIX *pixs, l_float32 rfract, l_float32 gfract, l_float32 bfract );
         extern PIX * pixMultConstantColor ( PIX *pixs, l_float32 rfact, l_float32 gfact, l_float32 bfact );
         extern PIX * pixMultMatrixColor ( PIX *pixs, L_KERNEL *kel );
         extern PIX * pixHalfEdgeByBandpass ( PIX *pixs, l_int32 sm1h, l_int32 sm1v, l_int32 sm2h, l_int32 sm2v );
         extern l_int32 fhmtautogen ( SELA *sela, l_int32 fileindex, const char *filename );
         extern l_int32 fhmtautogen1 ( SELA *sela, l_int32 fileindex, const char *filename );
         extern l_int32 fhmtautogen2 ( SELA *sela, l_int32 fileindex, const char *filename );
         extern PIX * pixHMTDwa_1 ( PIX *pixd, PIX *pixs, char *selname );
         extern PIX * pixFHMTGen_1 ( PIX *pixd, PIX *pixs, char *selname );
         extern l_int32 fhmtgen_low_1 ( l_uint32 *datad, l_int32 w, l_int32 h, l_int32 wpld, l_uint32 *datas, l_int32 wpls, l_int32 index );
         extern l_int32 pixItalicWords ( PIX *pixs, BOXA *boxaw, PIX *pixw, BOXA **pboxa, l_int32 debugflag );
         extern l_int32 pixOrientDetect ( PIX *pixs, l_float32 *pupconf, l_float32 *pleftconf, l_int32 mincount, l_int32 debug );
         extern l_int32 makeOrientDecision ( l_float32 upconf, l_float32 leftconf, l_float32 minupconf, l_float32 minratio, l_int32 *porient, l_int32 debug );
         extern l_int32 pixUpDownDetect ( PIX *pixs, l_float32 *pconf, l_int32 mincount, l_int32 debug );
         extern l_int32 pixUpDownDetectGeneral ( PIX *pixs, l_float32 *pconf, l_int32 mincount, l_int32 npixels, l_int32 debug );
         extern l_int32 pixOrientDetectDwa ( PIX *pixs, l_float32 *pupconf, l_float32 *pleftconf, l_int32 mincount, l_int32 debug );
         extern l_int32 pixUpDownDetectDwa ( PIX *pixs, l_float32 *pconf, l_int32 mincount, l_int32 debug );
         extern l_int32 pixUpDownDetectGeneralDwa ( PIX *pixs, l_float32 *pconf, l_int32 mincount, l_int32 npixels, l_int32 debug );
         extern l_int32 pixMirrorDetect ( PIX *pixs, l_float32 *pconf, l_int32 mincount, l_int32 debug );
         extern l_int32 pixMirrorDetectDwa ( PIX *pixs, l_float32 *pconf, l_int32 mincount, l_int32 debug );
         extern PIX * pixFlipFHMTGen ( PIX *pixd, PIX *pixs, char *selname );
         extern l_int32 fmorphautogen ( SELA *sela, l_int32 fileindex, const char *filename );
         extern l_int32 fmorphautogen1 ( SELA *sela, l_int32 fileindex, const char *filename );
         extern l_int32 fmorphautogen2 ( SELA *sela, l_int32 fileindex, const char *filename );
         extern PIX * pixMorphDwa_1 ( PIX *pixd, PIX *pixs, l_int32 operation, char *selname );
         extern PIX * pixFMorphopGen_1 ( PIX *pixd, PIX *pixs, l_int32 operation, char *selname );
         extern l_int32 fmorphopgen_low_1 ( l_uint32 *datad, l_int32 w, l_int32 h, l_int32 wpld, l_uint32 *datas, l_int32 wpls, l_int32 index );
         extern FPIX * fpixCreate ( l_int32 width, l_int32 height );
         extern FPIX * fpixCreateTemplate ( FPIX *fpixs );
         extern FPIX * fpixClone ( FPIX *fpix );
         extern FPIX * fpixCopy ( FPIX *fpixd, FPIX *fpixs );
         extern l_int32 fpixResizeImageData ( FPIX *fpixd, FPIX *fpixs );
         extern void fpixDestroy ( FPIX **pfpix );
         extern l_int32 fpixGetDimensions ( FPIX *fpix, l_int32 *pw, l_int32 *ph );
         extern l_int32 fpixSetDimensions ( FPIX *fpix, l_int32 w, l_int32 h );
         extern l_int32 fpixGetWpl ( FPIX *fpix );
         extern l_int32 fpixSetWpl ( FPIX *fpix, l_int32 wpl );
         extern l_int32 fpixGetRefcount ( FPIX *fpix );
         extern l_int32 fpixChangeRefcount ( FPIX *fpix, l_int32 delta );
         extern l_int32 fpixGetResolution ( FPIX *fpix, l_int32 *pxres, l_int32 *pyres );
         extern l_int32 fpixSetResolution ( FPIX *fpix, l_int32 xres, l_int32 yres );
         extern l_int32 fpixCopyResolution ( FPIX *fpixd, FPIX *fpixs );
         extern l_float32 * fpixGetData ( FPIX *fpix );
         extern l_int32 fpixSetData ( FPIX *fpix, l_float32 *data );
         extern l_int32 fpixGetPixel ( FPIX *fpix, l_int32 x, l_int32 y, l_float32 *pval );
         extern l_int32 fpixSetPixel ( FPIX *fpix, l_int32 x, l_int32 y, l_float32 val );
         extern FPIXA * fpixaCreate ( l_int32 n );
         extern FPIXA * fpixaCopy ( FPIXA *fpixa, l_int32 copyflag );
         extern void fpixaDestroy ( FPIXA **pfpixa );
         extern l_int32 fpixaAddFPix ( FPIXA *fpixa, FPIX *fpix, l_int32 copyflag );
         extern l_int32 fpixaGetCount ( FPIXA *fpixa );
         extern l_int32 fpixaChangeRefcount ( FPIXA *fpixa, l_int32 delta );
         extern FPIX * fpixaGetFPix ( FPIXA *fpixa, l_int32 index, l_int32 accesstype );
         extern l_int32 fpixaGetFPixDimensions ( FPIXA *fpixa, l_int32 index, l_int32 *pw, l_int32 *ph );
         extern l_int32 fpixaGetPixel ( FPIXA *fpixa, l_int32 index, l_int32 x, l_int32 y, l_float32 *pval );
         extern l_int32 fpixaSetPixel ( FPIXA *fpixa, l_int32 index, l_int32 x, l_int32 y, l_float32 val );
         extern DPIX * dpixCreate ( l_int32 width, l_int32 height );
         extern DPIX * dpixCreateTemplate ( DPIX *dpixs );
         extern DPIX * dpixClone ( DPIX *dpix );
         extern DPIX * dpixCopy ( DPIX *dpixd, DPIX *dpixs );
         extern l_int32 dpixResizeImageData ( DPIX *dpixd, DPIX *dpixs );
         extern void dpixDestroy ( DPIX **pdpix );
         extern l_int32 dpixGetDimensions ( DPIX *dpix, l_int32 *pw, l_int32 *ph );
         extern l_int32 dpixSetDimensions ( DPIX *dpix, l_int32 w, l_int32 h );
         extern l_int32 dpixGetWpl ( DPIX *dpix );
         extern l_int32 dpixSetWpl ( DPIX *dpix, l_int32 wpl );
         extern l_int32 dpixGetRefcount ( DPIX *dpix );
         extern l_int32 dpixChangeRefcount ( DPIX *dpix, l_int32 delta );
         extern l_int32 dpixGetResolution ( DPIX *dpix, l_int32 *pxres, l_int32 *pyres );
         extern l_int32 dpixSetResolution ( DPIX *dpix, l_int32 xres, l_int32 yres );
         extern l_int32 dpixCopyResolution ( DPIX *dpixd, DPIX *dpixs );
         extern l_float64 * dpixGetData ( DPIX *dpix );
         extern l_int32 dpixSetData ( DPIX *dpix, l_float64 *data );
         extern l_int32 dpixGetPixel ( DPIX *dpix, l_int32 x, l_int32 y, l_float64 *pval );
         extern l_int32 dpixSetPixel ( DPIX *dpix, l_int32 x, l_int32 y, l_float64 val );
         extern FPIX * fpixRead ( const char *filename );
         extern FPIX * fpixReadStream ( FILE *fp );
         extern l_int32 fpixWrite ( const char *filename, FPIX *fpix );
         extern l_int32 fpixWriteStream ( FILE *fp, FPIX *fpix );
         extern FPIX * fpixEndianByteSwap ( FPIX *fpixd, FPIX *fpixs );
         extern DPIX * dpixRead ( const char *filename );
         extern DPIX * dpixReadStream ( FILE *fp );
         extern l_int32 dpixWrite ( const char *filename, DPIX *dpix );
         extern l_int32 dpixWriteStream ( FILE *fp, DPIX *dpix );
         extern DPIX * dpixEndianByteSwap ( DPIX *dpixd, DPIX *dpixs );
         extern l_int32 fpixPrintStream ( FILE *fp, FPIX *fpix, l_int32 factor );
         extern FPIX * pixConvertToFPix ( PIX *pixs, l_int32 ncomps );
         extern DPIX * pixConvertToDPix ( PIX *pixs, l_int32 ncomps );
         extern PIX * fpixConvertToPix ( FPIX *fpixs, l_int32 outdepth, l_int32 negvals, l_int32 errorflag );
         extern PIX * fpixDisplayMaxDynamicRange ( FPIX *fpixs );
         extern DPIX * fpixConvertToDPix ( FPIX *fpix );
         extern PIX * dpixConvertToPix ( DPIX *dpixs, l_int32 outdepth, l_int32 negvals, l_int32 errorflag );
         extern FPIX * dpixConvertToFPix ( DPIX *dpix );
         extern l_int32 fpixGetMin ( FPIX *fpix, l_float32 *pminval, l_int32 *pxminloc, l_int32 *pyminloc );
         extern l_int32 fpixGetMax ( FPIX *fpix, l_float32 *pmaxval, l_int32 *pxmaxloc, l_int32 *pymaxloc );
         extern l_int32 dpixGetMin ( DPIX *dpix, l_float64 *pminval, l_int32 *pxminloc, l_int32 *pyminloc );
         extern l_int32 dpixGetMax ( DPIX *dpix, l_float64 *pmaxval, l_int32 *pxmaxloc, l_int32 *pymaxloc );
         extern FPIX * fpixScaleByInteger ( FPIX *fpixs, l_int32 factor );
         extern DPIX * dpixScaleByInteger ( DPIX *dpixs, l_int32 factor );
         extern FPIX * fpixLinearCombination ( FPIX *fpixd, FPIX *fpixs1, FPIX *fpixs2, l_float32 a, l_float32 b );
         extern l_int32 fpixAddMultConstant ( FPIX *fpix, l_float32 addc, l_float32 multc );
         extern DPIX * dpixLinearCombination ( DPIX *dpixd, DPIX *dpixs1, DPIX *dpixs2, l_float32 a, l_float32 b );
         extern l_int32 dpixAddMultConstant ( DPIX *dpix, l_float64 addc, l_float64 multc );
         extern l_int32 fpixSetAllArbitrary ( FPIX *fpix, l_float32 inval );
         extern l_int32 dpixSetAllArbitrary ( DPIX *dpix, l_float64 inval );
         extern FPIX * fpixAddBorder ( FPIX *fpixs, l_int32 left, l_int32 right, l_int32 top, l_int32 bot );
         extern FPIX * fpixRemoveBorder ( FPIX *fpixs, l_int32 left, l_int32 right, l_int32 top, l_int32 bot );
         extern FPIX * fpixAddMirroredBorder ( FPIX *fpixs, l_int32 left, l_int32 right, l_int32 top, l_int32 bot );
         extern FPIX * fpixAddContinuedBorder ( FPIX *fpixs, l_int32 left, l_int32 right, l_int32 top, l_int32 bot );
         extern FPIX * fpixAddSlopeBorder ( FPIX *fpixs, l_int32 left, l_int32 right, l_int32 top, l_int32 bot );
         extern l_int32 fpixRasterop ( FPIX *fpixd, l_int32 dx, l_int32 dy, l_int32 dw, l_int32 dh, FPIX *fpixs, l_int32 sx, l_int32 sy );
         extern FPIX * fpixRotateOrth ( FPIX *fpixs, l_int32 quads );
         extern FPIX * fpixRotate180 ( FPIX *fpixd, FPIX *fpixs );
         extern FPIX * fpixRotate90 ( FPIX *fpixs, l_int32 direction );
         extern FPIX * fpixFlipLR ( FPIX *fpixd, FPIX *fpixs );
         extern FPIX * fpixFlipTB ( FPIX *fpixd, FPIX *fpixs );
         extern FPIX * fpixAffinePta ( FPIX *fpixs, PTA *ptad, PTA *ptas, l_int32 border, l_float32 inval );
         extern FPIX * fpixAffine ( FPIX *fpixs, l_float32 *vc, l_float32 inval );
         extern FPIX * fpixProjectivePta ( FPIX *fpixs, PTA *ptad, PTA *ptas, l_int32 border, l_float32 inval );
         extern FPIX * fpixProjective ( FPIX *fpixs, l_float32 *vc, l_float32 inval );
         extern l_int32 linearInterpolatePixelFloat ( l_float32 *datas, l_int32 w, l_int32 h, l_float32 x, l_float32 y, l_float32 inval, l_float32 *pval );
         extern PIX * fpixThresholdToPix ( FPIX *fpix, l_float32 thresh );
         extern FPIX * pixComponentFunction ( PIX *pix, l_float32 rnum, l_float32 gnum, l_float32 bnum, l_float32 rdenom, l_float32 gdenom, l_float32 bdenom );
         extern PIX * pixReadStreamGif ( FILE *fp );
         extern l_int32 pixWriteStreamGif ( FILE *fp, PIX *pix );
         extern PIX * pixReadMemGif ( const l_uint8 *cdata, size_t size );
         extern l_int32 pixWriteMemGif ( l_uint8 **pdata, size_t *psize, PIX *pix );
         extern GPLOT * gplotCreate ( const char *rootname, l_int32 outformat, const char *title, const char *xlabel, const char *ylabel );
         extern void gplotDestroy ( GPLOT **pgplot );
         extern l_int32 gplotAddPlot ( GPLOT *gplot, NUMA *nax, NUMA *nay, l_int32 plotstyle, const char *plottitle );
         extern l_int32 gplotSetScaling ( GPLOT *gplot, l_int32 scaling );
         extern l_int32 gplotMakeOutput ( GPLOT *gplot );
         extern l_int32 gplotGenCommandFile ( GPLOT *gplot );
         extern l_int32 gplotGenDataFiles ( GPLOT *gplot );
         extern l_int32 gplotSimple1 ( NUMA *na, l_int32 outformat, const char *outroot, const char *title );
         extern l_int32 gplotSimple2 ( NUMA *na1, NUMA *na2, l_int32 outformat, const char *outroot, const char *title );
         extern l_int32 gplotSimpleN ( NUMAA *naa, l_int32 outformat, const char *outroot, const char *title );
         extern l_int32 gplotSimpleXY1 ( NUMA *nax, NUMA *nay, l_int32 outformat, const char *outroot, const char *title );
         extern l_int32 gplotSimpleXY2 ( NUMA *nax, NUMA *nay1, NUMA *nay2, l_int32 outformat, const char *outroot, const char *title );
         extern l_int32 gplotSimpleXYN ( NUMA *nax, NUMAA *naay, l_int32 outformat, const char *outroot, const char *title );
         extern GPLOT * gplotRead ( const char *filename );
         extern l_int32 gplotWrite ( const char *filename, GPLOT *gplot );
         extern PTA * generatePtaLine ( l_int32 x1, l_int32 y1, l_int32 x2, l_int32 y2 );
         extern PTA * generatePtaWideLine ( l_int32 x1, l_int32 y1, l_int32 x2, l_int32 y2, l_int32 width );
         extern PTA * generatePtaBox ( BOX *box, l_int32 width );
         extern PTA * generatePtaBoxa ( BOXA *boxa, l_int32 width, l_int32 removedups );
         extern PTA * generatePtaHashBox ( BOX *box, l_int32 spacing, l_int32 width, l_int32 orient, l_int32 outline );
         extern PTA * generatePtaHashBoxa ( BOXA *boxa, l_int32 spacing, l_int32 width, l_int32 orient, l_int32 outline, l_int32 removedups );
         extern PTAA * generatePtaaBoxa ( BOXA *boxa );
         extern PTAA * generatePtaaHashBoxa ( BOXA *boxa, l_int32 spacing, l_int32 width, l_int32 orient, l_int32 outline );
         extern PTA * generatePtaPolyline ( PTA *ptas, l_int32 width, l_int32 closeflag, l_int32 removedups );
         extern PTA * convertPtaLineTo4cc ( PTA *ptas );
         extern PTA * generatePtaFilledCircle ( l_int32 radius );
         extern PTA * generatePtaFilledSquare ( l_int32 side );
         extern PTA * generatePtaLineFromPt ( l_int32 x, l_int32 y, l_float64 length, l_float64 radang );
         extern l_int32 locatePtRadially ( l_int32 xr, l_int32 yr, l_float64 dist, l_float64 radang, l_float64 *px, l_float64 *py );
         extern l_int32 pixRenderPlotFromNuma ( PIX **ppix, NUMA *na, l_int32 plotloc, l_int32 linewidth, l_int32 max, l_uint32 color );
         extern PTA * makePlotPtaFromNuma ( NUMA *na, l_int32 size, l_int32 plotloc, l_int32 linewidth, l_int32 max );
         extern l_int32 pixRenderPlotFromNumaGen ( PIX **ppix, NUMA *na, l_int32 orient, l_int32 linewidth, l_int32 refpos, l_int32 max, l_int32 drawref, l_uint32 color );
         extern PTA * makePlotPtaFromNumaGen ( NUMA *na, l_int32 orient, l_int32 linewidth, l_int32 refpos, l_int32 max, l_int32 drawref );
         extern l_int32 pixRenderPta ( PIX *pix, PTA *pta, l_int32 op );
         extern l_int32 pixRenderPtaArb ( PIX *pix, PTA *pta, l_uint8 rval, l_uint8 gval, l_uint8 bval );
         extern l_int32 pixRenderPtaBlend ( PIX *pix, PTA *pta, l_uint8 rval, l_uint8 gval, l_uint8 bval, l_float32 fract );
         extern l_int32 pixRenderLine ( PIX *pix, l_int32 x1, l_int32 y1, l_int32 x2, l_int32 y2, l_int32 width, l_int32 op );
         extern l_int32 pixRenderLineArb ( PIX *pix, l_int32 x1, l_int32 y1, l_int32 x2, l_int32 y2, l_int32 width, l_uint8 rval, l_uint8 gval, l_uint8 bval );
         extern l_int32 pixRenderLineBlend ( PIX *pix, l_int32 x1, l_int32 y1, l_int32 x2, l_int32 y2, l_int32 width, l_uint8 rval, l_uint8 gval, l_uint8 bval, l_float32 fract );
         extern l_int32 pixRenderBox ( PIX *pix, BOX *box, l_int32 width, l_int32 op );
         extern l_int32 pixRenderBoxArb ( PIX *pix, BOX *box, l_int32 width, l_uint8 rval, l_uint8 gval, l_uint8 bval );
         extern l_int32 pixRenderBoxBlend ( PIX *pix, BOX *box, l_int32 width, l_uint8 rval, l_uint8 gval, l_uint8 bval, l_float32 fract );
         extern l_int32 pixRenderBoxa ( PIX *pix, BOXA *boxa, l_int32 width, l_int32 op );
         extern l_int32 pixRenderBoxaArb ( PIX *pix, BOXA *boxa, l_int32 width, l_uint8 rval, l_uint8 gval, l_uint8 bval );
         extern l_int32 pixRenderBoxaBlend ( PIX *pix, BOXA *boxa, l_int32 width, l_uint8 rval, l_uint8 gval, l_uint8 bval, l_float32 fract, l_int32 removedups );
         extern l_int32 pixRenderHashBox ( PIX *pix, BOX *box, l_int32 spacing, l_int32 width, l_int32 orient, l_int32 outline, l_int32 op );
         extern l_int32 pixRenderHashBoxArb ( PIX *pix, BOX *box, l_int32 spacing, l_int32 width, l_int32 orient, l_int32 outline, l_int32 rval, l_int32 gval, l_int32 bval );
         extern l_int32 pixRenderHashBoxBlend ( PIX *pix, BOX *box, l_int32 spacing, l_int32 width, l_int32 orient, l_int32 outline, l_int32 rval, l_int32 gval, l_int32 bval, l_float32 fract );
         extern l_int32 pixRenderHashBoxa ( PIX *pix, BOXA *boxa, l_int32 spacing, l_int32 width, l_int32 orient, l_int32 outline, l_int32 op );
         extern l_int32 pixRenderHashBoxaArb ( PIX *pix, BOXA *boxa, l_int32 spacing, l_int32 width, l_int32 orient, l_int32 outline, l_int32 rval, l_int32 gval, l_int32 bval );
         extern l_int32 pixRenderHashBoxaBlend ( PIX *pix, BOXA *boxa, l_int32 spacing, l_int32 width, l_int32 orient, l_int32 outline, l_int32 rval, l_int32 gval, l_int32 bval, l_float32 fract );
         extern l_int32 pixRenderPolyline ( PIX *pix, PTA *ptas, l_int32 width, l_int32 op, l_int32 closeflag );
         extern l_int32 pixRenderPolylineArb ( PIX *pix, PTA *ptas, l_int32 width, l_uint8 rval, l_uint8 gval, l_uint8 bval, l_int32 closeflag );
         extern l_int32 pixRenderPolylineBlend ( PIX *pix, PTA *ptas, l_int32 width, l_uint8 rval, l_uint8 gval, l_uint8 bval, l_float32 fract, l_int32 closeflag, l_int32 removedups );
         extern PIX * pixRenderRandomCmapPtaa ( PIX *pix, PTAA *ptaa, l_int32 polyflag, l_int32 width, l_int32 closeflag );
         extern PIX * pixRenderPolygon ( PTA *ptas, l_int32 width, l_int32 *pxmin, l_int32 *pymin );
         extern PIX * pixFillPolygon ( PIX *pixs, PTA *pta, l_int32 xmin, l_int32 ymin );
         extern PIX * pixRenderContours ( PIX *pixs, l_int32 startval, l_int32 incr, l_int32 outdepth );
         extern PIX * fpixAutoRenderContours ( FPIX *fpix, l_int32 ncontours );
         extern PIX * fpixRenderContours ( FPIX *fpixs, l_float32 incr, l_float32 proxim );
         extern PIX * pixErodeGray ( PIX *pixs, l_int32 hsize, l_int32 vsize );
         extern PIX * pixDilateGray ( PIX *pixs, l_int32 hsize, l_int32 vsize );
         extern PIX * pixOpenGray ( PIX *pixs, l_int32 hsize, l_int32 vsize );
         extern PIX * pixCloseGray ( PIX *pixs, l_int32 hsize, l_int32 vsize );
         extern PIX * pixErodeGray3 ( PIX *pixs, l_int32 hsize, l_int32 vsize );
         extern PIX * pixDilateGray3 ( PIX *pixs, l_int32 hsize, l_int32 vsize );
         extern PIX * pixOpenGray3 ( PIX *pixs, l_int32 hsize, l_int32 vsize );
         extern PIX * pixCloseGray3 ( PIX *pixs, l_int32 hsize, l_int32 vsize );
         extern void dilateGrayLow ( l_uint32 *datad, l_int32 w, l_int32 h, l_int32 wpld, l_uint32 *datas, l_int32 wpls, l_int32 size, l_int32 direction, l_uint8 *buffer, l_uint8 *maxarray );
         extern void erodeGrayLow ( l_uint32 *datad, l_int32 w, l_int32 h, l_int32 wpld, l_uint32 *datas, l_int32 wpls, l_int32 size, l_int32 direction, l_uint8 *buffer, l_uint8 *minarray );
         extern PIX * pixDitherToBinary ( PIX *pixs );
         extern PIX * pixDitherToBinarySpec ( PIX *pixs, l_int32 lowerclip, l_int32 upperclip );
         extern PIX * pixThresholdToBinary ( PIX *pixs, l_int32 thresh );
         extern PIX * pixVarThresholdToBinary ( PIX *pixs, PIX *pixg );
         extern PIX * pixAdaptThresholdToBinary ( PIX *pixs, PIX *pixm, l_float32 gamma );
         extern PIX * pixAdaptThresholdToBinaryGen ( PIX *pixs, PIX *pixm, l_float32 gamma, l_int32 blackval, l_int32 whiteval, l_int32 thresh );
         extern PIX * pixDitherToBinaryLUT ( PIX *pixs, l_int32 lowerclip, l_int32 upperclip );
         extern PIX * pixGenerateMaskByValue ( PIX *pixs, l_int32 val, l_int32 usecmap );
         extern PIX * pixGenerateMaskByBand ( PIX *pixs, l_int32 lower, l_int32 upper, l_int32 inband, l_int32 usecmap );
         extern PIX * pixDitherTo2bpp ( PIX *pixs, l_int32 cmapflag );
         extern PIX * pixDitherTo2bppSpec ( PIX *pixs, l_int32 lowerclip, l_int32 upperclip, l_int32 cmapflag );
         extern PIX * pixThresholdTo2bpp ( PIX *pixs, l_int32 nlevels, l_int32 cmapflag );
         extern PIX * pixThresholdTo4bpp ( PIX *pixs, l_int32 nlevels, l_int32 cmapflag );
         extern PIX * pixThresholdOn8bpp ( PIX *pixs, l_int32 nlevels, l_int32 cmapflag );
         extern PIX * pixThresholdGrayArb ( PIX *pixs, const char *edgevals, l_int32 outdepth, l_int32 use_average, l_int32 setblack, l_int32 setwhite );
         extern l_int32 * makeGrayQuantIndexTable ( l_int32 nlevels );
         extern l_int32 * makeGrayQuantTargetTable ( l_int32 nlevels, l_int32 depth );
         extern l_int32 makeGrayQuantTableArb ( NUMA *na, l_int32 outdepth, l_int32 **ptab, PIXCMAP **pcmap );
         extern l_int32 makeGrayQuantColormapArb ( PIX *pixs, l_int32 *tab, l_int32 outdepth, PIXCMAP **pcmap );
         extern PIX * pixGenerateMaskByBand32 ( PIX *pixs, l_uint32 refval, l_int32 delm, l_int32 delp, l_float32 fractm, l_float32 fractp );
         extern PIX * pixGenerateMaskByDiscr32 ( PIX *pixs, l_uint32 refval1, l_uint32 refval2, l_int32 distflag );
         extern PIX * pixGrayQuantFromHisto ( PIX *pixd, PIX *pixs, PIX *pixm, l_float32 minfract, l_int32 maxsize );
         extern PIX * pixGrayQuantFromCmap ( PIX *pixs, PIXCMAP *cmap, l_int32 mindepth );
         extern void ditherToBinaryLow ( l_uint32 *datad, l_int32 w, l_int32 h, l_int32 wpld, l_uint32 *datas, l_int32 wpls, l_uint32 *bufs1, l_uint32 *bufs2, l_int32 lowerclip, l_int32 upperclip );
         extern void ditherToBinaryLineLow ( l_uint32 *lined, l_int32 w, l_uint32 *bufs1, l_uint32 *bufs2, l_int32 lowerclip, l_int32 upperclip, l_int32 lastlineflag );
         extern void thresholdToBinaryLow ( l_uint32 *datad, l_int32 w, l_int32 h, l_int32 wpld, l_uint32 *datas, l_int32 d, l_int32 wpls, l_int32 thresh );
         extern void thresholdToBinaryLineLow ( l_uint32 *lined, l_int32 w, l_uint32 *lines, l_int32 d, l_int32 thresh );
         extern void ditherToBinaryLUTLow ( l_uint32 *datad, l_int32 w, l_int32 h, l_int32 wpld, l_uint32 *datas, l_int32 wpls, l_uint32 *bufs1, l_uint32 *bufs2, l_int32 *tabval, l_int32 *tab38, l_int32 *tab14 );
         extern void ditherToBinaryLineLUTLow ( l_uint32 *lined, l_int32 w, l_uint32 *bufs1, l_uint32 *bufs2, l_int32 *tabval, l_int32 *tab38, l_int32 *tab14, l_int32 lastlineflag );
         extern l_int32 make8To1DitherTables ( l_int32 **ptabval, l_int32 **ptab38, l_int32 **ptab14, l_int32 lowerclip, l_int32 upperclip );
         extern void ditherTo2bppLow ( l_uint32 *datad, l_int32 w, l_int32 h, l_int32 wpld, l_uint32 *datas, l_int32 wpls, l_uint32 *bufs1, l_uint32 *bufs2, l_int32 *tabval, l_int32 *tab38, l_int32 *tab14 );
         extern void ditherTo2bppLineLow ( l_uint32 *lined, l_int32 w, l_uint32 *bufs1, l_uint32 *bufs2, l_int32 *tabval, l_int32 *tab38, l_int32 *tab14, l_int32 lastlineflag );
         extern l_int32 make8To2DitherTables ( l_int32 **ptabval, l_int32 **ptab38, l_int32 **ptab14, l_int32 cliptoblack, l_int32 cliptowhite );
         extern void thresholdTo2bppLow ( l_uint32 *datad, l_int32 h, l_int32 wpld, l_uint32 *datas, l_int32 wpls, l_int32 *tab );
         extern void thresholdTo4bppLow ( l_uint32 *datad, l_int32 h, l_int32 wpld, l_uint32 *datas, l_int32 wpls, l_int32 *tab );
         extern L_HEAP * lheapCreate ( l_int32 nalloc, l_int32 direction );
         extern void lheapDestroy ( L_HEAP **plh, l_int32 freeflag );
         extern l_int32 lheapAdd ( L_HEAP *lh, void *item );
         extern void * lheapRemove ( L_HEAP *lh );
         extern l_int32 lheapGetCount ( L_HEAP *lh );
         extern l_int32 lheapSwapUp ( L_HEAP *lh, l_int32 index );
         extern l_int32 lheapSwapDown ( L_HEAP *lh );
         extern l_int32 lheapSort ( L_HEAP *lh );
         extern l_int32 lheapSortStrictOrder ( L_HEAP *lh );
         extern l_int32 lheapPrint ( FILE *fp, L_HEAP *lh );
         extern JBCLASSER * jbRankHausInit ( l_int32 components, l_int32 maxwidth, l_int32 maxheight, l_int32 size, l_float32 rank );
         extern JBCLASSER * jbCorrelationInit ( l_int32 components, l_int32 maxwidth, l_int32 maxheight, l_float32 thresh, l_float32 weightfactor );
         extern JBCLASSER * jbCorrelationInitWithoutComponents ( l_int32 components, l_int32 maxwidth, l_int32 maxheight, l_float32 thresh, l_float32 weightfactor );
         extern l_int32 jbAddPages ( JBCLASSER *classer, SARRAY *safiles );
         extern l_int32 jbAddPage ( JBCLASSER *classer, PIX *pixs );
         extern l_int32 jbAddPageComponents ( JBCLASSER *classer, PIX *pixs, BOXA *boxas, PIXA *pixas );
         extern l_int32 jbClassifyRankHaus ( JBCLASSER *classer, BOXA *boxa, PIXA *pixas );
         extern l_int32 pixHaustest ( PIX *pix1, PIX *pix2, PIX *pix3, PIX *pix4, l_float32 delx, l_float32 dely, l_int32 maxdiffw, l_int32 maxdiffh );
         extern l_int32 pixRankHaustest ( PIX *pix1, PIX *pix2, PIX *pix3, PIX *pix4, l_float32 delx, l_float32 dely, l_int32 maxdiffw, l_int32 maxdiffh, l_int32 area1, l_int32 area3, l_float32 rank, l_int32 *tab8 );
         extern l_int32 jbClassifyCorrelation ( JBCLASSER *classer, BOXA *boxa, PIXA *pixas );
         extern l_int32 jbGetComponents ( PIX *pixs, l_int32 components, l_int32 maxwidth, l_int32 maxheight, BOXA **pboxad, PIXA **ppixad );
         extern l_int32 pixWordMaskByDilation ( PIX *pixs, l_int32 maxdil, PIX **ppixm, l_int32 *psize );
         extern l_int32 pixWordBoxesByDilation ( PIX *pixs, l_int32 maxdil, l_int32 minwidth, l_int32 minheight, l_int32 maxwidth, l_int32 maxheight, BOXA **pboxa, l_int32 *psize );
         extern PIXA * jbAccumulateComposites ( PIXAA *pixaa, NUMA **pna, PTA **pptat );
         extern PIXA * jbTemplatesFromComposites ( PIXA *pixac, NUMA *na );
         extern JBCLASSER * jbClasserCreate ( l_int32 method, l_int32 components );
         extern void jbClasserDestroy ( JBCLASSER **pclasser );
         extern JBDATA * jbDataSave ( JBCLASSER *classer );
         extern void jbDataDestroy ( JBDATA **pdata );
         extern l_int32 jbDataWrite ( const char *rootout, JBDATA *jbdata );
         extern JBDATA * jbDataRead ( const char *rootname );
         extern PIXA * jbDataRender ( JBDATA *data, l_int32 debugflag );
         extern l_int32 jbGetULCorners ( JBCLASSER *classer, PIX *pixs, BOXA *boxa );
         extern l_int32 jbGetLLCorners ( JBCLASSER *classer );
         extern l_int32 readHeaderJp2k ( const char *filename, l_int32 *pw, l_int32 *ph, l_int32 *pbps, l_int32 *pspp );
         extern l_int32 freadHeaderJp2k ( FILE *fp, l_int32 *pw, l_int32 *ph, l_int32 *pbps, l_int32 *pspp );
         extern l_int32 readHeaderMemJp2k ( const l_uint8 *data, size_t size, l_int32 *pw, l_int32 *ph, l_int32 *pbps, l_int32 *pspp );
         extern l_int32 fgetJp2kResolution ( FILE *fp, l_int32 *pxres, l_int32 *pyres );
         extern PIX * pixReadJp2k ( const char *filename, l_uint32 reduction, BOX *box, l_int32 hint );
         extern PIX * pixReadStreamJp2k ( FILE *fp, l_uint32 reduction, BOX *box, l_int32 hint );
         extern l_int32 pixWriteJp2k ( const char *filename, PIX *pix, l_int32 quality, l_int32 nlevels, l_int32 hint );
         extern l_int32 pixWriteStreamJp2k ( FILE *fp, PIX *pix, l_int32 quality, l_int32 nlevels, l_int32 hint );
         extern PIX * pixReadMemJp2k ( const l_uint8 *data, size_t size, l_uint32 reduction, BOX *box, l_int32 hint );
         extern l_int32 pixWriteMemJp2k ( l_uint8 **pdata, size_t *psize, PIX *pix, l_int32 quality, l_int32 nlevels, l_int32 hint );
         extern PIX * pixReadJpeg ( const char *filename, l_int32 cmflag, l_int32 reduction, l_int32 *pnwarn, l_int32 hint );
         extern PIX * pixReadStreamJpeg ( FILE *fp, l_int32 cmflag, l_int32 reduction, l_int32 *pnwarn, l_int32 hint );
         extern l_int32 readHeaderJpeg ( const char *filename, l_int32 *pw, l_int32 *ph, l_int32 *pspp, l_int32 *pycck, l_int32 *pcmyk );
         extern l_int32 freadHeaderJpeg ( FILE *fp, l_int32 *pw, l_int32 *ph, l_int32 *pspp, l_int32 *pycck, l_int32 *pcmyk );
         extern l_int32 fgetJpegResolution ( FILE *fp, l_int32 *pxres, l_int32 *pyres );
         extern l_int32 fgetJpegComment ( FILE *fp, l_uint8 **pcomment );
         extern l_int32 pixWriteJpeg ( const char *filename, PIX *pix, l_int32 quality, l_int32 progressive );
         extern l_int32 pixWriteStreamJpeg ( FILE *fp, PIX *pixs, l_int32 quality, l_int32 progressive );
         extern PIX * pixReadMemJpeg ( const l_uint8 *data, size_t size, l_int32 cmflag, l_int32 reduction, l_int32 *pnwarn, l_int32 hint );
         extern l_int32 readHeaderMemJpeg ( const l_uint8 *data, size_t size, l_int32 *pw, l_int32 *ph, l_int32 *pspp, l_int32 *pycck, l_int32 *pcmyk );
         extern l_int32 pixWriteMemJpeg ( l_uint8 **pdata, size_t *psize, PIX *pix, l_int32 quality, l_int32 progressive );
         extern l_int32 pixSetChromaSampling ( PIX *pix, l_int32 sampling );
         extern L_KERNEL * kernelCreate ( l_int32 height, l_int32 width );
         extern void kernelDestroy ( L_KERNEL **pkel );
         extern L_KERNEL * kernelCopy ( L_KERNEL *kels );
         extern l_int32 kernelGetElement ( L_KERNEL *kel, l_int32 row, l_int32 col, l_float32 *pval );
         extern l_int32 kernelSetElement ( L_KERNEL *kel, l_int32 row, l_int32 col, l_float32 val );
         extern l_int32 kernelGetParameters ( L_KERNEL *kel, l_int32 *psy, l_int32 *psx, l_int32 *pcy, l_int32 *pcx );
         extern l_int32 kernelSetOrigin ( L_KERNEL *kel, l_int32 cy, l_int32 cx );
         extern l_int32 kernelGetSum ( L_KERNEL *kel, l_float32 *psum );
         extern l_int32 kernelGetMinMax ( L_KERNEL *kel, l_float32 *pmin, l_float32 *pmax );
         extern L_KERNEL * kernelNormalize ( L_KERNEL *kels, l_float32 normsum );
         extern L_KERNEL * kernelInvert ( L_KERNEL *kels );
         extern l_float32 ** create2dFloatArray ( l_int32 sy, l_int32 sx );
         extern L_KERNEL * kernelRead ( const char *fname );
         extern L_KERNEL * kernelReadStream ( FILE *fp );
         extern l_int32 kernelWrite ( const char *fname, L_KERNEL *kel );
         extern l_int32 kernelWriteStream ( FILE *fp, L_KERNEL *kel );
         extern L_KERNEL * kernelCreateFromString ( l_int32 h, l_int32 w, l_int32 cy, l_int32 cx, const char *kdata );
         extern L_KERNEL * kernelCreateFromFile ( const char *filename );
         extern L_KERNEL * kernelCreateFromPix ( PIX *pix, l_int32 cy, l_int32 cx );
         extern PIX * kernelDisplayInPix ( L_KERNEL *kel, l_int32 size, l_int32 gthick );
         extern NUMA * parseStringForNumbers ( const char *str, const char *seps );
         extern L_KERNEL * makeFlatKernel ( l_int32 height, l_int32 width, l_int32 cy, l_int32 cx );
         extern L_KERNEL * makeGaussianKernel ( l_int32 halfheight, l_int32 halfwidth, l_float32 stdev, l_float32 max );
         extern l_int32 makeGaussianKernelSep ( l_int32 halfheight, l_int32 halfwidth, l_float32 stdev, l_float32 max, L_KERNEL **pkelx, L_KERNEL **pkely );
         extern L_KERNEL * makeDoGKernel ( l_int32 halfheight, l_int32 halfwidth, l_float32 stdev, l_float32 ratio );
         extern char * getImagelibVersions ( );
         extern void listDestroy ( DLLIST **phead );
         extern l_int32 listAddToHead ( DLLIST **phead, void *data );
         extern l_int32 listAddToTail ( DLLIST **phead, DLLIST **ptail, void *data );
         extern l_int32 listInsertBefore ( DLLIST **phead, DLLIST *elem, void *data );
         extern l_int32 listInsertAfter ( DLLIST **phead, DLLIST *elem, void *data );
         extern void * listRemoveElement ( DLLIST **phead, DLLIST *elem );
         extern void * listRemoveFromHead ( DLLIST **phead );
         extern void * listRemoveFromTail ( DLLIST **phead, DLLIST **ptail );
         extern DLLIST * listFindElement ( DLLIST *head, void *data );
         extern DLLIST * listFindTail ( DLLIST *head );
         extern l_int32 listGetCount ( DLLIST *head );
         extern l_int32 listReverse ( DLLIST **phead );
         extern l_int32 listJoin ( DLLIST **phead1, DLLIST **phead2 );
         extern PIX * generateBinaryMaze ( l_int32 w, l_int32 h, l_int32 xi, l_int32 yi, l_float32 wallps, l_float32 ranis );
         extern PTA * pixSearchBinaryMaze ( PIX *pixs, l_int32 xi, l_int32 yi, l_int32 xf, l_int32 yf, PIX **ppixd );
         extern PTA * pixSearchGrayMaze ( PIX *pixs, l_int32 xi, l_int32 yi, l_int32 xf, l_int32 yf, PIX **ppixd );
         extern l_int32 pixFindLargestRectangle ( PIX *pixs, l_int32 polarity, BOX **pbox, const char *debugfile );
         extern PIX * pixDilate ( PIX *pixd, PIX *pixs, SEL *sel );
         extern PIX * pixErode ( PIX *pixd, PIX *pixs, SEL *sel );
         extern PIX * pixHMT ( PIX *pixd, PIX *pixs, SEL *sel );
         extern PIX * pixOpen ( PIX *pixd, PIX *pixs, SEL *sel );
         extern PIX * pixClose ( PIX *pixd, PIX *pixs, SEL *sel );
         extern PIX * pixCloseSafe ( PIX *pixd, PIX *pixs, SEL *sel );
         extern PIX * pixOpenGeneralized ( PIX *pixd, PIX *pixs, SEL *sel );
         extern PIX * pixCloseGeneralized ( PIX *pixd, PIX *pixs, SEL *sel );
         extern PIX * pixDilateBrick ( PIX *pixd, PIX *pixs, l_int32 hsize, l_int32 vsize );
         extern PIX * pixErodeBrick ( PIX *pixd, PIX *pixs, l_int32 hsize, l_int32 vsize );
         extern PIX * pixOpenBrick ( PIX *pixd, PIX *pixs, l_int32 hsize, l_int32 vsize );
         extern PIX * pixCloseBrick ( PIX *pixd, PIX *pixs, l_int32 hsize, l_int32 vsize );
         extern PIX * pixCloseSafeBrick ( PIX *pixd, PIX *pixs, l_int32 hsize, l_int32 vsize );
         extern l_int32 selectComposableSels ( l_int32 size, l_int32 direction, SEL **psel1, SEL **psel2 );
         extern l_int32 selectComposableSizes ( l_int32 size, l_int32 *pfactor1, l_int32 *pfactor2 );
         extern PIX * pixDilateCompBrick ( PIX *pixd, PIX *pixs, l_int32 hsize, l_int32 vsize );
         extern PIX * pixErodeCompBrick ( PIX *pixd, PIX *pixs, l_int32 hsize, l_int32 vsize );
         extern PIX * pixOpenCompBrick ( PIX *pixd, PIX *pixs, l_int32 hsize, l_int32 vsize );
         extern PIX * pixCloseCompBrick ( PIX *pixd, PIX *pixs, l_int32 hsize, l_int32 vsize );
         extern PIX * pixCloseSafeCompBrick ( PIX *pixd, PIX *pixs, l_int32 hsize, l_int32 vsize );
         extern void resetMorphBoundaryCondition ( l_int32 bc );
         extern l_uint32 getMorphBorderPixelColor ( l_int32 type, l_int32 depth );
         extern PIX * pixExtractBoundary ( PIX *pixs, l_int32 type );
         extern PIX * pixMorphSequenceMasked ( PIX *pixs, PIX *pixm, const char *sequence, l_int32 dispsep );
         extern PIX * pixMorphSequenceByComponent ( PIX *pixs, const char *sequence, l_int32 connectivity, l_int32 minw, l_int32 minh, BOXA **pboxa );
         extern PIXA * pixaMorphSequenceByComponent ( PIXA *pixas, const char *sequence, l_int32 minw, l_int32 minh );
         extern PIX * pixMorphSequenceByRegion ( PIX *pixs, PIX *pixm, const char *sequence, l_int32 connectivity, l_int32 minw, l_int32 minh, BOXA **pboxa );
         extern PIXA * pixaMorphSequenceByRegion ( PIX *pixs, PIXA *pixam, const char *sequence, l_int32 minw, l_int32 minh );
         extern PIX * pixUnionOfMorphOps ( PIX *pixs, SELA *sela, l_int32 type );
         extern PIX * pixIntersectionOfMorphOps ( PIX *pixs, SELA *sela, l_int32 type );
         extern PIX * pixSelectiveConnCompFill ( PIX *pixs, l_int32 connectivity, l_int32 minw, l_int32 minh );
         extern l_int32 pixRemoveMatchedPattern ( PIX *pixs, PIX *pixp, PIX *pixe, l_int32 x0, l_int32 y0, l_int32 dsize );
         extern PIX * pixDisplayMatchedPattern ( PIX *pixs, PIX *pixp, PIX *pixe, l_int32 x0, l_int32 y0, l_uint32 color, l_float32 scale, l_int32 nlevels );
         extern PIX * pixSeedfillMorph ( PIX *pixs, PIX *pixm, l_int32 maxiters, l_int32 connectivity );
         extern NUMA * pixRunHistogramMorph ( PIX *pixs, l_int32 runtype, l_int32 direction, l_int32 maxsize );
         extern PIX * pixTophat ( PIX *pixs, l_int32 hsize, l_int32 vsize, l_int32 type );
         extern PIX * pixHDome ( PIX *pixs, l_int32 height, l_int32 connectivity );
         extern PIX * pixFastTophat ( PIX *pixs, l_int32 xsize, l_int32 ysize, l_int32 type );
         extern PIX * pixMorphGradient ( PIX *pixs, l_int32 hsize, l_int32 vsize, l_int32 smoothing );
         extern PTA * pixaCentroids ( PIXA *pixa );
         extern l_int32 pixCentroid ( PIX *pix, l_int32 *centtab, l_int32 *sumtab, l_float32 *pxave, l_float32 *pyave );
         extern PIX * pixDilateBrickDwa ( PIX *pixd, PIX *pixs, l_int32 hsize, l_int32 vsize );
         extern PIX * pixErodeBrickDwa ( PIX *pixd, PIX *pixs, l_int32 hsize, l_int32 vsize );
         extern PIX * pixOpenBrickDwa ( PIX *pixd, PIX *pixs, l_int32 hsize, l_int32 vsize );
         extern PIX * pixCloseBrickDwa ( PIX *pixd, PIX *pixs, l_int32 hsize, l_int32 vsize );
         extern PIX * pixDilateCompBrickDwa ( PIX *pixd, PIX *pixs, l_int32 hsize, l_int32 vsize );
         extern PIX * pixErodeCompBrickDwa ( PIX *pixd, PIX *pixs, l_int32 hsize, l_int32 vsize );
         extern PIX * pixOpenCompBrickDwa ( PIX *pixd, PIX *pixs, l_int32 hsize, l_int32 vsize );
         extern PIX * pixCloseCompBrickDwa ( PIX *pixd, PIX *pixs, l_int32 hsize, l_int32 vsize );
         extern PIX * pixDilateCompBrickExtendDwa ( PIX *pixd, PIX *pixs, l_int32 hsize, l_int32 vsize );
         extern PIX * pixErodeCompBrickExtendDwa ( PIX *pixd, PIX *pixs, l_int32 hsize, l_int32 vsize );
         extern PIX * pixOpenCompBrickExtendDwa ( PIX *pixd, PIX *pixs, l_int32 hsize, l_int32 vsize );
         extern PIX * pixCloseCompBrickExtendDwa ( PIX *pixd, PIX *pixs, l_int32 hsize, l_int32 vsize );
         extern l_int32 getExtendedCompositeParameters ( l_int32 size, l_int32 *pn, l_int32 *pextra, l_int32 *pactualsize );
         extern PIX * pixMorphSequence ( PIX *pixs, const char *sequence, l_int32 dispsep );
         extern PIX * pixMorphCompSequence ( PIX *pixs, const char *sequence, l_int32 dispsep );
         extern PIX * pixMorphSequenceDwa ( PIX *pixs, const char *sequence, l_int32 dispsep );
         extern PIX * pixMorphCompSequenceDwa ( PIX *pixs, const char *sequence, l_int32 dispsep );
         extern l_int32 morphSequenceVerify ( SARRAY *sa );
         extern PIX * pixGrayMorphSequence ( PIX *pixs, const char *sequence, l_int32 dispsep, l_int32 dispy );
         extern PIX * pixColorMorphSequence ( PIX *pixs, const char *sequence, l_int32 dispsep, l_int32 dispy );
         extern NUMA * numaCreate ( l_int32 n );
         extern NUMA * numaCreateFromIArray ( l_int32 *iarray, l_int32 size );
         extern NUMA * numaCreateFromFArray ( l_float32 *farray, l_int32 size, l_int32 copyflag );
         extern void numaDestroy ( NUMA **pna );
         extern NUMA * numaCopy ( NUMA *na );
         extern NUMA * numaClone ( NUMA *na );
         extern l_int32 numaEmpty ( NUMA *na );
         extern l_int32 numaAddNumber ( NUMA *na, l_float32 val );
         extern l_int32 numaInsertNumber ( NUMA *na, l_int32 index, l_float32 val );
         extern l_int32 numaRemoveNumber ( NUMA *na, l_int32 index );
         extern l_int32 numaReplaceNumber ( NUMA *na, l_int32 index, l_float32 val );
         extern l_int32 numaGetCount ( NUMA *na );
         extern l_int32 numaSetCount ( NUMA *na, l_int32 newcount );
         extern l_int32 numaGetFValue ( NUMA *na, l_int32 index, l_float32 *pval );
         extern l_int32 numaGetIValue ( NUMA *na, l_int32 index, l_int32 *pival );
         extern l_int32 numaSetValue ( NUMA *na, l_int32 index, l_float32 val );
         extern l_int32 numaShiftValue ( NUMA *na, l_int32 index, l_float32 diff );
         extern l_int32 * numaGetIArray ( NUMA *na );
         extern l_float32 * numaGetFArray ( NUMA *na, l_int32 copyflag );
         extern l_int32 numaGetRefcount ( NUMA *na );
         extern l_int32 numaChangeRefcount ( NUMA *na, l_int32 delta );
         extern l_int32 numaGetParameters ( NUMA *na, l_float32 *pstartx, l_float32 *pdelx );
         extern l_int32 numaSetParameters ( NUMA *na, l_float32 startx, l_float32 delx );
         extern l_int32 numaCopyParameters ( NUMA *nad, NUMA *nas );
         extern SARRAY * numaConvertToSarray ( NUMA *na, l_int32 size1, l_int32 size2, l_int32 addzeros, l_int32 type );
         extern NUMA * numaRead ( const char *filename );
         extern NUMA * numaReadStream ( FILE *fp );
         extern l_int32 numaWrite ( const char *filename, NUMA *na );
         extern l_int32 numaWriteStream ( FILE *fp, NUMA *na );
         extern NUMAA * numaaCreate ( l_int32 n );
         extern NUMAA * numaaCreateFull ( l_int32 ntop, l_int32 n );
         extern l_int32 numaaTruncate ( NUMAA *naa );
         extern void numaaDestroy ( NUMAA **pnaa );
         extern l_int32 numaaAddNuma ( NUMAA *naa, NUMA *na, l_int32 copyflag );
         extern l_int32 numaaExtendArray ( NUMAA *naa );
         extern l_int32 numaaGetCount ( NUMAA *naa );
         extern l_int32 numaaGetNumaCount ( NUMAA *naa, l_int32 index );
         extern l_int32 numaaGetNumberCount ( NUMAA *naa );
         extern NUMA ** numaaGetPtrArray ( NUMAA *naa );
         extern NUMA * numaaGetNuma ( NUMAA *naa, l_int32 index, l_int32 accessflag );
         extern l_int32 numaaReplaceNuma ( NUMAA *naa, l_int32 index, NUMA *na );
         extern l_int32 numaaGetValue ( NUMAA *naa, l_int32 i, l_int32 j, l_float32 *pfval, l_int32 *pival );
         extern l_int32 numaaAddNumber ( NUMAA *naa, l_int32 index, l_float32 val );
         extern NUMAA * numaaRead ( const char *filename );
         extern NUMAA * numaaReadStream ( FILE *fp );
         extern l_int32 numaaWrite ( const char *filename, NUMAA *naa );
         extern l_int32 numaaWriteStream ( FILE *fp, NUMAA *naa );
         extern NUMA2D * numa2dCreate ( l_int32 nrows, l_int32 ncols, l_int32 initsize );
         extern void numa2dDestroy ( NUMA2D **pna2d );
         extern l_int32 numa2dAddNumber ( NUMA2D *na2d, l_int32 row, l_int32 col, l_float32 val );
         extern l_int32 numa2dGetCount ( NUMA2D *na2d, l_int32 row, l_int32 col );
         extern NUMA * numa2dGetNuma ( NUMA2D *na2d, l_int32 row, l_int32 col );
         extern l_int32 numa2dGetFValue ( NUMA2D *na2d, l_int32 row, l_int32 col, l_int32 index, l_float32 *pval );
         extern l_int32 numa2dGetIValue ( NUMA2D *na2d, l_int32 row, l_int32 col, l_int32 index, l_int32 *pval );
         extern NUMAHASH * numaHashCreate ( l_int32 nbuckets, l_int32 initsize );
         extern void numaHashDestroy ( NUMAHASH **pnahash );
         extern NUMA * numaHashGetNuma ( NUMAHASH *nahash, l_uint32 key );
         extern l_int32 numaHashAdd ( NUMAHASH *nahash, l_uint32 key, l_float32 value );
         extern NUMA * numaArithOp ( NUMA *nad, NUMA *na1, NUMA *na2, l_int32 op );
         extern NUMA * numaLogicalOp ( NUMA *nad, NUMA *na1, NUMA *na2, l_int32 op );
         extern NUMA * numaInvert ( NUMA *nad, NUMA *nas );
         extern l_int32 numaSimilar ( NUMA *na1, NUMA *na2, l_float32 maxdiff, l_int32 *psimilar );
         extern l_int32 numaAddToNumber ( NUMA *na, l_int32 index, l_float32 val );
         extern l_int32 numaGetMin ( NUMA *na, l_float32 *pminval, l_int32 *piminloc );
         extern l_int32 numaGetMax ( NUMA *na, l_float32 *pmaxval, l_int32 *pimaxloc );
         extern l_int32 numaGetSum ( NUMA *na, l_float32 *psum );
         extern NUMA * numaGetPartialSums ( NUMA *na );
         extern l_int32 numaGetSumOnInterval ( NUMA *na, l_int32 first, l_int32 last, l_float32 *psum );
         extern l_int32 numaHasOnlyIntegers ( NUMA *na, l_int32 maxsamples, l_int32 *pallints );
         extern NUMA * numaSubsample ( NUMA *nas, l_int32 subfactor );
         extern NUMA * numaMakeDelta ( NUMA *nas );
         extern NUMA * numaMakeSequence ( l_float32 startval, l_float32 increment, l_int32 size );
         extern NUMA * numaMakeConstant ( l_float32 val, l_int32 size );
         extern NUMA * numaMakeAbsValue ( NUMA *nad, NUMA *nas );
         extern NUMA * numaAddBorder ( NUMA *nas, l_int32 left, l_int32 right, l_float32 val );
         extern NUMA * numaAddSpecifiedBorder ( NUMA *nas, l_int32 left, l_int32 right, l_int32 type );
         extern NUMA * numaRemoveBorder ( NUMA *nas, l_int32 left, l_int32 right );
         extern l_int32 numaGetNonzeroRange ( NUMA *na, l_float32 eps, l_int32 *pfirst, l_int32 *plast );
         extern l_int32 numaGetCountRelativeToZero ( NUMA *na, l_int32 type, l_int32 *pcount );
         extern NUMA * numaClipToInterval ( NUMA *nas, l_int32 first, l_int32 last );
         extern NUMA * numaMakeThresholdIndicator ( NUMA *nas, l_float32 thresh, l_int32 type );
         extern NUMA * numaUniformSampling ( NUMA *nas, l_int32 nsamp );
         extern NUMA * numaReverse ( NUMA *nad, NUMA *nas );
         extern NUMA * numaLowPassIntervals ( NUMA *nas, l_float32 thresh, l_float32 maxn );
         extern NUMA * numaThresholdEdges ( NUMA *nas, l_float32 thresh1, l_float32 thresh2, l_float32 maxn );
         extern l_int32 numaGetSpanValues ( NUMA *na, l_int32 span, l_int32 *pstart, l_int32 *pend );
         extern l_int32 numaGetEdgeValues ( NUMA *na, l_int32 edge, l_int32 *pstart, l_int32 *pend, l_int32 *psign );
         extern l_int32 numaInterpolateEqxVal ( l_float32 startx, l_float32 deltax, NUMA *nay, l_int32 type, l_float32 xval, l_float32 *pyval );
         extern l_int32 numaInterpolateArbxVal ( NUMA *nax, NUMA *nay, l_int32 type, l_float32 xval, l_float32 *pyval );
         extern l_int32 numaInterpolateEqxInterval ( l_float32 startx, l_float32 deltax, NUMA *nasy, l_int32 type, l_float32 x0, l_float32 x1, l_int32 npts, NUMA **pnax, NUMA **pnay );
         extern l_int32 numaInterpolateArbxInterval ( NUMA *nax, NUMA *nay, l_int32 type, l_float32 x0, l_float32 x1, l_int32 npts, NUMA **pnadx, NUMA **pnady );
         extern l_int32 numaFitMax ( NUMA *na, l_float32 *pmaxval, NUMA *naloc, l_float32 *pmaxloc );
         extern l_int32 numaDifferentiateInterval ( NUMA *nax, NUMA *nay, l_float32 x0, l_float32 x1, l_int32 npts, NUMA **pnadx, NUMA **pnady );
         extern l_int32 numaIntegrateInterval ( NUMA *nax, NUMA *nay, l_float32 x0, l_float32 x1, l_int32 npts, l_float32 *psum );
         extern l_int32 numaSortGeneral ( NUMA *na, NUMA **pnasort, NUMA **pnaindex, NUMA **pnainvert, l_int32 sortorder, l_int32 sorttype );
         extern NUMA * numaSortAutoSelect ( NUMA *nas, l_int32 sortorder );
         extern NUMA * numaSortIndexAutoSelect ( NUMA *nas, l_int32 sortorder );
         extern l_int32 numaChooseSortType ( NUMA *nas );
         extern NUMA * numaSort ( NUMA *naout, NUMA *nain, l_int32 sortorder );
         extern NUMA * numaBinSort ( NUMA *nas, l_int32 sortorder );
         extern NUMA * numaGetSortIndex ( NUMA *na, l_int32 sortorder );
         extern NUMA * numaGetBinSortIndex ( NUMA *nas, l_int32 sortorder );
         extern NUMA * numaSortByIndex ( NUMA *nas, NUMA *naindex );
         extern l_int32 numaIsSorted ( NUMA *nas, l_int32 sortorder, l_int32 *psorted );
         extern l_int32 numaSortPair ( NUMA *nax, NUMA *nay, l_int32 sortorder, NUMA **pnasx, NUMA **pnasy );
         extern NUMA * numaInvertMap ( NUMA *nas );
         extern NUMA * numaPseudorandomSequence ( l_int32 size, l_int32 seed );
         extern NUMA * numaRandomPermutation ( NUMA *nas, l_int32 seed );
         extern l_int32 numaGetRankValue ( NUMA *na, l_float32 fract, NUMA *nasort, l_int32 usebins, l_float32 *pval );
         extern l_int32 numaGetMedian ( NUMA *na, l_float32 *pval );
         extern l_int32 numaGetBinnedMedian ( NUMA *na, l_int32 *pval );
         extern l_int32 numaGetMode ( NUMA *na, l_float32 *pval, l_int32 *pcount );
         extern l_int32 numaGetMedianVariation ( NUMA *na, l_float32 *pmedval, l_float32 *pmedvar );
         extern l_int32 numaJoin ( NUMA *nad, NUMA *nas, l_int32 istart, l_int32 iend );
         extern l_int32 numaaJoin ( NUMAA *naad, NUMAA *naas, l_int32 istart, l_int32 iend );
         extern NUMA * numaaFlattenToNuma ( NUMAA *naa );
         extern NUMA * numaErode ( NUMA *nas, l_int32 size );
         extern NUMA * numaDilate ( NUMA *nas, l_int32 size );
         extern NUMA * numaOpen ( NUMA *nas, l_int32 size );
         extern NUMA * numaClose ( NUMA *nas, l_int32 size );
         extern NUMA * numaTransform ( NUMA *nas, l_float32 shift, l_float32 scale );
         extern l_int32 numaWindowedStats ( NUMA *nas, l_int32 wc, NUMA **pnam, NUMA **pnams, NUMA **pnav, NUMA **pnarv );
         extern NUMA * numaWindowedMean ( NUMA *nas, l_int32 wc );
         extern NUMA * numaWindowedMeanSquare ( NUMA *nas, l_int32 wc );
         extern l_int32 numaWindowedVariance ( NUMA *nam, NUMA *nams, NUMA **pnav, NUMA **pnarv );
         extern NUMA * numaConvertToInt ( NUMA *nas );
         extern NUMA * numaMakeHistogram ( NUMA *na, l_int32 maxbins, l_int32 *pbinsize, l_int32 *pbinstart );
         extern NUMA * numaMakeHistogramAuto ( NUMA *na, l_int32 maxbins );
         extern NUMA * numaMakeHistogramClipped ( NUMA *na, l_float32 binsize, l_float32 maxsize );
         extern NUMA * numaRebinHistogram ( NUMA *nas, l_int32 newsize );
         extern NUMA * numaNormalizeHistogram ( NUMA *nas, l_float32 tsum );
         extern l_int32 numaGetStatsUsingHistogram ( NUMA *na, l_int32 maxbins, l_float32 *pmin, l_float32 *pmax, l_float32 *pmean, l_float32 *pvariance, l_float32 *pmedian, l_float32 rank, l_float32 *prval, NUMA **phisto );
         extern l_int32 numaGetHistogramStats ( NUMA *nahisto, l_float32 startx, l_float32 deltax, l_float32 *pxmean, l_float32 *pxmedian, l_float32 *pxmode, l_float32 *pxvariance );
         extern l_int32 numaGetHistogramStatsOnInterval ( NUMA *nahisto, l_float32 startx, l_float32 deltax, l_int32 ifirst, l_int32 ilast, l_float32 *pxmean, l_float32 *pxmedian, l_float32 *pxmode, l_float32 *pxvariance );
         extern l_int32 numaMakeRankFromHistogram ( l_float32 startx, l_float32 deltax, NUMA *nasy, l_int32 npts, NUMA **pnax, NUMA **pnay );
         extern l_int32 numaHistogramGetRankFromVal ( NUMA *na, l_float32 rval, l_float32 *prank );
         extern l_int32 numaHistogramGetValFromRank ( NUMA *na, l_float32 rank, l_float32 *prval );
         extern l_int32 numaDiscretizeRankAndIntensity ( NUMA *na, l_int32 nbins, NUMA **pnarbin, NUMA **pnam, NUMA **pnar, NUMA **pnabb );
         extern l_int32 numaGetRankBinValues ( NUMA *na, l_int32 nbins, NUMA **pnarbin, NUMA **pnam );
         extern l_int32 numaSplitDistribution ( NUMA *na, l_float32 scorefract, l_int32 *psplitindex, l_float32 *pave1, l_float32 *pave2, l_float32 *pnum1, l_float32 *pnum2, NUMA **pnascore );
         extern l_int32 numaEarthMoverDistance ( NUMA *na1, NUMA *na2, l_float32 *pdist );
         extern NUMA * numaFindPeaks ( NUMA *nas, l_int32 nmax, l_float32 fract1, l_float32 fract2 );
         extern NUMA * numaFindExtrema ( NUMA *nas, l_float32 delta );
         extern l_int32 numaCountReversals ( NUMA *nas, l_float32 minreversal, l_int32 *pnr, l_float32 *pnrpl );
         extern l_int32 numaSelectCrossingThreshold ( NUMA *nax, NUMA *nay, l_float32 estthresh, l_float32 *pbestthresh );
         extern NUMA * numaCrossingsByThreshold ( NUMA *nax, NUMA *nay, l_float32 thresh );
         extern NUMA * numaCrossingsByPeaks ( NUMA *nax, NUMA *nay, l_float32 delta );
         extern l_int32 numaEvalBestHaarParameters ( NUMA *nas, l_float32 relweight, l_int32 nwidth, l_int32 nshift, l_float32 minwidth, l_float32 maxwidth, l_float32 *pbestwidth, l_float32 *pbestshift, l_float32 *pbestscore );
         extern l_int32 numaEvalHaarSum ( NUMA *nas, l_float32 width, l_float32 shift, l_float32 relweight, l_float32 *pscore );
         extern l_int32 pixGetRegionsBinary ( PIX *pixs, PIX **ppixhm, PIX **ppixtm, PIX **ppixtb, l_int32 debug );
         extern PIX * pixGenHalftoneMask ( PIX *pixs, PIX **ppixtext, l_int32 *phtfound, l_int32 debug );
         extern PIX * pixGenTextlineMask ( PIX *pixs, PIX **ppixvws, l_int32 *ptlfound, l_int32 debug );
         extern PIX * pixGenTextblockMask ( PIX *pixs, PIX *pixvws, l_int32 debug );
         extern BOX * pixFindPageForeground ( PIX *pixs, l_int32 threshold, l_int32 mindist, l_int32 erasedist, l_int32 pagenum, l_int32 showmorph, l_int32 display, const char *pdfdir );
         extern l_int32 pixSplitIntoCharacters ( PIX *pixs, l_int32 minw, l_int32 minh, BOXA **pboxa, PIXA **ppixa, PIX **ppixdebug );
         extern BOXA * pixSplitComponentWithProfile ( PIX *pixs, l_int32 delta, l_int32 mindel, PIX **ppixdebug );
         extern l_int32 pixSetSelectCmap ( PIX *pixs, BOX *box, l_int32 sindex, l_int32 rval, l_int32 gval, l_int32 bval );
         extern l_int32 pixColorGrayRegionsCmap ( PIX *pixs, BOXA *boxa, l_int32 type, l_int32 rval, l_int32 gval, l_int32 bval );
         extern l_int32 pixColorGrayCmap ( PIX *pixs, BOX *box, l_int32 type, l_int32 rval, l_int32 gval, l_int32 bval );
         extern l_int32 addColorizedGrayToCmap ( PIXCMAP *cmap, l_int32 type, l_int32 rval, l_int32 gval, l_int32 bval, NUMA **pna );
         extern l_int32 pixSetSelectMaskedCmap ( PIX *pixs, PIX *pixm, l_int32 x, l_int32 y, l_int32 sindex, l_int32 rval, l_int32 gval, l_int32 bval );
         extern l_int32 pixSetMaskedCmap ( PIX *pixs, PIX *pixm, l_int32 x, l_int32 y, l_int32 rval, l_int32 gval, l_int32 bval );
         extern char * parseForProtos ( const char *filein, const char *prestring );
         extern BOXA * boxaGetWhiteblocks ( BOXA *boxas, BOX *box, l_int32 sortflag, l_int32 maxboxes, l_float32 maxoverlap, l_int32 maxperim, l_float32 fract, l_int32 maxpops );
         extern BOXA * boxaPruneSortedOnOverlap ( BOXA *boxas, l_float32 maxoverlap );
         extern l_int32 convertFilesToPdf ( const char *dirname, const char *substr, l_int32 res, l_float32 scalefactor, l_int32 type, l_int32 quality, const char *title, const char *fileout );
         extern l_int32 saConvertFilesToPdf ( SARRAY *sa, l_int32 res, l_float32 scalefactor, l_int32 type, l_int32 quality, const char *title, const char *fileout );
         extern l_int32 saConvertFilesToPdfData ( SARRAY *sa, l_int32 res, l_float32 scalefactor, l_int32 type, l_int32 quality, const char *title, l_uint8 **pdata, size_t *pnbytes );
         extern l_int32 selectDefaultPdfEncoding ( PIX *pix, l_int32 *ptype );
         extern l_int32 convertUnscaledFilesToPdf ( const char *dirname, const char *substr, const char *title, const char *fileout );
         extern l_int32 saConvertUnscaledFilesToPdf ( SARRAY *sa, const char *title, const char *fileout );
         extern l_int32 saConvertUnscaledFilesToPdfData ( SARRAY *sa, const char *title, l_uint8 **pdata, size_t *pnbytes );
         extern l_int32 convertUnscaledToPdfData ( const char *fname, const char *title, l_uint8 **pdata, size_t *pnbytes );
         extern l_int32 pixaConvertToPdf ( PIXA *pixa, l_int32 res, l_float32 scalefactor, l_int32 type, l_int32 quality, const char *title, const char *fileout );
         extern l_int32 pixaConvertToPdfData ( PIXA *pixa, l_int32 res, l_float32 scalefactor, l_int32 type, l_int32 quality, const char *title, l_uint8 **pdata, size_t *pnbytes );
         extern l_int32 convertToPdf ( const char *filein, l_int32 type, l_int32 quality, const char *fileout, l_int32 x, l_int32 y, l_int32 res, const char *title, L_PDF_DATA **plpd, l_int32 position );
         extern l_int32 convertImageDataToPdf ( l_uint8 *imdata, size_t size, l_int32 type, l_int32 quality, const char *fileout, l_int32 x, l_int32 y, l_int32 res, const char *title, L_PDF_DATA **plpd, l_int32 position );
         extern l_int32 convertToPdfData ( const char *filein, l_int32 type, l_int32 quality, l_uint8 **pdata, size_t *pnbytes, l_int32 x, l_int32 y, l_int32 res, const char *title, L_PDF_DATA **plpd, l_int32 position );
         extern l_int32 convertImageDataToPdfData ( l_uint8 *imdata, size_t size, l_int32 type, l_int32 quality, l_uint8 **pdata, size_t *pnbytes, l_int32 x, l_int32 y, l_int32 res, const char *title, L_PDF_DATA **plpd, l_int32 position );
         extern l_int32 pixConvertToPdf ( PIX *pix, l_int32 type, l_int32 quality, const char *fileout, l_int32 x, l_int32 y, l_int32 res, const char *title, L_PDF_DATA **plpd, l_int32 position );
         extern l_int32 pixWriteStreamPdf ( FILE *fp, PIX *pix, l_int32 res, const char *title );
         extern l_int32 pixWriteMemPdf ( l_uint8 **pdata, size_t *pnbytes, PIX *pix, l_int32 res, const char *title );
         extern l_int32 convertSegmentedFilesToPdf ( const char *dirname, const char *substr, l_int32 res, l_int32 type, l_int32 thresh, BOXAA *baa, l_int32 quality, l_float32 scalefactor, const char *title, const char *fileout );
         extern BOXAA * convertNumberedMasksToBoxaa ( const char *dirname, const char *substr, l_int32 numpre, l_int32 numpost );
         extern l_int32 convertToPdfSegmented ( const char *filein, l_int32 res, l_int32 type, l_int32 thresh, BOXA *boxa, l_int32 quality, l_float32 scalefactor, const char *title, const char *fileout );
         extern l_int32 pixConvertToPdfSegmented ( PIX *pixs, l_int32 res, l_int32 type, l_int32 thresh, BOXA *boxa, l_int32 quality, l_float32 scalefactor, const char *title, const char *fileout );
         extern l_int32 convertToPdfDataSegmented ( const char *filein, l_int32 res, l_int32 type, l_int32 thresh, BOXA *boxa, l_int32 quality, l_float32 scalefactor, const char *title, l_uint8 **pdata, size_t *pnbytes );
         extern l_int32 pixConvertToPdfDataSegmented ( PIX *pixs, l_int32 res, l_int32 type, l_int32 thresh, BOXA *boxa, l_int32 quality, l_float32 scalefactor, const char *title, l_uint8 **pdata, size_t *pnbytes );
         extern l_int32 concatenatePdf ( const char *dirname, const char *substr, const char *fileout );
         extern l_int32 saConcatenatePdf ( SARRAY *sa, const char *fileout );
         extern l_int32 ptraConcatenatePdf ( L_PTRA *pa, const char *fileout );
         extern l_int32 concatenatePdfToData ( const char *dirname, const char *substr, l_uint8 **pdata, size_t *pnbytes );
         extern l_int32 saConcatenatePdfToData ( SARRAY *sa, l_uint8 **pdata, size_t *pnbytes );
         extern l_int32 pixConvertToPdfData ( PIX *pix, l_int32 type, l_int32 quality, l_uint8 **pdata, size_t *pnbytes, l_int32 x, l_int32 y, l_int32 res, const char *title, L_PDF_DATA **plpd, l_int32 position );
         extern l_int32 ptraConcatenatePdfToData ( L_PTRA *pa_data, SARRAY *sa, l_uint8 **pdata, size_t *pnbytes );
         extern l_int32 l_generateCIDataForPdf ( const char *fname, PIX *pix, l_int32 quality, L_COMP_DATA **pcid );
         extern L_COMP_DATA * l_generateFlateDataPdf ( const char *fname );
         extern L_COMP_DATA * l_generateJpegData ( const char *fname, l_int32 ascii85flag );
         extern l_int32 l_generateCIData ( const char *fname, l_int32 type, l_int32 quality, l_int32 ascii85, L_COMP_DATA **pcid );
         extern l_int32 pixGenerateCIData ( PIX *pixs, l_int32 type, l_int32 quality, l_int32 ascii85, L_COMP_DATA **pcid );
         extern L_COMP_DATA * l_generateFlateData ( const char *fname, l_int32 ascii85flag );
         extern L_COMP_DATA * l_generateG4Data ( const char *fname, l_int32 ascii85flag );
         extern l_int32 cidConvertToPdfData ( L_COMP_DATA *cid, const char *title, l_uint8 **pdata, size_t *pnbytes );
         extern void l_CIDataDestroy ( L_COMP_DATA **pcid );
         extern void l_pdfSetG4ImageMask ( l_int32 flag );
         extern void l_pdfSetDateAndVersion ( l_int32 flag );
         extern void setPixMemoryManager ( void * ( ( *allocator ) ( size_t ) ), void ( ( *deallocator ) ( void * ) ) );
         extern PIX * pixCreate ( l_int32 width, l_int32 height, l_int32 depth );
         extern PIX * pixCreateNoInit ( l_int32 width, l_int32 height, l_int32 depth );
         extern PIX * pixCreateTemplate ( PIX *pixs );
         extern PIX * pixCreateTemplateNoInit ( PIX *pixs );
         extern PIX * pixCreateHeader ( l_int32 width, l_int32 height, l_int32 depth );
         extern PIX * pixClone ( PIX *pixs );
         extern void pixDestroy ( PIX **ppix );
         extern PIX * pixCopy ( PIX *pixd, PIX *pixs );
         extern l_int32 pixResizeImageData ( PIX *pixd, PIX *pixs );
         extern l_int32 pixCopyColormap ( PIX *pixd, PIX *pixs );
         extern l_int32 pixSizesEqual ( PIX *pix1, PIX *pix2 );
         extern l_int32 pixTransferAllData ( PIX *pixd, PIX **ppixs, l_int32 copytext, l_int32 copyformat );
         extern l_int32 pixSwapAndDestroy ( PIX **ppixd, PIX **ppixs );
         extern l_int32 pixGetWidth ( PIX *pix );
         extern l_int32 pixSetWidth ( PIX *pix, l_int32 width );
         extern l_int32 pixGetHeight ( PIX *pix );
         extern l_int32 pixSetHeight ( PIX *pix, l_int32 height );
         extern l_int32 pixGetDepth ( PIX *pix );
         extern l_int32 pixSetDepth ( PIX *pix, l_int32 depth );
         extern l_int32 pixGetDimensions ( PIX *pix, l_int32 *pw, l_int32 *ph, l_int32 *pd );
         extern l_int32 pixSetDimensions ( PIX *pix, l_int32 w, l_int32 h, l_int32 d );
         extern l_int32 pixCopyDimensions ( PIX *pixd, PIX *pixs );
         extern l_int32 pixGetSpp ( PIX *pix );
         extern l_int32 pixSetSpp ( PIX *pix, l_int32 spp );
         extern l_int32 pixCopySpp ( PIX *pixd, PIX *pixs );
         extern l_int32 pixGetWpl ( PIX *pix );
         extern l_int32 pixSetWpl ( PIX *pix, l_int32 wpl );
         extern l_int32 pixGetRefcount ( PIX *pix );
         extern l_int32 pixChangeRefcount ( PIX *pix, l_int32 delta );
         extern l_int32 pixGetXRes ( PIX *pix );
         extern l_int32 pixSetXRes ( PIX *pix, l_int32 res );
         extern l_int32 pixGetYRes ( PIX *pix );
         extern l_int32 pixSetYRes ( PIX *pix, l_int32 res );
         extern l_int32 pixGetResolution ( PIX *pix, l_int32 *pxres, l_int32 *pyres );
         extern l_int32 pixSetResolution ( PIX *pix, l_int32 xres, l_int32 yres );
         extern l_int32 pixCopyResolution ( PIX *pixd, PIX *pixs );
         extern l_int32 pixScaleResolution ( PIX *pix, l_float32 xscale, l_float32 yscale );
         extern l_int32 pixGetInputFormat ( PIX *pix );
         extern l_int32 pixSetInputFormat ( PIX *pix, l_int32 informat );
         extern l_int32 pixCopyInputFormat ( PIX *pixd, PIX *pixs );
         extern char * pixGetText ( PIX *pix );
         extern l_int32 pixSetText ( PIX *pix, const char *textstring );
         extern l_int32 pixAddText ( PIX *pix, const char *textstring );
         extern l_int32 pixCopyText ( PIX *pixd, PIX *pixs );
         extern PIXCMAP * pixGetColormap ( PIX *pix );
         extern l_int32 pixSetColormap ( PIX *pix, PIXCMAP *colormap );
         extern l_int32 pixDestroyColormap ( PIX *pix );
         extern l_uint32 * pixGetData ( PIX *pix );
         extern l_int32 pixSetData ( PIX *pix, l_uint32 *data );
         extern l_uint32 * pixExtractData ( PIX *pixs );
         extern l_int32 pixFreeData ( PIX *pix );
         extern void ** pixGetLinePtrs ( PIX *pix, l_int32 *psize );
         extern l_int32 pixPrintStreamInfo ( FILE *fp, PIX *pix, const char *text );
         extern l_int32 pixGetPixel ( PIX *pix, l_int32 x, l_int32 y, l_uint32 *pval );
         extern l_int32 pixSetPixel ( PIX *pix, l_int32 x, l_int32 y, l_uint32 val );
         extern l_int32 pixGetRGBPixel ( PIX *pix, l_int32 x, l_int32 y, l_int32 *prval, l_int32 *pgval, l_int32 *pbval );
         extern l_int32 pixSetRGBPixel ( PIX *pix, l_int32 x, l_int32 y, l_int32 rval, l_int32 gval, l_int32 bval );
         extern l_int32 pixGetRandomPixel ( PIX *pix, l_uint32 *pval, l_int32 *px, l_int32 *py );
         extern l_int32 pixClearPixel ( PIX *pix, l_int32 x, l_int32 y );
         extern l_int32 pixFlipPixel ( PIX *pix, l_int32 x, l_int32 y );
         extern void setPixelLow ( l_uint32 *line, l_int32 x, l_int32 depth, l_uint32 val );
         extern l_int32 pixGetBlackOrWhiteVal ( PIX *pixs, l_int32 op, l_uint32 *pval );
         extern l_int32 pixClearAll ( PIX *pix );
         extern l_int32 pixSetAll ( PIX *pix );
         extern l_int32 pixSetAllGray ( PIX *pix, l_int32 grayval );
         extern l_int32 pixSetAllArbitrary ( PIX *pix, l_uint32 val );
         extern l_int32 pixSetBlackOrWhite ( PIX *pixs, l_int32 op );
         extern l_int32 pixSetComponentArbitrary ( PIX *pix, l_int32 comp, l_int32 val );
         extern l_int32 pixClearInRect ( PIX *pix, BOX *box );
         extern l_int32 pixSetInRect ( PIX *pix, BOX *box );
         extern l_int32 pixSetInRectArbitrary ( PIX *pix, BOX *box, l_uint32 val );
         extern l_int32 pixBlendInRect ( PIX *pixs, BOX *box, l_uint32 val, l_float32 fract );
         extern l_int32 pixSetPadBits ( PIX *pix, l_int32 val );
         extern l_int32 pixSetPadBitsBand ( PIX *pix, l_int32 by, l_int32 bh, l_int32 val );
         extern l_int32 pixSetOrClearBorder ( PIX *pixs, l_int32 left, l_int32 right, l_int32 top, l_int32 bot, l_int32 op );
         extern l_int32 pixSetBorderVal ( PIX *pixs, l_int32 left, l_int32 right, l_int32 top, l_int32 bot, l_uint32 val );
         extern l_int32 pixSetBorderRingVal ( PIX *pixs, l_int32 dist, l_uint32 val );
         extern l_int32 pixSetMirroredBorder ( PIX *pixs, l_int32 left, l_int32 right, l_int32 top, l_int32 bot );
         extern PIX * pixCopyBorder ( PIX *pixd, PIX *pixs, l_int32 left, l_int32 right, l_int32 top, l_int32 bot );
         extern PIX * pixAddBorder ( PIX *pixs, l_int32 npix, l_uint32 val );
         extern PIX * pixAddBlackOrWhiteBorder ( PIX *pixs, l_int32 left, l_int32 right, l_int32 top, l_int32 bot, l_int32 op );
         extern PIX * pixAddBorderGeneral ( PIX *pixs, l_int32 left, l_int32 right, l_int32 top, l_int32 bot, l_uint32 val );
         extern PIX * pixRemoveBorder ( PIX *pixs, l_int32 npix );
         extern PIX * pixRemoveBorderGeneral ( PIX *pixs, l_int32 left, l_int32 right, l_int32 top, l_int32 bot );
         extern PIX * pixRemoveBorderToSize ( PIX *pixs, l_int32 wd, l_int32 hd );
         extern PIX * pixAddMirroredBorder ( PIX *pixs, l_int32 left, l_int32 right, l_int32 top, l_int32 bot );
         extern PIX * pixAddRepeatedBorder ( PIX *pixs, l_int32 left, l_int32 right, l_int32 top, l_int32 bot );
         extern PIX * pixAddMixedBorder ( PIX *pixs, l_int32 left, l_int32 right, l_int32 top, l_int32 bot );
         extern PIX * pixAddContinuedBorder ( PIX *pixs, l_int32 left, l_int32 right, l_int32 top, l_int32 bot );
         extern l_int32 pixShiftAndTransferAlpha ( PIX *pixd, PIX *pixs, l_float32 shiftx, l_float32 shifty );
         extern PIX * pixDisplayLayersRGBA ( PIX *pixs, l_uint32 val, l_int32 maxw );
         extern PIX * pixCreateRGBImage ( PIX *pixr, PIX *pixg, PIX *pixb );
         extern PIX * pixGetRGBComponent ( PIX *pixs, l_int32 comp );
         extern l_int32 pixSetRGBComponent ( PIX *pixd, PIX *pixs, l_int32 comp );
         extern PIX * pixGetRGBComponentCmap ( PIX *pixs, l_int32 comp );
         extern l_int32 pixCopyRGBComponent ( PIX *pixd, PIX *pixs, l_int32 comp );
         extern l_int32 composeRGBPixel ( l_int32 rval, l_int32 gval, l_int32 bval, l_uint32 *ppixel );
         extern l_int32 composeRGBAPixel ( l_int32 rval, l_int32 gval, l_int32 bval, l_int32 aval, l_uint32 *ppixel );
         extern void extractRGBValues ( l_uint32 pixel, l_int32 *prval, l_int32 *pgval, l_int32 *pbval );
         extern void extractRGBAValues ( l_uint32 pixel, l_int32 *prval, l_int32 *pgval, l_int32 *pbval, l_int32 *paval );
         extern l_int32 extractMinMaxComponent ( l_uint32 pixel, l_int32 type );
         extern l_int32 pixGetRGBLine ( PIX *pixs, l_int32 row, l_uint8 *bufr, l_uint8 *bufg, l_uint8 *bufb );
         extern PIX * pixEndianByteSwapNew ( PIX *pixs );
         extern l_int32 pixEndianByteSwap ( PIX *pixs );
         extern l_int32 lineEndianByteSwap ( l_uint32 *datad, l_uint32 *datas, l_int32 wpl );
         extern PIX * pixEndianTwoByteSwapNew ( PIX *pixs );
         extern l_int32 pixEndianTwoByteSwap ( PIX *pixs );
         extern l_int32 pixGetRasterData ( PIX *pixs, l_uint8 **pdata, size_t *pnbytes );
         extern l_int32 pixAlphaIsOpaque ( PIX *pix, l_int32 *popaque );
         extern l_uint8 ** pixSetupByteProcessing ( PIX *pix, l_int32 *pw, l_int32 *ph );
         extern l_int32 pixCleanupByteProcessing ( PIX *pix, l_uint8 **lineptrs );
         extern void l_setAlphaMaskBorder ( l_float32 val1, l_float32 val2 );
         extern l_int32 pixSetMasked ( PIX *pixd, PIX *pixm, l_uint32 val );
         extern l_int32 pixSetMaskedGeneral ( PIX *pixd, PIX *pixm, l_uint32 val, l_int32 x, l_int32 y );
         extern l_int32 pixCombineMasked ( PIX *pixd, PIX *pixs, PIX *pixm );
         extern l_int32 pixCombineMaskedGeneral ( PIX *pixd, PIX *pixs, PIX *pixm, l_int32 x, l_int32 y );
         extern l_int32 pixPaintThroughMask ( PIX *pixd, PIX *pixm, l_int32 x, l_int32 y, l_uint32 val );
         extern l_int32 pixPaintSelfThroughMask ( PIX *pixd, PIX *pixm, l_int32 x, l_int32 y, l_int32 tilesize, l_int32 searchdir );
         extern PIX * pixMakeMaskFromLUT ( PIX *pixs, l_int32 *tab );
         extern PIX * pixSetUnderTransparency ( PIX *pixs, l_uint32 val, l_int32 debug );
         extern PIX * pixInvert ( PIX *pixd, PIX *pixs );
         extern PIX * pixOr ( PIX *pixd, PIX *pixs1, PIX *pixs2 );
         extern PIX * pixAnd ( PIX *pixd, PIX *pixs1, PIX *pixs2 );
         extern PIX * pixXor ( PIX *pixd, PIX *pixs1, PIX *pixs2 );
         extern PIX * pixSubtract ( PIX *pixd, PIX *pixs1, PIX *pixs2 );
         extern l_int32 pixZero ( PIX *pix, l_int32 *pempty );
         extern l_int32 pixForegroundFraction ( PIX *pix, l_float32 *pfract );
         extern NUMA * pixaCountPixels ( PIXA *pixa );
         extern l_int32 pixCountPixels ( PIX *pix, l_int32 *pcount, l_int32 *tab8 );
         extern NUMA * pixCountByRow ( PIX *pix, BOX *box );
         extern NUMA * pixCountByColumn ( PIX *pix, BOX *box );
         extern NUMA * pixCountPixelsByRow ( PIX *pix, l_int32 *tab8 );
         extern NUMA * pixCountPixelsByColumn ( PIX *pix );
         extern l_int32 pixCountPixelsInRow ( PIX *pix, l_int32 row, l_int32 *pcount, l_int32 *tab8 );
         extern NUMA * pixGetMomentByColumn ( PIX *pix, l_int32 order );
         extern l_int32 pixThresholdPixelSum ( PIX *pix, l_int32 thresh, l_int32 *pabove, l_int32 *tab8 );
         extern l_int32 * makePixelSumTab8 ( void );
         extern l_int32 * makePixelCentroidTab8 ( void );
         extern NUMA * pixAverageByRow ( PIX *pix, BOX *box, l_int32 type );
         extern NUMA * pixAverageByColumn ( PIX *pix, BOX *box, l_int32 type );
         extern l_int32 pixAverageInRect ( PIX *pix, BOX *box, l_float32 *pave );
         extern NUMA * pixVarianceByRow ( PIX *pix, BOX *box );
         extern NUMA * pixVarianceByColumn ( PIX *pix, BOX *box );
         extern l_int32 pixVarianceInRect ( PIX *pix, BOX *box, l_float32 *prootvar );
         extern NUMA * pixAbsDiffByRow ( PIX *pix, BOX *box );
         extern NUMA * pixAbsDiffByColumn ( PIX *pix, BOX *box );
         extern l_int32 pixAbsDiffInRect ( PIX *pix, BOX *box, l_int32 dir, l_float32 *pabsdiff );
         extern l_int32 pixAbsDiffOnLine ( PIX *pix, l_int32 x1, l_int32 y1, l_int32 x2, l_int32 y2, l_float32 *pabsdiff );
         extern l_int32 pixCountArbInRect ( PIX *pixs, BOX *box, l_int32 val, l_int32 factor, l_int32 *pcount );
         extern PIX * pixMirroredTiling ( PIX *pixs, l_int32 w, l_int32 h );
         extern NUMA * pixGetGrayHistogram ( PIX *pixs, l_int32 factor );
         extern NUMA * pixGetGrayHistogramMasked ( PIX *pixs, PIX *pixm, l_int32 x, l_int32 y, l_int32 factor );
         extern NUMA * pixGetGrayHistogramInRect ( PIX *pixs, BOX *box, l_int32 factor );
         extern l_int32 pixGetColorHistogram ( PIX *pixs, l_int32 factor, NUMA **pnar, NUMA **pnag, NUMA **pnab );
         extern l_int32 pixGetColorHistogramMasked ( PIX *pixs, PIX *pixm, l_int32 x, l_int32 y, l_int32 factor, NUMA **pnar, NUMA **pnag, NUMA **pnab );
         extern NUMA * pixGetCmapHistogram ( PIX *pixs, l_int32 factor );
         extern NUMA * pixGetCmapHistogramMasked ( PIX *pixs, PIX *pixm, l_int32 x, l_int32 y, l_int32 factor );
         extern NUMA * pixGetCmapHistogramInRect ( PIX *pixs, BOX *box, l_int32 factor );
         extern l_int32 pixGetRankValue ( PIX *pixs, l_int32 factor, l_float32 rank, l_uint32 *pvalue );
         extern l_int32 pixGetRankValueMaskedRGB ( PIX *pixs, PIX *pixm, l_int32 x, l_int32 y, l_int32 factor, l_float32 rank, l_float32 *prval, l_float32 *pgval, l_float32 *pbval );
         extern l_int32 pixGetRankValueMasked ( PIX *pixs, PIX *pixm, l_int32 x, l_int32 y, l_int32 factor, l_float32 rank, l_float32 *pval, NUMA **pna );
         extern l_int32 pixGetAverageValue ( PIX *pixs, l_int32 factor, l_int32 type, l_uint32 *pvalue );
         extern l_int32 pixGetAverageMaskedRGB ( PIX *pixs, PIX *pixm, l_int32 x, l_int32 y, l_int32 factor, l_int32 type, l_float32 *prval, l_float32 *pgval, l_float32 *pbval );
         extern l_int32 pixGetAverageMasked ( PIX *pixs, PIX *pixm, l_int32 x, l_int32 y, l_int32 factor, l_int32 type, l_float32 *pval );
         extern l_int32 pixGetAverageTiledRGB ( PIX *pixs, l_int32 sx, l_int32 sy, l_int32 type, PIX **ppixr, PIX **ppixg, PIX **ppixb );
         extern PIX * pixGetAverageTiled ( PIX *pixs, l_int32 sx, l_int32 sy, l_int32 type );
         extern l_int32 pixRowStats ( PIX *pixs, BOX *box, NUMA **pnamean, NUMA **pnamedian, NUMA **pnamode, NUMA **pnamodecount, NUMA **pnavar, NUMA **pnarootvar );
         extern l_int32 pixColumnStats ( PIX *pixs, BOX *box, NUMA **pnamean, NUMA **pnamedian, NUMA **pnamode, NUMA **pnamodecount, NUMA **pnavar, NUMA **pnarootvar );
         extern l_int32 pixGetComponentRange ( PIX *pixs, l_int32 factor, l_int32 color, l_int32 *pminval, l_int32 *pmaxval );
         extern l_int32 pixGetExtremeValue ( PIX *pixs, l_int32 factor, l_int32 type, l_int32 *prval, l_int32 *pgval, l_int32 *pbval, l_int32 *pgrayval );
         extern l_int32 pixGetMaxValueInRect ( PIX *pixs, BOX *box, l_uint32 *pmaxval, l_int32 *pxmax, l_int32 *pymax );
         extern l_int32 pixGetBinnedComponentRange ( PIX *pixs, l_int32 nbins, l_int32 factor, l_int32 color, l_int32 *pminval, l_int32 *pmaxval, l_uint32 **pcarray, const char *fontdir );
         extern l_int32 pixGetRankColorArray ( PIX *pixs, l_int32 nbins, l_int32 type, l_int32 factor, l_uint32 **pcarray, l_int32 debugflag, const char *fontdir );
         extern l_int32 pixGetBinnedColor ( PIX *pixs, PIX *pixg, l_int32 factor, l_int32 nbins, NUMA *nalut, l_uint32 **pcarray, l_int32 debugflag );
         extern PIX * pixDisplayColorArray ( l_uint32 *carray, l_int32 ncolors, l_int32 side, l_int32 ncols, const char *fontdir );
         extern PIX * pixRankBinByStrip ( PIX *pixs, l_int32 direction, l_int32 size, l_int32 nbins, l_int32 type );
         extern PIX * pixaGetAlignedStats ( PIXA *pixa, l_int32 type, l_int32 nbins, l_int32 thresh );
         extern l_int32 pixaExtractColumnFromEachPix ( PIXA *pixa, l_int32 col, PIX *pixd );
         extern l_int32 pixGetRowStats ( PIX *pixs, l_int32 type, l_int32 nbins, l_int32 thresh, l_float32 *colvect );
         extern l_int32 pixGetColumnStats ( PIX *pixs, l_int32 type, l_int32 nbins, l_int32 thresh, l_float32 *rowvect );
         extern l_int32 pixSetPixelColumn ( PIX *pix, l_int32 col, l_float32 *colvect );
         extern l_int32 pixThresholdForFgBg ( PIX *pixs, l_int32 factor, l_int32 thresh, l_int32 *pfgval, l_int32 *pbgval );
         extern l_int32 pixSplitDistributionFgBg ( PIX *pixs, l_float32 scorefract, l_int32 factor, l_int32 *pthresh, l_int32 *pfgval, l_int32 *pbgval, l_int32 debugflag );
         extern l_int32 pixaFindDimensions ( PIXA *pixa, NUMA **pnaw, NUMA **pnah );
         extern l_int32 pixFindAreaPerimRatio ( PIX *pixs, l_int32 *tab, l_float32 *pfract );
         extern NUMA * pixaFindPerimToAreaRatio ( PIXA *pixa );
         extern l_int32 pixFindPerimToAreaRatio ( PIX *pixs, l_int32 *tab, l_float32 *pfract );
         extern NUMA * pixaFindPerimSizeRatio ( PIXA *pixa );
         extern l_int32 pixFindPerimSizeRatio ( PIX *pixs, l_int32 *tab, l_float32 *pratio );
         extern NUMA * pixaFindAreaFraction ( PIXA *pixa );
         extern l_int32 pixFindAreaFraction ( PIX *pixs, l_int32 *tab, l_float32 *pfract );
         extern NUMA * pixaFindAreaFractionMasked ( PIXA *pixa, PIX *pixm, l_int32 debug );
         extern l_int32 pixFindAreaFractionMasked ( PIX *pixs, BOX *box, PIX *pixm, l_int32 *tab, l_float32 *pfract );
         extern NUMA * pixaFindWidthHeightRatio ( PIXA *pixa );
         extern NUMA * pixaFindWidthHeightProduct ( PIXA *pixa );
         extern l_int32 pixFindOverlapFraction ( PIX *pixs1, PIX *pixs2, l_int32 x2, l_int32 y2, l_int32 *tab, l_float32 *pratio, l_int32 *pnoverlap );
         extern BOXA * pixFindRectangleComps ( PIX *pixs, l_int32 dist, l_int32 minw, l_int32 minh );
         extern l_int32 pixConformsToRectangle ( PIX *pixs, BOX *box, l_int32 dist, l_int32 *pconforms );
         extern PIXA * pixClipRectangles ( PIX *pixs, BOXA *boxa );
         extern PIX * pixClipRectangle ( PIX *pixs, BOX *box, BOX **pboxc );
         extern PIX * pixClipMasked ( PIX *pixs, PIX *pixm, l_int32 x, l_int32 y, l_uint32 outval );
         extern l_int32 pixCropToMatch ( PIX *pixs1, PIX *pixs2, PIX **ppixd1, PIX **ppixd2 );
         extern PIX * pixCropToSize ( PIX *pixs, l_int32 w, l_int32 h );
         extern PIX * pixResizeToMatch ( PIX *pixs, PIX *pixt, l_int32 w, l_int32 h );
         extern l_int32 pixClipToForeground ( PIX *pixs, PIX **ppixd, BOX **pbox );
         extern l_int32 pixTestClipToForeground ( PIX *pixs, l_int32 *pcanclip );
         extern l_int32 pixClipBoxToForeground ( PIX *pixs, BOX *boxs, PIX **ppixd, BOX **pboxd );
         extern l_int32 pixScanForForeground ( PIX *pixs, BOX *box, l_int32 scanflag, l_int32 *ploc );
         extern l_int32 pixClipBoxToEdges ( PIX *pixs, BOX *boxs, l_int32 lowthresh, l_int32 highthresh, l_int32 maxwidth, l_int32 factor, PIX **ppixd, BOX **pboxd );
         extern l_int32 pixScanForEdge ( PIX *pixs, BOX *box, l_int32 lowthresh, l_int32 highthresh, l_int32 maxwidth, l_int32 factor, l_int32 scanflag, l_int32 *ploc );
         extern NUMA * pixExtractOnLine ( PIX *pixs, l_int32 x1, l_int32 y1, l_int32 x2, l_int32 y2, l_int32 factor );
         extern l_float32 pixAverageOnLine ( PIX *pixs, l_int32 x1, l_int32 y1, l_int32 x2, l_int32 y2, l_int32 factor );
         extern NUMA * pixAverageIntensityProfile ( PIX *pixs, l_float32 fract, l_int32 dir, l_int32 first, l_int32 last, l_int32 factor1, l_int32 factor2 );
         extern NUMA * pixReversalProfile ( PIX *pixs, l_float32 fract, l_int32 dir, l_int32 first, l_int32 last, l_int32 minreversal, l_int32 factor1, l_int32 factor2 );
         extern l_int32 pixWindowedVarianceOnLine ( PIX *pixs, l_int32 dir, l_int32 loc, l_int32 c1, l_int32 c2, l_int32 size, NUMA **pnad );
         extern l_int32 pixMinMaxNearLine ( PIX *pixs, l_int32 x1, l_int32 y1, l_int32 x2, l_int32 y2, l_int32 dist, l_int32 direction, NUMA **pnamin, NUMA **pnamax, l_float32 *pminave, l_float32 *pmaxave );
         extern PIX * pixRankRowTransform ( PIX *pixs );
         extern PIX * pixRankColumnTransform ( PIX *pixs );
         extern PIXA * pixaCreate ( l_int32 n );
         extern PIXA * pixaCreateFromPix ( PIX *pixs, l_int32 n, l_int32 cellw, l_int32 cellh );
         extern PIXA * pixaCreateFromBoxa ( PIX *pixs, BOXA *boxa, l_int32 *pcropwarn );
         extern PIXA * pixaSplitPix ( PIX *pixs, l_int32 nx, l_int32 ny, l_int32 borderwidth, l_uint32 bordercolor );
         extern void pixaDestroy ( PIXA **ppixa );
         extern PIXA * pixaCopy ( PIXA *pixa, l_int32 copyflag );
         extern l_int32 pixaAddPix ( PIXA *pixa, PIX *pix, l_int32 copyflag );
         extern l_int32 pixaAddBox ( PIXA *pixa, BOX *box, l_int32 copyflag );
         extern l_int32 pixaExtendArrayToSize ( PIXA *pixa, l_int32 size );
         extern l_int32 pixaGetCount ( PIXA *pixa );
         extern l_int32 pixaChangeRefcount ( PIXA *pixa, l_int32 delta );
         extern PIX * pixaGetPix ( PIXA *pixa, l_int32 index, l_int32 accesstype );
         extern l_int32 pixaGetPixDimensions ( PIXA *pixa, l_int32 index, l_int32 *pw, l_int32 *ph, l_int32 *pd );
         extern BOXA * pixaGetBoxa ( PIXA *pixa, l_int32 accesstype );
         extern l_int32 pixaGetBoxaCount ( PIXA *pixa );
         extern BOX * pixaGetBox ( PIXA *pixa, l_int32 index, l_int32 accesstype );
         extern l_int32 pixaGetBoxGeometry ( PIXA *pixa, l_int32 index, l_int32 *px, l_int32 *py, l_int32 *pw, l_int32 *ph );
         extern l_int32 pixaSetBoxa ( PIXA *pixa, BOXA *boxa, l_int32 accesstype );
         extern PIX ** pixaGetPixArray ( PIXA *pixa );
         extern l_int32 pixaVerifyDepth ( PIXA *pixa, l_int32 *pmaxdepth );
         extern l_int32 pixaIsFull ( PIXA *pixa, l_int32 *pfullpa, l_int32 *pfullba );
         extern l_int32 pixaCountText ( PIXA *pixa, l_int32 *pntext );
         extern void *** pixaGetLinePtrs ( PIXA *pixa, l_int32 *psize );
         extern l_int32 pixaReplacePix ( PIXA *pixa, l_int32 index, PIX *pix, BOX *box );
         extern l_int32 pixaInsertPix ( PIXA *pixa, l_int32 index, PIX *pixs, BOX *box );
         extern l_int32 pixaRemovePix ( PIXA *pixa, l_int32 index );
         extern l_int32 pixaRemovePixAndSave ( PIXA *pixa, l_int32 index, PIX **ppix, BOX **pbox );
         extern l_int32 pixaInitFull ( PIXA *pixa, PIX *pix, BOX *box );
         extern l_int32 pixaClear ( PIXA *pixa );
         extern l_int32 pixaJoin ( PIXA *pixad, PIXA *pixas, l_int32 istart, l_int32 iend );
         extern l_int32 pixaaJoin ( PIXAA *paad, PIXAA *paas, l_int32 istart, l_int32 iend );
         extern PIXAA * pixaaCreate ( l_int32 n );
         extern PIXAA * pixaaCreateFromPixa ( PIXA *pixa, l_int32 n, l_int32 type, l_int32 copyflag );
         extern void pixaaDestroy ( PIXAA **ppaa );
         extern l_int32 pixaaAddPixa ( PIXAA *paa, PIXA *pixa, l_int32 copyflag );
         extern l_int32 pixaaExtendArray ( PIXAA *paa );
         extern l_int32 pixaaAddPix ( PIXAA *paa, l_int32 index, PIX *pix, BOX *box, l_int32 copyflag );
         extern l_int32 pixaaAddBox ( PIXAA *paa, BOX *box, l_int32 copyflag );
         extern l_int32 pixaaGetCount ( PIXAA *paa, NUMA **pna );
         extern PIXA * pixaaGetPixa ( PIXAA *paa, l_int32 index, l_int32 accesstype );
         extern BOXA * pixaaGetBoxa ( PIXAA *paa, l_int32 accesstype );
         extern PIX * pixaaGetPix ( PIXAA *paa, l_int32 index, l_int32 ipix, l_int32 accessflag );
         extern l_int32 pixaaVerifyDepth ( PIXAA *paa, l_int32 *pmaxdepth );
         extern l_int32 pixaaIsFull ( PIXAA *paa, l_int32 *pfull );
         extern l_int32 pixaaInitFull ( PIXAA *paa, PIXA *pixa );
         extern l_int32 pixaaReplacePixa ( PIXAA *paa, l_int32 index, PIXA *pixa );
         extern l_int32 pixaaClear ( PIXAA *paa );
         extern l_int32 pixaaTruncate ( PIXAA *paa );
         extern PIXA * pixaRead ( const char *filename );
         extern PIXA * pixaReadStream ( FILE *fp );
         extern l_int32 pixaWrite ( const char *filename, PIXA *pixa );
         extern l_int32 pixaWriteStream ( FILE *fp, PIXA *pixa );
         extern PIXAA * pixaaReadFromFiles ( const char *dirname, const char *substr, l_int32 first, l_int32 nfiles );
         extern PIXAA * pixaaRead ( const char *filename );
         extern PIXAA * pixaaReadStream ( FILE *fp );
         extern l_int32 pixaaWrite ( const char *filename, PIXAA *paa );
         extern l_int32 pixaaWriteStream ( FILE *fp, PIXAA *paa );
         extern PIXACC * pixaccCreate ( l_int32 w, l_int32 h, l_int32 negflag );
         extern PIXACC * pixaccCreateFromPix ( PIX *pix, l_int32 negflag );
         extern void pixaccDestroy ( PIXACC **ppixacc );
         extern PIX * pixaccFinal ( PIXACC *pixacc, l_int32 outdepth );
         extern PIX * pixaccGetPix ( PIXACC *pixacc );
         extern l_int32 pixaccGetOffset ( PIXACC *pixacc );
         extern l_int32 pixaccAdd ( PIXACC *pixacc, PIX *pix );
         extern l_int32 pixaccSubtract ( PIXACC *pixacc, PIX *pix );
         extern l_int32 pixaccMultConst ( PIXACC *pixacc, l_float32 factor );
         extern l_int32 pixaccMultConstAccumulate ( PIXACC *pixacc, PIX *pix, l_float32 factor );
         extern PIX * pixSelectBySize ( PIX *pixs, l_int32 width, l_int32 height, l_int32 connectivity, l_int32 type, l_int32 relation, l_int32 *pchanged );
         extern PIXA * pixaSelectBySize ( PIXA *pixas, l_int32 width, l_int32 height, l_int32 type, l_int32 relation, l_int32 *pchanged );
         extern NUMA * pixaMakeSizeIndicator ( PIXA *pixa, l_int32 width, l_int32 height, l_int32 type, l_int32 relation );
         extern PIX * pixSelectByPerimToAreaRatio ( PIX *pixs, l_float32 thresh, l_int32 connectivity, l_int32 type, l_int32 *pchanged );
         extern PIXA * pixaSelectByPerimToAreaRatio ( PIXA *pixas, l_float32 thresh, l_int32 type, l_int32 *pchanged );
         extern PIX * pixSelectByPerimSizeRatio ( PIX *pixs, l_float32 thresh, l_int32 connectivity, l_int32 type, l_int32 *pchanged );
         extern PIXA * pixaSelectByPerimSizeRatio ( PIXA *pixas, l_float32 thresh, l_int32 type, l_int32 *pchanged );
         extern PIX * pixSelectByAreaFraction ( PIX *pixs, l_float32 thresh, l_int32 connectivity, l_int32 type, l_int32 *pchanged );
         extern PIXA * pixaSelectByAreaFraction ( PIXA *pixas, l_float32 thresh, l_int32 type, l_int32 *pchanged );
         extern PIX * pixSelectByWidthHeightRatio ( PIX *pixs, l_float32 thresh, l_int32 connectivity, l_int32 type, l_int32 *pchanged );
         extern PIXA * pixaSelectByWidthHeightRatio ( PIXA *pixas, l_float32 thresh, l_int32 type, l_int32 *pchanged );
         extern PIXA * pixaSelectWithIndicator ( PIXA *pixas, NUMA *na, l_int32 *pchanged );
         extern l_int32 pixRemoveWithIndicator ( PIX *pixs, PIXA *pixa, NUMA *na );
         extern l_int32 pixAddWithIndicator ( PIX *pixs, PIXA *pixa, NUMA *na );
         extern PIX * pixaRenderComponent ( PIX *pixs, PIXA *pixa, l_int32 index );
         extern PIXA * pixaSort ( PIXA *pixas, l_int32 sorttype, l_int32 sortorder, NUMA **pnaindex, l_int32 copyflag );
         extern PIXA * pixaBinSort ( PIXA *pixas, l_int32 sorttype, l_int32 sortorder, NUMA **pnaindex, l_int32 copyflag );
         extern PIXA * pixaSortByIndex ( PIXA *pixas, NUMA *naindex, l_int32 copyflag );
         extern PIXAA * pixaSort2dByIndex ( PIXA *pixas, NUMAA *naa, l_int32 copyflag );
         extern PIXA * pixaSelectRange ( PIXA *pixas, l_int32 first, l_int32 last, l_int32 copyflag );
         extern PIXAA * pixaaSelectRange ( PIXAA *paas, l_int32 first, l_int32 last, l_int32 copyflag );
         extern PIXAA * pixaaScaleToSize ( PIXAA *paas, l_int32 wd, l_int32 hd );
         extern PIXAA * pixaaScaleToSizeVar ( PIXAA *paas, NUMA *nawd, NUMA *nahd );
         extern PIXA * pixaScaleToSize ( PIXA *pixas, l_int32 wd, l_int32 hd );
         extern PIXA * pixaAddBorderGeneral ( PIXA *pixad, PIXA *pixas, l_int32 left, l_int32 right, l_int32 top, l_int32 bot, l_uint32 val );
         extern PIXA * pixaaFlattenToPixa ( PIXAA *paa, NUMA **pnaindex, l_int32 copyflag );
         extern l_int32 pixaaSizeRange ( PIXAA *paa, l_int32 *pminw, l_int32 *pminh, l_int32 *pmaxw, l_int32 *pmaxh );
         extern l_int32 pixaSizeRange ( PIXA *pixa, l_int32 *pminw, l_int32 *pminh, l_int32 *pmaxw, l_int32 *pmaxh );
         extern PIXA * pixaClipToPix ( PIXA *pixas, PIX *pixs );
         extern l_int32 pixaGetRenderingDepth ( PIXA *pixa, l_int32 *pdepth );
         extern l_int32 pixaHasColor ( PIXA *pixa, l_int32 *phascolor );
         extern l_int32 pixaAnyColormaps ( PIXA *pixa, l_int32 *phascmap );
         extern l_int32 pixaGetDepthInfo ( PIXA *pixa, l_int32 *pmaxdepth, l_int32 *psame );
         extern PIXA * pixaConvertToSameDepth ( PIXA *pixas );
         extern l_int32 pixaEqual ( PIXA *pixa1, PIXA *pixa2, l_int32 maxdist, NUMA **pnaindex, l_int32 *psame );
         extern PIX * pixaDisplay ( PIXA *pixa, l_int32 w, l_int32 h );
         extern PIX * pixaDisplayOnColor ( PIXA *pixa, l_int32 w, l_int32 h, l_uint32 bgcolor );
         extern PIX * pixaDisplayRandomCmap ( PIXA *pixa, l_int32 w, l_int32 h );
         extern PIX * pixaDisplayLinearly ( PIXA *pixas, l_int32 direction, l_float32 scalefactor, l_int32 background, l_int32 spacing, l_int32 border, BOXA **pboxa );
         extern PIX * pixaDisplayOnLattice ( PIXA *pixa, l_int32 cellw, l_int32 cellh, l_int32 *pncols, BOXA **pboxa );
         extern PIX * pixaDisplayUnsplit ( PIXA *pixa, l_int32 nx, l_int32 ny, l_int32 borderwidth, l_uint32 bordercolor );
         extern PIX * pixaDisplayTiled ( PIXA *pixa, l_int32 maxwidth, l_int32 background, l_int32 spacing );
         extern PIX * pixaDisplayTiledInRows ( PIXA *pixa, l_int32 outdepth, l_int32 maxwidth, l_float32 scalefactor, l_int32 background, l_int32 spacing, l_int32 border );
         extern PIX * pixaDisplayTiledAndScaled ( PIXA *pixa, l_int32 outdepth, l_int32 tilewidth, l_int32 ncols, l_int32 background, l_int32 spacing, l_int32 border );
         extern PIX * pixaaDisplay ( PIXAA *paa, l_int32 w, l_int32 h );
         extern PIX * pixaaDisplayByPixa ( PIXAA *paa, l_int32 xspace, l_int32 yspace, l_int32 maxw );
         extern PIXA * pixaaDisplayTiledAndScaled ( PIXAA *paa, l_int32 outdepth, l_int32 tilewidth, l_int32 ncols, l_int32 background, l_int32 spacing, l_int32 border );
         extern PIXA * pixaConvertTo1 ( PIXA *pixas, l_int32 thresh );
         extern PIXA * pixaConvertTo8 ( PIXA *pixas, l_int32 cmapflag );
         extern PIXA * pixaConvertTo8Color ( PIXA *pixas, l_int32 dither );
         extern PIXA * pixaConvertTo32 ( PIXA *pixas );
         extern l_int32 convertToNUpFiles ( const char *dir, const char *substr, l_int32 nx, l_int32 ny, l_int32 tw, l_int32 spacing, l_int32 border, const char *fontdir, const char *outdir );
         extern PIXA * convertToNUpPixa ( const char *dir, const char *substr, l_int32 nx, l_int32 ny, l_int32 tw, l_int32 spacing, l_int32 border, const char *fontdir );
         extern l_int32 pmsCreate ( size_t minsize, size_t smallest, NUMA *numalloc, const char *logfile );
         extern void pmsDestroy ( );
         extern void * pmsCustomAlloc ( size_t nbytes );
         extern void pmsCustomDealloc ( void *data );
         extern void * pmsGetAlloc ( size_t nbytes );
         extern l_int32 pmsGetLevelForAlloc ( size_t nbytes, l_int32 *plevel );
         extern l_int32 pmsGetLevelForDealloc ( void *data, l_int32 *plevel );
         extern void pmsLogInfo ( );
         extern l_int32 pixAddConstantGray ( PIX *pixs, l_int32 val );
         extern l_int32 pixMultConstantGray ( PIX *pixs, l_float32 val );
         extern PIX * pixAddGray ( PIX *pixd, PIX *pixs1, PIX *pixs2 );
         extern PIX * pixSubtractGray ( PIX *pixd, PIX *pixs1, PIX *pixs2 );
         extern PIX * pixThresholdToValue ( PIX *pixd, PIX *pixs, l_int32 threshval, l_int32 setval );
         extern PIX * pixInitAccumulate ( l_int32 w, l_int32 h, l_uint32 offset );
         extern PIX * pixFinalAccumulate ( PIX *pixs, l_uint32 offset, l_int32 depth );
         extern PIX * pixFinalAccumulateThreshold ( PIX *pixs, l_uint32 offset, l_uint32 threshold );
         extern l_int32 pixAccumulate ( PIX *pixd, PIX *pixs, l_int32 op );
         extern l_int32 pixMultConstAccumulate ( PIX *pixs, l_float32 factor, l_uint32 offset );
         extern PIX * pixAbsDifference ( PIX *pixs1, PIX *pixs2 );
         extern PIX * pixAddRGB ( PIX *pixs1, PIX *pixs2 );
         extern PIX * pixMinOrMax ( PIX *pixd, PIX *pixs1, PIX *pixs2, l_int32 type );
         extern PIX * pixMaxDynamicRange ( PIX *pixs, l_int32 type );
         extern l_float32 * makeLogBase2Tab ( void );
         extern l_float32 getLogBase2 ( l_int32 val, l_float32 *logtab );
         extern PIXC * pixcompCreateFromPix ( PIX *pix, l_int32 comptype );
         extern PIXC * pixcompCreateFromString ( l_uint8 *data, size_t size, l_int32 copyflag );
         extern PIXC * pixcompCreateFromFile ( const char *filename, l_int32 comptype );
         extern void pixcompDestroy ( PIXC **ppixc );
         extern l_int32 pixcompGetDimensions ( PIXC *pixc, l_int32 *pw, l_int32 *ph, l_int32 *pd );
         extern l_int32 pixcompDetermineFormat ( l_int32 comptype, l_int32 d, l_int32 cmapflag, l_int32 *pformat );
         extern PIX * pixCreateFromPixcomp ( PIXC *pixc );
         extern PIXAC * pixacompCreate ( l_int32 n );
         extern PIXAC * pixacompCreateWithInit ( l_int32 n, l_int32 offset, PIX *pix, l_int32 comptype );
         extern PIXAC * pixacompCreateFromPixa ( PIXA *pixa, l_int32 comptype, l_int32 accesstype );
         extern PIXAC * pixacompCreateFromFiles ( const char *dirname, const char *substr, l_int32 comptype );
         extern PIXAC * pixacompCreateFromSA ( SARRAY *sa, l_int32 comptype );
         extern void pixacompDestroy ( PIXAC **ppixac );
         extern l_int32 pixacompAddPix ( PIXAC *pixac, PIX *pix, l_int32 comptype );
         extern l_int32 pixacompAddPixcomp ( PIXAC *pixac, PIXC *pixc );
         extern l_int32 pixacompReplacePix ( PIXAC *pixac, l_int32 index, PIX *pix, l_int32 comptype );
         extern l_int32 pixacompReplacePixcomp ( PIXAC *pixac, l_int32 index, PIXC *pixc );
         extern l_int32 pixacompAddBox ( PIXAC *pixac, BOX *box, l_int32 copyflag );
         extern l_int32 pixacompGetCount ( PIXAC *pixac );
         extern PIXC * pixacompGetPixcomp ( PIXAC *pixac, l_int32 index );
         extern PIX * pixacompGetPix ( PIXAC *pixac, l_int32 index );
         extern l_int32 pixacompGetPixDimensions ( PIXAC *pixac, l_int32 index, l_int32 *pw, l_int32 *ph, l_int32 *pd );
         extern BOXA * pixacompGetBoxa ( PIXAC *pixac, l_int32 accesstype );
         extern l_int32 pixacompGetBoxaCount ( PIXAC *pixac );
         extern BOX * pixacompGetBox ( PIXAC *pixac, l_int32 index, l_int32 accesstype );
         extern l_int32 pixacompGetBoxGeometry ( PIXAC *pixac, l_int32 index, l_int32 *px, l_int32 *py, l_int32 *pw, l_int32 *ph );
         extern l_int32 pixacompGetOffset ( PIXAC *pixac );
         extern l_int32 pixacompSetOffset ( PIXAC *pixac, l_int32 offset );
         extern PIXA * pixaCreateFromPixacomp ( PIXAC *pixac, l_int32 accesstype );
         extern PIXAC * pixacompRead ( const char *filename );
         extern PIXAC * pixacompReadStream ( FILE *fp );
         extern l_int32 pixacompWrite ( const char *filename, PIXAC *pixac );
         extern l_int32 pixacompWriteStream ( FILE *fp, PIXAC *pixac );
         extern l_int32 pixacompConvertToPdf ( PIXAC *pixac, l_int32 res, l_float32 scalefactor, l_int32 type, l_int32 quality, const char *title, const char *fileout );
         extern l_int32 pixacompConvertToPdfData ( PIXAC *pixac, l_int32 res, l_float32 scalefactor, l_int32 type, l_int32 quality, const char *title, l_uint8 **pdata, size_t *pnbytes );
         extern l_int32 pixacompWriteStreamInfo ( FILE *fp, PIXAC *pixac, const char *text );
         extern l_int32 pixcompWriteStreamInfo ( FILE *fp, PIXC *pixc, const char *text );
         extern PIX * pixacompDisplayTiledAndScaled ( PIXAC *pixac, l_int32 outdepth, l_int32 tilewidth, l_int32 ncols, l_int32 background, l_int32 spacing, l_int32 border );
         extern PIX * pixThreshold8 ( PIX *pixs, l_int32 d, l_int32 nlevels, l_int32 cmapflag );
         extern PIX * pixRemoveColormapGeneral ( PIX *pixs, l_int32 type, l_int32 ifnocmap );
         extern PIX * pixRemoveColormap ( PIX *pixs, l_int32 type );
         extern l_int32 pixAddGrayColormap8 ( PIX *pixs );
         extern PIX * pixAddMinimalGrayColormap8 ( PIX *pixs );
         extern PIX * pixConvertRGBToLuminance ( PIX *pixs );
         extern PIX * pixConvertRGBToGray ( PIX *pixs, l_float32 rwt, l_float32 gwt, l_float32 bwt );
         extern PIX * pixConvertRGBToGrayFast ( PIX *pixs );
         extern PIX * pixConvertRGBToGrayMinMax ( PIX *pixs, l_int32 type );
         extern PIX * pixConvertRGBToGraySatBoost ( PIX *pixs, l_int32 refval );
         extern PIX * pixConvertGrayToColormap ( PIX *pixs );
         extern PIX * pixConvertGrayToColormap8 ( PIX *pixs, l_int32 mindepth );
         extern PIX * pixColorizeGray ( PIX *pixs, l_uint32 color, l_int32 cmapflag );
         extern PIX * pixConvertRGBToColormap ( PIX *pixs, l_int32 ditherflag );
         extern l_int32 pixQuantizeIfFewColors ( PIX *pixs, l_int32 maxcolors, l_int32 mingraycolors, l_int32 octlevel, PIX **ppixd );
         extern PIX * pixConvert16To8 ( PIX *pixs, l_int32 type );
         extern PIX * pixConvertGrayToFalseColor ( PIX *pixs, l_float32 gamma );
         extern PIX * pixUnpackBinary ( PIX *pixs, l_int32 depth, l_int32 invert );
         extern PIX * pixConvert1To16 ( PIX *pixd, PIX *pixs, l_uint16 val0, l_uint16 val1 );
         extern PIX * pixConvert1To32 ( PIX *pixd, PIX *pixs, l_uint32 val0, l_uint32 val1 );
         extern PIX * pixConvert1To2Cmap ( PIX *pixs );
         extern PIX * pixConvert1To2 ( PIX *pixd, PIX *pixs, l_int32 val0, l_int32 val1 );
         extern PIX * pixConvert1To4Cmap ( PIX *pixs );
         extern PIX * pixConvert1To4 ( PIX *pixd, PIX *pixs, l_int32 val0, l_int32 val1 );
         extern PIX * pixConvert1To8 ( PIX *pixd, PIX *pixs, l_uint8 val0, l_uint8 val1 );
         extern PIX * pixConvert2To8 ( PIX *pixs, l_uint8 val0, l_uint8 val1, l_uint8 val2, l_uint8 val3, l_int32 cmapflag );
         extern PIX * pixConvert4To8 ( PIX *pixs, l_int32 cmapflag );
         extern PIX * pixConvert8To16 ( PIX *pixs, l_int32 leftshift );
         extern PIX * pixConvertTo1 ( PIX *pixs, l_int32 threshold );
         extern PIX * pixConvertTo1BySampling ( PIX *pixs, l_int32 factor, l_int32 threshold );
         extern PIX * pixConvertTo8 ( PIX *pixs, l_int32 cmapflag );
         extern PIX * pixConvertTo8BySampling ( PIX *pixs, l_int32 factor, l_int32 cmapflag );
         extern PIX * pixConvertTo8Color ( PIX *pixs, l_int32 dither );
         extern PIX * pixConvertTo16 ( PIX *pixs );
         extern PIX * pixConvertTo32 ( PIX *pixs );
         extern PIX * pixConvertTo32BySampling ( PIX *pixs, l_int32 factor );
         extern PIX * pixConvert8To32 ( PIX *pixs );
         extern PIX * pixConvertTo8Or32 ( PIX *pixs, l_int32 copyflag, l_int32 warnflag );
         extern PIX * pixConvert24To32 ( PIX *pixs );
         extern PIX * pixConvert32To24 ( PIX *pixs );
         extern PIX * pixRemoveAlpha ( PIX *pixs );
         extern PIX * pixAddAlphaTo1bpp ( PIX *pixd, PIX *pixs );
         extern PIX * pixConvertLossless ( PIX *pixs, l_int32 d );
         extern PIX * pixConvertForPSWrap ( PIX *pixs );
         extern PIX * pixConvertToSubpixelRGB ( PIX *pixs, l_float32 scalex, l_float32 scaley, l_int32 order );
         extern PIX * pixConvertGrayToSubpixelRGB ( PIX *pixs, l_float32 scalex, l_float32 scaley, l_int32 order );
         extern PIX * pixConvertColorToSubpixelRGB ( PIX *pixs, l_float32 scalex, l_float32 scaley, l_int32 order );
         extern PIX * pixConnCompTransform ( PIX *pixs, l_int32 connect, l_int32 depth );
         extern PIX * pixConnCompAreaTransform ( PIX *pixs, l_int32 connect );
         extern PIX * pixLocToColorTransform ( PIX *pixs );
         extern PIXTILING * pixTilingCreate ( PIX *pixs, l_int32 nx, l_int32 ny, l_int32 w, l_int32 h, l_int32 xoverlap, l_int32 yoverlap );
         extern void pixTilingDestroy ( PIXTILING **ppt );
         extern l_int32 pixTilingGetCount ( PIXTILING *pt, l_int32 *pnx, l_int32 *pny );
         extern l_int32 pixTilingGetSize ( PIXTILING *pt, l_int32 *pw, l_int32 *ph );
         extern PIX * pixTilingGetTile ( PIXTILING *pt, l_int32 i, l_int32 j );
         extern l_int32 pixTilingNoStripOnPaint ( PIXTILING *pt );
         extern l_int32 pixTilingPaintTile ( PIX *pixd, l_int32 i, l_int32 j, PIX *pixs, PIXTILING *pt );
         extern PIX * pixReadStreamPng ( FILE *fp );
         extern l_int32 readHeaderPng ( const char *filename, l_int32 *pw, l_int32 *ph, l_int32 *pbps, l_int32 *pspp, l_int32 *piscmap );
         extern l_int32 freadHeaderPng ( FILE *fp, l_int32 *pw, l_int32 *ph, l_int32 *pbps, l_int32 *pspp, l_int32 *piscmap );
         extern l_int32 readHeaderMemPng ( const l_uint8 *data, size_t size, l_int32 *pw, l_int32 *ph, l_int32 *pbps, l_int32 *pspp, l_int32 *piscmap );
         extern l_int32 fgetPngResolution ( FILE *fp, l_int32 *pxres, l_int32 *pyres );
         extern l_int32 isPngInterlaced ( const char *filename, l_int32 *pinterlaced );
         extern l_int32 pixWritePng ( const char *filename, PIX *pix, l_float32 gamma );
         extern l_int32 pixWriteStreamPng ( FILE *fp, PIX *pix, l_float32 gamma );
         extern l_int32 pixSetZlibCompression ( PIX *pix, l_int32 compval );
         extern void l_pngSetReadStrip16To8 ( l_int32 flag );
         extern PIX * pixReadMemPng ( const l_uint8 *cdata, size_t size );
         extern l_int32 pixWriteMemPng ( l_uint8 **pdata, size_t *psize, PIX *pix, l_float32 gamma );
         extern PIX * pixReadStreamPnm ( FILE *fp );
         extern l_int32 readHeaderPnm ( const char *filename, l_int32 *pw, l_int32 *ph, l_int32 *pd, l_int32 *ptype, l_int32 *pbps, l_int32 *pspp );
         extern l_int32 freadHeaderPnm ( FILE *fp, l_int32 *pw, l_int32 *ph, l_int32 *pd, l_int32 *ptype, l_int32 *pbps, l_int32 *pspp );
         extern l_int32 pixWriteStreamPnm ( FILE *fp, PIX *pix );
         extern l_int32 pixWriteStreamAsciiPnm ( FILE *fp, PIX *pix );
         extern PIX * pixReadMemPnm ( const l_uint8 *cdata, size_t size );
         extern l_int32 readHeaderMemPnm ( const l_uint8 *cdata, size_t size, l_int32 *pw, l_int32 *ph, l_int32 *pd, l_int32 *ptype, l_int32 *pbps, l_int32 *pspp );
         extern l_int32 pixWriteMemPnm ( l_uint8 **pdata, size_t *psize, PIX *pix );
         extern PIX * pixProjectiveSampledPta ( PIX *pixs, PTA *ptad, PTA *ptas, l_int32 incolor );
         extern PIX * pixProjectiveSampled ( PIX *pixs, l_float32 *vc, l_int32 incolor );
         extern PIX * pixProjectivePta ( PIX *pixs, PTA *ptad, PTA *ptas, l_int32 incolor );
         extern PIX * pixProjective ( PIX *pixs, l_float32 *vc, l_int32 incolor );
         extern PIX * pixProjectivePtaColor ( PIX *pixs, PTA *ptad, PTA *ptas, l_uint32 colorval );
         extern PIX * pixProjectiveColor ( PIX *pixs, l_float32 *vc, l_uint32 colorval );
         extern PIX * pixProjectivePtaGray ( PIX *pixs, PTA *ptad, PTA *ptas, l_uint8 grayval );
         extern PIX * pixProjectiveGray ( PIX *pixs, l_float32 *vc, l_uint8 grayval );
         extern PIX * pixProjectivePtaWithAlpha ( PIX *pixs, PTA *ptad, PTA *ptas, PIX *pixg, l_float32 fract, l_int32 border );
         extern l_int32 getProjectiveXformCoeffs ( PTA *ptas, PTA *ptad, l_float32 **pvc );
         extern l_int32 projectiveXformSampledPt ( l_float32 *vc, l_int32 x, l_int32 y, l_int32 *pxp, l_int32 *pyp );
         extern l_int32 projectiveXformPt ( l_float32 *vc, l_int32 x, l_int32 y, l_float32 *pxp, l_float32 *pyp );
         extern l_int32 convertFilesToPS ( const char *dirin, const char *substr, l_int32 res, const char *fileout );
         extern l_int32 sarrayConvertFilesToPS ( SARRAY *sa, l_int32 res, const char *fileout );
         extern l_int32 convertFilesFittedToPS ( const char *dirin, const char *substr, l_float32 xpts, l_float32 ypts, const char *fileout );
         extern l_int32 sarrayConvertFilesFittedToPS ( SARRAY *sa, l_float32 xpts, l_float32 ypts, const char *fileout );
         extern l_int32 writeImageCompressedToPSFile ( const char *filein, const char *fileout, l_int32 res, l_int32 *pfirstfile, l_int32 *pindex );
         extern l_int32 convertSegmentedPagesToPS ( const char *pagedir, const char *pagestr, l_int32 page_numpre, const char *maskdir, const char *maskstr, l_int32 mask_numpre, l_int32 numpost, l_int32 maxnum, l_float32 textscale, l_float32 imagescale, l_int32 threshold, const char *fileout );
         extern l_int32 pixWriteSegmentedPageToPS ( PIX *pixs, PIX *pixm, l_float32 textscale, l_float32 imagescale, l_int32 threshold, l_int32 pageno, const char *fileout );
         extern l_int32 pixWriteMixedToPS ( PIX *pixb, PIX *pixc, l_float32 scale, l_int32 pageno, const char *fileout );
         extern l_int32 convertToPSEmbed ( const char *filein, const char *fileout, l_int32 level );
         extern l_int32 pixaWriteCompressedToPS ( PIXA *pixa, const char *fileout, l_int32 res, l_int32 level );
         extern l_int32 pixWritePSEmbed ( const char *filein, const char *fileout );
         extern l_int32 pixWriteStreamPS ( FILE *fp, PIX *pix, BOX *box, l_int32 res, l_float32 scale );
         extern char * pixWriteStringPS ( PIX *pixs, BOX *box, l_int32 res, l_float32 scale );
         extern char * generateUncompressedPS ( char *hexdata, l_int32 w, l_int32 h, l_int32 d, l_int32 psbpl, l_int32 bps, l_float32 xpt, l_float32 ypt, l_float32 wpt, l_float32 hpt, l_int32 boxflag );
         extern void getScaledParametersPS ( BOX *box, l_int32 wpix, l_int32 hpix, l_int32 res, l_float32 scale, l_float32 *pxpt, l_float32 *pypt, l_float32 *pwpt, l_float32 *phpt );
         extern void convertByteToHexAscii ( l_uint8 byteval, char *pnib1, char *pnib2 );
         extern l_int32 convertJpegToPSEmbed ( const char *filein, const char *fileout );
         extern l_int32 convertJpegToPS ( const char *filein, const char *fileout, const char *operation, l_int32 x, l_int32 y, l_int32 res, l_float32 scale, l_int32 pageno, l_int32 endpage );
         extern l_int32 convertJpegToPSString ( const char *filein, char **poutstr, l_int32 *pnbytes, l_int32 x, l_int32 y, l_int32 res, l_float32 scale, l_int32 pageno, l_int32 endpage );
         extern char * generateJpegPS ( const char *filein, L_COMP_DATA *cid, l_float32 xpt, l_float32 ypt, l_float32 wpt, l_float32 hpt, l_int32 pageno, l_int32 endpage );
         extern l_int32 convertG4ToPSEmbed ( const char *filein, const char *fileout );
         extern l_int32 convertG4ToPS ( const char *filein, const char *fileout, const char *operation, l_int32 x, l_int32 y, l_int32 res, l_float32 scale, l_int32 pageno, l_int32 maskflag, l_int32 endpage );
         extern l_int32 convertG4ToPSString ( const char *filein, char **poutstr, l_int32 *pnbytes, l_int32 x, l_int32 y, l_int32 res, l_float32 scale, l_int32 pageno, l_int32 maskflag, l_int32 endpage );
         extern char * generateG4PS ( const char *filein, L_COMP_DATA *cid, l_float32 xpt, l_float32 ypt, l_float32 wpt, l_float32 hpt, l_int32 maskflag, l_int32 pageno, l_int32 endpage );
         extern l_int32 convertTiffMultipageToPS ( const char *filein, const char *fileout, const char *tempfile, l_float32 fillfract );
         extern l_int32 convertFlateToPSEmbed ( const char *filein, const char *fileout );
         extern l_int32 convertFlateToPS ( const char *filein, const char *fileout, const char *operation, l_int32 x, l_int32 y, l_int32 res, l_float32 scale, l_int32 pageno, l_int32 endpage );
         extern l_int32 convertFlateToPSString ( const char *filein, char **poutstr, l_int32 *pnbytes, l_int32 x, l_int32 y, l_int32 res, l_float32 scale, l_int32 pageno, l_int32 endpage );
         extern char * generateFlatePS ( const char *filein, L_COMP_DATA *cid, l_float32 xpt, l_float32 ypt, l_float32 wpt, l_float32 hpt, l_int32 pageno, l_int32 endpage );
         extern l_int32 pixWriteMemPS ( l_uint8 **pdata, size_t *psize, PIX *pix, BOX *box, l_int32 res, l_float32 scale );
         extern l_int32 getResLetterPage ( l_int32 w, l_int32 h, l_float32 fillfract );
         extern l_int32 getResA4Page ( l_int32 w, l_int32 h, l_float32 fillfract );
         extern char * encodeAscii85 ( l_uint8 *inarray, l_int32 insize, l_int32 *poutsize );
         extern l_uint8 * decodeAscii85 ( char *ina, l_int32 insize, l_int32 *poutsize );
         extern void l_psWriteBoundingBox ( l_int32 flag );
         extern PTA * ptaCreate ( l_int32 n );
         extern PTA * ptaCreateFromNuma ( NUMA *nax, NUMA *nay );
         extern void ptaDestroy ( PTA **ppta );
         extern PTA * ptaCopy ( PTA *pta );
         extern PTA * ptaCopyRange ( PTA *ptas, l_int32 istart, l_int32 iend );
         extern PTA * ptaClone ( PTA *pta );
         extern l_int32 ptaEmpty ( PTA *pta );
         extern l_int32 ptaAddPt ( PTA *pta, l_float32 x, l_float32 y );
         extern l_int32 ptaInsertPt ( PTA *pta, l_int32 index, l_int32 x, l_int32 y );
         extern l_int32 ptaRemovePt ( PTA *pta, l_int32 index );
         extern l_int32 ptaGetRefcount ( PTA *pta );
         extern l_int32 ptaChangeRefcount ( PTA *pta, l_int32 delta );
         extern l_int32 ptaGetCount ( PTA *pta );
         extern l_int32 ptaGetPt ( PTA *pta, l_int32 index, l_float32 *px, l_float32 *py );
         extern l_int32 ptaGetIPt ( PTA *pta, l_int32 index, l_int32 *px, l_int32 *py );
         extern l_int32 ptaSetPt ( PTA *pta, l_int32 index, l_float32 x, l_float32 y );
         extern l_int32 ptaGetArrays ( PTA *pta, NUMA **pnax, NUMA **pnay );
         extern PTA * ptaRead ( const char *filename );
         extern PTA * ptaReadStream ( FILE *fp );
         extern l_int32 ptaWrite ( const char *filename, PTA *pta, l_int32 type );
         extern l_int32 ptaWriteStream ( FILE *fp, PTA *pta, l_int32 type );
         extern PTAA * ptaaCreate ( l_int32 n );
         extern void ptaaDestroy ( PTAA **pptaa );
         extern l_int32 ptaaAddPta ( PTAA *ptaa, PTA *pta, l_int32 copyflag );
         extern l_int32 ptaaGetCount ( PTAA *ptaa );
         extern PTA * ptaaGetPta ( PTAA *ptaa, l_int32 index, l_int32 accessflag );
         extern l_int32 ptaaGetPt ( PTAA *ptaa, l_int32 ipta, l_int32 jpt, l_float32 *px, l_float32 *py );
         extern l_int32 ptaaInitFull ( PTAA *ptaa, PTA *pta );
         extern l_int32 ptaaReplacePta ( PTAA *ptaa, l_int32 index, PTA *pta );
         extern l_int32 ptaaAddPt ( PTAA *ptaa, l_int32 ipta, l_float32 x, l_float32 y );
         extern l_int32 ptaaTruncate ( PTAA *ptaa );
         extern PTAA * ptaaRead ( const char *filename );
         extern PTAA * ptaaReadStream ( FILE *fp );
         extern l_int32 ptaaWrite ( const char *filename, PTAA *ptaa, l_int32 type );
         extern l_int32 ptaaWriteStream ( FILE *fp, PTAA *ptaa, l_int32 type );
         extern PTA * ptaSubsample ( PTA *ptas, l_int32 subfactor );
         extern l_int32 ptaJoin ( PTA *ptad, PTA *ptas, l_int32 istart, l_int32 iend );
         extern l_int32 ptaaJoin ( PTAA *ptaad, PTAA *ptaas, l_int32 istart, l_int32 iend );
         extern PTA * ptaReverse ( PTA *ptas, l_int32 type );
         extern PTA * ptaTranspose ( PTA *ptas );
         extern PTA * ptaCyclicPerm ( PTA *ptas, l_int32 xs, l_int32 ys );
         extern PTA * ptaSort ( PTA *ptas, l_int32 sorttype, l_int32 sortorder, NUMA **pnaindex );
         extern l_int32 ptaGetSortIndex ( PTA *ptas, l_int32 sorttype, l_int32 sortorder, NUMA **pnaindex );
         extern PTA * ptaSortByIndex ( PTA *ptas, NUMA *naindex );
         extern PTA * ptaRemoveDuplicates ( PTA *ptas, l_uint32 factor );
         extern PTAA * ptaaSortByIndex ( PTAA *ptaas, NUMA *naindex );
         extern BOX * ptaGetBoundingRegion ( PTA *pta );
         extern l_int32 ptaGetRange ( PTA *pta, l_float32 *pminx, l_float32 *pmaxx, l_float32 *pminy, l_float32 *pmaxy );
         extern PTA * ptaGetInsideBox ( PTA *ptas, BOX *box );
         extern PTA * pixFindCornerPixels ( PIX *pixs );
         extern l_int32 ptaContainsPt ( PTA *pta, l_int32 x, l_int32 y );
         extern l_int32 ptaTestIntersection ( PTA *pta1, PTA *pta2 );
         extern PTA * ptaTransform ( PTA *ptas, l_int32 shiftx, l_int32 shifty, l_float32 scalex, l_float32 scaley );
         extern l_int32 ptaPtInsidePolygon ( PTA *pta, l_float32 x, l_float32 y, l_int32 *pinside );
         extern l_float32 l_angleBetweenVectors ( l_float32 x1, l_float32 y1, l_float32 x2, l_float32 y2 );
         extern l_int32 ptaGetLinearLSF ( PTA *pta, l_float32 *pa, l_float32 *pb, NUMA **pnafit );
         extern l_int32 ptaGetQuadraticLSF ( PTA *pta, l_float32 *pa, l_float32 *pb, l_float32 *pc, NUMA **pnafit );
         extern l_int32 ptaGetCubicLSF ( PTA *pta, l_float32 *pa, l_float32 *pb, l_float32 *pc, l_float32 *pd, NUMA **pnafit );
         extern l_int32 ptaGetQuarticLSF ( PTA *pta, l_float32 *pa, l_float32 *pb, l_float32 *pc, l_float32 *pd, l_float32 *pe, NUMA **pnafit );
         extern l_int32 ptaNoisyLinearLSF ( PTA *pta, l_float32 factor, PTA **pptad, l_float32 *pa, l_float32 *pb, l_float32 *pmederr, NUMA **pnafit );
         extern l_int32 ptaNoisyQuadraticLSF ( PTA *pta, l_float32 factor, PTA **pptad, l_float32 *pa, l_float32 *pb, l_float32 *pc, l_float32 *pmederr, NUMA **pnafit );
         extern l_int32 applyLinearFit ( l_float32 a, l_float32 b, l_float32 x, l_float32 *py );
         extern l_int32 applyQuadraticFit ( l_float32 a, l_float32 b, l_float32 c, l_float32 x, l_float32 *py );
         extern l_int32 applyCubicFit ( l_float32 a, l_float32 b, l_float32 c, l_float32 d, l_float32 x, l_float32 *py );
         extern l_int32 applyQuarticFit ( l_float32 a, l_float32 b, l_float32 c, l_float32 d, l_float32 e, l_float32 x, l_float32 *py );
         extern l_int32 pixPlotAlongPta ( PIX *pixs, PTA *pta, l_int32 outformat, const char *title );
         extern PTA * ptaGetPixelsFromPix ( PIX *pixs, BOX *box );
         extern PIX * pixGenerateFromPta ( PTA *pta, l_int32 w, l_int32 h );
         extern PTA * ptaGetBoundaryPixels ( PIX *pixs, l_int32 type );
         extern PTAA * ptaaGetBoundaryPixels ( PIX *pixs, l_int32 type, l_int32 connectivity, BOXA **pboxa, PIXA **ppixa );
         extern PIX * pixDisplayPta ( PIX *pixd, PIX *pixs, PTA *pta );
         extern PIX * pixDisplayPtaaPattern ( PIX *pixd, PIX *pixs, PTAA *ptaa, PIX *pixp, l_int32 cx, l_int32 cy );
         extern PIX * pixDisplayPtaPattern ( PIX *pixd, PIX *pixs, PTA *pta, PIX *pixp, l_int32 cx, l_int32 cy, l_uint32 color );
         extern PTA * ptaReplicatePattern ( PTA *ptas, PIX *pixp, PTA *ptap, l_int32 cx, l_int32 cy, l_int32 w, l_int32 h );
         extern PIX * pixDisplayPtaa ( PIX *pixs, PTAA *ptaa );
         extern L_PTRA * ptraCreate ( l_int32 n );
         extern void ptraDestroy ( L_PTRA **ppa, l_int32 freeflag, l_int32 warnflag );
         extern l_int32 ptraAdd ( L_PTRA *pa, void *item );
         extern l_int32 ptraInsert ( L_PTRA *pa, l_int32 index, void *item, l_int32 shiftflag );
         extern void * ptraRemove ( L_PTRA *pa, l_int32 index, l_int32 flag );
         extern void * ptraRemoveLast ( L_PTRA *pa );
         extern void * ptraReplace ( L_PTRA *pa, l_int32 index, void *item, l_int32 freeflag );
         extern l_int32 ptraSwap ( L_PTRA *pa, l_int32 index1, l_int32 index2 );
         extern l_int32 ptraCompactArray ( L_PTRA *pa );
         extern l_int32 ptraReverse ( L_PTRA *pa );
         extern l_int32 ptraJoin ( L_PTRA *pa1, L_PTRA *pa2 );
         extern l_int32 ptraGetMaxIndex ( L_PTRA *pa, l_int32 *pmaxindex );
         extern l_int32 ptraGetActualCount ( L_PTRA *pa, l_int32 *pcount );
         extern void * ptraGetPtrToItem ( L_PTRA *pa, l_int32 index );
         extern L_PTRAA * ptraaCreate ( l_int32 n );
         extern void ptraaDestroy ( L_PTRAA **ppaa, l_int32 freeflag, l_int32 warnflag );
         extern l_int32 ptraaGetSize ( L_PTRAA *paa, l_int32 *psize );
         extern l_int32 ptraaInsertPtra ( L_PTRAA *paa, l_int32 index, L_PTRA *pa );
         extern L_PTRA * ptraaGetPtra ( L_PTRAA *paa, l_int32 index, l_int32 accessflag );
         extern L_PTRA * ptraaFlattenToPtra ( L_PTRAA *paa );
         extern l_int32 pixQuadtreeMean ( PIX *pixs, l_int32 nlevels, PIX *pix_ma, FPIXA **pfpixa );
         extern l_int32 pixQuadtreeVariance ( PIX *pixs, l_int32 nlevels, PIX *pix_ma, DPIX *dpix_msa, FPIXA **pfpixa_v, FPIXA **pfpixa_rv );
         extern l_int32 pixMeanInRectangle ( PIX *pixs, BOX *box, PIX *pixma, l_float32 *pval );
         extern l_int32 pixVarianceInRectangle ( PIX *pixs, BOX *box, PIX *pix_ma, DPIX *dpix_msa, l_float32 *pvar, l_float32 *prvar );
         extern BOXAA * boxaaQuadtreeRegions ( l_int32 w, l_int32 h, l_int32 nlevels );
         extern l_int32 quadtreeGetParent ( FPIXA *fpixa, l_int32 level, l_int32 x, l_int32 y, l_float32 *pval );
         extern l_int32 quadtreeGetChildren ( FPIXA *fpixa, l_int32 level, l_int32 x, l_int32 y, l_float32 *pval00, l_float32 *pval10, l_float32 *pval01, l_float32 *pval11 );
         extern l_int32 quadtreeMaxLevels ( l_int32 w, l_int32 h );
         extern PIX * fpixaDisplayQuadtree ( FPIXA *fpixa, l_int32 factor, const char *fontdir );
         extern L_QUEUE * lqueueCreate ( l_int32 nalloc );
         extern void lqueueDestroy ( L_QUEUE **plq, l_int32 freeflag );
         extern l_int32 lqueueAdd ( L_QUEUE *lq, void *item );
         extern void * lqueueRemove ( L_QUEUE *lq );
         extern l_int32 lqueueGetCount ( L_QUEUE *lq );
         extern l_int32 lqueuePrint ( FILE *fp, L_QUEUE *lq );
         extern PIX * pixRankFilter ( PIX *pixs, l_int32 wf, l_int32 hf, l_float32 rank );
         extern PIX * pixRankFilterRGB ( PIX *pixs, l_int32 wf, l_int32 hf, l_float32 rank );
         extern PIX * pixRankFilterGray ( PIX *pixs, l_int32 wf, l_int32 hf, l_float32 rank );
         extern PIX * pixMedianFilter ( PIX *pixs, l_int32 wf, l_int32 hf );
         extern PIX * pixRankFilterWithScaling ( PIX *pixs, l_int32 wf, l_int32 hf, l_float32 rank, l_float32 scalefactor );
         extern SARRAY * pixProcessBarcodes ( PIX *pixs, l_int32 format, l_int32 method, SARRAY **psaw, l_int32 debugflag );
         extern PIXA * pixExtractBarcodes ( PIX *pixs, l_int32 debugflag );
         extern SARRAY * pixReadBarcodes ( PIXA *pixa, l_int32 format, l_int32 method, SARRAY **psaw, l_int32 debugflag );
         extern NUMA * pixReadBarcodeWidths ( PIX *pixs, l_int32 method, l_int32 debugflag );
         extern BOXA * pixLocateBarcodes ( PIX *pixs, l_int32 thresh, PIX **ppixb, PIX **ppixm );
         extern PIX * pixDeskewBarcode ( PIX *pixs, PIX *pixb, BOX *box, l_int32 margin, l_int32 threshold, l_float32 *pangle, l_float32 *pconf );
         extern NUMA * pixExtractBarcodeWidths1 ( PIX *pixs, l_float32 thresh, l_float32 binfract, NUMA **pnaehist, NUMA **pnaohist, l_int32 debugflag );
         extern NUMA * pixExtractBarcodeWidths2 ( PIX *pixs, l_float32 thresh, l_float32 *pwidth, NUMA **pnac, l_int32 debugflag );
         extern NUMA * pixExtractBarcodeCrossings ( PIX *pixs, l_float32 thresh, l_int32 debugflag );
         extern NUMA * numaQuantizeCrossingsByWidth ( NUMA *nas, l_float32 binfract, NUMA **pnaehist, NUMA **pnaohist, l_int32 debugflag );
         extern NUMA * numaQuantizeCrossingsByWindow ( NUMA *nas, l_float32 ratio, l_float32 *pwidth, l_float32 *pfirstloc, NUMA **pnac, l_int32 debugflag );
         extern PIXA * pixaReadFiles ( const char *dirname, const char *substr );
         extern PIXA * pixaReadFilesSA ( SARRAY *sa );
         extern PIX * pixRead ( const char *filename );
         extern PIX * pixReadWithHint ( const char *filename, l_int32 hint );
         extern PIX * pixReadIndexed ( SARRAY *sa, l_int32 index );
         extern PIX * pixReadStream ( FILE *fp, l_int32 hint );
         extern l_int32 pixReadHeader ( const char *filename, l_int32 *pformat, l_int32 *pw, l_int32 *ph, l_int32 *pbps, l_int32 *pspp, l_int32 *piscmap );
         extern l_int32 findFileFormat ( const char *filename, l_int32 *pformat );
         extern l_int32 findFileFormatStream ( FILE *fp, l_int32 *pformat );
         extern l_int32 findFileFormatBuffer ( const l_uint8 *buf, l_int32 *pformat );
         extern l_int32 fileFormatIsTiff ( FILE *fp );
         extern PIX * pixReadMem ( const l_uint8 *data, size_t size );
         extern l_int32 pixReadHeaderMem ( const l_uint8 *data, size_t size, l_int32 *pformat, l_int32 *pw, l_int32 *ph, l_int32 *pbps, l_int32 *pspp, l_int32 *piscmap );
         extern l_int32 ioFormatTest ( const char *filename );
         extern L_RECOGA * recogaCreateFromRecog ( L_RECOG *recog );
         extern L_RECOGA * recogaCreateFromPixaa ( PIXAA *paa, l_int32 scalew, l_int32 scaleh, l_int32 templ_type, l_int32 threshold, l_int32 maxyshift, const char *fontdir );
         extern L_RECOGA * recogaCreate ( l_int32 n );
         extern void recogaDestroy ( L_RECOGA **precoga );
         extern l_int32 recogaAddRecog ( L_RECOGA *recoga, L_RECOG *recog );
         extern l_int32 recogReplaceInRecoga ( L_RECOG **precog1, L_RECOG *recog2 );
         extern L_RECOG * recogaGetRecog ( L_RECOGA *recoga, l_int32 index );
         extern l_int32 recogaGetCount ( L_RECOGA *recoga );
         extern l_int32 recogGetCount ( L_RECOG *recog );
         extern l_int32 recogGetIndex ( L_RECOG *recog, l_int32 *pindex );
         extern L_RECOGA * recogGetParent ( L_RECOG *recog );
         extern l_int32 recogSetBootflag ( L_RECOG *recog );
         extern L_RECOG * recogCreateFromRecog ( L_RECOG *recs, l_int32 scalew, l_int32 scaleh, l_int32 templ_type, l_int32 threshold, l_int32 maxyshift, const char *fontdir );
         extern L_RECOG * recogCreateFromPixa ( PIXA *pixa, l_int32 scalew, l_int32 scaleh, l_int32 templ_type, l_int32 threshold, l_int32 maxyshift, const char *fontdir );
         extern L_RECOG * recogCreate ( l_int32 scalew, l_int32 scaleh, l_int32 templ_type, l_int32 threshold, l_int32 maxyshift, const char *fontdir );
         extern void recogDestroy ( L_RECOG **precog );
         extern l_int32 recogAppend ( L_RECOG *recog1, L_RECOG *recog2 );
         extern l_int32 recogGetClassIndex ( L_RECOG *recog, l_int32 val, char *text, l_int32 *pindex );
         extern l_int32 recogStringToIndex ( L_RECOG *recog, char *text, l_int32 *pindex );
         extern l_int32 recogGetClassString ( L_RECOG *recog, l_int32 index, char **pcharstr );
         extern l_int32 l_convertCharstrToInt ( const char *str, l_int32 *pval );
         extern L_RECOGA * recogaRead ( const char *filename );
         extern L_RECOGA * recogaReadStream ( FILE *fp );
         extern l_int32 recogaWrite ( const char *filename, L_RECOGA *recoga );
         extern l_int32 recogaWriteStream ( FILE *fp, L_RECOGA *recoga, const char *filename );
         extern l_int32 recogaWritePixaa ( const char *filename, L_RECOGA *recoga );
         extern L_RECOG * recogRead ( const char *filename );
         extern L_RECOG * recogReadStream ( FILE *fp );
         extern l_int32 recogWrite ( const char *filename, L_RECOG *recog );
         extern l_int32 recogWriteStream ( FILE *fp, L_RECOG *recog, const char *filename );
         extern l_int32 recogWritePixa ( const char *filename, L_RECOG *recog );
         extern l_int32 recogDecode ( L_RECOG *recog, PIX *pixs, l_int32 nlevels, PIX **ppixdb );
         extern l_int32 recogMakeDecodingArrays ( L_RECOG *recog, PIX *pixs, l_int32 debug );
         extern l_int32 recogRunViterbi ( L_RECOG *recog, PIX **ppixdb );
         extern l_int32 recogCreateDid ( L_RECOG *recog, PIX *pixs );
         extern l_int32 recogDestroyDid ( L_RECOG *recog );
         extern l_int32 recogDidExists ( L_RECOG *recog );
         extern L_RDID * recogGetDid ( L_RECOG *recog );
         extern l_int32 recogSetChannelParams ( L_RECOG *recog, l_int32 nlevels );
         extern l_int32 recogaIdentifyMultiple ( L_RECOGA *recoga, PIX *pixs, l_int32 nitems, l_int32 minw, l_int32 minh, BOXA **pboxa, PIXA **ppixa, PIX **ppixdb, l_int32 debugsplit );
         extern l_int32 recogSplitIntoCharacters ( L_RECOG *recog, PIX *pixs, l_int32 minw, l_int32 minh, BOXA **pboxa, PIXA **ppixa, NUMA **pnaid, l_int32 debug );
         extern l_int32 recogCorrelationBestRow ( L_RECOG *recog, PIX *pixs, BOXA **pboxa, NUMA **pnascore, NUMA **pnaindex, SARRAY **psachar, l_int32 debug );
         extern l_int32 recogCorrelationBestChar ( L_RECOG *recog, PIX *pixs, BOX **pbox, l_float32 *pscore, l_int32 *pindex, char **pcharstr, PIX **ppixdb );
         extern l_int32 recogaIdentifyPixa ( L_RECOGA *recoga, PIXA *pixa, NUMA *naid, PIX **ppixdb );
         extern l_int32 recogIdentifyPixa ( L_RECOG *recog, PIXA *pixa, NUMA *naid, PIX **ppixdb );
         extern l_int32 recogIdentifyPix ( L_RECOG *recog, PIX *pixs, PIX **ppixdb );
         extern l_int32 recogSkipIdentify ( L_RECOG *recog );
         extern void rchaDestroy ( L_RCHA **prcha );
         extern void rchDestroy ( L_RCH **prch );
         extern l_int32 rchaExtract ( L_RCHA *rcha, NUMA **pnaindex, NUMA **pnascore, SARRAY **psatext, NUMA **pnasample, NUMA **pnaxloc, NUMA **pnayloc, NUMA **pnawidth );
         extern l_int32 rchExtract ( L_RCH *rch, l_int32 *pindex, l_float32 *pscore, char **ptext, l_int32 *psample, l_int32 *pxloc, l_int32 *pyloc, l_int32 *pwidth );
         extern PIX * recogProcessToIdentify ( L_RECOG *recog, PIX *pixs, l_int32 pad );
         extern PIX * recogPreSplittingFilter ( L_RECOG *recog, PIX *pixs, l_float32 maxasp, l_float32 minaf, l_float32 maxaf, l_int32 debug );
         extern l_int32 recogSplittingFilter ( L_RECOG *recog, PIX *pixs, l_float32 maxasp, l_float32 minaf, l_float32 maxaf, l_int32 *premove, l_int32 debug );
         extern SARRAY * recogaExtractNumbers ( L_RECOGA *recoga, BOXA *boxas, l_float32 scorethresh, l_int32 spacethresh, BOXAA **pbaa, NUMAA **pnaa );
         extern l_int32 recogSetTemplateType ( L_RECOG *recog, l_int32 templ_type );
         extern l_int32 recogSetScaling ( L_RECOG *recog, l_int32 scalew, l_int32 scaleh );
         extern l_int32 recogTrainLabelled ( L_RECOG *recog, PIX *pixs, BOX *box, char *text, l_int32 multflag, l_int32 debug );
         extern l_int32 recogProcessMultLabelled ( L_RECOG *recog, PIX *pixs, BOX *box, char *text, PIXA **ppixa, l_int32 debug );
         extern l_int32 recogProcessSingleLabelled ( L_RECOG *recog, PIX *pixs, BOX *box, char *text, PIXA **ppixa );
         extern l_int32 recogAddSamples ( L_RECOG *recog, PIXA *pixa, l_int32 classindex, l_int32 debug );
         extern PIX * recogScaleCharacter ( L_RECOG *recog, PIX *pixs );
         extern l_int32 recogAverageSamples ( L_RECOG *recog, l_int32 debug );
         extern l_int32 pixaAccumulateSamples ( PIXA *pixa, PTA *pta, PIX **ppixd, l_float32 *px, l_float32 *py );
         extern l_int32 recogTrainingFinished ( L_RECOG *recog, l_int32 debug );
         extern l_int32 recogRemoveOutliers ( L_RECOG *recog, l_float32 targetscore, l_float32 minfract, l_int32 debug );
         extern l_int32 recogaTrainingDone ( L_RECOGA *recoga, l_int32 *pdone );
         extern l_int32 recogaFinishAveraging ( L_RECOGA *recoga );
         extern l_int32 recogTrainUnlabelled ( L_RECOG *recog, L_RECOG *recogboot, PIX *pixs, BOX *box, l_int32 singlechar, l_float32 minscore, l_int32 debug );
         extern l_int32 recogPadTrainingSet ( L_RECOG **precog, l_int32 debug );
         extern l_int32 recogBestCorrelForPadding ( L_RECOG *recog, L_RECOGA *recoga, NUMA **pnaset, NUMA **pnaindex, NUMA **pnascore, NUMA **pnasum, PIXA **ppixadb );
         extern l_int32 recogCorrelAverages ( L_RECOG *recog1, L_RECOG *recog2, NUMA **pnaindex, NUMA **pnascore, PIXA **ppixadb );
         extern l_int32 recogSetPadParams ( L_RECOG *recog, const char *bootdir, const char *bootpattern, const char *bootpath, l_int32 type, l_int32 min_nopad, l_int32 max_afterpad );
         extern l_int32 recogaShowContent ( FILE *fp, L_RECOGA *recoga, l_int32 display );
         extern l_int32 recogShowContent ( FILE *fp, L_RECOG *recog, l_int32 display );
         extern l_int32 recogDebugAverages ( L_RECOG *recog, l_int32 debug );
         extern l_int32 recogShowAverageTemplates ( L_RECOG *recog );
         extern l_int32 recogShowMatchesInRange ( L_RECOG *recog, PIXA *pixa, l_float32 minscore, l_float32 maxscore, l_int32 display );
         extern PIX * recogShowMatch ( L_RECOG *recog, PIX *pix1, PIX *pix2, BOX *box, l_int32 index, l_float32 score );
         extern l_int32 recogMakeBmf ( L_RECOG *recog, const char *fontdir, l_int32 size );
         extern l_int32 regTestSetup ( l_int32 argc, char **argv, L_REGPARAMS **prp );
         extern l_int32 regTestCleanup ( L_REGPARAMS *rp );
         extern l_int32 regTestCompareValues ( L_REGPARAMS *rp, l_float32 val1, l_float32 val2, l_float32 delta );
         extern l_int32 regTestCompareStrings ( L_REGPARAMS *rp, l_uint8 *string1, size_t bytes1, l_uint8 *string2, size_t bytes2 );
         extern l_int32 regTestComparePix ( L_REGPARAMS *rp, PIX *pix1, PIX *pix2 );
         extern l_int32 regTestCompareSimilarPix ( L_REGPARAMS *rp, PIX *pix1, PIX *pix2, l_int32 mindiff, l_float32 maxfract, l_int32 printstats );
         extern l_int32 regTestCheckFile ( L_REGPARAMS *rp, const char *localname );
         extern l_int32 regTestCompareFiles ( L_REGPARAMS *rp, l_int32 index1, l_int32 index2 );
         extern l_int32 regTestWritePixAndCheck ( L_REGPARAMS *rp, PIX *pix, l_int32 format );
         extern l_int32 pixRasterop ( PIX *pixd, l_int32 dx, l_int32 dy, l_int32 dw, l_int32 dh, l_int32 op, PIX *pixs, l_int32 sx, l_int32 sy );
         extern l_int32 pixRasteropVip ( PIX *pixd, l_int32 bx, l_int32 bw, l_int32 vshift, l_int32 incolor );
         extern l_int32 pixRasteropHip ( PIX *pixd, l_int32 by, l_int32 bh, l_int32 hshift, l_int32 incolor );
         extern PIX * pixTranslate ( PIX *pixd, PIX *pixs, l_int32 hshift, l_int32 vshift, l_int32 incolor );
         extern l_int32 pixRasteropIP ( PIX *pixd, l_int32 hshift, l_int32 vshift, l_int32 incolor );
         extern l_int32 pixRasteropFullImage ( PIX *pixd, PIX *pixs, l_int32 op );
         extern void rasteropVipLow ( l_uint32 *data, l_int32 pixw, l_int32 pixh, l_int32 depth, l_int32 wpl, l_int32 x, l_int32 w, l_int32 shift );
         extern void rasteropHipLow ( l_uint32 *data, l_int32 pixh, l_int32 depth, l_int32 wpl, l_int32 y, l_int32 h, l_int32 shift );
         extern void shiftDataHorizontalLow ( l_uint32 *datad, l_int32 wpld, l_uint32 *datas, l_int32 wpls, l_int32 shift );
         extern void rasteropUniLow ( l_uint32 *datad, l_int32 dpixw, l_int32 dpixh, l_int32 depth, l_int32 dwpl, l_int32 dx, l_int32 dy, l_int32 dw, l_int32 dh, l_int32 op );
         extern void rasteropLow ( l_uint32 *datad, l_int32 dpixw, l_int32 dpixh, l_int32 depth, l_int32 dwpl, l_int32 dx, l_int32 dy, l_int32 dw, l_int32 dh, l_int32 op, l_uint32 *datas, l_int32 spixw, l_int32 spixh, l_int32 swpl, l_int32 sx, l_int32 sy );
         extern PIX * pixRotate ( PIX *pixs, l_float32 angle, l_int32 type, l_int32 incolor, l_int32 width, l_int32 height );
         extern PIX * pixEmbedForRotation ( PIX *pixs, l_float32 angle, l_int32 incolor, l_int32 width, l_int32 height );
         extern PIX * pixRotateBySampling ( PIX *pixs, l_int32 xcen, l_int32 ycen, l_float32 angle, l_int32 incolor );
         extern PIX * pixRotateBinaryNice ( PIX *pixs, l_float32 angle, l_int32 incolor );
         extern PIX * pixRotateWithAlpha ( PIX *pixs, l_float32 angle, PIX *pixg, l_float32 fract );
         extern PIX * pixRotateAM ( PIX *pixs, l_float32 angle, l_int32 incolor );
         extern PIX * pixRotateAMColor ( PIX *pixs, l_float32 angle, l_uint32 colorval );
         extern PIX * pixRotateAMGray ( PIX *pixs, l_float32 angle, l_uint8 grayval );
         extern PIX * pixRotateAMCorner ( PIX *pixs, l_float32 angle, l_int32 incolor );
         extern PIX * pixRotateAMColorCorner ( PIX *pixs, l_float32 angle, l_uint32 fillval );
         extern PIX * pixRotateAMGrayCorner ( PIX *pixs, l_float32 angle, l_uint8 grayval );
         extern PIX * pixRotateAMColorFast ( PIX *pixs, l_float32 angle, l_uint32 colorval );
         extern void rotateAMColorLow ( l_uint32 *datad, l_int32 w, l_int32 h, l_int32 wpld, l_uint32 *datas, l_int32 wpls, l_float32 angle, l_uint32 colorval );
         extern void rotateAMGrayLow ( l_uint32 *datad, l_int32 w, l_int32 h, l_int32 wpld, l_uint32 *datas, l_int32 wpls, l_float32 angle, l_uint8 grayval );
         extern void rotateAMColorCornerLow ( l_uint32 *datad, l_int32 w, l_int32 h, l_int32 wpld, l_uint32 *datas, l_int32 wpls, l_float32 angle, l_uint32 colorval );
         extern void rotateAMGrayCornerLow ( l_uint32 *datad, l_int32 w, l_int32 h, l_int32 wpld, l_uint32 *datas, l_int32 wpls, l_float32 angle, l_uint8 grayval );
         extern void rotateAMColorFastLow ( l_uint32 *datad, l_int32 w, l_int32 h, l_int32 wpld, l_uint32 *datas, l_int32 wpls, l_float32 angle, l_uint32 colorval );
         extern PIX * pixRotateOrth ( PIX *pixs, l_int32 quads );
         extern PIX * pixRotate180 ( PIX *pixd, PIX *pixs );
         extern PIX * pixRotate90 ( PIX *pixs, l_int32 direction );
         extern PIX * pixFlipLR ( PIX *pixd, PIX *pixs );
         extern PIX * pixFlipTB ( PIX *pixd, PIX *pixs );
         extern PIX * pixRotateShear ( PIX *pixs, l_int32 xcen, l_int32 ycen, l_float32 angle, l_int32 incolor );
         extern PIX * pixRotate2Shear ( PIX *pixs, l_int32 xcen, l_int32 ycen, l_float32 angle, l_int32 incolor );
         extern PIX * pixRotate3Shear ( PIX *pixs, l_int32 xcen, l_int32 ycen, l_float32 angle, l_int32 incolor );
         extern l_int32 pixRotateShearIP ( PIX *pixs, l_int32 xcen, l_int32 ycen, l_float32 angle, l_int32 incolor );
         extern PIX * pixRotateShearCenter ( PIX *pixs, l_float32 angle, l_int32 incolor );
         extern l_int32 pixRotateShearCenterIP ( PIX *pixs, l_float32 angle, l_int32 incolor );
         extern PIX * pixStrokeWidthTransform ( PIX *pixs, l_int32 color, l_int32 depth, l_int32 nangles );
         extern PIX * pixRunlengthTransform ( PIX *pixs, l_int32 color, l_int32 direction, l_int32 depth );
         extern l_int32 pixFindHorizontalRuns ( PIX *pix, l_int32 y, l_int32 *xstart, l_int32 *xend, l_int32 *pn );
         extern l_int32 pixFindVerticalRuns ( PIX *pix, l_int32 x, l_int32 *ystart, l_int32 *yend, l_int32 *pn );
         extern NUMA * pixFindMaxRuns ( PIX *pix, l_int32 direction, NUMA **pnastart );
         extern l_int32 pixFindMaxHorizontalRunOnLine ( PIX *pix, l_int32 y, l_int32 *pxstart, l_int32 *psize );
         extern l_int32 pixFindMaxVerticalRunOnLine ( PIX *pix, l_int32 x, l_int32 *pystart, l_int32 *psize );
         extern l_int32 runlengthMembershipOnLine ( l_int32 *buffer, l_int32 size, l_int32 depth, l_int32 *start, l_int32 *end, l_int32 n );
         extern l_int32 * makeMSBitLocTab ( l_int32 bitval );
         extern SARRAY * sarrayCreate ( l_int32 n );
         extern SARRAY * sarrayCreateInitialized ( l_int32 n, char *initstr );
         extern SARRAY * sarrayCreateWordsFromString ( const char *string );
         extern SARRAY * sarrayCreateLinesFromString ( char *string, l_int32 blankflag );
         extern void sarrayDestroy ( SARRAY **psa );
         extern SARRAY * sarrayCopy ( SARRAY *sa );
         extern SARRAY * sarrayClone ( SARRAY *sa );
         extern l_int32 sarrayAddString ( SARRAY *sa, char *string, l_int32 copyflag );
         extern char * sarrayRemoveString ( SARRAY *sa, l_int32 index );
         extern l_int32 sarrayReplaceString ( SARRAY *sa, l_int32 index, char *newstr, l_int32 copyflag );
         extern l_int32 sarrayClear ( SARRAY *sa );
         extern l_int32 sarrayGetCount ( SARRAY *sa );
         extern char ** sarrayGetArray ( SARRAY *sa, l_int32 *pnalloc, l_int32 *pn );
         extern char * sarrayGetString ( SARRAY *sa, l_int32 index, l_int32 copyflag );
         extern l_int32 sarrayGetRefcount ( SARRAY *sa );
         extern l_int32 sarrayChangeRefcount ( SARRAY *sa, l_int32 delta );
         extern char * sarrayToString ( SARRAY *sa, l_int32 addnlflag );
         extern char * sarrayToStringRange ( SARRAY *sa, l_int32 first, l_int32 nstrings, l_int32 addnlflag );
         extern l_int32 sarrayConcatenate ( SARRAY *sa1, SARRAY *sa2 );
         extern l_int32 sarrayAppendRange ( SARRAY *sa1, SARRAY *sa2, l_int32 start, l_int32 end );
         extern l_int32 sarrayPadToSameSize ( SARRAY *sa1, SARRAY *sa2, char *padstring );
         extern SARRAY * sarrayConvertWordsToLines ( SARRAY *sa, l_int32 linesize );
         extern l_int32 sarraySplitString ( SARRAY *sa, const char *str, const char *separators );
         extern SARRAY * sarraySelectBySubstring ( SARRAY *sain, const char *substr );
         extern SARRAY * sarraySelectByRange ( SARRAY *sain, l_int32 first, l_int32 last );
         extern l_int32 sarrayParseRange ( SARRAY *sa, l_int32 start, l_int32 *pactualstart, l_int32 *pend, l_int32 *pnewstart, const char *substr, l_int32 loc );
         extern SARRAY * sarraySort ( SARRAY *saout, SARRAY *sain, l_int32 sortorder );
         extern SARRAY * sarraySortByIndex ( SARRAY *sain, NUMA *naindex );
         extern l_int32 stringCompareLexical ( const char *str1, const char *str2 );
         extern SARRAY * sarrayRead ( const char *filename );
         extern SARRAY * sarrayReadStream ( FILE *fp );
         extern l_int32 sarrayWrite ( const char *filename, SARRAY *sa );
         extern l_int32 sarrayWriteStream ( FILE *fp, SARRAY *sa );
         extern l_int32 sarrayAppend ( const char *filename, SARRAY *sa );
         extern SARRAY * getNumberedPathnamesInDirectory ( const char *dirname, const char *substr, l_int32 numpre, l_int32 numpost, l_int32 maxnum );
         extern SARRAY * getSortedPathnamesInDirectory ( const char *dirname, const char *substr, l_int32 first, l_int32 nfiles );
         extern SARRAY * convertSortedToNumberedPathnames ( SARRAY *sa, l_int32 numpre, l_int32 numpost, l_int32 maxnum );
         extern SARRAY * getFilenamesInDirectory ( const char *dirname );
         extern PIX * pixScale ( PIX *pixs, l_float32 scalex, l_float32 scaley );
         extern PIX * pixScaleToSize ( PIX *pixs, l_int32 wd, l_int32 hd );
         extern PIX * pixScaleGeneral ( PIX *pixs, l_float32 scalex, l_float32 scaley, l_float32 sharpfract, l_int32 sharpwidth );
         extern PIX * pixScaleLI ( PIX *pixs, l_float32 scalex, l_float32 scaley );
         extern PIX * pixScaleColorLI ( PIX *pixs, l_float32 scalex, l_float32 scaley );
         extern PIX * pixScaleColor2xLI ( PIX *pixs );
         extern PIX * pixScaleColor4xLI ( PIX *pixs );
         extern PIX * pixScaleGrayLI ( PIX *pixs, l_float32 scalex, l_float32 scaley );
         extern PIX * pixScaleGray2xLI ( PIX *pixs );
         extern PIX * pixScaleGray4xLI ( PIX *pixs );
         extern PIX * pixScaleBySampling ( PIX *pixs, l_float32 scalex, l_float32 scaley );
         extern PIX * pixScaleBySamplingToSize ( PIX *pixs, l_int32 wd, l_int32 hd );
         extern PIX * pixScaleByIntSampling ( PIX *pixs, l_int32 factor );
         extern PIX * pixScaleRGBToGrayFast ( PIX *pixs, l_int32 factor, l_int32 color );
         extern PIX * pixScaleRGBToBinaryFast ( PIX *pixs, l_int32 factor, l_int32 thresh );
         extern PIX * pixScaleGrayToBinaryFast ( PIX *pixs, l_int32 factor, l_int32 thresh );
         extern PIX * pixScaleSmooth ( PIX *pix, l_float32 scalex, l_float32 scaley );
         extern PIX * pixScaleRGBToGray2 ( PIX *pixs, l_float32 rwt, l_float32 gwt, l_float32 bwt );
         extern PIX * pixScaleAreaMap ( PIX *pix, l_float32 scalex, l_float32 scaley );
         extern PIX * pixScaleAreaMap2 ( PIX *pix );
         extern PIX * pixScaleBinary ( PIX *pixs, l_float32 scalex, l_float32 scaley );
         extern PIX * pixScaleToGray ( PIX *pixs, l_float32 scalefactor );
         extern PIX * pixScaleToGrayFast ( PIX *pixs, l_float32 scalefactor );
         extern PIX * pixScaleToGray2 ( PIX *pixs );
         extern PIX * pixScaleToGray3 ( PIX *pixs );
         extern PIX * pixScaleToGray4 ( PIX *pixs );
         extern PIX * pixScaleToGray6 ( PIX *pixs );
         extern PIX * pixScaleToGray8 ( PIX *pixs );
         extern PIX * pixScaleToGray16 ( PIX *pixs );
         extern PIX * pixScaleToGrayMipmap ( PIX *pixs, l_float32 scalefactor );
         extern PIX * pixScaleMipmap ( PIX *pixs1, PIX *pixs2, l_float32 scale );
         extern PIX * pixExpandReplicate ( PIX *pixs, l_int32 factor );
         extern PIX * pixScaleGray2xLIThresh ( PIX *pixs, l_int32 thresh );
         extern PIX * pixScaleGray2xLIDither ( PIX *pixs );
         extern PIX * pixScaleGray4xLIThresh ( PIX *pixs, l_int32 thresh );
         extern PIX * pixScaleGray4xLIDither ( PIX *pixs );
         extern PIX * pixScaleGrayMinMax ( PIX *pixs, l_int32 xfact, l_int32 yfact, l_int32 type );
         extern PIX * pixScaleGrayMinMax2 ( PIX *pixs, l_int32 type );
         extern PIX * pixScaleGrayRankCascade ( PIX *pixs, l_int32 level1, l_int32 level2, l_int32 level3, l_int32 level4 );
         extern PIX * pixScaleGrayRank2 ( PIX *pixs, l_int32 rank );
         extern l_int32 pixScaleAndTransferAlpha ( PIX *pixd, PIX *pixs, l_float32 scalex, l_float32 scaley );
         extern PIX * pixScaleWithAlpha ( PIX *pixs, l_float32 scalex, l_float32 scaley, PIX *pixg, l_float32 fract );
         extern void scaleColorLILow ( l_uint32 *datad, l_int32 wd, l_int32 hd, l_int32 wpld, l_uint32 *datas, l_int32 ws, l_int32 hs, l_int32 wpls );
         extern void scaleGrayLILow ( l_uint32 *datad, l_int32 wd, l_int32 hd, l_int32 wpld, l_uint32 *datas, l_int32 ws, l_int32 hs, l_int32 wpls );
         extern void scaleColor2xLILow ( l_uint32 *datad, l_int32 wpld, l_uint32 *datas, l_int32 ws, l_int32 hs, l_int32 wpls );
         extern void scaleColor2xLILineLow ( l_uint32 *lined, l_int32 wpld, l_uint32 *lines, l_int32 ws, l_int32 wpls, l_int32 lastlineflag );
         extern void scaleGray2xLILow ( l_uint32 *datad, l_int32 wpld, l_uint32 *datas, l_int32 ws, l_int32 hs, l_int32 wpls );
         extern void scaleGray2xLILineLow ( l_uint32 *lined, l_int32 wpld, l_uint32 *lines, l_int32 ws, l_int32 wpls, l_int32 lastlineflag );
         extern void scaleGray4xLILow ( l_uint32 *datad, l_int32 wpld, l_uint32 *datas, l_int32 ws, l_int32 hs, l_int32 wpls );
         extern void scaleGray4xLILineLow ( l_uint32 *lined, l_int32 wpld, l_uint32 *lines, l_int32 ws, l_int32 wpls, l_int32 lastlineflag );
         extern l_int32 scaleBySamplingLow ( l_uint32 *datad, l_int32 wd, l_int32 hd, l_int32 wpld, l_uint32 *datas, l_int32 ws, l_int32 hs, l_int32 d, l_int32 wpls );
         extern l_int32 scaleSmoothLow ( l_uint32 *datad, l_int32 wd, l_int32 hd, l_int32 wpld, l_uint32 *datas, l_int32 ws, l_int32 hs, l_int32 d, l_int32 wpls, l_int32 size );
         extern void scaleRGBToGray2Low ( l_uint32 *datad, l_int32 wd, l_int32 hd, l_int32 wpld, l_uint32 *datas, l_int32 wpls, l_float32 rwt, l_float32 gwt, l_float32 bwt );
         extern void scaleColorAreaMapLow ( l_uint32 *datad, l_int32 wd, l_int32 hd, l_int32 wpld, l_uint32 *datas, l_int32 ws, l_int32 hs, l_int32 wpls );
         extern void scaleGrayAreaMapLow ( l_uint32 *datad, l_int32 wd, l_int32 hd, l_int32 wpld, l_uint32 *datas, l_int32 ws, l_int32 hs, l_int32 wpls );
         extern void scaleAreaMapLow2 ( l_uint32 *datad, l_int32 wd, l_int32 hd, l_int32 wpld, l_uint32 *datas, l_int32 d, l_int32 wpls );
         extern l_int32 scaleBinaryLow ( l_uint32 *datad, l_int32 wd, l_int32 hd, l_int32 wpld, l_uint32 *datas, l_int32 ws, l_int32 hs, l_int32 wpls );
         extern void scaleToGray2Low ( l_uint32 *datad, l_int32 wd, l_int32 hd, l_int32 wpld, l_uint32 *datas, l_int32 wpls, l_uint32 *sumtab, l_uint8 *valtab );
         extern l_uint32 * makeSumTabSG2 ( void );
         extern l_uint8 * makeValTabSG2 ( void );
         extern void scaleToGray3Low ( l_uint32 *datad, l_int32 wd, l_int32 hd, l_int32 wpld, l_uint32 *datas, l_int32 wpls, l_uint32 *sumtab, l_uint8 *valtab );
         extern l_uint32 * makeSumTabSG3 ( void );
         extern l_uint8 * makeValTabSG3 ( void );
         extern void scaleToGray4Low ( l_uint32 *datad, l_int32 wd, l_int32 hd, l_int32 wpld, l_uint32 *datas, l_int32 wpls, l_uint32 *sumtab, l_uint8 *valtab );
         extern l_uint32 * makeSumTabSG4 ( void );
         extern l_uint8 * makeValTabSG4 ( void );
         extern void scaleToGray6Low ( l_uint32 *datad, l_int32 wd, l_int32 hd, l_int32 wpld, l_uint32 *datas, l_int32 wpls, l_int32 *tab8, l_uint8 *valtab );
         extern l_uint8 * makeValTabSG6 ( void );
         extern void scaleToGray8Low ( l_uint32 *datad, l_int32 wd, l_int32 hd, l_int32 wpld, l_uint32 *datas, l_int32 wpls, l_int32 *tab8, l_uint8 *valtab );
         extern l_uint8 * makeValTabSG8 ( void );
         extern void scaleToGray16Low ( l_uint32 *datad, l_int32 wd, l_int32 hd, l_int32 wpld, l_uint32 *datas, l_int32 wpls, l_int32 *tab8 );
         extern l_int32 scaleMipmapLow ( l_uint32 *datad, l_int32 wd, l_int32 hd, l_int32 wpld, l_uint32 *datas1, l_int32 wpls1, l_uint32 *datas2, l_int32 wpls2, l_float32 red );
         extern PIX * pixSeedfillBinary ( PIX *pixd, PIX *pixs, PIX *pixm, l_int32 connectivity );
         extern PIX * pixSeedfillBinaryRestricted ( PIX *pixd, PIX *pixs, PIX *pixm, l_int32 connectivity, l_int32 xmax, l_int32 ymax );
         extern PIX * pixHolesByFilling ( PIX *pixs, l_int32 connectivity );
         extern PIX * pixFillClosedBorders ( PIX *pixs, l_int32 connectivity );
         extern PIX * pixExtractBorderConnComps ( PIX *pixs, l_int32 connectivity );
         extern PIX * pixRemoveBorderConnComps ( PIX *pixs, l_int32 connectivity );
         extern PIX * pixFillBgFromBorder ( PIX *pixs, l_int32 connectivity );
         extern PIX * pixFillHolesToBoundingRect ( PIX *pixs, l_int32 minsize, l_float32 maxhfract, l_float32 minfgfract );
         extern l_int32 pixSeedfillGray ( PIX *pixs, PIX *pixm, l_int32 connectivity );
         extern l_int32 pixSeedfillGrayInv ( PIX *pixs, PIX *pixm, l_int32 connectivity );
         extern l_int32 pixSeedfillGraySimple ( PIX *pixs, PIX *pixm, l_int32 connectivity );
         extern l_int32 pixSeedfillGrayInvSimple ( PIX *pixs, PIX *pixm, l_int32 connectivity );
         extern PIX * pixSeedfillGrayBasin ( PIX *pixb, PIX *pixm, l_int32 delta, l_int32 connectivity );
         extern PIX * pixDistanceFunction ( PIX *pixs, l_int32 connectivity, l_int32 outdepth, l_int32 boundcond );
         extern PIX * pixSeedspread ( PIX *pixs, l_int32 connectivity );
         extern l_int32 pixLocalExtrema ( PIX *pixs, l_int32 maxmin, l_int32 minmax, PIX **ppixmin, PIX **ppixmax );
         extern l_int32 pixSelectedLocalExtrema ( PIX *pixs, l_int32 mindist, PIX **ppixmin, PIX **ppixmax );
         extern PIX * pixFindEqualValues ( PIX *pixs1, PIX *pixs2 );
         extern l_int32 pixSelectMinInConnComp ( PIX *pixs, PIX *pixm, PTA **ppta, NUMA **pnav );
         extern PIX * pixRemoveSeededComponents ( PIX *pixd, PIX *pixs, PIX *pixm, l_int32 connectivity, l_int32 bordersize );
         extern void seedfillBinaryLow ( l_uint32 *datas, l_int32 hs, l_int32 wpls, l_uint32 *datam, l_int32 hm, l_int32 wplm, l_int32 connectivity );
         extern void seedfillGrayLow ( l_uint32 *datas, l_int32 w, l_int32 h, l_int32 wpls, l_uint32 *datam, l_int32 wplm, l_int32 connectivity );
         extern void seedfillGrayInvLow ( l_uint32 *datas, l_int32 w, l_int32 h, l_int32 wpls, l_uint32 *datam, l_int32 wplm, l_int32 connectivity );
         extern void seedfillGrayLowSimple ( l_uint32 *datas, l_int32 w, l_int32 h, l_int32 wpls, l_uint32 *datam, l_int32 wplm, l_int32 connectivity );
         extern void seedfillGrayInvLowSimple ( l_uint32 *datas, l_int32 w, l_int32 h, l_int32 wpls, l_uint32 *datam, l_int32 wplm, l_int32 connectivity );
         extern void distanceFunctionLow ( l_uint32 *datad, l_int32 w, l_int32 h, l_int32 d, l_int32 wpld, l_int32 connectivity );
         extern void seedspreadLow ( l_uint32 *datad, l_int32 w, l_int32 h, l_int32 wpld, l_uint32 *datat, l_int32 wplt, l_int32 connectivity );
         extern SELA * selaCreate ( l_int32 n );
         extern void selaDestroy ( SELA **psela );
         extern SEL * selCreate ( l_int32 height, l_int32 width, const char *name );
         extern void selDestroy ( SEL **psel );
         extern SEL * selCopy ( SEL *sel );
         extern SEL * selCreateBrick ( l_int32 h, l_int32 w, l_int32 cy, l_int32 cx, l_int32 type );
         extern SEL * selCreateComb ( l_int32 factor1, l_int32 factor2, l_int32 direction );
         extern l_int32 ** create2dIntArray ( l_int32 sy, l_int32 sx );
         extern l_int32 selaAddSel ( SELA *sela, SEL *sel, const char *selname, l_int32 copyflag );
         extern l_int32 selaGetCount ( SELA *sela );
         extern SEL * selaGetSel ( SELA *sela, l_int32 i );
         extern char * selGetName ( SEL *sel );
         extern l_int32 selSetName ( SEL *sel, const char *name );
         extern l_int32 selaFindSelByName ( SELA *sela, const char *name, l_int32 *pindex, SEL **psel );
         extern l_int32 selGetElement ( SEL *sel, l_int32 row, l_int32 col, l_int32 *ptype );
         extern l_int32 selSetElement ( SEL *sel, l_int32 row, l_int32 col, l_int32 type );
         extern l_int32 selGetParameters ( SEL *sel, l_int32 *psy, l_int32 *psx, l_int32 *pcy, l_int32 *pcx );
         extern l_int32 selSetOrigin ( SEL *sel, l_int32 cy, l_int32 cx );
         extern l_int32 selGetTypeAtOrigin ( SEL *sel, l_int32 *ptype );
         extern char * selaGetBrickName ( SELA *sela, l_int32 hsize, l_int32 vsize );
         extern char * selaGetCombName ( SELA *sela, l_int32 size, l_int32 direction );
         extern l_int32 getCompositeParameters ( l_int32 size, l_int32 *psize1, l_int32 *psize2, char **pnameh1, char **pnameh2, char **pnamev1, char **pnamev2 );
         extern SARRAY * selaGetSelnames ( SELA *sela );
         extern l_int32 selFindMaxTranslations ( SEL *sel, l_int32 *pxp, l_int32 *pyp, l_int32 *pxn, l_int32 *pyn );
         extern SEL * selRotateOrth ( SEL *sel, l_int32 quads );
         extern SELA * selaRead ( const char *fname );
         extern SELA * selaReadStream ( FILE *fp );
         extern SEL * selRead ( const char *fname );
         extern SEL * selReadStream ( FILE *fp );
         extern l_int32 selaWrite ( const char *fname, SELA *sela );
         extern l_int32 selaWriteStream ( FILE *fp, SELA *sela );
         extern l_int32 selWrite ( const char *fname, SEL *sel );
         extern l_int32 selWriteStream ( FILE *fp, SEL *sel );
         extern SEL * selCreateFromString ( const char *text, l_int32 h, l_int32 w, const char *name );
         extern char * selPrintToString ( SEL *sel );
         extern SELA * selaCreateFromFile ( const char *filename );
         extern SEL * selCreateFromPta ( PTA *pta, l_int32 cy, l_int32 cx, const char *name );
         extern SEL * selCreateFromPix ( PIX *pix, l_int32 cy, l_int32 cx, const char *name );
         extern SEL * selReadFromColorImage ( const char *pathname );
         extern SEL * selCreateFromColorPix ( PIX *pixs, char *selname );
         extern PIX * selDisplayInPix ( SEL *sel, l_int32 size, l_int32 gthick );
         extern PIX * selaDisplayInPix ( SELA *sela, l_int32 size, l_int32 gthick, l_int32 spacing, l_int32 ncols );
         extern SELA * selaAddBasic ( SELA *sela );
         extern SELA * selaAddHitMiss ( SELA *sela );
         extern SELA * selaAddDwaLinear ( SELA *sela );
         extern SELA * selaAddDwaCombs ( SELA *sela );
         extern SELA * selaAddCrossJunctions ( SELA *sela, l_float32 hlsize, l_float32 mdist, l_int32 norient, l_int32 debugflag );
         extern SELA * selaAddTJunctions ( SELA *sela, l_float32 hlsize, l_float32 mdist, l_int32 norient, l_int32 debugflag );
         extern SEL * pixGenerateSelWithRuns ( PIX *pixs, l_int32 nhlines, l_int32 nvlines, l_int32 distance, l_int32 minlength, l_int32 toppix, l_int32 botpix, l_int32 leftpix, l_int32 rightpix, PIX **ppixe );
         extern SEL * pixGenerateSelRandom ( PIX *pixs, l_float32 hitfract, l_float32 missfract, l_int32 distance, l_int32 toppix, l_int32 botpix, l_int32 leftpix, l_int32 rightpix, PIX **ppixe );
         extern SEL * pixGenerateSelBoundary ( PIX *pixs, l_int32 hitdist, l_int32 missdist, l_int32 hitskip, l_int32 missskip, l_int32 topflag, l_int32 botflag, l_int32 leftflag, l_int32 rightflag, PIX **ppixe );
         extern NUMA * pixGetRunCentersOnLine ( PIX *pixs, l_int32 x, l_int32 y, l_int32 minlength );
         extern NUMA * pixGetRunsOnLine ( PIX *pixs, l_int32 x1, l_int32 y1, l_int32 x2, l_int32 y2 );
         extern PTA * pixSubsampleBoundaryPixels ( PIX *pixs, l_int32 skip );
         extern l_int32 adjacentOnPixelInRaster ( PIX *pixs, l_int32 x, l_int32 y, l_int32 *pxa, l_int32 *pya );
         extern PIX * pixDisplayHitMissSel ( PIX *pixs, SEL *sel, l_int32 scalefactor, l_uint32 hitcolor, l_uint32 misscolor );
         extern PIX * pixHShear ( PIX *pixd, PIX *pixs, l_int32 yloc, l_float32 radang, l_int32 incolor );
         extern PIX * pixVShear ( PIX *pixd, PIX *pixs, l_int32 xloc, l_float32 radang, l_int32 incolor );
         extern PIX * pixHShearCorner ( PIX *pixd, PIX *pixs, l_float32 radang, l_int32 incolor );
         extern PIX * pixVShearCorner ( PIX *pixd, PIX *pixs, l_float32 radang, l_int32 incolor );
         extern PIX * pixHShearCenter ( PIX *pixd, PIX *pixs, l_float32 radang, l_int32 incolor );
         extern PIX * pixVShearCenter ( PIX *pixd, PIX *pixs, l_float32 radang, l_int32 incolor );
         extern l_int32 pixHShearIP ( PIX *pixs, l_int32 yloc, l_float32 radang, l_int32 incolor );
         extern l_int32 pixVShearIP ( PIX *pixs, l_int32 xloc, l_float32 radang, l_int32 incolor );
         extern PIX * pixHShearLI ( PIX *pixs, l_int32 yloc, l_float32 radang, l_int32 incolor );
         extern PIX * pixVShearLI ( PIX *pixs, l_int32 xloc, l_float32 radang, l_int32 incolor );
         extern PIX * pixDeskew ( PIX *pixs, l_int32 redsearch );
         extern PIX * pixFindSkewAndDeskew ( PIX *pixs, l_int32 redsearch, l_float32 *pangle, l_float32 *pconf );
         extern PIX * pixDeskewGeneral ( PIX *pixs, l_int32 redsweep, l_float32 sweeprange, l_float32 sweepdelta, l_int32 redsearch, l_int32 thresh, l_float32 *pangle, l_float32 *pconf );
         extern l_int32 pixFindSkew ( PIX *pixs, l_float32 *pangle, l_float32 *pconf );
         extern l_int32 pixFindSkewSweep ( PIX *pixs, l_float32 *pangle, l_int32 reduction, l_float32 sweeprange, l_float32 sweepdelta );
         extern l_int32 pixFindSkewSweepAndSearch ( PIX *pixs, l_float32 *pangle, l_float32 *pconf, l_int32 redsweep, l_int32 redsearch, l_float32 sweeprange, l_float32 sweepdelta, l_float32 minbsdelta );
         extern l_int32 pixFindSkewSweepAndSearchScore ( PIX *pixs, l_float32 *pangle, l_float32 *pconf, l_float32 *pendscore, l_int32 redsweep, l_int32 redsearch, l_float32 sweepcenter, l_float32 sweeprange, l_float32 sweepdelta, l_float32 minbsdelta );
         extern l_int32 pixFindSkewSweepAndSearchScorePivot ( PIX *pixs, l_float32 *pangle, l_float32 *pconf, l_float32 *pendscore, l_int32 redsweep, l_int32 redsearch, l_float32 sweepcenter, l_float32 sweeprange, l_float32 sweepdelta, l_float32 minbsdelta, l_int32 pivot );
         extern l_int32 pixFindSkewOrthogonalRange ( PIX *pixs, l_float32 *pangle, l_float32 *pconf, l_int32 redsweep, l_int32 redsearch, l_float32 sweeprange, l_float32 sweepdelta, l_float32 minbsdelta, l_float32 confprior );
         extern l_int32 pixFindDifferentialSquareSum ( PIX *pixs, l_float32 *psum );
         extern l_int32 pixFindNormalizedSquareSum ( PIX *pixs, l_float32 *phratio, l_float32 *pvratio, l_float32 *pfract );
         extern PIX * pixReadStreamSpix ( FILE *fp );
         extern l_int32 readHeaderSpix ( const char *filename, l_int32 *pwidth, l_int32 *pheight, l_int32 *pbps, l_int32 *pspp, l_int32 *piscmap );
         extern l_int32 freadHeaderSpix ( FILE *fp, l_int32 *pwidth, l_int32 *pheight, l_int32 *pbps, l_int32 *pspp, l_int32 *piscmap );
         extern l_int32 sreadHeaderSpix ( const l_uint32 *data, l_int32 *pwidth, l_int32 *pheight, l_int32 *pbps, l_int32 *pspp, l_int32 *piscmap );
         extern l_int32 pixWriteStreamSpix ( FILE *fp, PIX *pix );
         extern PIX * pixReadMemSpix ( const l_uint8 *data, size_t size );
         extern l_int32 pixWriteMemSpix ( l_uint8 **pdata, size_t *psize, PIX *pix );
         extern l_int32 pixSerializeToMemory ( PIX *pixs, l_uint32 **pdata, size_t *pnbytes );
         extern PIX * pixDeserializeFromMemory ( const l_uint32 *data, size_t nbytes );
         extern L_STACK * lstackCreate ( l_int32 nalloc );
         extern void lstackDestroy ( L_STACK **plstack, l_int32 freeflag );
         extern l_int32 lstackAdd ( L_STACK *lstack, void *item );
         extern void * lstackRemove ( L_STACK *lstack );
         extern l_int32 lstackGetCount ( L_STACK *lstack );
         extern l_int32 lstackPrint ( FILE *fp, L_STACK *lstack );
         extern l_int32 * sudokuReadFile ( const char *filename );
         extern l_int32 * sudokuReadString ( const char *str );
         extern L_SUDOKU * sudokuCreate ( l_int32 *array );
         extern void sudokuDestroy ( L_SUDOKU **psud );
         extern l_int32 sudokuSolve ( L_SUDOKU *sud );
         extern l_int32 sudokuTestUniqueness ( l_int32 *array, l_int32 *punique );
         extern L_SUDOKU * sudokuGenerate ( l_int32 *array, l_int32 seed, l_int32 minelems, l_int32 maxtries );
         extern l_int32 sudokuOutput ( L_SUDOKU *sud, l_int32 arraytype );
         extern PIX * pixAddSingleTextblock ( PIX *pixs, L_BMF *bmf, const char *textstr, l_uint32 val, l_int32 location, l_int32 *poverflow );
         extern PIX * pixAddSingleTextline ( PIX *pixs, L_BMF *bmf, const char *textstr, l_uint32 val, l_int32 location );
         extern l_int32 pixSetTextblock ( PIX *pixs, L_BMF *bmf, const char *textstr, l_uint32 val, l_int32 x0, l_int32 y0, l_int32 wtext, l_int32 firstindent, l_int32 *poverflow );
         extern l_int32 pixSetTextline ( PIX *pixs, L_BMF *bmf, const char *textstr, l_uint32 val, l_int32 x0, l_int32 y0, l_int32 *pwidth, l_int32 *poverflow );
         extern PIXA * pixaAddTextNumber ( PIXA *pixas, L_BMF *bmf, NUMA *na, l_uint32 val, l_int32 location );
         extern PIXA * pixaAddTextline ( PIXA *pixas, L_BMF *bmf, SARRAY *sa, l_uint32 val, l_int32 location );
         extern SARRAY * bmfGetLineStrings ( L_BMF *bmf, const char *textstr, l_int32 maxw, l_int32 firstindent, l_int32 *ph );
         extern NUMA * bmfGetWordWidths ( L_BMF *bmf, const char *textstr, SARRAY *sa );
         extern l_int32 bmfGetStringWidth ( L_BMF *bmf, const char *textstr, l_int32 *pw );
         extern SARRAY * splitStringToParagraphs ( char *textstr, l_int32 splitflag );
         extern PIX * pixReadTiff ( const char *filename, l_int32 n );
         extern PIX * pixReadStreamTiff ( FILE *fp, l_int32 n );
         extern l_int32 pixWriteTiff ( const char *filename, PIX *pix, l_int32 comptype, const char *modestring );
         extern l_int32 pixWriteTiffCustom ( const char *filename, PIX *pix, l_int32 comptype, const char *modestring, NUMA *natags, SARRAY *savals, SARRAY *satypes, NUMA *nasizes );
         extern l_int32 pixWriteStreamTiff ( FILE *fp, PIX *pix, l_int32 comptype );
         extern PIXA * pixaReadMultipageTiff ( const char *filename );
         extern l_int32 writeMultipageTiff ( const char *dirin, const char *substr, const char *fileout );
         extern l_int32 writeMultipageTiffSA ( SARRAY *sa, const char *fileout );
         extern l_int32 fprintTiffInfo ( FILE *fpout, const char *tiffile );
         extern l_int32 tiffGetCount ( FILE *fp, l_int32 *pn );
         extern l_int32 getTiffResolution ( FILE *fp, l_int32 *pxres, l_int32 *pyres );
         extern l_int32 readHeaderTiff ( const char *filename, l_int32 n, l_int32 *pwidth, l_int32 *pheight, l_int32 *pbps, l_int32 *pspp, l_int32 *pres, l_int32 *pcmap, l_int32 *pformat );
         extern l_int32 freadHeaderTiff ( FILE *fp, l_int32 n, l_int32 *pwidth, l_int32 *pheight, l_int32 *pbps, l_int32 *pspp, l_int32 *pres, l_int32 *pcmap, l_int32 *pformat );
         extern l_int32 readHeaderMemTiff ( const l_uint8 *cdata, size_t size, l_int32 n, l_int32 *pwidth, l_int32 *pheight, l_int32 *pbps, l_int32 *pspp, l_int32 *pres, l_int32 *pcmap, l_int32 *pformat );
         extern l_int32 findTiffCompression ( FILE *fp, l_int32 *pcomptype );
         extern l_int32 extractG4DataFromFile ( const char *filein, l_uint8 **pdata, size_t *pnbytes, l_int32 *pw, l_int32 *ph, l_int32 *pminisblack );
         extern PIX * pixReadMemTiff ( const l_uint8 *cdata, size_t size, l_int32 n );
         extern l_int32 pixWriteMemTiff ( l_uint8 **pdata, size_t *psize, PIX *pix, l_int32 comptype );
         extern l_int32 pixWriteMemTiffCustom ( l_uint8 **pdata, size_t *psize, PIX *pix, l_int32 comptype, NUMA *natags, SARRAY *savals, SARRAY *satypes, NUMA *nasizes );
         extern l_int32 setMsgSeverity ( l_int32 newsev );
         extern l_int32 returnErrorInt ( const char *msg, const char *procname, l_int32 ival );
         extern l_float32 returnErrorFloat ( const char *msg, const char *procname, l_float32 fval );
         extern void * returnErrorPtr ( const char *msg, const char *procname, void *pval );
         extern char * stringNew ( const char *src );
         extern l_int32 stringCopy ( char *dest, const char *src, l_int32 n );
         extern l_int32 stringReplace ( char **pdest, const char *src );
         extern l_int32 stringLength ( const char *src, size_t size );
         extern l_int32 stringCat ( char *dest, size_t size, const char *src );
         extern char * stringConcatNew ( const char *first, ... );
         extern char * stringJoin ( const char *src1, const char *src2 );
         extern char * stringReverse ( const char *src );
         extern char * strtokSafe ( char *cstr, const char *seps, char **psaveptr );
         extern l_int32 stringSplitOnToken ( char *cstr, const char *seps, char **phead, char **ptail );
         extern char * stringRemoveChars ( const char *src, const char *remchars );
         extern l_int32 stringFindSubstr ( const char *src, const char *sub, l_int32 *ploc );
         extern char * stringReplaceSubstr ( const char *src, const char *sub1, const char *sub2, l_int32 *pfound, l_int32 *ploc );
         extern char * stringReplaceEachSubstr ( const char *src, const char *sub1, const char *sub2, l_int32 *pcount );
         extern L_DNA * arrayFindEachSequence ( const l_uint8 *data, size_t datalen, const l_uint8 *sequence, size_t seqlen );
         extern l_int32 arrayFindSequence ( const l_uint8 *data, size_t datalen, const l_uint8 *sequence, size_t seqlen, l_int32 *poffset, l_int32 *pfound );
         extern void * reallocNew ( void **pindata, l_int32 oldsize, l_int32 newsize );
         extern l_uint8 * l_binaryRead ( const char *filename, size_t *pnbytes );
         extern l_uint8 * l_binaryReadStream ( FILE *fp, size_t *pnbytes );
         extern l_uint8 * l_binaryReadSelect ( const char *filename, size_t start, size_t nbytes, size_t *pnread );
         extern l_uint8 * l_binaryReadSelectStream ( FILE *fp, size_t start, size_t nbytes, size_t *pnread );
         extern l_int32 l_binaryWrite ( const char *filename, const char *operation, void *data, size_t nbytes );
         extern size_t nbytesInFile ( const char *filename );
         extern size_t fnbytesInFile ( FILE *fp );
         extern l_uint8 * l_binaryCopy ( l_uint8 *datas, size_t size );
         extern l_int32 fileCopy ( const char *srcfile, const char *newfile );
         extern l_int32 fileConcatenate ( const char *srcfile, const char *destfile );
         extern l_int32 fileAppendString ( const char *filename, const char *str );
         extern l_int32 filesAreIdentical ( const char *fname1, const char *fname2, l_int32 *psame );
         extern l_uint16 convertOnLittleEnd16 ( l_uint16 shortin );
         extern l_uint16 convertOnBigEnd16 ( l_uint16 shortin );
         extern l_uint32 convertOnLittleEnd32 ( l_uint32 wordin );
         extern l_uint32 convertOnBigEnd32 ( l_uint32 wordin );
         extern FILE * fopenReadStream ( const char *filename );
         extern FILE * fopenWriteStream ( const char *filename, const char *modestring );
         extern FILE * lept_fopen ( const char *filename, const char *mode );
         extern l_int32 lept_fclose ( FILE *fp );
         extern void * lept_calloc ( size_t nmemb, size_t size );
         extern void lept_free ( void *ptr );
         extern l_int32 lept_mkdir ( const char *subdir );
         extern l_int32 lept_rmdir ( const char *subdir );
         extern void lept_direxists ( const char *dir, l_int32 *pexists );
         extern l_int32 lept_rm_match ( const char *subdir, const char *substr );
         extern l_int32 lept_rm ( const char *subdir, const char *tail );
         extern l_int32 lept_rmfile ( const char *filepath );
         extern l_int32 lept_mv ( const char *srcfile, const char *newdir, const char *newtail, char **pnewpath );
         extern l_int32 lept_cp ( const char *srcfile, const char *newdir, const char *newtail, char **pnewpath );
         extern l_int32 splitPathAtDirectory ( const char *pathname, char **pdir, char **ptail );
         extern l_int32 splitPathAtExtension ( const char *pathname, char **pbasename, char **pextension );
         extern char * pathJoin ( const char *dir, const char *fname );
         extern char * appendSubdirectory ( const char *dir, const char *subdir );
         extern l_int32 convertSepCharsInPath ( char *path, l_int32 type );
         extern char * genPathname ( const char *dir, const char *fname );
         extern l_int32 makeTempDirname ( char *result, size_t nbytes, const char *subdir );
         extern l_int32 modifyTrailingSlash ( char *path, size_t nbytes, l_int32 flag );
         extern char * genTempFilename ( const char *dir, const char *tail, l_int32 usetime, l_int32 usepid );
         extern l_int32 extractNumberFromFilename ( const char *fname, l_int32 numpre, l_int32 numpost );
         extern l_int32 fileCorruptByDeletion ( const char *filein, l_float32 loc, l_float32 size, const char *fileout );
         extern l_int32 fileCorruptByMutation ( const char *filein, l_float32 loc, l_float32 size, const char *fileout );
         extern l_int32 genRandomIntegerInRange ( l_int32 range, l_int32 seed, l_int32 *pval );
         extern l_int32 lept_roundftoi ( l_float32 fval );
         extern l_uint32 convertBinaryToGrayCode ( l_uint32 val );
         extern l_uint32 convertGrayCodeToBinary ( l_uint32 val );
         extern char * getLeptonicaVersion ( );
         extern void startTimer ( void );
         extern l_float32 stopTimer ( void );
         extern L_TIMER startTimerNested ( void );
         extern l_float32 stopTimerNested ( L_TIMER rusage_start );
         extern void l_getCurrentTime ( l_int32 *sec, l_int32 *usec );
         extern char * l_getFormattedDate ( );
         extern l_int32 pixHtmlViewer ( const char *dirin, const char *dirout, const char *rootname, l_int32 thumbwidth, l_int32 viewwidth, l_int32 copyorig );
         extern PIX * pixSimpleCaptcha ( PIX *pixs, l_int32 border, l_int32 nterms, l_uint32 seed, l_uint32 color, l_int32 cmapflag );
         extern PIX * pixRandomHarmonicWarp ( PIX *pixs, l_float32 xmag, l_float32 ymag, l_float32 xfreq, l_float32 yfreq, l_int32 nx, l_int32 ny, l_uint32 seed, l_int32 grayval );
         extern PIX * pixWarpStereoscopic ( PIX *pixs, l_int32 zbend, l_int32 zshiftt, l_int32 zshiftb, l_int32 ybendt, l_int32 ybendb, l_int32 redleft );
         extern PIX * pixStretchHorizontal ( PIX *pixs, l_int32 dir, l_int32 type, l_int32 hmax, l_int32 operation, l_int32 incolor );
         extern PIX * pixStretchHorizontalSampled ( PIX *pixs, l_int32 dir, l_int32 type, l_int32 hmax, l_int32 incolor );
         extern PIX * pixStretchHorizontalLI ( PIX *pixs, l_int32 dir, l_int32 type, l_int32 hmax, l_int32 incolor );
         extern PIX * pixQuadraticVShear ( PIX *pixs, l_int32 dir, l_int32 vmaxt, l_int32 vmaxb, l_int32 operation, l_int32 incolor );
         extern PIX * pixQuadraticVShearSampled ( PIX *pixs, l_int32 dir, l_int32 vmaxt, l_int32 vmaxb, l_int32 incolor );
         extern PIX * pixQuadraticVShearLI ( PIX *pixs, l_int32 dir, l_int32 vmaxt, l_int32 vmaxb, l_int32 incolor );
         extern PIX * pixStereoFromPair ( PIX *pix1, PIX *pix2, l_float32 rwt, l_float32 gwt, l_float32 bwt );
         extern L_WSHED * wshedCreate ( PIX *pixs, PIX *pixm, l_int32 mindepth, l_int32 debugflag );
         extern void wshedDestroy ( L_WSHED **pwshed );
         extern l_int32 wshedApply ( L_WSHED *wshed );
         extern l_int32 wshedBasins ( L_WSHED *wshed, PIXA **ppixa, NUMA **pnalevels );
         extern PIX * wshedRenderFill ( L_WSHED *wshed );
         extern PIX * wshedRenderColors ( L_WSHED *wshed );
         extern PIX * pixReadStreamWebP ( FILE *fp );
         extern PIX * pixReadMemWebP ( const l_uint8 *filedata, size_t filesize );
         extern l_int32 readHeaderWebP ( const char *filename, l_int32 *pw, l_int32 *ph, l_int32 *pspp );
         extern l_int32 readHeaderMemWebP ( const l_uint8 *data, size_t size, l_int32 *pw, l_int32 *ph, l_int32 *pspp );
         extern l_int32 pixWriteWebP ( const char *filename, PIX *pixs, l_int32 quality, l_int32 lossless );
         extern l_int32 pixWriteStreamWebP ( FILE *fp, PIX *pixs, l_int32 quality, l_int32 lossless );
         extern l_int32 pixWriteMemWebP ( l_uint8 **pencdata, size_t *pencsize, PIX *pixs, l_int32 quality, l_int32 lossless );
         extern l_int32 pixaWriteFiles ( const char *rootname, PIXA *pixa, l_int32 format );
         extern l_int32 pixWrite ( const char *filename, PIX *pix, l_int32 format );
         extern l_int32 pixWriteStream ( FILE *fp, PIX *pix, l_int32 format );
         extern l_int32 pixWriteImpliedFormat ( const char *filename, PIX *pix, l_int32 quality, l_int32 progressive );
         extern l_int32 pixWriteTempfile ( const char *dir, const char *tail, PIX *pix, l_int32 format, char **pfilename );
         extern l_int32 pixChooseOutputFormat ( PIX *pix );
         extern l_int32 getImpliedFileFormat ( const char *filename );
         extern const char * getFormatExtension ( l_int32 format );
         extern l_int32 pixWriteMem ( l_uint8 **pdata, size_t *psize, PIX *pix, l_int32 format );
         extern l_int32 pixDisplay ( PIX *pixs, l_int32 x, l_int32 y );
         extern l_int32 pixDisplayWithTitle ( PIX *pixs, l_int32 x, l_int32 y, const char *title, l_int32 dispflag );
         extern l_int32 pixDisplayMultiple ( const char *filepattern );
         extern l_int32 pixDisplayWrite ( PIX *pixs, l_int32 reduction );
         extern l_int32 pixDisplayWriteFormat ( PIX *pixs, l_int32 reduction, l_int32 format );
         extern l_int32 pixSaveTiled ( PIX *pixs, PIXA *pixa, l_float32 scalefactor, l_int32 newrow, l_int32 space, l_int32 dp );
         extern l_int32 pixSaveTiledOutline ( PIX *pixs, PIXA *pixa, l_float32 scalefactor, l_int32 newrow, l_int32 space, l_int32 linewidth, l_int32 dp );
         extern l_int32 pixSaveTiledWithText ( PIX *pixs, PIXA *pixa, l_int32 outwidth, l_int32 newrow, l_int32 space, l_int32 linewidth, L_BMF *bmf, const char *textstr, l_uint32 val, l_int32 location );
         extern void l_chooseDisplayProg ( l_int32 selection );
         extern l_uint8 * zlibCompress ( l_uint8 *datain, size_t nin, size_t *pnout );
         extern l_uint8 * zlibUncompress ( l_uint8 *datain, size_t nin, size_t *pnout );


}
# 5 "tessapi-quality.cpp" 2
# 1 "/usr/local/opt/libiomp/include/libiomp/omp.h" 1 3 4
/*
 * include/40/omp.h.var
 */

/* <copyright>
    Copyright (c) 1985-2015 Intel Corporation.  All Rights Reserved.

    Redistribution and use in source and binary forms, with or without
    modification, are permitted provided that the following conditions
    are met:

      * Redistributions of source code must retain the above copyright
        notice, this list of conditions and the following disclaimer.
      * Redistributions in binary form must reproduce the above copyright
        notice, this list of conditions and the following disclaimer in the
        documentation and/or other materials provided with the distribution.
      * Neither the name of Intel Corporation nor the names of its
        contributors may be used to endorse or promote products derived
        from this software without specific prior written permission.

    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
    "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
    A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
    HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
    LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
    DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
    OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

</copyright> */
# 44 "/usr/local/opt/libiomp/include/libiomp/omp.h" 3 4
    extern "C" {
# 53 "/usr/local/opt/libiomp/include/libiomp/omp.h" 3 4
    /* schedule kind constants */
    typedef enum omp_sched_t {
 omp_sched_static = 1,
 omp_sched_dynamic = 2,
 omp_sched_guided = 3,
 omp_sched_auto = 4
    } omp_sched_t;

    /* set API functions */
    extern void omp_set_num_threads (int);
    extern void omp_set_dynamic (int);
    extern void omp_set_nested (int);
    extern void omp_set_max_active_levels (int);
    extern void omp_set_schedule (omp_sched_t, int);

    /* query API functions */
    extern int omp_get_num_threads (void);
    extern int omp_get_dynamic (void);
    extern int omp_get_nested (void);
    extern int omp_get_max_threads (void);
    extern int omp_get_thread_num (void);
    extern int omp_get_num_procs (void);
    extern int omp_in_parallel (void);
    extern int omp_in_final (void);
    extern int omp_get_active_level (void);
    extern int omp_get_level (void);
    extern int omp_get_ancestor_thread_num (int);
    extern int omp_get_team_size (int);
    extern int omp_get_thread_limit (void);
    extern int omp_get_max_active_levels (void);
    extern void omp_get_schedule (omp_sched_t *, int *);

    /* lock API functions */
    typedef struct omp_lock_t {
        void * _lk;
    } omp_lock_t;

    extern void omp_init_lock (omp_lock_t *);
    extern void omp_set_lock (omp_lock_t *);
    extern void omp_unset_lock (omp_lock_t *);
    extern void omp_destroy_lock (omp_lock_t *);
    extern int omp_test_lock (omp_lock_t *);

    /* nested lock API functions */
    typedef struct omp_nest_lock_t {
        void * _lk;
    } omp_nest_lock_t;

    extern void omp_init_nest_lock (omp_nest_lock_t *);
    extern void omp_set_nest_lock (omp_nest_lock_t *);
    extern void omp_unset_nest_lock (omp_nest_lock_t *);
    extern void omp_destroy_nest_lock (omp_nest_lock_t *);
    extern int omp_test_nest_lock (omp_nest_lock_t *);

    /* lock hint type for dynamic user lock */
    typedef enum kmp_lock_hint_t {
        kmp_lock_hint_none = 0,
        kmp_lock_hint_contended,
        kmp_lock_hint_uncontended,
        kmp_lock_hint_nonspeculative,
        kmp_lock_hint_speculative,
        kmp_lock_hint_adaptive,
    } kmp_lock_hint_t;

    /* hinted lock initializers */
    extern void kmp_init_lock_hinted(omp_lock_t *, kmp_lock_hint_t);
    extern void kmp_init_nest_lock_hinted(omp_nest_lock_t *, kmp_lock_hint_t);

    /* time API functions */
    extern double omp_get_wtime (void);
    extern double omp_get_wtick (void);

    /* OpenMP 4.0 */
    extern int omp_get_default_device (void);
    extern void omp_set_default_device (int);
    extern int omp_is_initial_device (void);
    extern int omp_get_num_devices (void);
    extern int omp_get_num_teams (void);
    extern int omp_get_team_num (void);
    extern int omp_get_cancellation (void);


    /* kmp API functions */
    extern int kmp_get_stacksize (void);
    extern void kmp_set_stacksize (int);
    extern size_t kmp_get_stacksize_s (void);
    extern void kmp_set_stacksize_s (size_t);
    extern int kmp_get_blocktime (void);
    extern int kmp_get_library (void);
    extern void kmp_set_blocktime (int);
    extern void kmp_set_library (int);
    extern void kmp_set_library_serial (void);
    extern void kmp_set_library_turnaround (void);
    extern void kmp_set_library_throughput (void);
    extern void kmp_set_defaults (char const *);

    /* Intel affinity API */
    typedef void * kmp_affinity_mask_t;

    extern int kmp_set_affinity (kmp_affinity_mask_t *);
    extern int kmp_get_affinity (kmp_affinity_mask_t *);
    extern int kmp_get_affinity_max_proc (void);
    extern void kmp_create_affinity_mask (kmp_affinity_mask_t *);
    extern void kmp_destroy_affinity_mask (kmp_affinity_mask_t *);
    extern int kmp_set_affinity_mask_proc (int, kmp_affinity_mask_t *);
    extern int kmp_unset_affinity_mask_proc (int, kmp_affinity_mask_t *);
    extern int kmp_get_affinity_mask_proc (int, kmp_affinity_mask_t *);

    /* OpenMP 4.0 affinity API */
    typedef enum omp_proc_bind_t {
        omp_proc_bind_false = 0,
        omp_proc_bind_true = 1,
        omp_proc_bind_master = 2,
        omp_proc_bind_close = 3,
        omp_proc_bind_spread = 4
    } omp_proc_bind_t;

    extern omp_proc_bind_t omp_get_proc_bind (void);

    extern void * kmp_malloc (size_t);
    extern void * kmp_calloc (size_t, size_t);
    extern void * kmp_realloc (void *, size_t);
    extern void kmp_free (void *);

    extern void kmp_set_warnings_on(void);
    extern void kmp_set_warnings_off(void);



    /* Warning:
       The following typedefs are not standard, deprecated and will be removed in a future release.
    */
    typedef int omp_int_t;
    typedef double omp_wtime_t;


    }
# 6 "tessapi-quality.cpp" 2
# 1 "/usr/include/sys/time.h" 1 3 4
/*
 * Copyright (c) 2000-2006 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
/* Copyright (c) 1995 NeXT Computer, Inc. All Rights Reserved */
/*
 * Copyright (c) 1982, 1986, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)time.h	8.2 (Berkeley) 7/10/94
 */
# 71 "/usr/include/sys/time.h" 3 4
/*
 * [XSI] The fd_set type shall be defined as described in <sys/select.h>.
 * The timespec structure shall be defined as described in <time.h>
 */







/*
 * Structure used as a parameter by getitimer(2) and setitimer(2) system
 * calls.
 */
struct itimerval {
 struct timeval it_interval; /* timer interval */
 struct timeval it_value; /* current value */
};

/*
 * Names of the interval timers, and structure
 * defining a timer setting.
 */




/*
 * Select uses bit masks of file descriptors in longs.  These macros
 * manipulate such bit fields (the filesystem macros use chars).  The
 * extra protection here is to permit application redefinition above
 * the default size.
 */
# 124 "/usr/include/sys/time.h" 3 4
struct timezone {
 int tz_minuteswest; /* minutes west of Greenwich */
 int tz_dsttime; /* type of dst correction */
};
# 136 "/usr/include/sys/time.h" 3 4
/* Operations on timevals. */
# 164 "/usr/include/sys/time.h" 3 4
/*
 * Getkerninfo clock information structure
 */
struct clockinfo {
 int hz; /* clock frequency */
 int tick; /* micro-seconds per hz tick */
 int tickadj; /* clock skew rate for adjtime() */
 int stathz; /* statistics clock frequency */
 int profhz; /* profiling clock frequency */
};







extern "C" {


int adjtime(const struct timeval *, struct timeval *);
int futimes(int, const struct timeval *);
int lutimes(const char *, const struct timeval *) __attribute__((availability(macosx,introduced=10.5)));
int settimeofday(const struct timeval *, const struct timezone *);


int getitimer(int, struct itimerval *);
int gettimeofday(struct timeval * , void * );


# 1 "/usr/include/sys/_select.h" 1 3 4
/*
 * Copyright (c) 2005, 2007 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */

/*
 * This is called from sys/select.h and sys/time.h for the common prototype
 * of select().  Setting _DARWIN_C_SOURCE or _DARWIN_UNLIMITED_SELECT uses
 * the version of select() that does not place a limit on the first argument
 * (nfds).  In the UNIX conformance case, values of nfds greater than
 * FD_SETSIZE will return an error of EINVAL.
 */



int select(int, fd_set * , fd_set * ,
  fd_set * , struct timeval * )




  __asm("_" "select" "$1050")




  ;
# 194 "/usr/include/sys/time.h" 2 3 4

int setitimer(int, const struct itimerval * ,
  struct itimerval * );
int utimes(const char *, const struct timeval *);

}
# 7 "tessapi-quality.cpp" 2
# 1 "/usr/include/sys/syscall.h" 1 3 4
/*
 * Copyright (c) 2004-2008 Apple Inc. All rights reserved.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 * 
 * 
 * System call switch table.
 *
 * DO NOT EDIT-- this file is automatically generated.
 * created from /SourceCache/xnu/xnu-2782.40.9/bsd/kern/syscalls.master
 */
# 48 "/usr/include/sys/syscall.h" 3 4
   /* 8  old creat */


   /* 11  old execv */





   /* 17  old break */

   /* 19  old lseek */

   /* 21  old mount */
   /* 22  old umount */
# 78 "/usr/include/sys/syscall.h" 3 4
   /* 38  old stat */

   /* 40  old lstat */



   /* 44  old profil */
   /* 45  old ktrace */
# 102 "/usr/include/sys/syscall.h" 3 4
   /* 62  old fstat */
   /* 63  used internally , reserved */
   /* 64  old getpagesize */


   /* 67  old vread */
   /* 68  old vwrite */
   /* 69  old sbrk */
   /* 70  old sstk */
   /* 71  old mmap */
   /* 72  old vadvise */



   /* 76  old vhangup */
   /* 77  old vlimit */






   /* 84  old wait */


   /* 87  old gethostname */
   /* 88  old sethostname */


   /* 91  old getdopt */


   /* 94  old setdopt */




   /* 99  old accept */

   /* 101  old send */
   /* 102  old recv */
   /* 103  old sigreturn */



   /* 107  old vtimes */
   /* 108  old sigvec */
   /* 109  old sigblock */
   /* 110  old sigsetmask */

   /* 112  old sigstack */
   /* 113  old recvmsg */
   /* 114  old sendmsg */
   /* 115  old vtrace */



   /* 119  old resuba */





   /* 125  old recvfrom */



   /* 129  old truncate */
   /* 130  old ftruncate */
# 181 "/usr/include/sys/syscall.h" 3 4
   /* 141  old getpeername */

   /* 143  old sethostid */
   /* 144  old getrlimit */
   /* 145  old setrlimit */
   /* 146  old killpg */

   /* 148  old setquota */
   /* 149  old qquota */
   /* 150  old getsockname */





   /* 156  old getdirentries */



   /* 160  old async_daemon */

   /* 162  old getdomainname */
   /* 163  old setdomainname */
   /* 164  */

   /* 166  old exportfs */

   /* 168  old ustat */


   /* 171  old wait3 */
   /* 172  old rpause */

   /* 174  old getdents */
   /* 175  old gc_control */
   /* 176  old add_profil */
   /* 177  */
   /* 178  */







   /* 186  */






   /* 193  */




   /* 198  __syscall */







   /* 206  old ATsocket */
   /* 207  old ATgetmsg */
   /* 208  old ATputmsg */
   /* 209  old ATsndreq */
   /* 210  old ATsndrsp */
   /* 211  old ATgetreq */
   /* 212  old ATgetrsp */
   /* 213  Reserved for AppleTalk */
   /* 214  */
   /* 215  */

   /* 217  */
   /* 218  */
   /* 219  */




   /* 224  old checkuseraccess / fsgetpath ( which moved to 427 ) */
# 286 "/usr/include/sys/syscall.h" 3 4
   /* 246  */


   /* 249  */







   /* 257  */
# 315 "/usr/include/sys/syscall.h" 3 4
   /* 275  old sem_init */
   /* 276  old sem_destroy */
# 335 "/usr/include/sys/syscall.h" 3 4
   /* 295  old shared_region_map_np */
# 361 "/usr/include/sys/syscall.h" 3 4
   /* 321  old __pthread_cond_wait */




   /* 326  */
# 375 "/usr/include/sys/syscall.h" 3 4
   /* 335  old utrace */
# 392 "/usr/include/sys/syscall.h" 3 4
   /* 352  */


   /* 355  old getaudit */
   /* 356  old setaudit */
# 414 "/usr/include/sys/syscall.h" 3 4
   /* 374  */
   /* 375  */
   /* 376  */
   /* 377  */
   /* 378  */
   /* 379  */
# 477 "/usr/include/sys/syscall.h" 3 4
   /* 437  old shared_region_slide_np */







   /* 445  old __proc_suppress */
# 502 "/usr/include/sys/syscall.h" 3 4
   /* 462  */
# 8 "tessapi-quality.cpp" 2
# 1 "/usr/include/unistd.h" 1 3 4
/*
 * Copyright (c) 2000, 2002-2006, 2008-2010, 2012 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
/*-
 * Copyright (c) 1998-1999 Apple Computer, Inc. All Rights Reserved
 * Copyright (c) 1991, 1993, 1994
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)unistd.h	8.12 (Berkeley) 4/27/95
 *
 *  Copyright (c)  1998 Apple Compter, Inc.
 *  All Rights Reserved
 */

/* History:
        7/14/99 EKN at Apple fixed getdirentriesattr from getdirentryattr
        3/26/98 CHW at Apple added real interface to searchfs call
  	3/5/98  CHW at Apple added hfs semantic system calls headers
*/






# 1 "/usr/include/sys/unistd.h" 1 3 4
/*
 * Copyright (c) 2000-2013 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
/* Copyright (c) 1995 NeXT Computer, Inc. All Rights Reserved */
/*
 * Copyright (c) 1989, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)unistd.h	8.2 (Berkeley) 1/7/94
 */






/*
 * Although we have saved user/group IDs, we do not use them in setuid
 * as described in POSIX 1003.1, because the feature does not work for
 * root.  We use the saved IDs in seteuid/setegid, which are not currently
 * part of the POSIX 1003.1 specification.
 */







/* execution-time symbolic constants */
    /* may disable terminal special characters */

# 1 "/usr/include/sys/_types/_posix_vdisable.h" 1 3 4
/*
 * Copyright (c) 2003-2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
# 85 "/usr/include/sys/unistd.h" 2 3 4



/* access function */






/*
 * Extended access functions.
 * Note that we depend on these matching the definitions in sys/kauth.h,
 * but with the bits shifted left by 8.
 */
# 121 "/usr/include/sys/unistd.h" 3 4
/* whence values for lseek(2) */

# 1 "/usr/include/sys/_types/_seek_set.h" 1 3 4
/*
 * Copyright (c) 2003-2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */

/* whence values for lseek(2) */
# 123 "/usr/include/sys/unistd.h" 2 3 4


/* whence values for lseek(2); renamed by POSIX 1003.1 */






struct accessx_descriptor {
 unsigned int ad_name_offset;
 int ad_flags;
 int ad_pad[2];
};




/* configurable pathname variables */
# 173 "/usr/include/sys/unistd.h" 3 4
/* configurable system strings */
# 183 "/usr/include/sys/unistd.h" 3 4
extern "C" {

int getattrlistbulk(int, void *, void *, size_t, uint64_t) __attribute__((availability(macosx,introduced=10.10)));

}
# 201 "/usr/include/sys/unistd.h" 3 4
extern "C" {

int faccessat(int, const char *, int, int) __attribute__((availability(macosx,introduced=10.10)));
int fchownat(int, const char *, uid_t, gid_t, int) __attribute__((availability(macosx,introduced=10.10)));
int linkat(int, const char *, int, const char *, int) __attribute__((availability(macosx,introduced=10.10)));
ssize_t readlinkat(int, const char *, char *, size_t) __attribute__((availability(macosx,introduced=10.10)));
int symlinkat(const char *, int, const char *) __attribute__((availability(macosx,introduced=10.10)));
int unlinkat(int, const char *, int) __attribute__((availability(macosx,introduced=10.10)));
int getattrlistat(int, const char *, void *, void *, size_t, unsigned long) __attribute__((availability(macosx,introduced=10.10)));

}
# 73 "/usr/include/unistd.h" 2 3 4





/* DO NOT REMOVE THIS COMMENT: fixincludes needs to see:
 * _GCC_SIZE_T */
# 91 "/usr/include/unistd.h" 3 4
/* Version test macros */
/* _POSIX_VERSION and _POSIX2_VERSION from sys/unistd.h */




/* Please keep this list in the same order as the applicable standard */
# 193 "/usr/include/unistd.h" 3 4
/* Removed in Issue 7 */
# 211 "/usr/include/unistd.h" 3 4
/* configurable system variables */
# 344 "/usr/include/unistd.h" 3 4
/* Removed in Issue 7 */
# 360 "/usr/include/unistd.h" 3 4
/* Removed in Issue 6 */
# 387 "/usr/include/unistd.h" 3 4
/* Removed in Issue 7 */
# 421 "/usr/include/unistd.h" 3 4
/* POSIX.1-1990 */

extern "C" {
void _exit(int) __attribute__((noreturn));
int access(const char *, int);
unsigned int
  alarm(unsigned int);
int chdir(const char *);
int chown(const char *, uid_t, gid_t);

int close(int) __asm("_" "close" );

int dup(int);
int dup2(int, int);
int execl(const char *, const char *, ...);
int execle(const char *, const char *, ...);
int execlp(const char *, const char *, ...);
int execv(const char *, char * const *);
int execve(const char *, char * const *, char * const *);
int execvp(const char *, char * const *);
pid_t fork(void);
long fpathconf(int, int);
char *getcwd(char *, size_t);
gid_t getegid(void);
uid_t geteuid(void);
gid_t getgid(void);



int getgroups(int, gid_t []);

char *getlogin(void);
pid_t getpgrp(void);
pid_t getpid(void);
pid_t getppid(void);
uid_t getuid(void);
int isatty(int);
int link(const char *, const char *);
off_t lseek(int, off_t, int);
long pathconf(const char *, int);

int pause(void) __asm("_" "pause" );

int pipe(int [2]);

ssize_t read(int, void *, size_t) __asm("_" "read" );

int rmdir(const char *);
int setgid(gid_t);
int setpgid(pid_t, pid_t);
pid_t setsid(void);
int setuid(uid_t);

unsigned int
  sleep(unsigned int) __asm("_" "sleep" );

long sysconf(int);
pid_t tcgetpgrp(int);
int tcsetpgrp(int, pid_t);
char *ttyname(int);


int ttyname_r(int, char *, size_t) __asm("_" "ttyname_r" );




int unlink(const char *);

ssize_t write(int, const void *, size_t) __asm("_" "write" );
}



/* Additional functionality provided by:
 * POSIX.2-1992 C Language Binding Option
 */


extern "C" {
size_t confstr(int, char *, size_t) __asm("_" "confstr" );

int getopt(int, char * const [], const char *) __asm("_" "getopt" );

extern char *optarg; /* getopt(3) external variables */
extern int optind, opterr, optopt;
}




/* Additional functionality provided by:
 * POSIX.1c-1995,
 * POSIX.1i-1995,
 * and the omnibus ISO/IEC 9945-1: 1996
 */


                               /* These F_* are really XSI or Issue 6 */





 extern "C" {

/* Begin XSI */
/* Removed in Issue 6 */


__attribute__((deprecated))

void *brk(const void *);
int chroot(const char *) ;


char *crypt(const char *, const char *);






void encrypt(char *, int) __asm("_" "encrypt" );



int fchdir(int);
long gethostid(void);
pid_t getpgid(pid_t);
pid_t getsid(pid_t);

/* Removed in Issue 6 */

int getdtablesize(void) ;
int getpagesize(void) __attribute__((const)) ;
char *getpass(const char *) ;


/* Removed in Issue 7 */

char *getwd(char *) ; /* obsoleted by getcwd() */


int lchown(const char *, uid_t, gid_t) __asm("_" "lchown" );

int lockf(int, int, off_t) __asm("_" "lockf" );

int nice(int) __asm("_" "nice" );

ssize_t pread(int, void *, size_t, off_t) __asm("_" "pread" );

ssize_t pwrite(int, const void *, size_t, off_t) __asm("_" "pwrite" );

/* Removed in Issue 6 */

/* Note that Issue 5 changed the argument as intprt_t,
 * but we keep it as int for binary compatability. */

__attribute__((deprecated))

void *sbrk(int);



pid_t setpgrp(void) __asm("_" "setpgrp" );




int setregid(gid_t, gid_t) __asm("_" "setregid" );

int setreuid(uid_t, uid_t) __asm("_" "setreuid" );

void swab(const void * , void * , ssize_t);
void sync(void);
int truncate(const char *, off_t);
useconds_t ualarm(useconds_t, useconds_t);
int usleep(useconds_t) __asm("_" "usleep" );
pid_t vfork(void);
/* End XSI */

int fsync(int) __asm("_" "fsync" );

int ftruncate(int, off_t);
int getlogin_r(char *, size_t);
}




/* Additional functionality provided by:
 * POSIX.1-2001
 * ISO C99
 */


extern "C" {
int fchown(int, uid_t, gid_t);
int gethostname(char *, size_t);
ssize_t readlink(const char * , char * , size_t);
int setegid(gid_t);
int seteuid(uid_t);
int symlink(const char *, const char *);
}




/* Darwin extensions */



# 1 "/usr/include/sys/select.h" 1 3 4
/*
 * Copyright (c) 2000-2005 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
/*
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)select.h	8.2 (Berkeley) 1/4/94
 */
# 70 "/usr/include/sys/select.h" 3 4
/*
 * [XSI] The <sys/select.h> header shall define the fd_set type as a structure.
 * The timespec structure shall be defined as described in <time.h>
 * The <sys/select.h> header shall define the timeval structure.
 */




/*
 * The time_t and suseconds_t types shall be defined as described in
 * <sys/types.h>
 * The sigset_t type shall be defined as described in <signal.h>
 */




/*
 * [XSI] FD_CLR, FD_ISSET, FD_SET, FD_ZERO may be declared as a function, or
 *	 defined as a macro, or both
 * [XSI] FD_SETSIZE shall be defined as a macro
 */

/*
 * Select uses bit masks of file descriptors in longs.  These macros
 * manipulate such bit fields (the filesystem macros use chars).  The
 * extra protection here is to permit application redefinition above
 * the default size.
 */
# 111 "/usr/include/sys/select.h" 3 4
extern "C" {


int pselect(int, fd_set * , fd_set * ,
  fd_set * , const struct timespec * ,
  const sigset_t * )




  __asm("_" "pselect" "$1050")




  ;




}
# 634 "/usr/include/unistd.h" 2 3 4



# 1 "/usr/include/sys/_types/_uuid_t.h" 1 3 4
/*
 * Copyright (c) 2003-2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */


typedef __darwin_uuid_t uuid_t;
# 638 "/usr/include/unistd.h" 2 3 4

extern "C" {
void _Exit(int) __attribute__((noreturn));
int accessx_np(const struct accessx_descriptor *, size_t, int *, uid_t);
int acct(const char *);
int add_profil(char *, size_t, unsigned long, unsigned int);
void endusershell(void);
int execvP(const char *, const char *, char * const *);
char *fflagstostr(unsigned long);
int getdomainname(char *, int);
int getgrouplist(const char *, int, int *, int *);





# 1 "/usr/include/gethostuuid.h" 1 3 4
/*
 * Copyright (c) 2013 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
# 39 "/usr/include/gethostuuid.h" 3 4
int gethostuuid(uuid_t, const struct timespec *) __attribute__((availability(macosx,introduced=10.5)));
# 654 "/usr/include/unistd.h" 2 3 4




mode_t getmode(const void *, mode_t);
int getpeereid(int, uid_t *, gid_t *);
int getsgroups_np(int *, uuid_t);
char *getusershell(void);
int getwgroups_np(int *, uuid_t);
int initgroups(const char *, int);
int iruserok(unsigned long, int, const char *, const char *);
int iruserok_sa(const void *, int, int, const char *, const char *);
int issetugid(void);
char *mkdtemp(char *);
int mknod(const char *, mode_t, dev_t);
int mkpath_np(const char *path, mode_t omode) __attribute__((availability(macosx,introduced=10.8))); /* returns errno */
int mkstemp(char *);
int mkstemps(char *, int);
char *mktemp(char *);
int nfssvc(int, void *);
int profil(char *, size_t, unsigned long, unsigned int);
int pthread_setugid_np(uid_t, gid_t);
int pthread_getugid_np( uid_t *, gid_t *);
int rcmd(char **, int, const char *, const char *, const char *, int *);
int rcmd_af(char **, int, const char *, const char *, const char *, int *,
  int);
int reboot(int);
int revoke(const char *);
int rresvport(int *);
int rresvport_af(int *, int);
int ruserok(const char *, int, const char *, const char *);
int setdomainname(const char *, int);
int setgroups(int, const gid_t *);
void sethostid(long);
int sethostname(const char *, int);

void setkey(const char *) __asm("_" "setkey" );



int setlogin(const char *);
void *setmode(const char *) __asm("_" "setmode" );
int setrgid(gid_t);
int setruid(uid_t);
int setsgroups_np(int, const uuid_t);
void setusershell(void);
int setwgroups_np(int, const uuid_t);
int strtofflags(char **, unsigned long *, unsigned long *);
int swapon(const char *);
int syscall(int, ...);
int ttyslot(void);
int undelete(const char *);
int unwhiteout(const char *);
void *valloc(size_t);

extern char *suboptarg; /* getsubopt(3) external variable */
int getsubopt(char **, char * const *, char **);

/*  HFS & HFS Plus semantics system calls go here */

int fgetattrlist(int,void*,void*,size_t,unsigned int) __attribute__((availability(macosx,introduced=10.6)));
int fsetattrlist(int,void*,void*,size_t,unsigned int) __attribute__((availability(macosx,introduced=10.6)));
int getattrlist(const char*,void*,void*,size_t,unsigned int) __asm("_" "getattrlist" );
int setattrlist(const char*,void*,void*,size_t,unsigned int) __asm("_" "setattrlist" );
int exchangedata(const char*,const char*,unsigned int);
int getdirentriesattr(int,void*,void*,size_t,unsigned int*,unsigned int*,unsigned int*,unsigned int);
# 731 "/usr/include/unistd.h" 3 4
struct fssearchblock;
struct searchstate;

int searchfs(const char *, struct fssearchblock *, unsigned long *, unsigned int, unsigned int, struct searchstate *);
int fsctl(const char *,unsigned long,void*,unsigned int);
int ffsctl(int,unsigned long,void*,unsigned int) __attribute__((availability(macosx,introduced=10.6)));




int fsync_volume_np(int, int) __attribute__((availability(macosx,introduced=10.8)));
int sync_volume_np(const char *, int) __attribute__((availability(macosx,introduced=10.8)));

extern int optreset;

}
# 9 "tessapi-quality.cpp" 2
// include tesseract baseapi.h with the right path

# 1 "/Users/satavtar/github/tesseract/api/baseapi.h" 1
///////////////////////////////////////////////////////////////////////
// File:        baseapi.h
// Description: Simple API for calling tesseract.
// Author:      Ray Smith
// Created:     Fri Oct 06 15:35:01 PDT 2006
//
// (C) Copyright 2006, Google Inc.
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
///////////////////////////////////////////////////////////////////////
# 29 "/Users/satavtar/github/tesseract/api/baseapi.h"
// To avoid collision with other typenames include the ABSOLUTE MINIMUM
// complexity of includes here. Use forward declarations wherever possible
// and hide includes of complex types in baseapi.cpp.

# 1 "/usr/local/include/tesseract/platform.h" 1
///////////////////////////////////////////////////////////////////////
// File:        platform.h
// Description: Place holder
// Author:
// Created:
//
// (C) Copyright 2006, Google Inc.
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
///////////////////////////////////////////////////////////////////////
# 33 "/Users/satavtar/github/tesseract/api/baseapi.h" 2
# 1 "/Users/satavtar/github/tesseract/api/apitypes.h" 1
///////////////////////////////////////////////////////////////////////
// File:        apitypes.h
// Description: Types used in both the API and internally
// Author:      Ray Smith
// Created:     Wed Mar 03 09:22:53 PST 2010
//
// (C) Copyright 2010, Google Inc.
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
///////////////////////////////////////////////////////////////////////





# 1 "/usr/local/include/tesseract/publictypes.h" 1
///////////////////////////////////////////////////////////////////////
// File:        publictypes.h
// Description: Types used in both the API and internally
// Author:      Ray Smith
// Created:     Wed Mar 03 09:22:53 PST 2010
//
// (C) Copyright 2010, Google Inc.
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
///////////////////////////////////////////////////////////////////////




// This file contains types that are used both by the API and internally
// to Tesseract. In order to decouple the API from Tesseract and prevent cyclic
// dependencies, THIS FILE SHOULD NOT DEPEND ON ANY OTHER PART OF TESSERACT.
// Restated: It is OK for low-level Tesseract files to include publictypes.h,
// but not for the low-level tesseract code to include top-level API code.
// This file should not use other Tesseract types, as that would drag
// their includes into the API-level.
// API-level code should include apitypes.h in preference to this file.

/** Number of printers' points in an inch. The unit of the pointsize return. */
const int kPointsPerInch = 72;

/**
 * Possible types for a POLY_BLOCK or ColPartition.
 * Must be kept in sync with kPBColors in polyblk.cpp and PTIs*Type functions
 * below, as well as kPolyBlockNames in publictypes.cpp.
 * Used extensively by ColPartition, and POLY_BLOCK.
*/
enum PolyBlockType {
  PT_UNKNOWN, // Type is not yet known. Keep as the first element.
  PT_FLOWING_TEXT, // Text that lives inside a column.
  PT_HEADING_TEXT, // Text that spans more than one column.
  PT_PULLOUT_TEXT, // Text that is in a cross-column pull-out region.
  PT_EQUATION, // Partition belonging to an equation region.
  PT_INLINE_EQUATION, // Partition has inline equation.
  PT_TABLE, // Partition belonging to a table region.
  PT_VERTICAL_TEXT, // Text-line runs vertically.
  PT_CAPTION_TEXT, // Text that belongs to an image.
  PT_FLOWING_IMAGE, // Image that lives inside a column.
  PT_HEADING_IMAGE, // Image that spans more than one column.
  PT_PULLOUT_IMAGE, // Image that is in a cross-column pull-out region.
  PT_HORZ_LINE, // Horizontal Line.
  PT_VERT_LINE, // Vertical Line.
  PT_NOISE, // Lies outside of any column.
  PT_COUNT
};

/** Returns true if PolyBlockType is of horizontal line type */
inline bool PTIsLineType(PolyBlockType type) {
  return type == PT_HORZ_LINE || type == PT_VERT_LINE;
}
/** Returns true if PolyBlockType is of image type */
inline bool PTIsImageType(PolyBlockType type) {
  return type == PT_FLOWING_IMAGE || type == PT_HEADING_IMAGE ||
         type == PT_PULLOUT_IMAGE;
}
/** Returns true if PolyBlockType is of text type */
inline bool PTIsTextType(PolyBlockType type) {
  return type == PT_FLOWING_TEXT || type == PT_HEADING_TEXT ||
         type == PT_PULLOUT_TEXT || type == PT_TABLE ||
         type == PT_VERTICAL_TEXT || type == PT_CAPTION_TEXT ||
         type == PT_INLINE_EQUATION;
}
// Returns true if PolyBlockType is of pullout(inter-column) type
inline bool PTIsPulloutType(PolyBlockType type) {
  return type == PT_PULLOUT_IMAGE || type == PT_PULLOUT_TEXT;
}

/** String name for each block type. Keep in sync with PolyBlockType. */
extern const char* kPolyBlockNames[];

namespace tesseract {
/**
 *  +------------------+  Orientation Example:
 *  | 1 Aaaa Aaaa Aaaa |  ====================
 *  | Aaa aa aaa aa    |  To left is a diagram of some (1) English and
 *  | aaaaaa A aa aaa. |  (2) Chinese text and a (3) photo credit.
 *  |                2 |
 *  |   #######  c c C |  Upright Latin characters are represented as A and a.
 *  |   #######  c c c |  '<' represents a latin character rotated
 *  | < #######  c c c |      anti-clockwise 90 degrees.
 *  | < #######  c   c |
 *  | < #######  .   c |  Upright Chinese characters are represented C and c.
 *  | 3 #######      c |
 *  +------------------+  NOTA BENE: enum values here should match goodoc.proto

 * If you orient your head so that "up" aligns with Orientation,
 * then the characters will appear "right side up" and readable.
 *
 * In the example above, both the English and Chinese paragraphs are oriented
 * so their "up" is the top of the page (page up).  The photo credit is read
 * with one's head turned leftward ("up" is to page left).
 *
 * The values of this enum match the convention of Tesseract's osdetect.h
*/
enum Orientation {
  ORIENTATION_PAGE_UP = 0,
  ORIENTATION_PAGE_RIGHT = 1,
  ORIENTATION_PAGE_DOWN = 2,
  ORIENTATION_PAGE_LEFT = 3,
};

/**
 * The grapheme clusters within a line of text are laid out logically
 * in this direction, judged when looking at the text line rotated so that
 * its Orientation is "page up".
 *
 * For English text, the writing direction is left-to-right.  For the
 * Chinese text in the above example, the writing direction is top-to-bottom.
*/
enum WritingDirection {
  WRITING_DIRECTION_LEFT_TO_RIGHT = 0,
  WRITING_DIRECTION_RIGHT_TO_LEFT = 1,
  WRITING_DIRECTION_TOP_TO_BOTTOM = 2,
};

/**
 * The text lines are read in the given sequence.
 *
 * In English, the order is top-to-bottom.
 * In Chinese, vertical text lines are read right-to-left.  Mongolian is
 * written in vertical columns top to bottom like Chinese, but the lines
 * order left-to right.
 *
 * Note that only some combinations make sense.  For example,
 * WRITING_DIRECTION_LEFT_TO_RIGHT implies TEXTLINE_ORDER_TOP_TO_BOTTOM
*/
enum TextlineOrder {
  TEXTLINE_ORDER_LEFT_TO_RIGHT = 0,
  TEXTLINE_ORDER_RIGHT_TO_LEFT = 1,
  TEXTLINE_ORDER_TOP_TO_BOTTOM = 2,
};

/**
 * Possible modes for page layout analysis. These *must* be kept in order
 * of decreasing amount of layout analysis to be done, except for OSD_ONLY,
 * so that the inequality test macros below work.
*/
enum PageSegMode {
  PSM_OSD_ONLY, ///< Orientation and script detection only.
  PSM_AUTO_OSD, ///< Automatic page segmentation with orientation and
                      ///< script detection. (OSD)
  PSM_AUTO_ONLY, ///< Automatic page segmentation, but no OSD, or OCR.
  PSM_AUTO, ///< Fully automatic page segmentation, but no OSD.
  PSM_SINGLE_COLUMN, ///< Assume a single column of text of variable sizes.
  PSM_SINGLE_BLOCK_VERT_TEXT, ///< Assume a single uniform block of vertically
                               ///< aligned text.
  PSM_SINGLE_BLOCK, ///< Assume a single uniform block of text. (Default.)
  PSM_SINGLE_LINE, ///< Treat the image as a single text line.
  PSM_SINGLE_WORD, ///< Treat the image as a single word.
  PSM_CIRCLE_WORD, ///< Treat the image as a single word in a circle.
  PSM_SINGLE_CHAR, ///< Treat the image as a single character.
  PSM_SPARSE_TEXT, ///< Find as much text as possible in no particular order.
  PSM_SPARSE_TEXT_OSD, ///< Sparse text with orientation and script det.
  PSM_RAW_LINE, ///< Treat the image as a single text line, bypassing
                      ///< hacks that are Tesseract-specific.

  PSM_COUNT ///< Number of enum entries.
};

/**
 * Inline functions that act on a PageSegMode to determine whether components of
 * layout analysis are enabled.
 * *Depend critically on the order of elements of PageSegMode.*
 * NOTE that arg is an int for compatibility with INT_PARAM.
*/
inline bool PSM_OSD_ENABLED(int pageseg_mode) {
  return pageseg_mode <= PSM_AUTO_OSD || pageseg_mode == PSM_SPARSE_TEXT_OSD;
}
inline bool PSM_ORIENTATION_ENABLED(int pageseg_mode) {
  return pageseg_mode <= PSM_AUTO || pageseg_mode == PSM_SPARSE_TEXT_OSD;
}
inline bool PSM_COL_FIND_ENABLED(int pageseg_mode) {
  return pageseg_mode >= PSM_AUTO_OSD && pageseg_mode <= PSM_AUTO;
}
inline bool PSM_SPARSE(int pageseg_mode) {
  return pageseg_mode == PSM_SPARSE_TEXT || pageseg_mode == PSM_SPARSE_TEXT_OSD;
}
inline bool PSM_BLOCK_FIND_ENABLED(int pageseg_mode) {
  return pageseg_mode >= PSM_AUTO_OSD && pageseg_mode <= PSM_SINGLE_COLUMN;
}
inline bool PSM_LINE_FIND_ENABLED(int pageseg_mode) {
  return pageseg_mode >= PSM_AUTO_OSD && pageseg_mode <= PSM_SINGLE_BLOCK;
}
inline bool PSM_WORD_FIND_ENABLED(int pageseg_mode) {
  return (pageseg_mode >= PSM_AUTO_OSD && pageseg_mode <= PSM_SINGLE_LINE) ||
      pageseg_mode == PSM_SPARSE_TEXT || pageseg_mode == PSM_SPARSE_TEXT_OSD;
}

/**
 * enum of the elements of the page hierarchy, used in ResultIterator
 * to provide functions that operate on each level without having to
 * have 5x as many functions.
*/
enum PageIteratorLevel {
  RIL_BLOCK, // Block of text/image/separator line.
  RIL_PARA, // Paragraph within a block.
  RIL_TEXTLINE, // Line within a paragraph.
  RIL_WORD, // Word within a textline.
  RIL_SYMBOL // Symbol/character within a word.
};

/**
 * JUSTIFICATION_UNKNONW
 *   The alignment is not clearly one of the other options.  This could happen
 *   for example if there are only one or two lines of text or the text looks
 *   like source code or poetry.
 *
 * NOTA BENE: Fully justified paragraphs (text aligned to both left and right
 *    margins) are marked by Tesseract with JUSTIFICATION_LEFT if their text
 *    is written with a left-to-right script and with JUSTIFICATION_RIGHT if
 *    their text is written in a right-to-left script.
 *
 * Interpretation for text read in vertical lines:
 *   "Left" is wherever the starting reading position is.
 *
 * JUSTIFICATION_LEFT
 *   Each line, except possibly the first, is flush to the same left tab stop.
 *
 * JUSTIFICATION_CENTER
 *   The text lines of the paragraph are centered about a line going
 *   down through their middle of the text lines.
 *
 * JUSTIFICATION_RIGHT
 *   Each line, except possibly the first, is flush to the same right tab stop.
*/
enum ParagraphJustification {
  JUSTIFICATION_UNKNOWN,
  JUSTIFICATION_LEFT,
  JUSTIFICATION_CENTER,
  JUSTIFICATION_RIGHT,
};

/**
 * When Tesseract/Cube is initialized we can choose to instantiate/load/run
 * only the Tesseract part, only the Cube part or both along with the combiner.
 * The preference of which engine to use is stored in tessedit_ocr_engine_mode.
 *
 * ATTENTION: When modifying this enum, please make sure to make the
 * appropriate changes to all the enums mirroring it (e.g. OCREngine in
 * cityblock/workflow/detection/detection_storage.proto). Such enums will
 * mention the connection to OcrEngineMode in the comments.
*/
enum OcrEngineMode {
  OEM_TESSERACT_ONLY, // Run Tesseract only - fastest
  OEM_CUBE_ONLY, // Run Cube only - better accuracy, but slower
  OEM_TESSERACT_CUBE_COMBINED, // Run both and combine results - best accuracy
  OEM_DEFAULT // Specify this mode when calling init_*(),
                                // to indicate that any of the above modes
                                // should be automatically inferred from the
                                // variables in the language-specific config,
                                // command-line configs, or if not specified
                                // in any of the above should be set to the
                                // default OEM_TESSERACT_ONLY.
};

} // namespace tesseract.
# 24 "/Users/satavtar/github/tesseract/api/apitypes.h" 2

// The types used by the API and Page/ResultIterator can be found in:
//   ccstruct/publictypes.h
//   ccmain/resultiterator.h
//   ccmain/pageiterator.h
// API interfaces and API users should be sure to include this file, rather
// than the lower-level one, and lower-level code should be sure to include
// only the lower-level file.
# 34 "/Users/satavtar/github/tesseract/api/baseapi.h" 2
# 1 "/usr/local/include/tesseract/thresholder.h" 1
///////////////////////////////////////////////////////////////////////
// File:        thresholder.h
// Description: Base API for thresolding images in tesseract.
// Author:      Ray Smith
// Created:     Mon May 12 11:00:15 PDT 2008
//
// (C) Copyright 2008, Google Inc.
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
///////////////////////////////////////////////////////////////////////







struct Pix;

namespace tesseract {

/// Base class for all tesseract image thresholding classes.
/// Specific classes can add new thresholding methods by
/// overriding ThresholdToPix.
/// Each instance deals with a single image, but the design is intended to
/// be useful for multiple calls to SetRectangle and ThresholdTo* if
/// desired.
class ImageThresholder {
 public:
  ImageThresholder();
  virtual ~ImageThresholder();

  /// Destroy the Pix if there is one, freeing memory.
  virtual void Clear();

  /// Return true if no image has been set.
  bool IsEmpty() const;

  /// SetImage makes a copy of all the image data, so it may be deleted
  /// immediately after this call.
  /// Greyscale of 8 and color of 24 or 32 bits per pixel may be given.
  /// Palette color images will not work properly and must be converted to
  /// 24 bit.
  /// Binary images of 1 bit per pixel may also be given but they must be
  /// byte packed with the MSB of the first byte being the first pixel, and a
  /// one pixel is WHITE. For binary images set bytes_per_pixel=0.
  void SetImage(const unsigned char* imagedata, int width, int height,
                int bytes_per_pixel, int bytes_per_line);

  /// Store the coordinates of the rectangle to process for later use.
  /// Doesn't actually do any thresholding.
  void SetRectangle(int left, int top, int width, int height);

  /// Get enough parameters to be able to rebuild bounding boxes in the
  /// original image (not just within the rectangle).
  /// Left and top are enough with top-down coordinates, but
  /// the height of the rectangle and the image are needed for bottom-up.
  virtual void GetImageSizes(int* left, int* top, int* width, int* height,
                             int* imagewidth, int* imageheight);

  /// Return true if the source image is color.
  bool IsColor() const {
    return pix_channels_ >= 3;
  }

  /// Returns true if the source image is binary.
  bool IsBinary() const {
    return pix_channels_ == 0;
  }

  int GetScaleFactor() const {
    return scale_;
  }

  // Set the resolution of the source image in pixels per inch.
  // This should be called right after SetImage(), and will let us return
  // appropriate font sizes for the text.
  void SetSourceYResolution(int ppi) {
    yres_ = ppi;
    estimated_res_ = ppi;
  }
  int GetSourceYResolution() const {
    return yres_;
  }
  int GetScaledYResolution() const {
    return scale_ * yres_;
  }
  // Set the resolution of the source image in pixels per inch, as estimated
  // by the thresholder from the text size found during thresholding.
  // This value will be used to set internal size thresholds during recognition
  // and will not influence the output "point size." The default value is
  // the same as the source resolution. (yres_)
  void SetEstimatedResolution(int ppi) {
    estimated_res_ = ppi;
  }
  // Returns the estimated resolution, including any active scaling.
  // This value will be used to set internal size thresholds during recognition.
  int GetScaledEstimatedResolution() const {
    return scale_ * estimated_res_;
  }

  /// Pix vs raw, which to use? Pix is the preferred input for efficiency,
  /// since raw buffers are copied.
  /// SetImage for Pix clones its input, so the source pix may be pixDestroyed
  /// immediately after, but may not go away until after the Thresholder has
  /// finished with it.
  void SetImage(const Pix* pix);

  /// Threshold the source image as efficiently as possible to the output Pix.
  /// Creates a Pix and sets pix to point to the resulting pointer.
  /// Caller must use pixDestroy to free the created Pix.
  virtual void ThresholdToPix(PageSegMode pageseg_mode, Pix** pix);

  // Gets a pix that contains an 8 bit threshold value at each pixel. The
  // returned pix may be an integer reduction of the binary image such that
  // the scale factor may be inferred from the ratio of the sizes, even down
  // to the extreme of a 1x1 pixel thresholds image.
  // Ideally the 8 bit threshold should be the exact threshold used to generate
  // the binary image in ThresholdToPix, but this is not a hard constraint.
  // Returns NULL if the input is binary. PixDestroy after use.
  virtual Pix* GetPixRectThresholds();

  /// Get a clone/copy of the source image rectangle.
  /// The returned Pix must be pixDestroyed.
  /// This function will be used in the future by the page layout analysis, and
  /// the layout analysis that uses it will only be available with Leptonica,
  /// so there is no raw equivalent.
  Pix* GetPixRect();

  // Get a clone/copy of the source image rectangle, reduced to greyscale,
  // and at the same resolution as the output binary.
  // The returned Pix must be pixDestroyed.
  // Provided to the classifier to extract features from the greyscale image.
  virtual Pix* GetPixRectGrey();

 protected:
  // ----------------------------------------------------------------------
  // Utility functions that may be useful components for other thresholders.

  /// Common initialization shared between SetImage methods.
  virtual void Init();

  /// Return true if we are processing the full image.
  bool IsFullImage() const {
    return rect_left_ == 0 && rect_top_ == 0 &&
           rect_width_ == image_width_ && rect_height_ == image_height_;
  }

  // Otsu thresholds the rectangle, taking the rectangle from *this.
  void OtsuThresholdRectToPix(Pix* src_pix, Pix** out_pix) const;

  /// Threshold the rectangle, taking everything except the src_pix
  /// from the class, using thresholds/hi_values to the output pix.
  /// NOTE that num_channels is the size of the thresholds and hi_values
  // arrays and also the bytes per pixel in src_pix.
  void ThresholdRectToPix(Pix* src_pix, int num_channels,
                          const int* thresholds, const int* hi_values,
                          Pix** pix) const;

 protected:
  /// Clone or other copy of the source Pix.
  /// The pix will always be PixDestroy()ed on destruction of the class.
  Pix* pix_;

  int image_width_; //< Width of source pix_.
  int image_height_; //< Height of source pix_.
  int pix_channels_; //< Number of 8-bit channels in pix_.
  int pix_wpl_; //< Words per line of pix_.
  // Limits of image rectangle to be processed.
  int scale_; //< Scale factor from original image.
  int yres_; //< y pixels/inch in source image.
  int estimated_res_; //< Resolution estimate from text size.
  int rect_left_;
  int rect_top_;
  int rect_width_;
  int rect_height_;
};

} // namespace tesseract.
# 35 "/Users/satavtar/github/tesseract/api/baseapi.h" 2
# 1 "/usr/local/include/tesseract/unichar.h" 1
///////////////////////////////////////////////////////////////////////
// File:        unichar.h
// Description: Unicode character/ligature class.
// Author:      Ray Smith
// Created:     Wed Jun 28 17:05:01 PDT 2006
//
// (C) Copyright 2006, Google Inc.
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
///////////////////////////////////////////////////////////////////////





# 1 "/usr/include/memory.h" 1 3 4
/*
 * Copyright (c) 1988, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)memory.h	8.1 (Berkeley) 6/2/93
 */
# 24 "/usr/local/include/tesseract/unichar.h" 2


template <typename T> class GenericVector;

// Maximum number of characters that can be stored in a UNICHAR. Must be
// at least 4. Must not exceed 31 without changing the coding of length.


// A UNICHAR_ID is the unique id of a unichar.
typedef int UNICHAR_ID;

// A variable to indicate an invalid or uninitialized unichar id.
static const int INVALID_UNICHAR_ID = -1;
// A special unichar that corresponds to INVALID_UNICHAR_ID.
static const char INVALID_UNICHAR[] = "__INVALID_UNICHAR__";

enum StrongScriptDirection {
  DIR_NEUTRAL = 0, // Text contains only neutral characters.
  DIR_LEFT_TO_RIGHT = 1, // Text contains no Right-to-Left characters.
  DIR_RIGHT_TO_LEFT = 2, // Text contains no Left-to-Right characters.
  DIR_MIX = 3, // Text contains a mixture of left-to-right
                          // and right-to-left characters.
};

// The UNICHAR class holds a single classification result. This may be
// a single Unicode character (stored as between 1 and 4 utf8 bytes) or
// multple Unicode characters representing the NFKC expansion of a ligature
// such as fi, ffl etc. These are also stored as utf8.
class UNICHAR {
 public:
  UNICHAR() {
    memset(chars, 0, 30);
  }

  // Construct from a utf8 string. If len<0 then the string is null terminated.
  // If the string is too long to fit in the UNICHAR then it takes only what
  // will fit.
  UNICHAR(const char* utf8_str, int len);

  // Construct from a single UCS4 character.
  explicit UNICHAR(int unicode);

  // Default copy constructor and operator= are OK.

  // Get the first character as UCS-4.
  int first_uni() const;

  // Get the length of the UTF8 string.
  int utf8_len() const {
    int len = chars[30 - 1];
    return len >=0 && len < 30 ? len : 30;
  }

  // Get a UTF8 string, but NOT NULL terminated.
  const char* utf8() const {
    return chars;
  }

  // Get a terminated UTF8 string: Must delete[] it after use.
  char* utf8_str() const;

  // Get the number of bytes in the first character of the given utf8 string.
  static int utf8_step(const char* utf8_str);

  // A class to simplify iterating over and accessing elements of a UTF8
  // string. Note that unlike the UNICHAR class, const_iterator does NOT COPY or
  // take ownership of the underlying byte array. It also does not permit
  // modification of the array (as the name suggests).
  //
  // Example:
  //   for (UNICHAR::const_iterator it = UNICHAR::begin(str, str_len);
  //        it != UNICHAR::end(str, len);
  //        ++it) {
  //     tprintf("UCS-4 symbol code = %d\n", *it);
  //     char buf[5];
  //     int char_len = it.get_utf8(buf); buf[char_len] = '\0';
  //     tprintf("Char = %s\n", buf);
  //   }
  class const_iterator {
    typedef const_iterator CI;

   public:
    // Step to the next UTF8 character.
    // If the current position is at an illegal UTF8 character, then print an
    // error message and step by one byte. If the current position is at a NULL
    // value, don't step past it.
    const_iterator& operator++();

    // Return the UCS-4 value at the current position.
    // If the current position is at an illegal UTF8 value, return a single
    // space character.
    int operator*() const;

    // Store the UTF-8 encoding of the current codepoint into buf, which must be
    // at least 4 bytes long. Return the number of bytes written.
    // If the current position is at an illegal UTF8 value, writes a single
    // space character and returns 1.
    // Note that this method does not null-terminate the buffer.
    int get_utf8(char* buf) const;
    // Returns the number of bytes of the current codepoint. Returns 1 if the
    // current position is at an illegal UTF8 value.
    int utf8_len() const;
    // Returns true if the UTF-8 encoding at the current position is legal.
    bool is_legal() const;

    // Return the pointer into the string at the current position.
    const char* utf8_data() const { return it_; }

    // Iterator equality operators.
    friend bool operator==(const CI& lhs, const CI& rhs) {
      return lhs.it_ == rhs.it_;
    }
    friend bool operator!=(const CI& lhs, const CI& rhs) {
      return !(lhs == rhs);
    }

   private:
    friend class UNICHAR;
    explicit const_iterator(const char* it) : it_(it) {}

    const char* it_; // Pointer into the string.
  };

  // Create a start/end iterator pointing to a string. Note that these methods
  // are static and do NOT create a copy or take ownership of the underlying
  // array.
  static const_iterator begin(const char* utf8_str, const int byte_length);
  static const_iterator end(const char* utf8_str, const int byte_length);

  // Converts a utf-8 string to a vector of unicodes.
  // Returns false if the input contains invalid UTF-8, and replaces
  // the rest of the string with a single space.
  static bool UTF8ToUnicode(const char* utf8_str, GenericVector<int>* unicodes);

 private:
  // A UTF-8 representation of 1 or more Unicode characters.
  // The last element (chars[UNICHAR_LEN - 1]) is a length if
  // its value < UNICHAR_LEN, otherwise it is a genuine character.
  char chars[30];
};
# 36 "/Users/satavtar/github/tesseract/api/baseapi.h" 2
# 1 "/usr/local/include/tesseract/tesscallback.h" 1
///////////////////////////////////////////////////////////////////////
// File:        tesscallback.h
// Description: classes and functions to replace pointer-to-functions
// Author:      Samuel Charron
//
// (C) Copyright 2006, Google Inc.
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
///////////////////////////////////////////////////////////////////////





# 1 "/usr/local/include/tesseract/host.h" 1
/******************************************************************************
 **  Filename:       Host.h
 **  Purpose:        This is the system independent typedefs and defines
 **  Author:         MN, JG, MD
 **  Version:        5.4.1
 **  History:        11/7/94 MCD received the modification that Lennart made
 **                  to port to 32 bit world and modify this file so that it
 **                  will be shared between platform.
 **                  11/9/94 MCD Make MSW32 subset of MSW. Now MSW means
 **                  MicroSoft Window and MSW32 means the 32 bit worlds
 **                  of MicroSoft Window. Therefore you want the environment
 **                  to be MicroSoft Window and in the 32 bit world -
 **                  _WIN32 must be defined by your compiler.
 **                  11/30/94 MCD Incorporated comments received for more
 **                  readability and the missing typedef for FLOAT.
 **                  12/1/94 MCD Added PFVOID typedef
 **                  5/1/95 MCD. Made many changes based on the inputs.
 **                  Changes:
 **                  1) Rearrange the #ifdef so that there're definitions for
 **                  particular platforms.
 **                  2) Took out the #define for computer and environment
 **                  that developer can uncomment
 **                  3) Added __OLDCODE__ where the defines will be
 **                  obsoleted in the next version and advise not to use.
 **                  4) Added the definitions for the following:
 **                  FILE_HANDLE, MEMORY_HANDLE, BOOL8,
 **                  MAX_INT8, MAX_INT16, MAX_INT32, MAX_UINT8
 **                  MAX_UINT16, MAX_UINT32, MAX_FLOAT32
 **                 06/19/96 MCD. Took out MAX_FLOAT32
 **                 07/15/96 MCD. Fixed the comments error
 **                 Add back BOOL8.
 **
 **  (c) Copyright Hewlett-Packard Company, 1988-1996.
 ** Licensed under the Apache License, Version 2.0 (the "License");
 ** you may not use this file except in compliance with the License.
 ** You may obtain a copy of the License at
 ** http://www.apache.org/licenses/LICENSE-2.0
 ** Unless required by applicable law or agreed to in writing, software
 ** distributed under the License is distributed on an "AS IS" BASIS,
 ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 ** See the License for the specific language governing permissions and
 ** limitations under the License.
 */




/******************************************************************************
 **                                IMPORTANT!!!                                                                                                                 **
 **                                                                                                                                                                              **
 ** Defines either _WIN32, __MAC__, __UNIX__, __OS2__, __PM__ to
 ** use the specified definitions indicated below in the preprocessor settings.                                                        **
 **                                                                                                                                                                              **
 ** Also define either  __FarProc__ or  __FarData__  and __MOTO__ to use the
 ** specified definitions indicated below in the preprocessor settings.                                                                        **
 **                                                                                                                                                                             **
 ** If a preprocessor settings is not allow in the compiler that is being use,
 ** then it is recommended that a "platform.h" is created with the definition
 ** of the computer and/or operating system.
 ******************************************************************************/


/* _WIN32 */





/********************************************************/
/* __MAC__ */





/********************************************************/

/*----------------------------*/
/* FarProc and FarData */
/*----------------------------*/
/*----------------------------*/

/*****************************************************************************
 **
 **                      Standard GHC Definitions
 **
 *****************************************************************************/







//typedef HANDLE FD*  PHANDLE;

// definitions of portable data types (numbers and characters)
typedef signed char inT8;
typedef unsigned char uinT8;
typedef short inT16;
typedef unsigned short uinT16;
typedef int inT32;
typedef unsigned int uinT32;




typedef long long int inT64;
typedef unsigned long long int uinT64;

typedef float FLOAT32;
typedef double FLOAT64;
typedef unsigned char BOOL8;
# 134 "/usr/local/include/tesseract/host.h"
// Defines
# 143 "/usr/local/include/tesseract/host.h"
// Return true if x is within tolerance of y
template<class T> bool NearlyEqual(T x, T y, T tolerance) {
  T diff = x - y;
  return diff <= tolerance && -diff <= tolerance;
}
# 23 "/usr/local/include/tesseract/tesscallback.h" 2

struct TessCallbackUtils_ {
  static void FailIsRepeatable(const char* name);
};


class TessClosure {
 public:
  virtual ~TessClosure() { }
  virtual void Run() = 0;
};

template <class R>
class TessResultCallback {
 public:
  virtual ~TessResultCallback() { }
  virtual R Run() = 0;
};

template <bool del, class R, class T>
class _ConstTessMemberResultCallback_0_0 : public TessResultCallback<R> {
 public:
  typedef TessResultCallback<R> base;
  typedef R (T::*MemberSignature)() const;

 private:
  const T* object_;
  MemberSignature member_;

 public:
  inline _ConstTessMemberResultCallback_0_0(
     const T* object, MemberSignature member)
    : object_(object),
      member_(member) {
  }

  virtual R Run() {
    if (!del) {
      R result = (object_->*member_)();
      return result;
    } else {
      R result = (object_->*member_)();
      //  zero out the pointer to ensure segfault if used again
      member_ = __null;
      delete this;
      return result;
    }
  }
};

template <bool del, class T>
class _ConstTessMemberResultCallback_0_0<del, void, T>
  : public TessClosure {
 public:
  typedef TessClosure base;
  typedef void (T::*MemberSignature)() const;

 private:
  const T* object_;
  MemberSignature member_;

 public:
  inline _ConstTessMemberResultCallback_0_0(
      const T* object, MemberSignature member)
    : object_(object),
      member_(member) {
  }

  virtual void Run() {
    if (!del) {
      (object_->*member_)();
    } else {
      (object_->*member_)();
      //  zero out the pointer to ensure segfault if used again
      member_ = __null;
      delete this;
    }
  }
};


template <class T1, class T2, class R>
inline typename _ConstTessMemberResultCallback_0_0<true,R,T1>::base*
NewTessCallback(
    const T1* obj, R (T2::*member)() const) {
  return new _ConstTessMemberResultCallback_0_0<true,R,T1>(
      obj, member);
}



template <class T1, class T2, class R>
inline typename _ConstTessMemberResultCallback_0_0<false,R,T1>::base*
NewPermanentTessCallback(
    const T1* obj, R (T2::*member)() const) {
  return new _ConstTessMemberResultCallback_0_0<false,R,T1>(
      obj, member);
}


template <bool del, class R, class T>
class _TessMemberResultCallback_0_0 : public TessResultCallback<R> {
 public:
  typedef TessResultCallback<R> base;
  typedef R (T::*MemberSignature)() ;

 private:
  T* object_;
  MemberSignature member_;

 public:
  inline _TessMemberResultCallback_0_0(
      T* object, MemberSignature member)
    : object_(object),
      member_(member) {
  }

  virtual R Run() {
    if (!del) {
      R result = (object_->*member_)();
      return result;
    } else {
      R result = (object_->*member_)();
      //  zero out the pointer to ensure segfault if used again
      member_ = __null;
      delete this;
      return result;
    }
  }
};

template <bool del, class T>
class _TessMemberResultCallback_0_0<del, void, T>
  : public TessClosure {
 public:
  typedef TessClosure base;
  typedef void (T::*MemberSignature)() ;

 private:
  T* object_;
  MemberSignature member_;

 public:
  inline _TessMemberResultCallback_0_0(
       T* object, MemberSignature member)
    : object_(object),
      member_(member) {
  }

  virtual void Run() {
    if (!del) {
      (object_->*member_)();
    } else {
      (object_->*member_)();
      //  zero out the pointer to ensure segfault if used again
      member_ = __null;
      delete this;
    }
  }
};


template <class T1, class T2, class R>
inline typename _TessMemberResultCallback_0_0<true,R,T1>::base*
NewTessCallback(
     T1* obj, R (T2::*member)() ) {
  return new _TessMemberResultCallback_0_0<true,R,T1>(
      obj, member);
}



template <class T1, class T2, class R>
inline typename _TessMemberResultCallback_0_0<false,R,T1>::base*
NewPermanentTessCallback(
     T1* obj, R (T2::*member)() ) {
  return new _TessMemberResultCallback_0_0<false,R,T1>(
      obj, member);
}


template <bool del, class R>
class _TessFunctionResultCallback_0_0 : public TessResultCallback<R> {
 public:
  typedef TessResultCallback<R> base;
  typedef R (*FunctionSignature)();

 private:
  FunctionSignature function_;

 public:
  inline _TessFunctionResultCallback_0_0(
      FunctionSignature function)
    : function_(function) {
  }

  virtual R Run() {
    if (!del) {
      R result = (*function_)();
      return result;
    } else {
      R result = (*function_)();
      //  zero out the pointer to ensure segfault if used again
      function_ = __null;
      delete this;
      return result;
    }
  }
};

template <bool del>
class _TessFunctionResultCallback_0_0<del, void>
  : public TessClosure {
 public:
  typedef TessClosure base;
  typedef void (*FunctionSignature)();

 private:
  FunctionSignature function_;

 public:
  inline _TessFunctionResultCallback_0_0(
      FunctionSignature function)
    : function_(function) {
  }

  virtual void Run() {
    if (!del) {
      (*function_)();
    } else {
      (*function_)();
      //  zero out the pointer to ensure segfault if used again
      function_ = __null;
      delete this;
    }
  }
};

template <class R>
inline typename _TessFunctionResultCallback_0_0<true,R>::base*
NewTessCallback(R (*function)()) {
  return new _TessFunctionResultCallback_0_0<true,R>(function);
}

template <class R>
inline typename _TessFunctionResultCallback_0_0<false,R>::base*
NewPermanentTessCallback(R (*function)()) {
  return new _TessFunctionResultCallback_0_0<false,R>(function);
}



// Specified by TR1 [4.7.2] Reference modifications.
template <class T> struct remove_reference;
template<typename T> struct remove_reference { typedef T type; };
template<typename T> struct remove_reference<T&> { typedef T type; };

// Identity<T>::type is a typedef of T. Useful for preventing the
// compiler from inferring the type of an argument in templates.
template <typename T>
struct Identity {
  typedef T type;
};

template <bool del, class R, class T, class P1>
class _ConstTessMemberResultCallback_1_0 : public TessResultCallback<R> {
 public:
  typedef TessResultCallback<R> base;
  typedef R (T::*MemberSignature)(P1) const;

 private:
  const T* object_;
  MemberSignature member_;
  typename remove_reference<P1>::type p1_;

 public:
  inline _ConstTessMemberResultCallback_1_0(const T* object, MemberSignature member, P1 p1)
    : object_(object),
      member_(member), p1_(p1) { }

  virtual R Run() {
    if (!del) {
      R result = (object_->*member_)(p1_);
      return result;
    } else {
      R result = (object_->*member_)(p1_);
      //  zero out the pointer to ensure segfault if used again
      member_ = __null;
      delete this;
      return result;
    }
  }
};

template <bool del, class T, class P1>
class _ConstTessMemberResultCallback_1_0<del, void, T, P1> : public TessClosure {
 public:
  typedef TessClosure base;
  typedef void (T::*MemberSignature)(P1) const;

 private:
  const T* object_;
  MemberSignature member_;
  typename remove_reference<P1>::type p1_;

 public:
  inline _ConstTessMemberResultCallback_1_0(const T* object, MemberSignature member, P1 p1)
    : object_(object),
      member_(member), p1_(p1) { }

  virtual void Run() {
    if (!del) {
      (object_->*member_)(p1_);
    } else {
      (object_->*member_)(p1_);
      //  zero out the pointer to ensure segfault if used again
      member_ = __null;
      delete this;
    }
  }
};


template <class T1, class T2, class R, class P1>
inline typename _ConstTessMemberResultCallback_1_0<true,R,T1,P1>::base*
NewTessCallback(const T1* obj, R (T2::*member)(P1) const, typename Identity<P1>::type p1) {
  return new _ConstTessMemberResultCallback_1_0<true,R,T1,P1>(obj, member, p1);
}



template <class T1, class T2, class R, class P1>
inline typename _ConstTessMemberResultCallback_1_0<false,R,T1,P1>::base*
NewPermanentTessCallback(const T1* obj, R (T2::*member)(P1) const, typename Identity<P1>::type p1) {
  return new _ConstTessMemberResultCallback_1_0<false,R,T1,P1>(obj, member, p1);
}


template <bool del, class R, class T, class P1>
class _TessMemberResultCallback_1_0 : public TessResultCallback<R> {
 public:
  typedef TessResultCallback<R> base;
  typedef R (T::*MemberSignature)(P1) ;

 private:
   T* object_;
  MemberSignature member_;
  typename remove_reference<P1>::type p1_;

 public:
  inline _TessMemberResultCallback_1_0( T* object, MemberSignature member, P1 p1)
    : object_(object),
      member_(member), p1_(p1) { }

  virtual R Run() {
    if (!del) {
      R result = (object_->*member_)(p1_);
      return result;
    } else {
      R result = (object_->*member_)(p1_);
      //  zero out the pointer to ensure segfault if used again
      member_ = __null;
      delete this;
      return result;
    }
  }
};

template <bool del, class T, class P1>
class _TessMemberResultCallback_1_0<del, void, T, P1> : public TessClosure {
 public:
  typedef TessClosure base;
  typedef void (T::*MemberSignature)(P1) ;

 private:
   T* object_;
  MemberSignature member_;
  typename remove_reference<P1>::type p1_;

 public:
  inline _TessMemberResultCallback_1_0( T* object, MemberSignature member, P1 p1)
    : object_(object),
      member_(member), p1_(p1) { }

  virtual void Run() {
    if (!del) {
      (object_->*member_)(p1_);
    } else {
      (object_->*member_)(p1_);
      //  zero out the pointer to ensure segfault if used again
      member_ = __null;
      delete this;
    }
  }
};


template <class T1, class T2, class R, class P1>
inline typename _TessMemberResultCallback_1_0<true,R,T1,P1>::base*
NewTessCallback( T1* obj, R (T2::*member)(P1) , typename Identity<P1>::type p1) {
  return new _TessMemberResultCallback_1_0<true,R,T1,P1>(obj, member, p1);
}



template <class T1, class T2, class R, class P1>
inline typename _TessMemberResultCallback_1_0<false,R,T1,P1>::base*
NewPermanentTessCallback( T1* obj, R (T2::*member)(P1) , typename Identity<P1>::type p1) {
  return new _TessMemberResultCallback_1_0<false,R,T1,P1>(obj, member, p1);
}


template <bool del, class R, class P1>
class _TessFunctionResultCallback_1_0 : public TessResultCallback<R> {
 public:
  typedef TessResultCallback<R> base;
  typedef R (*FunctionSignature)(P1);

 private:
  FunctionSignature function_;
  typename remove_reference<P1>::type p1_;

 public:
  inline _TessFunctionResultCallback_1_0(FunctionSignature function, P1 p1)
    : function_(function), p1_(p1) { }

  virtual R Run() {
    if (!del) {
      R result = (*function_)(p1_);
      return result;
    } else {
      R result = (*function_)(p1_);
      //  zero out the pointer to ensure segfault if used again
      function_ = __null;
      delete this;
      return result;
    }
  }
};

template <bool del, class P1>
class _TessFunctionResultCallback_1_0<del, void, P1> : public TessClosure {
 public:
  typedef TessClosure base;
  typedef void (*FunctionSignature)(P1);

 private:
  FunctionSignature function_;
  typename remove_reference<P1>::type p1_;

 public:
  inline _TessFunctionResultCallback_1_0(FunctionSignature function, P1 p1)
    : function_(function), p1_(p1) { }

  virtual void Run() {
    if (!del) {
      (*function_)(p1_);
    } else {
      (*function_)(p1_);
      //  zero out the pointer to ensure segfault if used again
      function_ = __null;
      delete this;
    }
  }
};

template <class R, class P1>
inline typename _TessFunctionResultCallback_1_0<true,R,P1>::base*
NewTessCallback(R (*function)(P1), typename Identity<P1>::type p1) {
  return new _TessFunctionResultCallback_1_0<true,R,P1>(function, p1);
}

template <class R, class P1>
inline typename _TessFunctionResultCallback_1_0<false,R,P1>::base*
NewPermanentTessCallback(R (*function)(P1), typename Identity<P1>::type p1) {
  return new _TessFunctionResultCallback_1_0<false,R,P1>(function, p1);
}

template <bool del, class R, class T, class P1, class P2>
class _ConstTessMemberResultCallback_2_0 : public TessResultCallback<R> {
 public:
  typedef TessResultCallback<R> base;
  typedef R (T::*MemberSignature)(P1,P2) const;

 private:
  const T* object_;
  MemberSignature member_;
  typename remove_reference<P1>::type p1_;
  typename remove_reference<P2>::type p2_;

 public:
  inline _ConstTessMemberResultCallback_2_0(const T* object, MemberSignature member, P1 p1, P2 p2)
    : object_(object),
      member_(member), p1_(p1), p2_(p2) { }

  virtual R Run() {
    if (!del) {
      R result = (object_->*member_)(p1_,p2_);
      return result;
    } else {
      R result = (object_->*member_)(p1_,p2_);
      //  zero out the pointer to ensure segfault if used again
      member_ = __null;
      delete this;
      return result;
    }
  }
};

template <bool del, class T, class P1, class P2>
class _ConstTessMemberResultCallback_2_0<del, void, T, P1, P2> : public TessClosure {
 public:
  typedef TessClosure base;
  typedef void (T::*MemberSignature)(P1,P2) const;

 private:
  const T* object_;
  MemberSignature member_;
  typename remove_reference<P1>::type p1_;
  typename remove_reference<P2>::type p2_;

 public:
  inline _ConstTessMemberResultCallback_2_0(const T* object, MemberSignature member, P1 p1, P2 p2)
    :
      object_(object),
      member_(member), p1_(p1), p2_(p2) { }

  virtual void Run() {
    if (!del) {
      (object_->*member_)(p1_,p2_);
    } else {
      (object_->*member_)(p1_,p2_);
      //  zero out the pointer to ensure segfault if used again
      member_ = __null;
      delete this;
    }
  }
};


template <class T1, class T2, class R, class P1, class P2>
inline typename _ConstTessMemberResultCallback_2_0<true,R,T1,P1,P2>::base*
NewTessCallback(const T1* obj, R (T2::*member)(P1,P2) const, typename Identity<P1>::type p1, typename Identity<P2>::type p2) {
  return new _ConstTessMemberResultCallback_2_0<true,R,T1,P1,P2>(obj, member, p1, p2);
}



template <class T1, class T2, class R, class P1, class P2>
inline typename _ConstTessMemberResultCallback_2_0<false,R,T1,P1,P2>::base*
NewPermanentTessCallback(const T1* obj, R (T2::*member)(P1,P2) const, typename Identity<P1>::type p1, typename Identity<P2>::type p2) {
  return new _ConstTessMemberResultCallback_2_0<false,R,T1,P1,P2>(obj, member, p1, p2);
}


template <bool del, class R, class T, class P1, class P2>
class _TessMemberResultCallback_2_0 : public TessResultCallback<R> {
 public:
  typedef TessResultCallback<R> base;
  typedef R (T::*MemberSignature)(P1,P2) ;

 private:
   T* object_;
  MemberSignature member_;
  typename remove_reference<P1>::type p1_;
  typename remove_reference<P2>::type p2_;

 public:
  inline _TessMemberResultCallback_2_0( T* object, MemberSignature member, P1 p1, P2 p2)
    : object_(object),
      member_(member), p1_(p1), p2_(p2) { }

  virtual R Run() {
    if (!del) {
      R result = (object_->*member_)(p1_,p2_);
      return result;
    } else {
      R result = (object_->*member_)(p1_,p2_);
      //  zero out the pointer to ensure segfault if used again
      member_ = __null;
      delete this;
      return result;
    }
  }
};

template <bool del, class T, class P1, class P2>
class _TessMemberResultCallback_2_0<del, void, T, P1, P2> : public TessClosure {
 public:
  typedef TessClosure base;
  typedef void (T::*MemberSignature)(P1,P2) ;

 private:
   T* object_;
  MemberSignature member_;
  typename remove_reference<P1>::type p1_;
  typename remove_reference<P2>::type p2_;

 public:
  inline _TessMemberResultCallback_2_0( T* object, MemberSignature member, P1 p1, P2 p2)
    :
      object_(object),
      member_(member), p1_(p1), p2_(p2) { }

  virtual void Run() {
    if (!del) {
      (object_->*member_)(p1_,p2_);
    } else {
      (object_->*member_)(p1_,p2_);
      //  zero out the pointer to ensure segfault if used again
      member_ = __null;
      delete this;
    }
  }
};


template <class T1, class T2, class R, class P1, class P2>
inline typename _TessMemberResultCallback_2_0<true,R,T1,P1,P2>::base*
NewTessCallback( T1* obj, R (T2::*member)(P1,P2) , typename Identity<P1>::type p1, typename Identity<P2>::type p2) {
  return new _TessMemberResultCallback_2_0<true,R,T1,P1,P2>(obj, member, p1, p2);
}



template <class T1, class T2, class R, class P1, class P2>
inline typename _TessMemberResultCallback_2_0<false,R,T1,P1,P2>::base*
NewPermanentTessCallback( T1* obj, R (T2::*member)(P1,P2) , typename Identity<P1>::type p1, typename Identity<P2>::type p2) {
  return new _TessMemberResultCallback_2_0<false,R,T1,P1,P2>(obj, member, p1, p2);
}


template <bool del, class R, class P1, class P2>
class _TessFunctionResultCallback_2_0 : public TessResultCallback<R> {
 public:
  typedef TessResultCallback<R> base;
  typedef R (*FunctionSignature)(P1,P2);

 private:
  FunctionSignature function_;
  typename remove_reference<P1>::type p1_;
  typename remove_reference<P2>::type p2_;

 public:
  inline _TessFunctionResultCallback_2_0(FunctionSignature function, P1 p1, P2 p2)
    : function_(function), p1_(p1), p2_(p2) { }

  virtual R Run() {
    if (!del) {
      R result = (*function_)(p1_,p2_);
      return result;
    } else {
      R result = (*function_)(p1_,p2_);
      //  zero out the pointer to ensure segfault if used again
      function_ = __null;
      delete this;
      return result;
    }
  }
};

template <bool del, class P1, class P2>
class _TessFunctionResultCallback_2_0<del, void, P1, P2> : public TessClosure {
 public:
  typedef TessClosure base;
  typedef void (*FunctionSignature)(P1,P2);

 private:
  FunctionSignature function_;
  typename remove_reference<P1>::type p1_;
  typename remove_reference<P2>::type p2_;

 public:
  inline _TessFunctionResultCallback_2_0(FunctionSignature function, P1 p1, P2 p2)
    :
      function_(function), p1_(p1), p2_(p2) { }

  virtual void Run() {
    if (!del) {
      (*function_)(p1_,p2_);
    } else {
      (*function_)(p1_,p2_);
      //  zero out the pointer to ensure segfault if used again
      function_ = __null;
      delete this;
    }
  }
};

template <class R, class P1, class P2>
inline typename _TessFunctionResultCallback_2_0<true,R,P1,P2>::base*
NewTessCallback(R (*function)(P1,P2), typename Identity<P1>::type p1, typename Identity<P2>::type p2) {
  return new _TessFunctionResultCallback_2_0<true,R,P1,P2>(function, p1, p2);
}

template <class R, class P1, class P2>
inline typename _TessFunctionResultCallback_2_0<false,R,P1,P2>::base*
NewPermanentTessCallback(R (*function)(P1,P2), typename Identity<P1>::type p1, typename Identity<P2>::type p2) {
  return new _TessFunctionResultCallback_2_0<false,R,P1,P2>(function, p1, p2);
}

template <bool del, class R, class T, class P1, class P2, class P3>
class _ConstTessMemberResultCallback_3_0 : public TessResultCallback<R> {
 public:
  typedef TessResultCallback<R> base;
  typedef R (T::*MemberSignature)(P1,P2,P3) const;

 private:
  const T* object_;
  MemberSignature member_;
  typename remove_reference<P1>::type p1_;
  typename remove_reference<P2>::type p2_;
  typename remove_reference<P3>::type p3_;

 public:
  inline _ConstTessMemberResultCallback_3_0(const T* object, MemberSignature member, P1 p1, P2 p2, P3 p3)
    :
      object_(object),
      member_(member), p1_(p1), p2_(p2), p3_(p3) { }

  virtual R Run() {
    if (!del) {
      R result = (object_->*member_)(p1_,p2_,p3_);
      return result;
    } else {
      R result = (object_->*member_)(p1_,p2_,p3_);
      //  zero out the pointer to ensure segfault if used again
      member_ = __null;
      delete this;
      return result;
    }
  }
};

template <bool del, class T, class P1, class P2, class P3>
class _ConstTessMemberResultCallback_3_0<del, void, T, P1, P2, P3> : public TessClosure {
 public:
  typedef TessClosure base;
  typedef void (T::*MemberSignature)(P1,P2,P3) const;

 private:
  const T* object_;
  MemberSignature member_;
  typename remove_reference<P1>::type p1_;
  typename remove_reference<P2>::type p2_;
  typename remove_reference<P3>::type p3_;

 public:
  inline _ConstTessMemberResultCallback_3_0(const T* object, MemberSignature member, P1 p1, P2 p2, P3 p3)
    : object_(object),
      member_(member), p1_(p1), p2_(p2), p3_(p3) { }

  virtual void Run() {
    if (!del) {
      (object_->*member_)(p1_,p2_,p3_);
    } else {
      (object_->*member_)(p1_,p2_,p3_);
      //  zero out the pointer to ensure segfault if used again
      member_ = __null;
      delete this;
    }
  }
};


template <class T1, class T2, class R, class P1, class P2, class P3>
inline typename _ConstTessMemberResultCallback_3_0<true,R,T1,P1,P2,P3>::base*
NewTessCallback(const T1* obj, R (T2::*member)(P1,P2,P3) const, typename Identity<P1>::type p1, typename Identity<P2>::type p2, typename Identity<P3>::type p3) {
  return new _ConstTessMemberResultCallback_3_0<true,R,T1,P1,P2,P3>(obj, member, p1, p2, p3);
}



template <class T1, class T2, class R, class P1, class P2, class P3>
inline typename _ConstTessMemberResultCallback_3_0<false,R,T1,P1,P2,P3>::base*
NewPermanentTessCallback(const T1* obj, R (T2::*member)(P1,P2,P3) const, typename Identity<P1>::type p1, typename Identity<P2>::type p2, typename Identity<P3>::type p3) {
  return new _ConstTessMemberResultCallback_3_0<false,R,T1,P1,P2,P3>(obj, member, p1, p2, p3);
}


template <bool del, class R, class T, class P1, class P2, class P3>
class _TessMemberResultCallback_3_0 : public TessResultCallback<R> {
 public:
  typedef TessResultCallback<R> base;
  typedef R (T::*MemberSignature)(P1,P2,P3) ;

 private:
   T* object_;
  MemberSignature member_;
  typename remove_reference<P1>::type p1_;
  typename remove_reference<P2>::type p2_;
  typename remove_reference<P3>::type p3_;

 public:
  inline _TessMemberResultCallback_3_0( T* object, MemberSignature member, P1 p1, P2 p2, P3 p3)
    : object_(object),
      member_(member), p1_(p1), p2_(p2), p3_(p3) { }

  virtual R Run() {
    if (!del) {
      R result = (object_->*member_)(p1_,p2_,p3_);
      return result;
    } else {
      R result = (object_->*member_)(p1_,p2_,p3_);
      //  zero out the pointer to ensure segfault if used again
      member_ = __null;
      delete this;
      return result;
    }
  }
};

template <bool del, class T, class P1, class P2, class P3>
class _TessMemberResultCallback_3_0<del, void, T, P1, P2, P3> : public TessClosure {
 public:
  typedef TessClosure base;
  typedef void (T::*MemberSignature)(P1,P2,P3) ;

 private:
   T* object_;
  MemberSignature member_;
  typename remove_reference<P1>::type p1_;
  typename remove_reference<P2>::type p2_;
  typename remove_reference<P3>::type p3_;

 public:
  inline _TessMemberResultCallback_3_0( T* object, MemberSignature member, P1 p1, P2 p2, P3 p3)
    : object_(object),
      member_(member), p1_(p1), p2_(p2), p3_(p3) { }

  virtual void Run() {
    if (!del) {
      (object_->*member_)(p1_,p2_,p3_);
    } else {
      (object_->*member_)(p1_,p2_,p3_);
      //  zero out the pointer to ensure segfault if used again
      member_ = __null;
      delete this;
    }
  }
};


template <class T1, class T2, class R, class P1, class P2, class P3>
inline typename _TessMemberResultCallback_3_0<true,R,T1,P1,P2,P3>::base*
NewTessCallback( T1* obj, R (T2::*member)(P1,P2,P3) , typename Identity<P1>::type p1, typename Identity<P2>::type p2, typename Identity<P3>::type p3) {
  return new _TessMemberResultCallback_3_0<true,R,T1,P1,P2,P3>(obj, member, p1, p2, p3);
}



template <class T1, class T2, class R, class P1, class P2, class P3>
inline typename _TessMemberResultCallback_3_0<false,R,T1,P1,P2,P3>::base*
NewPermanentTessCallback( T1* obj, R (T2::*member)(P1,P2,P3) , typename Identity<P1>::type p1, typename Identity<P2>::type p2, typename Identity<P3>::type p3) {
  return new _TessMemberResultCallback_3_0<false,R,T1,P1,P2,P3>(obj, member, p1, p2, p3);
}


template <bool del, class R, class P1, class P2, class P3>
class _TessFunctionResultCallback_3_0 : public TessResultCallback<R> {
 public:
  typedef TessResultCallback<R> base;
  typedef R (*FunctionSignature)(P1,P2,P3);

 private:
  FunctionSignature function_;
  typename remove_reference<P1>::type p1_;
  typename remove_reference<P2>::type p2_;
  typename remove_reference<P3>::type p3_;

 public:
  inline _TessFunctionResultCallback_3_0(FunctionSignature function, P1 p1, P2 p2, P3 p3)
    : function_(function), p1_(p1), p2_(p2), p3_(p3) { }

  virtual R Run() {
    if (!del) {
      R result = (*function_)(p1_,p2_,p3_);
      return result;
    } else {
      R result = (*function_)(p1_,p2_,p3_);
      //  zero out the pointer to ensure segfault if used again
      function_ = __null;
      delete this;
      return result;
    }
  }
};

template <bool del, class P1, class P2, class P3>
class _TessFunctionResultCallback_3_0<del, void, P1, P2, P3> : public TessClosure {
 public:
  typedef TessClosure base;
  typedef void (*FunctionSignature)(P1,P2,P3);

 private:
  FunctionSignature function_;
  typename remove_reference<P1>::type p1_;
  typename remove_reference<P2>::type p2_;
  typename remove_reference<P3>::type p3_;

 public:
  inline _TessFunctionResultCallback_3_0(FunctionSignature function, P1 p1, P2 p2, P3 p3)
    : function_(function), p1_(p1), p2_(p2), p3_(p3) { }

  virtual void Run() {
    if (!del) {
      (*function_)(p1_,p2_,p3_);
    } else {
      (*function_)(p1_,p2_,p3_);
      //  zero out the pointer to ensure segfault if used again
      function_ = __null;
      delete this;
    }
  }
};

template <class R, class P1, class P2, class P3>
inline typename _TessFunctionResultCallback_3_0<true,R,P1,P2,P3>::base*
NewTessCallback(R (*function)(P1,P2,P3), typename Identity<P1>::type p1, typename Identity<P2>::type p2, typename Identity<P3>::type p3) {
  return new _TessFunctionResultCallback_3_0<true,R,P1,P2,P3>(function, p1, p2, p3);
}

template <class R, class P1, class P2, class P3>
inline typename _TessFunctionResultCallback_3_0<false,R,P1,P2,P3>::base*
NewPermanentTessCallback(R (*function)(P1,P2,P3), typename Identity<P1>::type p1, typename Identity<P2>::type p2, typename Identity<P3>::type p3) {
  return new _TessFunctionResultCallback_3_0<false,R,P1,P2,P3>(function, p1, p2, p3);
}

template <bool del, class R, class T, class P1, class P2, class P3, class P4>
class _ConstTessMemberResultCallback_4_0 : public TessResultCallback<R> {
 public:
  typedef TessResultCallback<R> base;
  typedef R (T::*MemberSignature)(P1,P2,P3,P4) const;

 private:
  const T* object_;
  MemberSignature member_;
  typename remove_reference<P1>::type p1_;
  typename remove_reference<P2>::type p2_;
  typename remove_reference<P3>::type p3_;
  typename remove_reference<P4>::type p4_;

 public:
  inline _ConstTessMemberResultCallback_4_0(const T* object, MemberSignature member, P1 p1, P2 p2, P3 p3, P4 p4)
    : object_(object),
      member_(member), p1_(p1), p2_(p2), p3_(p3), p4_(p4) { }

  virtual R Run() {
    if (!del) {
      R result = (object_->*member_)(p1_,p2_,p3_,p4_);
      return result;
    } else {
      R result = (object_->*member_)(p1_,p2_,p3_,p4_);
      //  zero out the pointer to ensure segfault if used again
      member_ = __null;
      delete this;
      return result;
    }
  }
};

template <bool del, class T, class P1, class P2, class P3, class P4>
class _ConstTessMemberResultCallback_4_0<del, void, T, P1, P2, P3, P4> : public TessClosure {
 public:
  typedef TessClosure base;
  typedef void (T::*MemberSignature)(P1,P2,P3,P4) const;

 private:
  const T* object_;
  MemberSignature member_;
  typename remove_reference<P1>::type p1_;
  typename remove_reference<P2>::type p2_;
  typename remove_reference<P3>::type p3_;
  typename remove_reference<P4>::type p4_;

 public:
  inline _ConstTessMemberResultCallback_4_0(const T* object, MemberSignature member, P1 p1, P2 p2, P3 p3, P4 p4)
    : object_(object),
      member_(member), p1_(p1), p2_(p2), p3_(p3), p4_(p4) { }

  virtual void Run() {
    if (!del) {
      (object_->*member_)(p1_,p2_,p3_,p4_);
    } else {
      (object_->*member_)(p1_,p2_,p3_,p4_);
      //  zero out the pointer to ensure segfault if used again
      member_ = __null;
      delete this;
    }
  }
};


template <class T1, class T2, class R, class P1, class P2, class P3, class P4>
inline typename _ConstTessMemberResultCallback_4_0<true,R,T1,P1,P2,P3,P4>::base*
NewTessCallback(const T1* obj, R (T2::*member)(P1,P2,P3,P4) const, typename Identity<P1>::type p1, typename Identity<P2>::type p2, typename Identity<P3>::type p3, typename Identity<P4>::type p4) {
  return new _ConstTessMemberResultCallback_4_0<true,R,T1,P1,P2,P3,P4>(obj, member, p1, p2, p3, p4);
}



template <class T1, class T2, class R, class P1, class P2, class P3, class P4>
inline typename _ConstTessMemberResultCallback_4_0<false,R,T1,P1,P2,P3,P4>::base*
NewPermanentTessCallback(const T1* obj, R (T2::*member)(P1,P2,P3,P4) const, typename Identity<P1>::type p1, typename Identity<P2>::type p2, typename Identity<P3>::type p3, typename Identity<P4>::type p4) {
  return new _ConstTessMemberResultCallback_4_0<false,R,T1,P1,P2,P3,P4>(obj, member, p1, p2, p3, p4);
}


template <bool del, class R, class T, class P1, class P2, class P3, class P4>
class _TessMemberResultCallback_4_0 : public TessResultCallback<R> {
 public:
  typedef TessResultCallback<R> base;
  typedef R (T::*MemberSignature)(P1,P2,P3,P4) ;

 private:
   T* object_;
  MemberSignature member_;
  typename remove_reference<P1>::type p1_;
  typename remove_reference<P2>::type p2_;
  typename remove_reference<P3>::type p3_;
  typename remove_reference<P4>::type p4_;

 public:
  inline _TessMemberResultCallback_4_0( T* object, MemberSignature member, P1 p1, P2 p2, P3 p3, P4 p4)
    : object_(object),
      member_(member), p1_(p1), p2_(p2), p3_(p3), p4_(p4) { }

  virtual R Run() {
    if (!del) {
      R result = (object_->*member_)(p1_,p2_,p3_,p4_);
      return result;
    } else {
      R result = (object_->*member_)(p1_,p2_,p3_,p4_);
      //  zero out the pointer to ensure segfault if used again
      member_ = __null;
      delete this;
      return result;
    }
  }
};

template <bool del, class T, class P1, class P2, class P3, class P4>
class _TessMemberResultCallback_4_0<del, void, T, P1, P2, P3, P4> : public TessClosure {
 public:
  typedef TessClosure base;
  typedef void (T::*MemberSignature)(P1,P2,P3,P4) ;

 private:
   T* object_;
  MemberSignature member_;
  typename remove_reference<P1>::type p1_;
  typename remove_reference<P2>::type p2_;
  typename remove_reference<P3>::type p3_;
  typename remove_reference<P4>::type p4_;

 public:
  inline _TessMemberResultCallback_4_0( T* object, MemberSignature member, P1 p1, P2 p2, P3 p3, P4 p4)
    : object_(object),
      member_(member), p1_(p1), p2_(p2), p3_(p3), p4_(p4) { }

  virtual void Run() {
    if (!del) {
      (object_->*member_)(p1_,p2_,p3_,p4_);
    } else {
      (object_->*member_)(p1_,p2_,p3_,p4_);
      //  zero out the pointer to ensure segfault if used again
      member_ = __null;
      delete this;
    }
  }
};


template <class T1, class T2, class R, class P1, class P2, class P3, class P4>
inline typename _TessMemberResultCallback_4_0<true,R,T1,P1,P2,P3,P4>::base*
NewTessCallback( T1* obj, R (T2::*member)(P1,P2,P3,P4) , typename Identity<P1>::type p1, typename Identity<P2>::type p2, typename Identity<P3>::type p3, typename Identity<P4>::type p4) {
  return new _TessMemberResultCallback_4_0<true,R,T1,P1,P2,P3,P4>(obj, member, p1, p2, p3, p4);
}



template <class T1, class T2, class R, class P1, class P2, class P3, class P4>
inline typename _TessMemberResultCallback_4_0<false,R,T1,P1,P2,P3,P4>::base*
NewPermanentTessCallback( T1* obj, R (T2::*member)(P1,P2,P3,P4) , typename Identity<P1>::type p1, typename Identity<P2>::type p2, typename Identity<P3>::type p3, typename Identity<P4>::type p4) {
  return new _TessMemberResultCallback_4_0<false,R,T1,P1,P2,P3,P4>(obj, member, p1, p2, p3, p4);
}


template <bool del, class R, class P1, class P2, class P3, class P4>
class _TessFunctionResultCallback_4_0 : public TessResultCallback<R> {
 public:
  typedef TessResultCallback<R> base;
  typedef R (*FunctionSignature)(P1,P2,P3,P4);

 private:
  FunctionSignature function_;
  typename remove_reference<P1>::type p1_;
  typename remove_reference<P2>::type p2_;
  typename remove_reference<P3>::type p3_;
  typename remove_reference<P4>::type p4_;

 public:
  inline _TessFunctionResultCallback_4_0(FunctionSignature function, P1 p1, P2 p2, P3 p3, P4 p4)
    : function_(function), p1_(p1), p2_(p2), p3_(p3), p4_(p4) { }

  virtual R Run() {
    if (!del) {
      R result = (*function_)(p1_,p2_,p3_,p4_);
      return result;
    } else {
      R result = (*function_)(p1_,p2_,p3_,p4_);
      //  zero out the pointer to ensure segfault if used again
      function_ = __null;
      delete this;
      return result;
    }
  }
};

template <bool del, class P1, class P2, class P3, class P4>
class _TessFunctionResultCallback_4_0<del, void, P1, P2, P3, P4> : public TessClosure {
 public:
  typedef TessClosure base;
  typedef void (*FunctionSignature)(P1,P2,P3,P4);

 private:
  FunctionSignature function_;
  typename remove_reference<P1>::type p1_;
  typename remove_reference<P2>::type p2_;
  typename remove_reference<P3>::type p3_;
  typename remove_reference<P4>::type p4_;

 public:
  inline _TessFunctionResultCallback_4_0(FunctionSignature function, P1 p1, P2 p2, P3 p3, P4 p4)
    : function_(function), p1_(p1), p2_(p2), p3_(p3), p4_(p4) { }

  virtual void Run() {
    if (!del) {
      (*function_)(p1_,p2_,p3_,p4_);
    } else {
      (*function_)(p1_,p2_,p3_,p4_);
      //  zero out the pointer to ensure segfault if used again
      function_ = __null;
      delete this;
    }
  }
};

template <class R, class P1, class P2, class P3, class P4>
inline typename _TessFunctionResultCallback_4_0<true,R,P1,P2,P3,P4>::base*
NewTessCallback(R (*function)(P1,P2,P3,P4), typename Identity<P1>::type p1, typename Identity<P2>::type p2, typename Identity<P3>::type p3, typename Identity<P4>::type p4) {
  return new _TessFunctionResultCallback_4_0<true,R,P1,P2,P3,P4>(function, p1, p2, p3, p4);
}

template <class R, class P1, class P2, class P3, class P4>
inline typename _TessFunctionResultCallback_4_0<false,R,P1,P2,P3,P4>::base*
NewPermanentTessCallback(R (*function)(P1,P2,P3,P4), typename Identity<P1>::type p1, typename Identity<P2>::type p2, typename Identity<P3>::type p3, typename Identity<P4>::type p4) {
  return new _TessFunctionResultCallback_4_0<false,R,P1,P2,P3,P4>(function, p1, p2, p3, p4);
}

template <bool del, class R, class T, class P1, class P2, class P3, class P4, class P5>
class _ConstTessMemberResultCallback_5_0 : public TessResultCallback<R> {
 public:
  typedef TessResultCallback<R> base;
  typedef R (T::*MemberSignature)(P1,P2,P3,P4,P5) const;

 private:
  const T* object_;
  MemberSignature member_;
  typename remove_reference<P1>::type p1_;
  typename remove_reference<P2>::type p2_;
  typename remove_reference<P3>::type p3_;
  typename remove_reference<P4>::type p4_;
  typename remove_reference<P5>::type p5_;

 public:
  inline _ConstTessMemberResultCallback_5_0(const T* object, MemberSignature member, P1 p1, P2 p2, P3 p3, P4 p4, P5 p5)
    : object_(object),
      member_(member), p1_(p1), p2_(p2), p3_(p3), p4_(p4), p5_(p5) { }

  virtual R Run() {
    if (!del) {
      R result = (object_->*member_)(p1_,p2_,p3_,p4_,p5_);
      return result;
    } else {
      R result = (object_->*member_)(p1_,p2_,p3_,p4_,p5_);
      //  zero out the pointer to ensure segfault if used again
      member_ = __null;
      delete this;
      return result;
    }
  }
};

template <bool del, class T, class P1, class P2, class P3, class P4, class P5>
class _ConstTessMemberResultCallback_5_0<del, void, T, P1, P2, P3, P4, P5> : public TessClosure {
 public:
  typedef TessClosure base;
  typedef void (T::*MemberSignature)(P1,P2,P3,P4,P5) const;

 private:
  const T* object_;
  MemberSignature member_;
  typename remove_reference<P1>::type p1_;
  typename remove_reference<P2>::type p2_;
  typename remove_reference<P3>::type p3_;
  typename remove_reference<P4>::type p4_;
  typename remove_reference<P5>::type p5_;

 public:
  inline _ConstTessMemberResultCallback_5_0(const T* object, MemberSignature member, P1 p1, P2 p2, P3 p3, P4 p4, P5 p5)
    : object_(object),
      member_(member), p1_(p1), p2_(p2), p3_(p3), p4_(p4), p5_(p5) { }

  virtual void Run() {
    if (!del) {
      (object_->*member_)(p1_,p2_,p3_,p4_,p5_);
    } else {
      (object_->*member_)(p1_,p2_,p3_,p4_,p5_);
      //  zero out the pointer to ensure segfault if used again
      member_ = __null;
      delete this;
    }
  }
};


template <class T1, class T2, class R, class P1, class P2, class P3, class P4, class P5>
inline typename _ConstTessMemberResultCallback_5_0<true,R,T1,P1,P2,P3,P4,P5>::base*
NewTessCallback(const T1* obj, R (T2::*member)(P1,P2,P3,P4,P5) const, typename Identity<P1>::type p1, typename Identity<P2>::type p2, typename Identity<P3>::type p3, typename Identity<P4>::type p4, typename Identity<P5>::type p5) {
  return new _ConstTessMemberResultCallback_5_0<true,R,T1,P1,P2,P3,P4,P5>(obj, member, p1, p2, p3, p4, p5);
}



template <class T1, class T2, class R, class P1, class P2, class P3, class P4, class P5>
inline typename _ConstTessMemberResultCallback_5_0<false,R,T1,P1,P2,P3,P4,P5>::base*
NewPermanentTessCallback(const T1* obj, R (T2::*member)(P1,P2,P3,P4,P5) const, typename Identity<P1>::type p1, typename Identity<P2>::type p2, typename Identity<P3>::type p3, typename Identity<P4>::type p4, typename Identity<P5>::type p5) {
  return new _ConstTessMemberResultCallback_5_0<false,R,T1,P1,P2,P3,P4,P5>(obj, member, p1, p2, p3, p4, p5);
}


template <bool del, class R, class T, class P1, class P2, class P3, class P4, class P5>
class _TessMemberResultCallback_5_0 : public TessResultCallback<R> {
 public:
  typedef TessResultCallback<R> base;
  typedef R (T::*MemberSignature)(P1,P2,P3,P4,P5) ;

 private:
   T* object_;
  MemberSignature member_;
  typename remove_reference<P1>::type p1_;
  typename remove_reference<P2>::type p2_;
  typename remove_reference<P3>::type p3_;
  typename remove_reference<P4>::type p4_;
  typename remove_reference<P5>::type p5_;

 public:
  inline _TessMemberResultCallback_5_0( T* object, MemberSignature member, P1 p1, P2 p2, P3 p3, P4 p4, P5 p5)
    : object_(object),
      member_(member), p1_(p1), p2_(p2), p3_(p3), p4_(p4), p5_(p5) { }

  virtual R Run() {
    if (!del) {
      R result = (object_->*member_)(p1_,p2_,p3_,p4_,p5_);
      return result;
    } else {
      R result = (object_->*member_)(p1_,p2_,p3_,p4_,p5_);
      //  zero out the pointer to ensure segfault if used again
      member_ = __null;
      delete this;
      return result;
    }
  }
};

template <bool del, class T, class P1, class P2, class P3, class P4, class P5>
class _TessMemberResultCallback_5_0<del, void, T, P1, P2, P3, P4, P5> : public TessClosure {
 public:
  typedef TessClosure base;
  typedef void (T::*MemberSignature)(P1,P2,P3,P4,P5) ;

 private:
   T* object_;
  MemberSignature member_;
  typename remove_reference<P1>::type p1_;
  typename remove_reference<P2>::type p2_;
  typename remove_reference<P3>::type p3_;
  typename remove_reference<P4>::type p4_;
  typename remove_reference<P5>::type p5_;

 public:
  inline _TessMemberResultCallback_5_0( T* object, MemberSignature member, P1 p1, P2 p2, P3 p3, P4 p4, P5 p5)
    : object_(object),
      member_(member), p1_(p1), p2_(p2), p3_(p3), p4_(p4), p5_(p5) { }

  virtual void Run() {
    if (!del) {
      (object_->*member_)(p1_,p2_,p3_,p4_,p5_);
    } else {
      (object_->*member_)(p1_,p2_,p3_,p4_,p5_);
      //  zero out the pointer to ensure segfault if used again
      member_ = __null;
      delete this;
    }
  }
};


template <class T1, class T2, class R, class P1, class P2, class P3, class P4, class P5>
inline typename _TessMemberResultCallback_5_0<true,R,T1,P1,P2,P3,P4,P5>::base*
NewTessCallback( T1* obj, R (T2::*member)(P1,P2,P3,P4,P5) , typename Identity<P1>::type p1, typename Identity<P2>::type p2, typename Identity<P3>::type p3, typename Identity<P4>::type p4, typename Identity<P5>::type p5) {
  return new _TessMemberResultCallback_5_0<true,R,T1,P1,P2,P3,P4,P5>(obj, member, p1, p2, p3, p4, p5);
}



template <class T1, class T2, class R, class P1, class P2, class P3, class P4, class P5>
inline typename _TessMemberResultCallback_5_0<false,R,T1,P1,P2,P3,P4,P5>::base*
NewPermanentTessCallback( T1* obj, R (T2::*member)(P1,P2,P3,P4,P5) , typename Identity<P1>::type p1, typename Identity<P2>::type p2, typename Identity<P3>::type p3, typename Identity<P4>::type p4, typename Identity<P5>::type p5) {
  return new _TessMemberResultCallback_5_0<false,R,T1,P1,P2,P3,P4,P5>(obj, member, p1, p2, p3, p4, p5);
}


template <bool del, class R, class P1, class P2, class P3, class P4, class P5>
class _TessFunctionResultCallback_5_0 : public TessResultCallback<R> {
 public:
  typedef TessResultCallback<R> base;
  typedef R (*FunctionSignature)(P1,P2,P3,P4,P5);

 private:
  FunctionSignature function_;
  typename remove_reference<P1>::type p1_;
  typename remove_reference<P2>::type p2_;
  typename remove_reference<P3>::type p3_;
  typename remove_reference<P4>::type p4_;
  typename remove_reference<P5>::type p5_;

 public:
  inline _TessFunctionResultCallback_5_0(FunctionSignature function, P1 p1, P2 p2, P3 p3, P4 p4, P5 p5)
    : function_(function), p1_(p1), p2_(p2), p3_(p3), p4_(p4), p5_(p5) { }

  virtual R Run() {
    if (!del) {
      R result = (*function_)(p1_,p2_,p3_,p4_,p5_);
      return result;
    } else {
      R result = (*function_)(p1_,p2_,p3_,p4_,p5_);
      //  zero out the pointer to ensure segfault if used again
      function_ = __null;
      delete this;
      return result;
    }
  }
};

template <bool del, class P1, class P2, class P3, class P4, class P5>
class _TessFunctionResultCallback_5_0<del, void, P1, P2, P3, P4, P5> : public TessClosure {
 public:
  typedef TessClosure base;
  typedef void (*FunctionSignature)(P1,P2,P3,P4,P5);

 private:
  FunctionSignature function_;
  typename remove_reference<P1>::type p1_;
  typename remove_reference<P2>::type p2_;
  typename remove_reference<P3>::type p3_;
  typename remove_reference<P4>::type p4_;
  typename remove_reference<P5>::type p5_;

 public:
  inline _TessFunctionResultCallback_5_0(FunctionSignature function, P1 p1, P2 p2, P3 p3, P4 p4, P5 p5)
    : function_(function), p1_(p1), p2_(p2), p3_(p3), p4_(p4), p5_(p5) { }

  virtual void Run() {
    if (!del) {
      (*function_)(p1_,p2_,p3_,p4_,p5_);
    } else {
      (*function_)(p1_,p2_,p3_,p4_,p5_);
      //  zero out the pointer to ensure segfault if used again
      function_ = __null;
      delete this;
    }
  }
};

template <class R, class P1, class P2, class P3, class P4, class P5>
inline typename _TessFunctionResultCallback_5_0<true,R,P1,P2,P3,P4,P5>::base*
NewTessCallback(R (*function)(P1,P2,P3,P4,P5), typename Identity<P1>::type p1, typename Identity<P2>::type p2, typename Identity<P3>::type p3, typename Identity<P4>::type p4, typename Identity<P5>::type p5) {
  return new _TessFunctionResultCallback_5_0<true,R,P1,P2,P3,P4,P5>(function, p1, p2, p3, p4, p5);
}

template <class R, class P1, class P2, class P3, class P4, class P5>
inline typename _TessFunctionResultCallback_5_0<false,R,P1,P2,P3,P4,P5>::base*
NewPermanentTessCallback(R (*function)(P1,P2,P3,P4,P5), typename Identity<P1>::type p1, typename Identity<P2>::type p2, typename Identity<P3>::type p3, typename Identity<P4>::type p4, typename Identity<P5>::type p5) {
  return new _TessFunctionResultCallback_5_0<false,R,P1,P2,P3,P4,P5>(function, p1, p2, p3, p4, p5);
}

template <bool del, class R, class T, class P1, class P2, class P3, class P4, class P5, class P6>
class _ConstTessMemberResultCallback_6_0 : public TessResultCallback<R> {
 public:
  typedef TessResultCallback<R> base;
  typedef R (T::*MemberSignature)(P1,P2,P3,P4,P5,P6) const;

 private:
  const T* object_;
  MemberSignature member_;
  typename remove_reference<P1>::type p1_;
  typename remove_reference<P2>::type p2_;
  typename remove_reference<P3>::type p3_;
  typename remove_reference<P4>::type p4_;
  typename remove_reference<P5>::type p5_;
  typename remove_reference<P6>::type p6_;

 public:
  inline _ConstTessMemberResultCallback_6_0(const T* object, MemberSignature member, P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6)
    : object_(object),
      member_(member), p1_(p1), p2_(p2), p3_(p3), p4_(p4), p5_(p5), p6_(p6) { }

  virtual R Run() {
    if (!del) {
      R result = (object_->*member_)(p1_,p2_,p3_,p4_,p5_,p6_);
      return result;
    } else {
      R result = (object_->*member_)(p1_,p2_,p3_,p4_,p5_,p6_);
      //  zero out the pointer to ensure segfault if used again
      member_ = __null;
      delete this;
      return result;
    }
  }
};

template <bool del, class T, class P1, class P2, class P3, class P4, class P5, class P6>
class _ConstTessMemberResultCallback_6_0<del, void, T, P1, P2, P3, P4, P5, P6> : public TessClosure {
 public:
  typedef TessClosure base;
  typedef void (T::*MemberSignature)(P1,P2,P3,P4,P5,P6) const;

 private:
  const T* object_;
  MemberSignature member_;
  typename remove_reference<P1>::type p1_;
  typename remove_reference<P2>::type p2_;
  typename remove_reference<P3>::type p3_;
  typename remove_reference<P4>::type p4_;
  typename remove_reference<P5>::type p5_;
  typename remove_reference<P6>::type p6_;

 public:
  inline _ConstTessMemberResultCallback_6_0(const T* object, MemberSignature member, P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6)
    : object_(object),
      member_(member), p1_(p1), p2_(p2), p3_(p3), p4_(p4), p5_(p5), p6_(p6) { }

  virtual void Run() {
    if (!del) {
      (object_->*member_)(p1_,p2_,p3_,p4_,p5_,p6_);
    } else {
      (object_->*member_)(p1_,p2_,p3_,p4_,p5_,p6_);
      //  zero out the pointer to ensure segfault if used again
      member_ = __null;
      delete this;
    }
  }
};


template <class T1, class T2, class R, class P1, class P2, class P3, class P4, class P5, class P6>
inline typename _ConstTessMemberResultCallback_6_0<true,R,T1,P1,P2,P3,P4,P5,P6>::base*
NewTessCallback(const T1* obj, R (T2::*member)(P1,P2,P3,P4,P5,P6) const, typename Identity<P1>::type p1, typename Identity<P2>::type p2, typename Identity<P3>::type p3, typename Identity<P4>::type p4, typename Identity<P5>::type p5, typename Identity<P6>::type p6) {
  return new _ConstTessMemberResultCallback_6_0<true,R,T1,P1,P2,P3,P4,P5,P6>(obj, member, p1, p2, p3, p4, p5, p6);
}



template <class T1, class T2, class R, class P1, class P2, class P3, class P4, class P5, class P6>
inline typename _ConstTessMemberResultCallback_6_0<false,R,T1,P1,P2,P3,P4,P5,P6>::base*
NewPermanentTessCallback(const T1* obj, R (T2::*member)(P1,P2,P3,P4,P5,P6) const, typename Identity<P1>::type p1, typename Identity<P2>::type p2, typename Identity<P3>::type p3, typename Identity<P4>::type p4, typename Identity<P5>::type p5, typename Identity<P6>::type p6) {
  return new _ConstTessMemberResultCallback_6_0<false,R,T1,P1,P2,P3,P4,P5,P6>(obj, member, p1, p2, p3, p4, p5, p6);
}


template <bool del, class R, class T, class P1, class P2, class P3, class P4, class P5, class P6>
class _TessMemberResultCallback_6_0 : public TessResultCallback<R> {
 public:
  typedef TessResultCallback<R> base;
  typedef R (T::*MemberSignature)(P1,P2,P3,P4,P5,P6) ;

 private:
   T* object_;
  MemberSignature member_;
  typename remove_reference<P1>::type p1_;
  typename remove_reference<P2>::type p2_;
  typename remove_reference<P3>::type p3_;
  typename remove_reference<P4>::type p4_;
  typename remove_reference<P5>::type p5_;
  typename remove_reference<P6>::type p6_;

 public:
  inline _TessMemberResultCallback_6_0( T* object, MemberSignature member, P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6)
    : object_(object),
      member_(member), p1_(p1), p2_(p2), p3_(p3), p4_(p4), p5_(p5), p6_(p6) { }

  virtual R Run() {
    if (!del) {
      R result = (object_->*member_)(p1_,p2_,p3_,p4_,p5_,p6_);
      return result;
    } else {
      R result = (object_->*member_)(p1_,p2_,p3_,p4_,p5_,p6_);
      //  zero out the pointer to ensure segfault if used again
      member_ = __null;
      delete this;
      return result;
    }
  }
};

template <bool del, class T, class P1, class P2, class P3, class P4, class P5, class P6>
class _TessMemberResultCallback_6_0<del, void, T, P1, P2, P3, P4, P5, P6> : public TessClosure {
 public:
  typedef TessClosure base;
  typedef void (T::*MemberSignature)(P1,P2,P3,P4,P5,P6) ;

 private:
   T* object_;
  MemberSignature member_;
  typename remove_reference<P1>::type p1_;
  typename remove_reference<P2>::type p2_;
  typename remove_reference<P3>::type p3_;
  typename remove_reference<P4>::type p4_;
  typename remove_reference<P5>::type p5_;
  typename remove_reference<P6>::type p6_;

 public:
  inline _TessMemberResultCallback_6_0( T* object, MemberSignature member, P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6)
    : object_(object),
      member_(member), p1_(p1), p2_(p2), p3_(p3), p4_(p4), p5_(p5), p6_(p6) { }

  virtual void Run() {
    if (!del) {
      (object_->*member_)(p1_,p2_,p3_,p4_,p5_,p6_);
    } else {
      (object_->*member_)(p1_,p2_,p3_,p4_,p5_,p6_);
      //  zero out the pointer to ensure segfault if used again
      member_ = __null;
      delete this;
    }
  }
};


template <class T1, class T2, class R, class P1, class P2, class P3, class P4, class P5, class P6>
inline typename _TessMemberResultCallback_6_0<true,R,T1,P1,P2,P3,P4,P5,P6>::base*
NewTessCallback( T1* obj, R (T2::*member)(P1,P2,P3,P4,P5,P6) , typename Identity<P1>::type p1, typename Identity<P2>::type p2, typename Identity<P3>::type p3, typename Identity<P4>::type p4, typename Identity<P5>::type p5, typename Identity<P6>::type p6) {
  return new _TessMemberResultCallback_6_0<true,R,T1,P1,P2,P3,P4,P5,P6>(obj, member, p1, p2, p3, p4, p5, p6);
}



template <class T1, class T2, class R, class P1, class P2, class P3, class P4, class P5, class P6>
inline typename _TessMemberResultCallback_6_0<false,R,T1,P1,P2,P3,P4,P5,P6>::base*
NewPermanentTessCallback( T1* obj, R (T2::*member)(P1,P2,P3,P4,P5,P6) , typename Identity<P1>::type p1, typename Identity<P2>::type p2, typename Identity<P3>::type p3, typename Identity<P4>::type p4, typename Identity<P5>::type p5, typename Identity<P6>::type p6) {
  return new _TessMemberResultCallback_6_0<false,R,T1,P1,P2,P3,P4,P5,P6>(obj, member, p1, p2, p3, p4, p5, p6);
}


template <bool del, class R, class P1, class P2, class P3, class P4, class P5, class P6>
class _TessFunctionResultCallback_6_0 : public TessResultCallback<R> {
 public:
  typedef TessResultCallback<R> base;
  typedef R (*FunctionSignature)(P1,P2,P3,P4,P5,P6);

 private:
  FunctionSignature function_;
  typename remove_reference<P1>::type p1_;
  typename remove_reference<P2>::type p2_;
  typename remove_reference<P3>::type p3_;
  typename remove_reference<P4>::type p4_;
  typename remove_reference<P5>::type p5_;
  typename remove_reference<P6>::type p6_;

 public:
  inline _TessFunctionResultCallback_6_0(FunctionSignature function, P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6)
    : function_(function), p1_(p1), p2_(p2), p3_(p3), p4_(p4), p5_(p5), p6_(p6) { }

  virtual R Run() {
    if (!del) {
      R result = (*function_)(p1_,p2_,p3_,p4_,p5_,p6_);
      return result;
    } else {
      R result = (*function_)(p1_,p2_,p3_,p4_,p5_,p6_);
      //  zero out the pointer to ensure segfault if used again
      function_ = __null;
      delete this;
      return result;
    }
  }
};

template <bool del, class P1, class P2, class P3, class P4, class P5, class P6>
class _TessFunctionResultCallback_6_0<del, void, P1, P2, P3, P4, P5, P6> : public TessClosure {
 public:
  typedef TessClosure base;
  typedef void (*FunctionSignature)(P1,P2,P3,P4,P5,P6);

 private:
  FunctionSignature function_;
  typename remove_reference<P1>::type p1_;
  typename remove_reference<P2>::type p2_;
  typename remove_reference<P3>::type p3_;
  typename remove_reference<P4>::type p4_;
  typename remove_reference<P5>::type p5_;
  typename remove_reference<P6>::type p6_;

 public:
  inline _TessFunctionResultCallback_6_0(FunctionSignature function, P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6)
    : function_(function), p1_(p1), p2_(p2), p3_(p3), p4_(p4), p5_(p5), p6_(p6) { }

  virtual void Run() {
    if (!del) {
      (*function_)(p1_,p2_,p3_,p4_,p5_,p6_);
    } else {
      (*function_)(p1_,p2_,p3_,p4_,p5_,p6_);
      //  zero out the pointer to ensure segfault if used again
      function_ = __null;
      delete this;
    }
  }
};

template <class R, class P1, class P2, class P3, class P4, class P5, class P6>
inline typename _TessFunctionResultCallback_6_0<true,R,P1,P2,P3,P4,P5,P6>::base*
NewTessCallback(R (*function)(P1,P2,P3,P4,P5,P6), typename Identity<P1>::type p1, typename Identity<P2>::type p2, typename Identity<P3>::type p3, typename Identity<P4>::type p4, typename Identity<P5>::type p5, typename Identity<P6>::type p6) {
  return new _TessFunctionResultCallback_6_0<true,R,P1,P2,P3,P4,P5,P6>(function, p1, p2, p3, p4, p5, p6);
}

template <class R, class P1, class P2, class P3, class P4, class P5, class P6>
inline typename _TessFunctionResultCallback_6_0<false,R,P1,P2,P3,P4,P5,P6>::base*
NewPermanentTessCallback(R (*function)(P1,P2,P3,P4,P5,P6), typename Identity<P1>::type p1, typename Identity<P2>::type p2, typename Identity<P3>::type p3, typename Identity<P4>::type p4, typename Identity<P5>::type p5, typename Identity<P6>::type p6) {
  return new _TessFunctionResultCallback_6_0<false,R,P1,P2,P3,P4,P5,P6>(function, p1, p2, p3, p4, p5, p6);
}

template <class A1>
class TessCallback1 {
 public:
  virtual ~TessCallback1() { }
  virtual void Run(A1) = 0;
};

template <class R, class A1>
class TessResultCallback1 {
 public:
  virtual ~TessResultCallback1() { }
  virtual R Run(A1) = 0;
};


template <class A1,class A2>
class TessCallback2 {
 public:
  virtual ~TessCallback2() { }
  virtual void Run(A1,A2) = 0;
};

template <class R, class A1,class A2>
class TessResultCallback2 {
 public:
  virtual ~TessResultCallback2() { }
  virtual R Run(A1,A2) = 0;
};

template <class A1,class A2,class A3>
class TessCallback3 {
 public:
  virtual ~TessCallback3() { }
  virtual void Run(A1,A2,A3) = 0;
};

template <class R, class A1,class A2,class A3>
class TessResultCallback3 {
 public:
  virtual ~TessResultCallback3() { }
  virtual R Run(A1,A2,A3) = 0;
};

template <class A1,class A2,class A3,class A4>
class TessCallback4 {
 public:
  virtual ~TessCallback4() { }
  virtual void Run(A1,A2,A3,A4) = 0;
};

template <class R, class A1,class A2,class A3,class A4>
class TessResultCallback4 {
 public:
  virtual ~TessResultCallback4() { }
  virtual R Run(A1,A2,A3,A4) = 0;
};

template <bool del, class R, class T, class A1>
class _ConstTessMemberResultCallback_0_1 : public TessResultCallback1<R,A1> {
 public:
  typedef TessResultCallback1<R,A1> base;
  typedef R (T::*MemberSignature)(A1) const;

 private:
  const T* object_;
  MemberSignature member_;

 public:
  inline _ConstTessMemberResultCallback_0_1(
     const T* object, MemberSignature member)
    : object_(object),
      member_(member) {
  }

  virtual R Run(A1 a1) {
    if (!del) {
      R result = (object_->*member_)(a1);
      return result;
    } else {
      R result = (object_->*member_)(a1);
      //  zero out the pointer to ensure segfault if used again
      member_ = __null;
      delete this;
      return result;
    }
  }
};

template <bool del, class T, class A1>
class _ConstTessMemberResultCallback_0_1<del, void, T, A1>
  : public TessCallback1<A1> {
 public:
  typedef TessCallback1<A1> base;
  typedef void (T::*MemberSignature)(A1) const;

 private:
  const T* object_;
  MemberSignature member_;

 public:
  inline _ConstTessMemberResultCallback_0_1(
      const T* object, MemberSignature member)
    : object_(object),
      member_(member) {
  }

  virtual void Run(A1 a1) {
    if (!del) {
      (object_->*member_)(a1);
    } else {
      (object_->*member_)(a1);
      //  zero out the pointer to ensure segfault if used again
      member_ = __null;
      delete this;
    }
  }
};


template <class T1, class T2, class R, class A1>
inline typename _ConstTessMemberResultCallback_0_1<true,R,T1,A1>::base*
NewTessCallback(
    const T1* obj, R (T2::*member)(A1) const) {
  return new _ConstTessMemberResultCallback_0_1<true,R,T1,A1>(
      obj, member);
}



template <class T1, class T2, class R, class A1>
inline typename _ConstTessMemberResultCallback_0_1<false,R,T1,A1>::base*
NewPermanentTessCallback(
    const T1* obj, R (T2::*member)(A1) const) {
  return new _ConstTessMemberResultCallback_0_1<false,R,T1,A1>(
      obj, member);
}


template <bool del, class R, class T, class A1>
class _TessMemberResultCallback_0_1 : public TessResultCallback1<R,A1> {
 public:
  typedef TessResultCallback1<R,A1> base;
  typedef R (T::*MemberSignature)(A1) ;

 private:
   T* object_;
  MemberSignature member_;

 public:
  inline _TessMemberResultCallback_0_1(
      T* object, MemberSignature member)
    : object_(object),
      member_(member) {
  }

  virtual R Run(A1 a1) {
    if (!del) {
      R result = (object_->*member_)(a1);
      return result;
    } else {
      R result = (object_->*member_)(a1);
      //  zero out the pointer to ensure segfault if used again
      member_ = __null;
      delete this;
      return result;
    }
  }
};

template <bool del, class T, class A1>
class _TessMemberResultCallback_0_1<del, void, T, A1>
  : public TessCallback1<A1> {
 public:
  typedef TessCallback1<A1> base;
  typedef void (T::*MemberSignature)(A1) ;

 private:
   T* object_;
  MemberSignature member_;

 public:
  inline _TessMemberResultCallback_0_1(
       T* object, MemberSignature member)
    : object_(object),
      member_(member) {
  }

  virtual void Run(A1 a1) {
    if (!del) {
      (object_->*member_)(a1);
    } else {
      (object_->*member_)(a1);
      //  zero out the pointer to ensure segfault if used again
      member_ = __null;
      delete this;
    }
  }
};


template <class T1, class T2, class R, class A1>
inline typename _TessMemberResultCallback_0_1<true,R,T1,A1>::base*
NewTessCallback(
     T1* obj, R (T2::*member)(A1) ) {
  return new _TessMemberResultCallback_0_1<true,R,T1,A1>(
      obj, member);
}



template <class T1, class T2, class R, class A1>
inline typename _TessMemberResultCallback_0_1<false,R,T1,A1>::base*
NewPermanentTessCallback(
     T1* obj, R (T2::*member)(A1) ) {
  return new _TessMemberResultCallback_0_1<false,R,T1,A1>(
      obj, member);
}


template <bool del, class R, class A1>
class _TessFunctionResultCallback_0_1 : public TessResultCallback1<R,A1> {
 public:
  typedef TessResultCallback1<R,A1> base;
  typedef R (*FunctionSignature)(A1);

 private:
  FunctionSignature function_;

 public:
  inline _TessFunctionResultCallback_0_1(
      FunctionSignature function)
    : function_(function) {
  }

  virtual R Run(A1 a1) {
    if (!del) {
      R result = (*function_)(a1);
      return result;
    } else {
      R result = (*function_)(a1);
      //  zero out the pointer to ensure segfault if used again
      function_ = __null;
      delete this;
      return result;
    }
  }
};

template <bool del, class A1>
class _TessFunctionResultCallback_0_1<del, void, A1>
  : public TessCallback1<A1> {
 public:
  typedef TessCallback1<A1> base;
  typedef void (*FunctionSignature)(A1);

 private:
  FunctionSignature function_;

 public:
  inline _TessFunctionResultCallback_0_1(
      FunctionSignature function)
    : function_(function) {
  }

  virtual void Run(A1 a1) {
    if (!del) {
      (*function_)(a1);
    } else {
      (*function_)(a1);
      //  zero out the pointer to ensure segfault if used again
      function_ = __null;
      delete this;
    }
  }
};

template <class R, class A1>
inline typename _TessFunctionResultCallback_0_1<true,R,A1>::base*
NewTessCallback(R (*function)(A1)) {
  return new _TessFunctionResultCallback_0_1<true,R,A1>(function);
}

template <class R, class A1>
inline typename _TessFunctionResultCallback_0_1<false,R,A1>::base*
NewPermanentTessCallback(R (*function)(A1)) {
  return new _TessFunctionResultCallback_0_1<false,R,A1>(function);
}

template <bool del, class R, class T, class P1, class A1>
class _ConstTessMemberResultCallback_1_1 : public TessResultCallback1<R,A1> {
 public:
  typedef TessResultCallback1<R,A1> base;
  typedef R (T::*MemberSignature)(P1,A1) const;

 private:
  const T* object_;
  MemberSignature member_;
  typename remove_reference<P1>::type p1_;

 public:
  inline _ConstTessMemberResultCallback_1_1(const T* object, MemberSignature member, P1 p1)
    : object_(object),
      member_(member), p1_(p1) { }

  virtual R Run(A1 a1) {
    if (!del) {
      R result = (object_->*member_)(p1_,a1);
      return result;
    } else {
      R result = (object_->*member_)(p1_,a1);
      //  zero out the pointer to ensure segfault if used again
      member_ = __null;
      delete this;
      return result;
    }
  }
};

template <bool del, class T, class P1, class A1>
class _ConstTessMemberResultCallback_1_1<del, void, T, P1, A1> : public TessCallback1<A1> {
 public:
  typedef TessCallback1<A1> base;
  typedef void (T::*MemberSignature)(P1,A1) const;

 private:
  const T* object_;
  MemberSignature member_;
  typename remove_reference<P1>::type p1_;

 public:
  inline _ConstTessMemberResultCallback_1_1(const T* object, MemberSignature member, P1 p1)
    : object_(object),
      member_(member), p1_(p1) { }

  virtual void Run(A1 a1) {
    if (!del) {
      (object_->*member_)(p1_,a1);
    } else {
      (object_->*member_)(p1_,a1);
      //  zero out the pointer to ensure segfault if used again
      member_ = __null;
      delete this;
    }
  }
};


template <class T1, class T2, class R, class P1, class A1>
inline typename _ConstTessMemberResultCallback_1_1<true,R,T1,P1,A1>::base*
NewTessCallback(const T1* obj, R (T2::*member)(P1,A1) const, typename Identity<P1>::type p1) {
  return new _ConstTessMemberResultCallback_1_1<true,R,T1,P1,A1>(obj, member, p1);
}



template <class T1, class T2, class R, class P1, class A1>
inline typename _ConstTessMemberResultCallback_1_1<false,R,T1,P1,A1>::base*
NewPermanentTessCallback(const T1* obj, R (T2::*member)(P1,A1) const, typename Identity<P1>::type p1) {
  return new _ConstTessMemberResultCallback_1_1<false,R,T1,P1,A1>(obj, member, p1);
}


template <bool del, class R, class T, class P1, class A1>
class _TessMemberResultCallback_1_1 : public TessResultCallback1<R,A1> {
 public:
  typedef TessResultCallback1<R,A1> base;
  typedef R (T::*MemberSignature)(P1,A1) ;

 private:
   T* object_;
  MemberSignature member_;
  typename remove_reference<P1>::type p1_;

 public:
  inline _TessMemberResultCallback_1_1( T* object, MemberSignature member, P1 p1)
    : object_(object),
      member_(member), p1_(p1) { }

  virtual R Run(A1 a1) {
    if (!del) {
      R result = (object_->*member_)(p1_,a1);
      return result;
    } else {
      R result = (object_->*member_)(p1_,a1);
      //  zero out the pointer to ensure segfault if used again
      member_ = __null;
      delete this;
      return result;
    }
  }
};

template <bool del, class T, class P1, class A1>
class _TessMemberResultCallback_1_1<del, void, T, P1, A1> : public TessCallback1<A1> {
 public:
  typedef TessCallback1<A1> base;
  typedef void (T::*MemberSignature)(P1,A1) ;

 private:
   T* object_;
  MemberSignature member_;
  typename remove_reference<P1>::type p1_;

 public:
  inline _TessMemberResultCallback_1_1( T* object, MemberSignature member, P1 p1)
    : object_(object),
      member_(member), p1_(p1) { }

  virtual void Run(A1 a1) {
    if (!del) {
      (object_->*member_)(p1_,a1);
    } else {
      (object_->*member_)(p1_,a1);
      //  zero out the pointer to ensure segfault if used again
      member_ = __null;
      delete this;
    }
  }
};


template <class T1, class T2, class R, class P1, class A1>
inline typename _TessMemberResultCallback_1_1<true,R,T1,P1,A1>::base*
NewTessCallback( T1* obj, R (T2::*member)(P1,A1) , typename Identity<P1>::type p1) {
  return new _TessMemberResultCallback_1_1<true,R,T1,P1,A1>(obj, member, p1);
}



template <class T1, class T2, class R, class P1, class A1>
inline typename _TessMemberResultCallback_1_1<false,R,T1,P1,A1>::base*
NewPermanentTessCallback( T1* obj, R (T2::*member)(P1,A1) , typename Identity<P1>::type p1) {
  return new _TessMemberResultCallback_1_1<false,R,T1,P1,A1>(obj, member, p1);
}


template <bool del, class R, class P1, class A1>
class _TessFunctionResultCallback_1_1 : public TessResultCallback1<R,A1> {
 public:
  typedef TessResultCallback1<R,A1> base;
  typedef R (*FunctionSignature)(P1,A1);

 private:
  FunctionSignature function_;
  typename remove_reference<P1>::type p1_;

 public:
  inline _TessFunctionResultCallback_1_1(FunctionSignature function, P1 p1)
    : function_(function), p1_(p1) { }

  virtual R Run(A1 a1) {
    if (!del) {
      R result = (*function_)(p1_,a1);
      return result;
    } else {
      R result = (*function_)(p1_,a1);
      //  zero out the pointer to ensure segfault if used again
      function_ = __null;
      delete this;
      return result;
    }
  }
};

template <bool del, class P1, class A1>
class _TessFunctionResultCallback_1_1<del, void, P1, A1> : public TessCallback1<A1> {
 public:
  typedef TessCallback1<A1> base;
  typedef void (*FunctionSignature)(P1,A1);

 private:
  FunctionSignature function_;
  typename remove_reference<P1>::type p1_;

 public:
  inline _TessFunctionResultCallback_1_1(FunctionSignature function, P1 p1)
    : function_(function), p1_(p1) { }

  virtual void Run(A1 a1) {
    if (!del) {
      (*function_)(p1_,a1);
    } else {
      (*function_)(p1_,a1);
      //  zero out the pointer to ensure segfault if used again
      function_ = __null;
      delete this;
    }
  }
};

template <class R, class P1, class A1>
inline typename _TessFunctionResultCallback_1_1<true,R,P1,A1>::base*
NewTessCallback(R (*function)(P1,A1), typename Identity<P1>::type p1) {
  return new _TessFunctionResultCallback_1_1<true,R,P1,A1>(function, p1);
}

template <class R, class P1, class A1>
inline typename _TessFunctionResultCallback_1_1<false,R,P1,A1>::base*
NewPermanentTessCallback(R (*function)(P1,A1), typename Identity<P1>::type p1) {
  return new _TessFunctionResultCallback_1_1<false,R,P1,A1>(function, p1);
}

template <bool del, class R, class T, class P1, class P2, class A1>
class _ConstTessMemberResultCallback_2_1 : public TessResultCallback1<R,A1> {
 public:
  typedef TessResultCallback1<R,A1> base;
  typedef R (T::*MemberSignature)(P1,P2,A1) const;

 private:
  const T* object_;
  MemberSignature member_;
  typename remove_reference<P1>::type p1_;
  typename remove_reference<P2>::type p2_;

 public:
  inline _ConstTessMemberResultCallback_2_1(const T* object, MemberSignature member, P1 p1, P2 p2)
    : object_(object),
      member_(member), p1_(p1), p2_(p2) { }

  virtual R Run(A1 a1) {
    if (!del) {
      R result = (object_->*member_)(p1_,p2_,a1);
      return result;
    } else {
      R result = (object_->*member_)(p1_,p2_,a1);
      //  zero out the pointer to ensure segfault if used again
      member_ = __null;
      delete this;
      return result;
    }
  }
};

template <bool del, class T, class P1, class P2, class A1>
class _ConstTessMemberResultCallback_2_1<del, void, T, P1, P2, A1> : public TessCallback1<A1> {
 public:
  typedef TessCallback1<A1> base;
  typedef void (T::*MemberSignature)(P1,P2,A1) const;

 private:
  const T* object_;
  MemberSignature member_;
  typename remove_reference<P1>::type p1_;
  typename remove_reference<P2>::type p2_;

 public:
  inline _ConstTessMemberResultCallback_2_1(const T* object, MemberSignature member, P1 p1, P2 p2)
    : object_(object),
      member_(member), p1_(p1), p2_(p2) { }

  virtual void Run(A1 a1) {
    if (!del) {
      (object_->*member_)(p1_,p2_,a1);
    } else {
      (object_->*member_)(p1_,p2_,a1);
      //  zero out the pointer to ensure segfault if used again
      member_ = __null;
      delete this;
    }
  }
};


template <class T1, class T2, class R, class P1, class P2, class A1>
inline typename _ConstTessMemberResultCallback_2_1<true,R,T1,P1,P2,A1>::base*
NewTessCallback(const T1* obj, R (T2::*member)(P1,P2,A1) const, typename Identity<P1>::type p1, typename Identity<P2>::type p2) {
  return new _ConstTessMemberResultCallback_2_1<true,R,T1,P1,P2,A1>(obj, member, p1, p2);
}



template <class T1, class T2, class R, class P1, class P2, class A1>
inline typename _ConstTessMemberResultCallback_2_1<false,R,T1,P1,P2,A1>::base*
NewPermanentTessCallback(const T1* obj, R (T2::*member)(P1,P2,A1) const, typename Identity<P1>::type p1, typename Identity<P2>::type p2) {
  return new _ConstTessMemberResultCallback_2_1<false,R,T1,P1,P2,A1>(obj, member, p1, p2);
}


template <bool del, class R, class T, class P1, class P2, class A1>
class _TessMemberResultCallback_2_1 : public TessResultCallback1<R,A1> {
 public:
  typedef TessResultCallback1<R,A1> base;
  typedef R (T::*MemberSignature)(P1,P2,A1) ;

 private:
   T* object_;
  MemberSignature member_;
  typename remove_reference<P1>::type p1_;
  typename remove_reference<P2>::type p2_;

 public:
  inline _TessMemberResultCallback_2_1( T* object, MemberSignature member, P1 p1, P2 p2)
    : object_(object),
      member_(member), p1_(p1), p2_(p2) { }

  virtual R Run(A1 a1) {
    if (!del) {
      R result = (object_->*member_)(p1_,p2_,a1);
      return result;
    } else {
      R result = (object_->*member_)(p1_,p2_,a1);
      //  zero out the pointer to ensure segfault if used again
      member_ = __null;
      delete this;
      return result;
    }
  }
};

template <bool del, class T, class P1, class P2, class A1>
class _TessMemberResultCallback_2_1<del, void, T, P1, P2, A1> : public TessCallback1<A1> {
 public:
  typedef TessCallback1<A1> base;
  typedef void (T::*MemberSignature)(P1,P2,A1) ;

 private:
   T* object_;
  MemberSignature member_;
  typename remove_reference<P1>::type p1_;
  typename remove_reference<P2>::type p2_;

 public:
  inline _TessMemberResultCallback_2_1( T* object, MemberSignature member, P1 p1, P2 p2)
    : object_(object),
      member_(member), p1_(p1), p2_(p2) { }

  virtual void Run(A1 a1) {
    if (!del) {
      (object_->*member_)(p1_,p2_,a1);
    } else {
      (object_->*member_)(p1_,p2_,a1);
      //  zero out the pointer to ensure segfault if used again
      member_ = __null;
      delete this;
    }
  }
};


template <class T1, class T2, class R, class P1, class P2, class A1>
inline typename _TessMemberResultCallback_2_1<true,R,T1,P1,P2,A1>::base*
NewTessCallback( T1* obj, R (T2::*member)(P1,P2,A1) , typename Identity<P1>::type p1, typename Identity<P2>::type p2) {
  return new _TessMemberResultCallback_2_1<true,R,T1,P1,P2,A1>(obj, member, p1, p2);
}



template <class T1, class T2, class R, class P1, class P2, class A1>
inline typename _TessMemberResultCallback_2_1<false,R,T1,P1,P2,A1>::base*
NewPermanentTessCallback( T1* obj, R (T2::*member)(P1,P2,A1) , typename Identity<P1>::type p1, typename Identity<P2>::type p2) {
  return new _TessMemberResultCallback_2_1<false,R,T1,P1,P2,A1>(obj, member, p1, p2);
}


template <bool del, class R, class P1, class P2, class A1>
class _TessFunctionResultCallback_2_1 : public TessResultCallback1<R,A1> {
 public:
  typedef TessResultCallback1<R,A1> base;
  typedef R (*FunctionSignature)(P1,P2,A1);

 private:
  FunctionSignature function_;
  typename remove_reference<P1>::type p1_;
  typename remove_reference<P2>::type p2_;

 public:
  inline _TessFunctionResultCallback_2_1(FunctionSignature function, P1 p1, P2 p2)
    : function_(function), p1_(p1), p2_(p2) { }

  virtual R Run(A1 a1) {
    if (!del) {
      R result = (*function_)(p1_,p2_,a1);
      return result;
    } else {
      R result = (*function_)(p1_,p2_,a1);
      //  zero out the pointer to ensure segfault if used again
      function_ = __null;
      delete this;
      return result;
    }
  }
};

template <bool del, class P1, class P2, class A1>
class _TessFunctionResultCallback_2_1<del, void, P1, P2, A1> : public TessCallback1<A1> {
 public:
  typedef TessCallback1<A1> base;
  typedef void (*FunctionSignature)(P1,P2,A1);

 private:
  FunctionSignature function_;
  typename remove_reference<P1>::type p1_;
  typename remove_reference<P2>::type p2_;

 public:
  inline _TessFunctionResultCallback_2_1(FunctionSignature function, P1 p1, P2 p2)
    : function_(function), p1_(p1), p2_(p2) { }

  virtual void Run(A1 a1) {
    if (!del) {
      (*function_)(p1_,p2_,a1);
    } else {
      (*function_)(p1_,p2_,a1);
      //  zero out the pointer to ensure segfault if used again
      function_ = __null;
      delete this;
    }
  }
};

template <class R, class P1, class P2, class A1>
inline typename _TessFunctionResultCallback_2_1<true,R,P1,P2,A1>::base*
NewTessCallback(R (*function)(P1,P2,A1), typename Identity<P1>::type p1, typename Identity<P2>::type p2) {
  return new _TessFunctionResultCallback_2_1<true,R,P1,P2,A1>(function, p1, p2);
}

template <class R, class P1, class P2, class A1>
inline typename _TessFunctionResultCallback_2_1<false,R,P1,P2,A1>::base*
NewPermanentTessCallback(R (*function)(P1,P2,A1), typename Identity<P1>::type p1, typename Identity<P2>::type p2) {
  return new _TessFunctionResultCallback_2_1<false,R,P1,P2,A1>(function, p1, p2);
}

template <bool del, class R, class T, class P1, class P2, class P3, class A1>
class _ConstTessMemberResultCallback_3_1 : public TessResultCallback1<R,A1> {
 public:
  typedef TessResultCallback1<R,A1> base;
  typedef R (T::*MemberSignature)(P1,P2,P3,A1) const;

 private:
  const T* object_;
  MemberSignature member_;
  typename remove_reference<P1>::type p1_;
  typename remove_reference<P2>::type p2_;
  typename remove_reference<P3>::type p3_;

 public:
  inline _ConstTessMemberResultCallback_3_1(const T* object, MemberSignature member, P1 p1, P2 p2, P3 p3)
    : object_(object),
      member_(member), p1_(p1), p2_(p2), p3_(p3) { }

  virtual R Run(A1 a1) {
    if (!del) {
      R result = (object_->*member_)(p1_,p2_,p3_,a1);
      return result;
    } else {
      R result = (object_->*member_)(p1_,p2_,p3_,a1);
      //  zero out the pointer to ensure segfault if used again
      member_ = __null;
      delete this;
      return result;
    }
  }
};

template <bool del, class T, class P1, class P2, class P3, class A1>
class _ConstTessMemberResultCallback_3_1<del, void, T, P1, P2, P3, A1> : public TessCallback1<A1> {
 public:
  typedef TessCallback1<A1> base;
  typedef void (T::*MemberSignature)(P1,P2,P3,A1) const;

 private:
  const T* object_;
  MemberSignature member_;
  typename remove_reference<P1>::type p1_;
  typename remove_reference<P2>::type p2_;
  typename remove_reference<P3>::type p3_;

 public:
  inline _ConstTessMemberResultCallback_3_1(const T* object, MemberSignature member, P1 p1, P2 p2, P3 p3)
    : object_(object),
      member_(member), p1_(p1), p2_(p2), p3_(p3) { }

  virtual void Run(A1 a1) {
    if (!del) {
      (object_->*member_)(p1_,p2_,p3_,a1);
    } else {
      (object_->*member_)(p1_,p2_,p3_,a1);
      //  zero out the pointer to ensure segfault if used again
      member_ = __null;
      delete this;
    }
  }
};


template <class T1, class T2, class R, class P1, class P2, class P3, class A1>
inline typename _ConstTessMemberResultCallback_3_1<true,R,T1,P1,P2,P3,A1>::base*
NewTessCallback(const T1* obj, R (T2::*member)(P1,P2,P3,A1) const, typename Identity<P1>::type p1, typename Identity<P2>::type p2, typename Identity<P3>::type p3) {
  return new _ConstTessMemberResultCallback_3_1<true,R,T1,P1,P2,P3,A1>(obj, member, p1, p2, p3);
}



template <class T1, class T2, class R, class P1, class P2, class P3, class A1>
inline typename _ConstTessMemberResultCallback_3_1<false,R,T1,P1,P2,P3,A1>::base*
NewPermanentTessCallback(const T1* obj, R (T2::*member)(P1,P2,P3,A1) const, typename Identity<P1>::type p1, typename Identity<P2>::type p2, typename Identity<P3>::type p3) {
  return new _ConstTessMemberResultCallback_3_1<false,R,T1,P1,P2,P3,A1>(obj, member, p1, p2, p3);
}


template <bool del, class R, class T, class P1, class P2, class P3, class A1>
class _TessMemberResultCallback_3_1 : public TessResultCallback1<R,A1> {
 public:
  typedef TessResultCallback1<R,A1> base;
  typedef R (T::*MemberSignature)(P1,P2,P3,A1) ;

 private:
   T* object_;
  MemberSignature member_;
  typename remove_reference<P1>::type p1_;
  typename remove_reference<P2>::type p2_;
  typename remove_reference<P3>::type p3_;

 public:
  inline _TessMemberResultCallback_3_1( T* object, MemberSignature member, P1 p1, P2 p2, P3 p3)
    : object_(object),
      member_(member), p1_(p1), p2_(p2), p3_(p3) { }

  virtual R Run(A1 a1) {
    if (!del) {
      R result = (object_->*member_)(p1_,p2_,p3_,a1);
      return result;
    } else {
      R result = (object_->*member_)(p1_,p2_,p3_,a1);
      //  zero out the pointer to ensure segfault if used again
      member_ = __null;
      delete this;
      return result;
    }
  }
};

template <bool del, class T, class P1, class P2, class P3, class A1>
class _TessMemberResultCallback_3_1<del, void, T, P1, P2, P3, A1> : public TessCallback1<A1> {
 public:
  typedef TessCallback1<A1> base;
  typedef void (T::*MemberSignature)(P1,P2,P3,A1) ;

 private:
   T* object_;
  MemberSignature member_;
  typename remove_reference<P1>::type p1_;
  typename remove_reference<P2>::type p2_;
  typename remove_reference<P3>::type p3_;

 public:
  inline _TessMemberResultCallback_3_1( T* object, MemberSignature member, P1 p1, P2 p2, P3 p3)
    : object_(object),
      member_(member), p1_(p1), p2_(p2), p3_(p3) { }

  virtual void Run(A1 a1) {
    if (!del) {
      (object_->*member_)(p1_,p2_,p3_,a1);
    } else {
      (object_->*member_)(p1_,p2_,p3_,a1);
      //  zero out the pointer to ensure segfault if used again
      member_ = __null;
      delete this;
    }
  }
};


template <class T1, class T2, class R, class P1, class P2, class P3, class A1>
inline typename _TessMemberResultCallback_3_1<true,R,T1,P1,P2,P3,A1>::base*
NewTessCallback( T1* obj, R (T2::*member)(P1,P2,P3,A1) , typename Identity<P1>::type p1, typename Identity<P2>::type p2, typename Identity<P3>::type p3) {
  return new _TessMemberResultCallback_3_1<true,R,T1,P1,P2,P3,A1>(obj, member, p1, p2, p3);
}



template <class T1, class T2, class R, class P1, class P2, class P3, class A1>
inline typename _TessMemberResultCallback_3_1<false,R,T1,P1,P2,P3,A1>::base*
NewPermanentTessCallback( T1* obj, R (T2::*member)(P1,P2,P3,A1) , typename Identity<P1>::type p1, typename Identity<P2>::type p2, typename Identity<P3>::type p3) {
  return new _TessMemberResultCallback_3_1<false,R,T1,P1,P2,P3,A1>(obj, member, p1, p2, p3);
}


template <bool del, class R, class P1, class P2, class P3, class A1>
class _TessFunctionResultCallback_3_1 : public TessResultCallback1<R,A1> {
 public:
  typedef TessResultCallback1<R,A1> base;
  typedef R (*FunctionSignature)(P1,P2,P3,A1);

 private:
  FunctionSignature function_;
  typename remove_reference<P1>::type p1_;
  typename remove_reference<P2>::type p2_;
  typename remove_reference<P3>::type p3_;

 public:
  inline _TessFunctionResultCallback_3_1(FunctionSignature function, P1 p1, P2 p2, P3 p3)
    : function_(function), p1_(p1), p2_(p2), p3_(p3) { }

  virtual R Run(A1 a1) {
    if (!del) {
      R result = (*function_)(p1_,p2_,p3_,a1);
      return result;
    } else {
      R result = (*function_)(p1_,p2_,p3_,a1);
      //  zero out the pointer to ensure segfault if used again
      function_ = __null;
      delete this;
      return result;
    }
  }
};

template <bool del, class P1, class P2, class P3, class A1>
class _TessFunctionResultCallback_3_1<del, void, P1, P2, P3, A1> : public TessCallback1<A1> {
 public:
  typedef TessCallback1<A1> base;
  typedef void (*FunctionSignature)(P1,P2,P3,A1);

 private:
  FunctionSignature function_;
  typename remove_reference<P1>::type p1_;
  typename remove_reference<P2>::type p2_;
  typename remove_reference<P3>::type p3_;

 public:
  inline _TessFunctionResultCallback_3_1(FunctionSignature function, P1 p1, P2 p2, P3 p3)
    : function_(function), p1_(p1), p2_(p2), p3_(p3) { }

  virtual void Run(A1 a1) {
    if (!del) {
      (*function_)(p1_,p2_,p3_,a1);
    } else {
      (*function_)(p1_,p2_,p3_,a1);
      //  zero out the pointer to ensure segfault if used again
      function_ = __null;
      delete this;
    }
  }
};

template <class R, class P1, class P2, class P3, class A1>
inline typename _TessFunctionResultCallback_3_1<true,R,P1,P2,P3,A1>::base*
NewTessCallback(R (*function)(P1,P2,P3,A1), typename Identity<P1>::type p1, typename Identity<P2>::type p2, typename Identity<P3>::type p3) {
  return new _TessFunctionResultCallback_3_1<true,R,P1,P2,P3,A1>(function, p1, p2, p3);
}

template <class R, class P1, class P2, class P3, class A1>
inline typename _TessFunctionResultCallback_3_1<false,R,P1,P2,P3,A1>::base*
NewPermanentTessCallback(R (*function)(P1,P2,P3,A1), typename Identity<P1>::type p1, typename Identity<P2>::type p2, typename Identity<P3>::type p3) {
  return new _TessFunctionResultCallback_3_1<false,R,P1,P2,P3,A1>(function, p1, p2, p3);
}

template <bool del, class R, class T, class P1, class P2, class P3, class P4, class A1>
class _ConstTessMemberResultCallback_4_1 : public TessResultCallback1<R,A1> {
 public:
  typedef TessResultCallback1<R,A1> base;
  typedef R (T::*MemberSignature)(P1,P2,P3,P4,A1) const;

 private:
  const T* object_;
  MemberSignature member_;
  typename remove_reference<P1>::type p1_;
  typename remove_reference<P2>::type p2_;
  typename remove_reference<P3>::type p3_;
  typename remove_reference<P4>::type p4_;

 public:
  inline _ConstTessMemberResultCallback_4_1(const T* object, MemberSignature member, P1 p1, P2 p2, P3 p3, P4 p4)
    : object_(object),
      member_(member), p1_(p1), p2_(p2), p3_(p3), p4_(p4) { }

  virtual R Run(A1 a1) {
    if (!del) {
      R result = (object_->*member_)(p1_,p2_,p3_,p4_,a1);
      return result;
    } else {
      R result = (object_->*member_)(p1_,p2_,p3_,p4_,a1);
      //  zero out the pointer to ensure segfault if used again
      member_ = __null;
      delete this;
      return result;
    }
  }
};

template <bool del, class T, class P1, class P2, class P3, class P4, class A1>
class _ConstTessMemberResultCallback_4_1<del, void, T, P1, P2, P3, P4, A1> : public TessCallback1<A1> {
 public:
  typedef TessCallback1<A1> base;
  typedef void (T::*MemberSignature)(P1,P2,P3,P4,A1) const;

 private:
  const T* object_;
  MemberSignature member_;
  typename remove_reference<P1>::type p1_;
  typename remove_reference<P2>::type p2_;
  typename remove_reference<P3>::type p3_;
  typename remove_reference<P4>::type p4_;

 public:
  inline _ConstTessMemberResultCallback_4_1(const T* object, MemberSignature member, P1 p1, P2 p2, P3 p3, P4 p4)
    : object_(object),
      member_(member), p1_(p1), p2_(p2), p3_(p3), p4_(p4) { }

  virtual void Run(A1 a1) {
    if (!del) {
      (object_->*member_)(p1_,p2_,p3_,p4_,a1);
    } else {
      (object_->*member_)(p1_,p2_,p3_,p4_,a1);
      //  zero out the pointer to ensure segfault if used again
      member_ = __null;
      delete this;
    }
  }
};


template <class T1, class T2, class R, class P1, class P2, class P3, class P4, class A1>
inline typename _ConstTessMemberResultCallback_4_1<true,R,T1,P1,P2,P3,P4,A1>::base*
NewTessCallback(const T1* obj, R (T2::*member)(P1,P2,P3,P4,A1) const, typename Identity<P1>::type p1, typename Identity<P2>::type p2, typename Identity<P3>::type p3, typename Identity<P4>::type p4) {
  return new _ConstTessMemberResultCallback_4_1<true,R,T1,P1,P2,P3,P4,A1>(obj, member, p1, p2, p3, p4);
}



template <class T1, class T2, class R, class P1, class P2, class P3, class P4, class A1>
inline typename _ConstTessMemberResultCallback_4_1<false,R,T1,P1,P2,P3,P4,A1>::base*
NewPermanentTessCallback(const T1* obj, R (T2::*member)(P1,P2,P3,P4,A1) const, typename Identity<P1>::type p1, typename Identity<P2>::type p2, typename Identity<P3>::type p3, typename Identity<P4>::type p4) {
  return new _ConstTessMemberResultCallback_4_1<false,R,T1,P1,P2,P3,P4,A1>(obj, member, p1, p2, p3, p4);
}


template <bool del, class R, class T, class P1, class P2, class P3, class P4, class A1>
class _TessMemberResultCallback_4_1 : public TessResultCallback1<R,A1> {
 public:
  typedef TessResultCallback1<R,A1> base;
  typedef R (T::*MemberSignature)(P1,P2,P3,P4,A1) ;

 private:
   T* object_;
  MemberSignature member_;
  typename remove_reference<P1>::type p1_;
  typename remove_reference<P2>::type p2_;
  typename remove_reference<P3>::type p3_;
  typename remove_reference<P4>::type p4_;

 public:
  inline _TessMemberResultCallback_4_1( T* object, MemberSignature member, P1 p1, P2 p2, P3 p3, P4 p4)
    : object_(object),
      member_(member), p1_(p1), p2_(p2), p3_(p3), p4_(p4) { }

  virtual R Run(A1 a1) {
    if (!del) {
      R result = (object_->*member_)(p1_,p2_,p3_,p4_,a1);
      return result;
    } else {
      R result = (object_->*member_)(p1_,p2_,p3_,p4_,a1);
      //  zero out the pointer to ensure segfault if used again
      member_ = __null;
      delete this;
      return result;
    }
  }
};

template <bool del, class T, class P1, class P2, class P3, class P4, class A1>
class _TessMemberResultCallback_4_1<del, void, T, P1, P2, P3, P4, A1> : public TessCallback1<A1> {
 public:
  typedef TessCallback1<A1> base;
  typedef void (T::*MemberSignature)(P1,P2,P3,P4,A1) ;

 private:
   T* object_;
  MemberSignature member_;
  typename remove_reference<P1>::type p1_;
  typename remove_reference<P2>::type p2_;
  typename remove_reference<P3>::type p3_;
  typename remove_reference<P4>::type p4_;

 public:
  inline _TessMemberResultCallback_4_1( T* object, MemberSignature member, P1 p1, P2 p2, P3 p3, P4 p4)
    : object_(object),
      member_(member), p1_(p1), p2_(p2), p3_(p3), p4_(p4) { }

  virtual void Run(A1 a1) {
    if (!del) {
      (object_->*member_)(p1_,p2_,p3_,p4_,a1);
    } else {
      (object_->*member_)(p1_,p2_,p3_,p4_,a1);
      //  zero out the pointer to ensure segfault if used again
      member_ = __null;
      delete this;
    }
  }
};


template <class T1, class T2, class R, class P1, class P2, class P3, class P4, class A1>
inline typename _TessMemberResultCallback_4_1<true,R,T1,P1,P2,P3,P4,A1>::base*
NewTessCallback( T1* obj, R (T2::*member)(P1,P2,P3,P4,A1) , typename Identity<P1>::type p1, typename Identity<P2>::type p2, typename Identity<P3>::type p3, typename Identity<P4>::type p4) {
  return new _TessMemberResultCallback_4_1<true,R,T1,P1,P2,P3,P4,A1>(obj, member, p1, p2, p3, p4);
}



template <class T1, class T2, class R, class P1, class P2, class P3, class P4, class A1>
inline typename _TessMemberResultCallback_4_1<false,R,T1,P1,P2,P3,P4,A1>::base*
NewPermanentTessCallback( T1* obj, R (T2::*member)(P1,P2,P3,P4,A1) , typename Identity<P1>::type p1, typename Identity<P2>::type p2, typename Identity<P3>::type p3, typename Identity<P4>::type p4) {
  return new _TessMemberResultCallback_4_1<false,R,T1,P1,P2,P3,P4,A1>(obj, member, p1, p2, p3, p4);
}


template <bool del, class R, class P1, class P2, class P3, class P4, class A1>
class _TessFunctionResultCallback_4_1 : public TessResultCallback1<R,A1> {
 public:
  typedef TessResultCallback1<R,A1> base;
  typedef R (*FunctionSignature)(P1,P2,P3,P4,A1);

 private:
  FunctionSignature function_;
  typename remove_reference<P1>::type p1_;
  typename remove_reference<P2>::type p2_;
  typename remove_reference<P3>::type p3_;
  typename remove_reference<P4>::type p4_;

 public:
  inline _TessFunctionResultCallback_4_1(FunctionSignature function, P1 p1, P2 p2, P3 p3, P4 p4)
    : function_(function), p1_(p1), p2_(p2), p3_(p3), p4_(p4) { }

  virtual R Run(A1 a1) {
    if (!del) {
      R result = (*function_)(p1_,p2_,p3_,p4_,a1);
      return result;
    } else {
      R result = (*function_)(p1_,p2_,p3_,p4_,a1);
      //  zero out the pointer to ensure segfault if used again
      function_ = __null;
      delete this;
      return result;
    }
  }
};

template <bool del, class P1, class P2, class P3, class P4, class A1>
class _TessFunctionResultCallback_4_1<del, void, P1, P2, P3, P4, A1> : public TessCallback1<A1> {
 public:
  typedef TessCallback1<A1> base;
  typedef void (*FunctionSignature)(P1,P2,P3,P4,A1);

 private:
  FunctionSignature function_;
  typename remove_reference<P1>::type p1_;
  typename remove_reference<P2>::type p2_;
  typename remove_reference<P3>::type p3_;
  typename remove_reference<P4>::type p4_;

 public:
  inline _TessFunctionResultCallback_4_1(FunctionSignature function, P1 p1, P2 p2, P3 p3, P4 p4)
    : function_(function), p1_(p1), p2_(p2), p3_(p3), p4_(p4) { }

  virtual void Run(A1 a1) {
    if (!del) {
      (*function_)(p1_,p2_,p3_,p4_,a1);
    } else {
      (*function_)(p1_,p2_,p3_,p4_,a1);
      //  zero out the pointer to ensure segfault if used again
      function_ = __null;
      delete this;
    }
  }
};

template <class R, class P1, class P2, class P3, class P4, class A1>
inline typename _TessFunctionResultCallback_4_1<true,R,P1,P2,P3,P4,A1>::base*
NewTessCallback(R (*function)(P1,P2,P3,P4,A1), typename Identity<P1>::type p1, typename Identity<P2>::type p2, typename Identity<P3>::type p3, typename Identity<P4>::type p4) {
  return new _TessFunctionResultCallback_4_1<true,R,P1,P2,P3,P4,A1>(function, p1, p2, p3, p4);
}

template <class R, class P1, class P2, class P3, class P4, class A1>
inline typename _TessFunctionResultCallback_4_1<false,R,P1,P2,P3,P4,A1>::base*
NewPermanentTessCallback(R (*function)(P1,P2,P3,P4,A1), typename Identity<P1>::type p1, typename Identity<P2>::type p2, typename Identity<P3>::type p3, typename Identity<P4>::type p4) {
  return new _TessFunctionResultCallback_4_1<false,R,P1,P2,P3,P4,A1>(function, p1, p2, p3, p4);
}

template <bool del, class R, class T, class P1, class P2, class P3, class P4, class P5, class A1>
class _ConstTessMemberResultCallback_5_1 : public TessResultCallback1<R,A1> {
 public:
  typedef TessResultCallback1<R,A1> base;
  typedef R (T::*MemberSignature)(P1,P2,P3,P4,P5,A1) const;

 private:
  const T* object_;
  MemberSignature member_;
  typename remove_reference<P1>::type p1_;
  typename remove_reference<P2>::type p2_;
  typename remove_reference<P3>::type p3_;
  typename remove_reference<P4>::type p4_;
  typename remove_reference<P5>::type p5_;

 public:
  inline _ConstTessMemberResultCallback_5_1(const T* object, MemberSignature member, P1 p1, P2 p2, P3 p3, P4 p4, P5 p5)
    : object_(object),
      member_(member), p1_(p1), p2_(p2), p3_(p3), p4_(p4), p5_(p5) { }

  virtual R Run(A1 a1) {
    if (!del) {
      R result = (object_->*member_)(p1_,p2_,p3_,p4_,p5_,a1);
      return result;
    } else {
      R result = (object_->*member_)(p1_,p2_,p3_,p4_,p5_,a1);
      //  zero out the pointer to ensure segfault if used again
      member_ = __null;
      delete this;
      return result;
    }
  }
};

template <bool del, class T, class P1, class P2, class P3, class P4, class P5, class A1>
class _ConstTessMemberResultCallback_5_1<del, void, T, P1, P2, P3, P4, P5, A1> : public TessCallback1<A1> {
 public:
  typedef TessCallback1<A1> base;
  typedef void (T::*MemberSignature)(P1,P2,P3,P4,P5,A1) const;

 private:
  const T* object_;
  MemberSignature member_;
  typename remove_reference<P1>::type p1_;
  typename remove_reference<P2>::type p2_;
  typename remove_reference<P3>::type p3_;
  typename remove_reference<P4>::type p4_;
  typename remove_reference<P5>::type p5_;

 public:
  inline _ConstTessMemberResultCallback_5_1(const T* object, MemberSignature member, P1 p1, P2 p2, P3 p3, P4 p4, P5 p5)
    : object_(object),
      member_(member), p1_(p1), p2_(p2), p3_(p3), p4_(p4), p5_(p5) { }

  virtual void Run(A1 a1) {
    if (!del) {
      (object_->*member_)(p1_,p2_,p3_,p4_,p5_,a1);
    } else {
      (object_->*member_)(p1_,p2_,p3_,p4_,p5_,a1);
      //  zero out the pointer to ensure segfault if used again
      member_ = __null;
      delete this;
    }
  }
};


template <class T1, class T2, class R, class P1, class P2, class P3, class P4, class P5, class A1>
inline typename _ConstTessMemberResultCallback_5_1<true,R,T1,P1,P2,P3,P4,P5,A1>::base*
NewTessCallback(const T1* obj, R (T2::*member)(P1,P2,P3,P4,P5,A1) const, typename Identity<P1>::type p1, typename Identity<P2>::type p2, typename Identity<P3>::type p3, typename Identity<P4>::type p4, typename Identity<P5>::type p5) {
  return new _ConstTessMemberResultCallback_5_1<true,R,T1,P1,P2,P3,P4,P5,A1>(obj, member, p1, p2, p3, p4, p5);
}



template <class T1, class T2, class R, class P1, class P2, class P3, class P4, class P5, class A1>
inline typename _ConstTessMemberResultCallback_5_1<false,R,T1,P1,P2,P3,P4,P5,A1>::base*
NewPermanentTessCallback(const T1* obj, R (T2::*member)(P1,P2,P3,P4,P5,A1) const, typename Identity<P1>::type p1, typename Identity<P2>::type p2, typename Identity<P3>::type p3, typename Identity<P4>::type p4, typename Identity<P5>::type p5) {
  return new _ConstTessMemberResultCallback_5_1<false,R,T1,P1,P2,P3,P4,P5,A1>(obj, member, p1, p2, p3, p4, p5);
}


template <bool del, class R, class T, class P1, class P2, class P3, class P4, class P5, class A1>
class _TessMemberResultCallback_5_1 : public TessResultCallback1<R,A1> {
 public:
  typedef TessResultCallback1<R,A1> base;
  typedef R (T::*MemberSignature)(P1,P2,P3,P4,P5,A1) ;

 private:
   T* object_;
  MemberSignature member_;
  typename remove_reference<P1>::type p1_;
  typename remove_reference<P2>::type p2_;
  typename remove_reference<P3>::type p3_;
  typename remove_reference<P4>::type p4_;
  typename remove_reference<P5>::type p5_;

 public:
  inline _TessMemberResultCallback_5_1( T* object, MemberSignature member, P1 p1, P2 p2, P3 p3, P4 p4, P5 p5)
    : object_(object),
      member_(member), p1_(p1), p2_(p2), p3_(p3), p4_(p4), p5_(p5) { }

  virtual R Run(A1 a1) {
    if (!del) {
      R result = (object_->*member_)(p1_,p2_,p3_,p4_,p5_,a1);
      return result;
    } else {
      R result = (object_->*member_)(p1_,p2_,p3_,p4_,p5_,a1);
      //  zero out the pointer to ensure segfault if used again
      member_ = __null;
      delete this;
      return result;
    }
  }
};

template <bool del, class T, class P1, class P2, class P3, class P4, class P5, class A1>
class _TessMemberResultCallback_5_1<del, void, T, P1, P2, P3, P4, P5, A1> : public TessCallback1<A1> {
 public:
  typedef TessCallback1<A1> base;
  typedef void (T::*MemberSignature)(P1,P2,P3,P4,P5,A1) ;

 private:
   T* object_;
  MemberSignature member_;
  typename remove_reference<P1>::type p1_;
  typename remove_reference<P2>::type p2_;
  typename remove_reference<P3>::type p3_;
  typename remove_reference<P4>::type p4_;
  typename remove_reference<P5>::type p5_;

 public:
  inline _TessMemberResultCallback_5_1( T* object, MemberSignature member, P1 p1, P2 p2, P3 p3, P4 p4, P5 p5)
    : object_(object),
      member_(member), p1_(p1), p2_(p2), p3_(p3), p4_(p4), p5_(p5) { }

  virtual void Run(A1 a1) {
    if (!del) {
      (object_->*member_)(p1_,p2_,p3_,p4_,p5_,a1);
    } else {
      (object_->*member_)(p1_,p2_,p3_,p4_,p5_,a1);
      //  zero out the pointer to ensure segfault if used again
      member_ = __null;
      delete this;
    }
  }
};


template <class T1, class T2, class R, class P1, class P2, class P3, class P4, class P5, class A1>
inline typename _TessMemberResultCallback_5_1<true,R,T1,P1,P2,P3,P4,P5,A1>::base*
NewTessCallback( T1* obj, R (T2::*member)(P1,P2,P3,P4,P5,A1) , typename Identity<P1>::type p1, typename Identity<P2>::type p2, typename Identity<P3>::type p3, typename Identity<P4>::type p4, typename Identity<P5>::type p5) {
  return new _TessMemberResultCallback_5_1<true,R,T1,P1,P2,P3,P4,P5,A1>(obj, member, p1, p2, p3, p4, p5);
}



template <class T1, class T2, class R, class P1, class P2, class P3, class P4, class P5, class A1>
inline typename _TessMemberResultCallback_5_1<false,R,T1,P1,P2,P3,P4,P5,A1>::base*
NewPermanentTessCallback( T1* obj, R (T2::*member)(P1,P2,P3,P4,P5,A1) , typename Identity<P1>::type p1, typename Identity<P2>::type p2, typename Identity<P3>::type p3, typename Identity<P4>::type p4, typename Identity<P5>::type p5) {
  return new _TessMemberResultCallback_5_1<false,R,T1,P1,P2,P3,P4,P5,A1>(obj, member, p1, p2, p3, p4, p5);
}


template <bool del, class R, class P1, class P2, class P3, class P4, class P5, class A1>
class _TessFunctionResultCallback_5_1 : public TessResultCallback1<R,A1> {
 public:
  typedef TessResultCallback1<R,A1> base;
  typedef R (*FunctionSignature)(P1,P2,P3,P4,P5,A1);

 private:
  FunctionSignature function_;
  typename remove_reference<P1>::type p1_;
  typename remove_reference<P2>::type p2_;
  typename remove_reference<P3>::type p3_;
  typename remove_reference<P4>::type p4_;
  typename remove_reference<P5>::type p5_;

 public:
  inline _TessFunctionResultCallback_5_1(FunctionSignature function, P1 p1, P2 p2, P3 p3, P4 p4, P5 p5)
    : function_(function), p1_(p1), p2_(p2), p3_(p3), p4_(p4), p5_(p5) { }

  virtual R Run(A1 a1) {
    if (!del) {
      R result = (*function_)(p1_,p2_,p3_,p4_,p5_,a1);
      return result;
    } else {
      R result = (*function_)(p1_,p2_,p3_,p4_,p5_,a1);
      //  zero out the pointer to ensure segfault if used again
      function_ = __null;
      delete this;
      return result;
    }
  }
};

template <bool del, class P1, class P2, class P3, class P4, class P5, class A1>
class _TessFunctionResultCallback_5_1<del, void, P1, P2, P3, P4, P5, A1> : public TessCallback1<A1> {
 public:
  typedef TessCallback1<A1> base;
  typedef void (*FunctionSignature)(P1,P2,P3,P4,P5,A1);

 private:
  FunctionSignature function_;
  typename remove_reference<P1>::type p1_;
  typename remove_reference<P2>::type p2_;
  typename remove_reference<P3>::type p3_;
  typename remove_reference<P4>::type p4_;
  typename remove_reference<P5>::type p5_;

 public:
  inline _TessFunctionResultCallback_5_1(FunctionSignature function, P1 p1, P2 p2, P3 p3, P4 p4, P5 p5)
    : function_(function), p1_(p1), p2_(p2), p3_(p3), p4_(p4), p5_(p5) { }

  virtual void Run(A1 a1) {
    if (!del) {
      (*function_)(p1_,p2_,p3_,p4_,p5_,a1);
    } else {
      (*function_)(p1_,p2_,p3_,p4_,p5_,a1);
      //  zero out the pointer to ensure segfault if used again
      function_ = __null;
      delete this;
    }
  }
};

template <class R, class P1, class P2, class P3, class P4, class P5, class A1>
inline typename _TessFunctionResultCallback_5_1<true,R,P1,P2,P3,P4,P5,A1>::base*
NewTessCallback(R (*function)(P1,P2,P3,P4,P5,A1), typename Identity<P1>::type p1, typename Identity<P2>::type p2, typename Identity<P3>::type p3, typename Identity<P4>::type p4, typename Identity<P5>::type p5) {
  return new _TessFunctionResultCallback_5_1<true,R,P1,P2,P3,P4,P5,A1>(function, p1, p2, p3, p4, p5);
}

template <class R, class P1, class P2, class P3, class P4, class P5, class A1>
inline typename _TessFunctionResultCallback_5_1<false,R,P1,P2,P3,P4,P5,A1>::base*
NewPermanentTessCallback(R (*function)(P1,P2,P3,P4,P5,A1), typename Identity<P1>::type p1, typename Identity<P2>::type p2, typename Identity<P3>::type p3, typename Identity<P4>::type p4, typename Identity<P5>::type p5) {
  return new _TessFunctionResultCallback_5_1<false,R,P1,P2,P3,P4,P5,A1>(function, p1, p2, p3, p4, p5);
}

template <bool del, class R, class T, class P1, class P2, class P3, class P4, class P5, class P6, class A1>
class _ConstTessMemberResultCallback_6_1 : public TessResultCallback1<R,A1> {
 public:
  typedef TessResultCallback1<R,A1> base;
  typedef R (T::*MemberSignature)(P1,P2,P3,P4,P5,P6,A1) const;

 private:
  const T* object_;
  MemberSignature member_;
  typename remove_reference<P1>::type p1_;
  typename remove_reference<P2>::type p2_;
  typename remove_reference<P3>::type p3_;
  typename remove_reference<P4>::type p4_;
  typename remove_reference<P5>::type p5_;
  typename remove_reference<P6>::type p6_;

 public:
  inline _ConstTessMemberResultCallback_6_1(const T* object, MemberSignature member, P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6)
    : object_(object),
      member_(member), p1_(p1), p2_(p2), p3_(p3), p4_(p4), p5_(p5), p6_(p6) { }

  virtual R Run(A1 a1) {
    if (!del) {
      R result = (object_->*member_)(p1_,p2_,p3_,p4_,p5_,p6_,a1);
      return result;
    } else {
      R result = (object_->*member_)(p1_,p2_,p3_,p4_,p5_,p6_,a1);
      //  zero out the pointer to ensure segfault if used again
      member_ = __null;
      delete this;
      return result;
    }
  }
};

template <bool del, class T, class P1, class P2, class P3, class P4, class P5, class P6, class A1>
class _ConstTessMemberResultCallback_6_1<del, void, T, P1, P2, P3, P4, P5, P6, A1> : public TessCallback1<A1> {
 public:
  typedef TessCallback1<A1> base;
  typedef void (T::*MemberSignature)(P1,P2,P3,P4,P5,P6,A1) const;

 private:
  const T* object_;
  MemberSignature member_;
  typename remove_reference<P1>::type p1_;
  typename remove_reference<P2>::type p2_;
  typename remove_reference<P3>::type p3_;
  typename remove_reference<P4>::type p4_;
  typename remove_reference<P5>::type p5_;
  typename remove_reference<P6>::type p6_;

 public:
  inline _ConstTessMemberResultCallback_6_1(const T* object, MemberSignature member, P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6)
    : object_(object),
      member_(member), p1_(p1), p2_(p2), p3_(p3), p4_(p4), p5_(p5), p6_(p6) { }

  virtual void Run(A1 a1) {
    if (!del) {
      (object_->*member_)(p1_,p2_,p3_,p4_,p5_,p6_,a1);
    } else {
      (object_->*member_)(p1_,p2_,p3_,p4_,p5_,p6_,a1);
      //  zero out the pointer to ensure segfault if used again
      member_ = __null;
      delete this;
    }
  }
};


template <class T1, class T2, class R, class P1, class P2, class P3, class P4, class P5, class P6, class A1>
inline typename _ConstTessMemberResultCallback_6_1<true,R,T1,P1,P2,P3,P4,P5,P6,A1>::base*
NewTessCallback(const T1* obj, R (T2::*member)(P1,P2,P3,P4,P5,P6,A1) const, typename Identity<P1>::type p1, typename Identity<P2>::type p2, typename Identity<P3>::type p3, typename Identity<P4>::type p4, typename Identity<P5>::type p5, typename Identity<P6>::type p6) {
  return new _ConstTessMemberResultCallback_6_1<true,R,T1,P1,P2,P3,P4,P5,P6,A1>(obj, member, p1, p2, p3, p4, p5, p6);
}



template <class T1, class T2, class R, class P1, class P2, class P3, class P4, class P5, class P6, class A1>
inline typename _ConstTessMemberResultCallback_6_1<false,R,T1,P1,P2,P3,P4,P5,P6,A1>::base*
NewPermanentTessCallback(const T1* obj, R (T2::*member)(P1,P2,P3,P4,P5,P6,A1) const, typename Identity<P1>::type p1, typename Identity<P2>::type p2, typename Identity<P3>::type p3, typename Identity<P4>::type p4, typename Identity<P5>::type p5, typename Identity<P6>::type p6) {
  return new _ConstTessMemberResultCallback_6_1<false,R,T1,P1,P2,P3,P4,P5,P6,A1>(obj, member, p1, p2, p3, p4, p5, p6);
}


template <bool del, class R, class T, class P1, class P2, class P3, class P4, class P5, class P6, class A1>
class _TessMemberResultCallback_6_1 : public TessResultCallback1<R,A1> {
 public:
  typedef TessResultCallback1<R,A1> base;
  typedef R (T::*MemberSignature)(P1,P2,P3,P4,P5,P6,A1) ;

 private:
   T* object_;
  MemberSignature member_;
  typename remove_reference<P1>::type p1_;
  typename remove_reference<P2>::type p2_;
  typename remove_reference<P3>::type p3_;
  typename remove_reference<P4>::type p4_;
  typename remove_reference<P5>::type p5_;
  typename remove_reference<P6>::type p6_;

 public:
  inline _TessMemberResultCallback_6_1( T* object, MemberSignature member, P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6)
    : object_(object),
      member_(member), p1_(p1), p2_(p2), p3_(p3), p4_(p4), p5_(p5), p6_(p6) { }

  virtual R Run(A1 a1) {
    if (!del) {
      R result = (object_->*member_)(p1_,p2_,p3_,p4_,p5_,p6_,a1);
      return result;
    } else {
      R result = (object_->*member_)(p1_,p2_,p3_,p4_,p5_,p6_,a1);
      //  zero out the pointer to ensure segfault if used again
      member_ = __null;
      delete this;
      return result;
    }
  }
};

template <bool del, class T, class P1, class P2, class P3, class P4, class P5, class P6, class A1>
class _TessMemberResultCallback_6_1<del, void, T, P1, P2, P3, P4, P5, P6, A1> : public TessCallback1<A1> {
 public:
  typedef TessCallback1<A1> base;
  typedef void (T::*MemberSignature)(P1,P2,P3,P4,P5,P6,A1) ;

 private:
   T* object_;
  MemberSignature member_;
  typename remove_reference<P1>::type p1_;
  typename remove_reference<P2>::type p2_;
  typename remove_reference<P3>::type p3_;
  typename remove_reference<P4>::type p4_;
  typename remove_reference<P5>::type p5_;
  typename remove_reference<P6>::type p6_;

 public:
  inline _TessMemberResultCallback_6_1( T* object, MemberSignature member, P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6)
    : object_(object),
      member_(member), p1_(p1), p2_(p2), p3_(p3), p4_(p4), p5_(p5), p6_(p6) { }

  virtual void Run(A1 a1) {
    if (!del) {
      (object_->*member_)(p1_,p2_,p3_,p4_,p5_,p6_,a1);
    } else {
      (object_->*member_)(p1_,p2_,p3_,p4_,p5_,p6_,a1);
      //  zero out the pointer to ensure segfault if used again
      member_ = __null;
      delete this;
    }
  }
};


template <class T1, class T2, class R, class P1, class P2, class P3, class P4, class P5, class P6, class A1>
inline typename _TessMemberResultCallback_6_1<true,R,T1,P1,P2,P3,P4,P5,P6,A1>::base*
NewTessCallback( T1* obj, R (T2::*member)(P1,P2,P3,P4,P5,P6,A1) , typename Identity<P1>::type p1, typename Identity<P2>::type p2, typename Identity<P3>::type p3, typename Identity<P4>::type p4, typename Identity<P5>::type p5, typename Identity<P6>::type p6) {
  return new _TessMemberResultCallback_6_1<true,R,T1,P1,P2,P3,P4,P5,P6,A1>(obj, member, p1, p2, p3, p4, p5, p6);
}



template <class T1, class T2, class R, class P1, class P2, class P3, class P4, class P5, class P6, class A1>
inline typename _TessMemberResultCallback_6_1<false,R,T1,P1,P2,P3,P4,P5,P6,A1>::base*
NewPermanentTessCallback( T1* obj, R (T2::*member)(P1,P2,P3,P4,P5,P6,A1) , typename Identity<P1>::type p1, typename Identity<P2>::type p2, typename Identity<P3>::type p3, typename Identity<P4>::type p4, typename Identity<P5>::type p5, typename Identity<P6>::type p6) {
  return new _TessMemberResultCallback_6_1<false,R,T1,P1,P2,P3,P4,P5,P6,A1>(obj, member, p1, p2, p3, p4, p5, p6);
}


template <bool del, class R, class P1, class P2, class P3, class P4, class P5, class P6, class A1>
class _TessFunctionResultCallback_6_1 : public TessResultCallback1<R,A1> {
 public:
  typedef TessResultCallback1<R,A1> base;
  typedef R (*FunctionSignature)(P1,P2,P3,P4,P5,P6,A1);

 private:
  FunctionSignature function_;
  typename remove_reference<P1>::type p1_;
  typename remove_reference<P2>::type p2_;
  typename remove_reference<P3>::type p3_;
  typename remove_reference<P4>::type p4_;
  typename remove_reference<P5>::type p5_;
  typename remove_reference<P6>::type p6_;

 public:
  inline _TessFunctionResultCallback_6_1(FunctionSignature function, P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6)
    : function_(function), p1_(p1), p2_(p2), p3_(p3), p4_(p4), p5_(p5), p6_(p6) { }

  virtual R Run(A1 a1) {
    if (!del) {
      R result = (*function_)(p1_,p2_,p3_,p4_,p5_,p6_,a1);
      return result;
    } else {
      R result = (*function_)(p1_,p2_,p3_,p4_,p5_,p6_,a1);
      //  zero out the pointer to ensure segfault if used again
      function_ = __null;
      delete this;
      return result;
    }
  }
};

template <bool del, class P1, class P2, class P3, class P4, class P5, class P6, class A1>
class _TessFunctionResultCallback_6_1<del, void, P1, P2, P3, P4, P5, P6, A1> : public TessCallback1<A1> {
 public:
  typedef TessCallback1<A1> base;
  typedef void (*FunctionSignature)(P1,P2,P3,P4,P5,P6,A1);

 private:
  FunctionSignature function_;
  typename remove_reference<P1>::type p1_;
  typename remove_reference<P2>::type p2_;
  typename remove_reference<P3>::type p3_;
  typename remove_reference<P4>::type p4_;
  typename remove_reference<P5>::type p5_;
  typename remove_reference<P6>::type p6_;

 public:
  inline _TessFunctionResultCallback_6_1(FunctionSignature function, P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6)
    : function_(function), p1_(p1), p2_(p2), p3_(p3), p4_(p4), p5_(p5), p6_(p6) { }

  virtual void Run(A1 a1) {
    if (!del) {
      (*function_)(p1_,p2_,p3_,p4_,p5_,p6_,a1);
    } else {
      (*function_)(p1_,p2_,p3_,p4_,p5_,p6_,a1);
      //  zero out the pointer to ensure segfault if used again
      function_ = __null;
      delete this;
    }
  }
};

template <class R, class P1, class P2, class P3, class P4, class P5, class P6, class A1>
inline typename _TessFunctionResultCallback_6_1<true,R,P1,P2,P3,P4,P5,P6,A1>::base*
NewTessCallback(R (*function)(P1,P2,P3,P4,P5,P6,A1), typename Identity<P1>::type p1, typename Identity<P2>::type p2, typename Identity<P3>::type p3, typename Identity<P4>::type p4, typename Identity<P5>::type p5, typename Identity<P6>::type p6) {
  return new _TessFunctionResultCallback_6_1<true,R,P1,P2,P3,P4,P5,P6,A1>(function, p1, p2, p3, p4, p5, p6);
}

template <class R, class P1, class P2, class P3, class P4, class P5, class P6, class A1>
inline typename _TessFunctionResultCallback_6_1<false,R,P1,P2,P3,P4,P5,P6,A1>::base*
NewPermanentTessCallback(R (*function)(P1,P2,P3,P4,P5,P6,A1), typename Identity<P1>::type p1, typename Identity<P2>::type p2, typename Identity<P3>::type p3, typename Identity<P4>::type p4, typename Identity<P5>::type p5, typename Identity<P6>::type p6) {
  return new _TessFunctionResultCallback_6_1<false,R,P1,P2,P3,P4,P5,P6,A1>(function, p1, p2, p3, p4, p5, p6);
}

template <bool del, class R, class T, class A1, class A2>
class _ConstTessMemberResultCallback_0_2 : public TessResultCallback2<R,A1,A2> {
 public:
  typedef TessResultCallback2<R,A1,A2> base;
  typedef R (T::*MemberSignature)(A1,A2) const;

 private:
  const T* object_;
  MemberSignature member_;

 public:
  inline _ConstTessMemberResultCallback_0_2(
     const T* object, MemberSignature member)
    : object_(object),
      member_(member) {
  }

  virtual R Run(A1 a1,A2 a2) {
    if (!del) {
      R result = (object_->*member_)(a1,a2);
      return result;
    } else {
      R result = (object_->*member_)(a1,a2);
      //  zero out the pointer to ensure segfault if used again
      member_ = __null;
      delete this;
      return result;
    }
  }
};

template <bool del, class T, class A1, class A2>
class _ConstTessMemberResultCallback_0_2<del, void, T, A1, A2>
  : public TessCallback2<A1,A2> {
 public:
  typedef TessCallback2<A1,A2> base;
  typedef void (T::*MemberSignature)(A1,A2) const;

 private:
  const T* object_;
  MemberSignature member_;

 public:
  inline _ConstTessMemberResultCallback_0_2(
      const T* object, MemberSignature member)
    : object_(object),
      member_(member) {
  }

  virtual void Run(A1 a1,A2 a2) {
    if (!del) {
      (object_->*member_)(a1,a2);
    } else {
      (object_->*member_)(a1,a2);
      //  zero out the pointer to ensure segfault if used again
      member_ = __null;
      delete this;
    }
  }
};


template <class T1, class T2, class R, class A1, class A2>
inline typename _ConstTessMemberResultCallback_0_2<true,R,T1,A1,A2>::base*
NewTessCallback(
    const T1* obj, R (T2::*member)(A1,A2) const) {
  return new _ConstTessMemberResultCallback_0_2<true,R,T1,A1,A2>(
      obj, member);
}



template <class T1, class T2, class R, class A1, class A2>
inline typename _ConstTessMemberResultCallback_0_2<false,R,T1,A1,A2>::base*
NewPermanentTessCallback(
    const T1* obj, R (T2::*member)(A1,A2) const) {
  return new _ConstTessMemberResultCallback_0_2<false,R,T1,A1,A2>(
      obj, member);
}


template <bool del, class R, class T, class A1, class A2>
class _TessMemberResultCallback_0_2 : public TessResultCallback2<R,A1,A2> {
 public:
  typedef TessResultCallback2<R,A1,A2> base;
  typedef R (T::*MemberSignature)(A1,A2) ;

 private:
   T* object_;
  MemberSignature member_;

 public:
  inline _TessMemberResultCallback_0_2(
      T* object, MemberSignature member)
    : object_(object),
      member_(member) {
  }

  virtual R Run(A1 a1,A2 a2) {
    if (!del) {
      R result = (object_->*member_)(a1,a2);
      return result;
    } else {
      R result = (object_->*member_)(a1,a2);
      //  zero out the pointer to ensure segfault if used again
      member_ = __null;
      delete this;
      return result;
    }
  }
};

template <bool del, class T, class A1, class A2>
class _TessMemberResultCallback_0_2<del, void, T, A1, A2>
  : public TessCallback2<A1,A2> {
 public:
  typedef TessCallback2<A1,A2> base;
  typedef void (T::*MemberSignature)(A1,A2) ;

 private:
   T* object_;
  MemberSignature member_;

 public:
  inline _TessMemberResultCallback_0_2(
       T* object, MemberSignature member)
    : object_(object),
      member_(member) {
  }

  virtual void Run(A1 a1,A2 a2) {
    if (!del) {
      (object_->*member_)(a1,a2);
    } else {
      (object_->*member_)(a1,a2);
      //  zero out the pointer to ensure segfault if used again
      member_ = __null;
      delete this;
    }
  }
};


template <class T1, class T2, class R, class A1, class A2>
inline typename _TessMemberResultCallback_0_2<true,R,T1,A1,A2>::base*
NewTessCallback(
     T1* obj, R (T2::*member)(A1,A2) ) {
  return new _TessMemberResultCallback_0_2<true,R,T1,A1,A2>(
      obj, member);
}



template <class T1, class T2, class R, class A1, class A2>
inline typename _TessMemberResultCallback_0_2<false,R,T1,A1,A2>::base*
NewPermanentTessCallback(
     T1* obj, R (T2::*member)(A1,A2) ) {
  return new _TessMemberResultCallback_0_2<false,R,T1,A1,A2>(
      obj, member);
}


template <bool del, class R, class A1, class A2>
class _TessFunctionResultCallback_0_2 : public TessResultCallback2<R,A1,A2> {
 public:
  typedef TessResultCallback2<R,A1,A2> base;
  typedef R (*FunctionSignature)(A1,A2);

 private:
  FunctionSignature function_;

 public:
  inline _TessFunctionResultCallback_0_2(
      FunctionSignature function)
    : function_(function) {
  }

  virtual R Run(A1 a1,A2 a2) {
    if (!del) {
      R result = (*function_)(a1,a2);
      return result;
    } else {
      R result = (*function_)(a1,a2);
      //  zero out the pointer to ensure segfault if used again
      function_ = __null;
      delete this;
      return result;
    }
  }
};

template <bool del, class A1, class A2>
class _TessFunctionResultCallback_0_2<del, void, A1, A2>
  : public TessCallback2<A1,A2> {
 public:
  typedef TessCallback2<A1,A2> base;
  typedef void (*FunctionSignature)(A1,A2);

 private:
  FunctionSignature function_;

 public:
  inline _TessFunctionResultCallback_0_2(
      FunctionSignature function)
    : function_(function) {
  }

  virtual void Run(A1 a1,A2 a2) {
    if (!del) {
      (*function_)(a1,a2);
    } else {
      (*function_)(a1,a2);
      //  zero out the pointer to ensure segfault if used again
      function_ = __null;
      delete this;
    }
  }
};

template <class R, class A1, class A2>
inline typename _TessFunctionResultCallback_0_2<true,R,A1,A2>::base*
NewTessCallback(R (*function)(A1,A2)) {
  return new _TessFunctionResultCallback_0_2<true,R,A1,A2>(function);
}

template <class R, class A1, class A2>
inline typename _TessFunctionResultCallback_0_2<false,R,A1,A2>::base*
NewPermanentTessCallback(R (*function)(A1,A2)) {
  return new _TessFunctionResultCallback_0_2<false,R,A1,A2>(function);
}

template <bool del, class R, class T, class P1, class A1, class A2>
class _ConstTessMemberResultCallback_1_2 : public TessResultCallback2<R,A1,A2> {
 public:
  typedef TessResultCallback2<R,A1,A2> base;
  typedef R (T::*MemberSignature)(P1,A1,A2) const;

 private:
  const T* object_;
  MemberSignature member_;
  typename remove_reference<P1>::type p1_;

 public:
  inline _ConstTessMemberResultCallback_1_2(const T* object, MemberSignature member, P1 p1)
    : object_(object),
      member_(member), p1_(p1) { }

  virtual R Run(A1 a1,A2 a2) {
    if (!del) {
      R result = (object_->*member_)(p1_,a1,a2);
      return result;
    } else {
      R result = (object_->*member_)(p1_,a1,a2);
      //  zero out the pointer to ensure segfault if used again
      member_ = __null;
      delete this;
      return result;
    }
  }
};

template <bool del, class T, class P1, class A1, class A2>
class _ConstTessMemberResultCallback_1_2<del, void, T, P1, A1, A2> : public TessCallback2<A1,A2> {
 public:
  typedef TessCallback2<A1,A2> base;
  typedef void (T::*MemberSignature)(P1,A1,A2) const;

 private:
  const T* object_;
  MemberSignature member_;
  typename remove_reference<P1>::type p1_;

 public:
  inline _ConstTessMemberResultCallback_1_2(const T* object, MemberSignature member, P1 p1)
    : object_(object),
      member_(member), p1_(p1) { }

  virtual void Run(A1 a1,A2 a2) {
    if (!del) {
      (object_->*member_)(p1_,a1,a2);
    } else {
      (object_->*member_)(p1_,a1,a2);
      //  zero out the pointer to ensure segfault if used again
      member_ = __null;
      delete this;
    }
  }
};


template <class T1, class T2, class R, class P1, class A1, class A2>
inline typename _ConstTessMemberResultCallback_1_2<true,R,T1,P1,A1,A2>::base*
NewTessCallback(const T1* obj, R (T2::*member)(P1,A1,A2) const, typename Identity<P1>::type p1) {
  return new _ConstTessMemberResultCallback_1_2<true,R,T1,P1,A1,A2>(obj, member, p1);
}



template <class T1, class T2, class R, class P1, class A1, class A2>
inline typename _ConstTessMemberResultCallback_1_2<false,R,T1,P1,A1,A2>::base*
NewPermanentTessCallback(const T1* obj, R (T2::*member)(P1,A1,A2) const, typename Identity<P1>::type p1) {
  return new _ConstTessMemberResultCallback_1_2<false,R,T1,P1,A1,A2>(obj, member, p1);
}


template <bool del, class R, class T, class P1, class A1, class A2>
class _TessMemberResultCallback_1_2 : public TessResultCallback2<R,A1,A2> {
 public:
  typedef TessResultCallback2<R,A1,A2> base;
  typedef R (T::*MemberSignature)(P1,A1,A2) ;

 private:
   T* object_;
  MemberSignature member_;
  typename remove_reference<P1>::type p1_;

 public:
  inline _TessMemberResultCallback_1_2( T* object, MemberSignature member, P1 p1)
    : object_(object),
      member_(member), p1_(p1) { }

  virtual R Run(A1 a1,A2 a2) {
    if (!del) {
      R result = (object_->*member_)(p1_,a1,a2);
      return result;
    } else {
      R result = (object_->*member_)(p1_,a1,a2);
      //  zero out the pointer to ensure segfault if used again
      member_ = __null;
      delete this;
      return result;
    }
  }
};

template <bool del, class T, class P1, class A1, class A2>
class _TessMemberResultCallback_1_2<del, void, T, P1, A1, A2> : public TessCallback2<A1,A2> {
 public:
  typedef TessCallback2<A1,A2> base;
  typedef void (T::*MemberSignature)(P1,A1,A2) ;

 private:
   T* object_;
  MemberSignature member_;
  typename remove_reference<P1>::type p1_;

 public:
  inline _TessMemberResultCallback_1_2( T* object, MemberSignature member, P1 p1)
    : object_(object),
      member_(member), p1_(p1) { }

  virtual void Run(A1 a1,A2 a2) {
    if (!del) {
      (object_->*member_)(p1_,a1,a2);
    } else {
      (object_->*member_)(p1_,a1,a2);
      //  zero out the pointer to ensure segfault if used again
      member_ = __null;
      delete this;
    }
  }
};


template <class T1, class T2, class R, class P1, class A1, class A2>
inline typename _TessMemberResultCallback_1_2<true,R,T1,P1,A1,A2>::base*
NewTessCallback( T1* obj, R (T2::*member)(P1,A1,A2) , typename Identity<P1>::type p1) {
  return new _TessMemberResultCallback_1_2<true,R,T1,P1,A1,A2>(obj, member, p1);
}



template <class T1, class T2, class R, class P1, class A1, class A2>
inline typename _TessMemberResultCallback_1_2<false,R,T1,P1,A1,A2>::base*
NewPermanentTessCallback( T1* obj, R (T2::*member)(P1,A1,A2) , typename Identity<P1>::type p1) {
  return new _TessMemberResultCallback_1_2<false,R,T1,P1,A1,A2>(obj, member, p1);
}


template <bool del, class R, class P1, class A1, class A2>
class _TessFunctionResultCallback_1_2 : public TessResultCallback2<R,A1,A2> {
 public:
  typedef TessResultCallback2<R,A1,A2> base;
  typedef R (*FunctionSignature)(P1,A1,A2);

 private:
  FunctionSignature function_;
  typename remove_reference<P1>::type p1_;

 public:
  inline _TessFunctionResultCallback_1_2(FunctionSignature function, P1 p1)
    : function_(function), p1_(p1) { }

  virtual R Run(A1 a1,A2 a2) {
    if (!del) {
      R result = (*function_)(p1_,a1,a2);
      return result;
    } else {
      R result = (*function_)(p1_,a1,a2);
      //  zero out the pointer to ensure segfault if used again
      function_ = __null;
      delete this;
      return result;
    }
  }
};

template <bool del, class P1, class A1, class A2>
class _TessFunctionResultCallback_1_2<del, void, P1, A1, A2> : public TessCallback2<A1,A2> {
 public:
  typedef TessCallback2<A1,A2> base;
  typedef void (*FunctionSignature)(P1,A1,A2);

 private:
  FunctionSignature function_;
  typename remove_reference<P1>::type p1_;

 public:
  inline _TessFunctionResultCallback_1_2(FunctionSignature function, P1 p1)
    : function_(function), p1_(p1) { }

  virtual void Run(A1 a1,A2 a2) {
    if (!del) {
      (*function_)(p1_,a1,a2);
    } else {
      (*function_)(p1_,a1,a2);
      //  zero out the pointer to ensure segfault if used again
      function_ = __null;
      delete this;
    }
  }
};

template <class R, class P1, class A1, class A2>
inline typename _TessFunctionResultCallback_1_2<true,R,P1,A1,A2>::base*
NewTessCallback(R (*function)(P1,A1,A2), typename Identity<P1>::type p1) {
  return new _TessFunctionResultCallback_1_2<true,R,P1,A1,A2>(function, p1);
}

template <class R, class P1, class A1, class A2>
inline typename _TessFunctionResultCallback_1_2<false,R,P1,A1,A2>::base*
NewPermanentTessCallback(R (*function)(P1,A1,A2), typename Identity<P1>::type p1) {
  return new _TessFunctionResultCallback_1_2<false,R,P1,A1,A2>(function, p1);
}

template <bool del, class R, class T, class P1, class P2, class A1, class A2>
class _ConstTessMemberResultCallback_2_2 : public TessResultCallback2<R,A1,A2> {
 public:
  typedef TessResultCallback2<R,A1,A2> base;
  typedef R (T::*MemberSignature)(P1,P2,A1,A2) const;

 private:
  const T* object_;
  MemberSignature member_;
  typename remove_reference<P1>::type p1_;
  typename remove_reference<P2>::type p2_;

 public:
  inline _ConstTessMemberResultCallback_2_2(const T* object, MemberSignature member, P1 p1, P2 p2)
    : object_(object),
      member_(member), p1_(p1), p2_(p2) { }

  virtual R Run(A1 a1,A2 a2) {
    if (!del) {
      R result = (object_->*member_)(p1_,p2_,a1,a2);
      return result;
    } else {
      R result = (object_->*member_)(p1_,p2_,a1,a2);
      //  zero out the pointer to ensure segfault if used again
      member_ = __null;
      delete this;
      return result;
    }
  }
};

template <bool del, class T, class P1, class P2, class A1, class A2>
class _ConstTessMemberResultCallback_2_2<del, void, T, P1, P2, A1, A2> : public TessCallback2<A1,A2> {
 public:
  typedef TessCallback2<A1,A2> base;
  typedef void (T::*MemberSignature)(P1,P2,A1,A2) const;

 private:
  const T* object_;
  MemberSignature member_;
  typename remove_reference<P1>::type p1_;
  typename remove_reference<P2>::type p2_;

 public:
  inline _ConstTessMemberResultCallback_2_2(const T* object, MemberSignature member, P1 p1, P2 p2)
    : object_(object),
      member_(member), p1_(p1), p2_(p2) { }

  virtual void Run(A1 a1,A2 a2) {
    if (!del) {
      (object_->*member_)(p1_,p2_,a1,a2);
    } else {
      (object_->*member_)(p1_,p2_,a1,a2);
      //  zero out the pointer to ensure segfault if used again
      member_ = __null;
      delete this;
    }
  }
};


template <class T1, class T2, class R, class P1, class P2, class A1, class A2>
inline typename _ConstTessMemberResultCallback_2_2<true,R,T1,P1,P2,A1,A2>::base*
NewTessCallback(const T1* obj, R (T2::*member)(P1,P2,A1,A2) const, typename Identity<P1>::type p1, typename Identity<P2>::type p2) {
  return new _ConstTessMemberResultCallback_2_2<true,R,T1,P1,P2,A1,A2>(obj, member, p1, p2);
}



template <class T1, class T2, class R, class P1, class P2, class A1, class A2>
inline typename _ConstTessMemberResultCallback_2_2<false,R,T1,P1,P2,A1,A2>::base*
NewPermanentTessCallback(const T1* obj, R (T2::*member)(P1,P2,A1,A2) const, typename Identity<P1>::type p1, typename Identity<P2>::type p2) {
  return new _ConstTessMemberResultCallback_2_2<false,R,T1,P1,P2,A1,A2>(obj, member, p1, p2);
}


template <bool del, class R, class T, class P1, class P2, class A1, class A2>
class _TessMemberResultCallback_2_2 : public TessResultCallback2<R,A1,A2> {
 public:
  typedef TessResultCallback2<R,A1,A2> base;
  typedef R (T::*MemberSignature)(P1,P2,A1,A2) ;

 private:
   T* object_;
  MemberSignature member_;
  typename remove_reference<P1>::type p1_;
  typename remove_reference<P2>::type p2_;

 public:
  inline _TessMemberResultCallback_2_2( T* object, MemberSignature member, P1 p1, P2 p2)
    : object_(object),
      member_(member), p1_(p1), p2_(p2) { }

  virtual R Run(A1 a1,A2 a2) {
    if (!del) {
      R result = (object_->*member_)(p1_,p2_,a1,a2);
      return result;
    } else {
      R result = (object_->*member_)(p1_,p2_,a1,a2);
      //  zero out the pointer to ensure segfault if used again
      member_ = __null;
      delete this;
      return result;
    }
  }
};

template <bool del, class T, class P1, class P2, class A1, class A2>
class _TessMemberResultCallback_2_2<del, void, T, P1, P2, A1, A2> : public TessCallback2<A1,A2> {
 public:
  typedef TessCallback2<A1,A2> base;
  typedef void (T::*MemberSignature)(P1,P2,A1,A2) ;

 private:
   T* object_;
  MemberSignature member_;
  typename remove_reference<P1>::type p1_;
  typename remove_reference<P2>::type p2_;

 public:
  inline _TessMemberResultCallback_2_2( T* object, MemberSignature member, P1 p1, P2 p2)
    : object_(object),
      member_(member), p1_(p1), p2_(p2) { }

  virtual void Run(A1 a1,A2 a2) {
    if (!del) {
      (object_->*member_)(p1_,p2_,a1,a2);
    } else {
      (object_->*member_)(p1_,p2_,a1,a2);
      //  zero out the pointer to ensure segfault if used again
      member_ = __null;
      delete this;
    }
  }
};


template <class T1, class T2, class R, class P1, class P2, class A1, class A2>
inline typename _TessMemberResultCallback_2_2<true,R,T1,P1,P2,A1,A2>::base*
NewTessCallback( T1* obj, R (T2::*member)(P1,P2,A1,A2) , typename Identity<P1>::type p1, typename Identity<P2>::type p2) {
  return new _TessMemberResultCallback_2_2<true,R,T1,P1,P2,A1,A2>(obj, member, p1, p2);
}



template <class T1, class T2, class R, class P1, class P2, class A1, class A2>
inline typename _TessMemberResultCallback_2_2<false,R,T1,P1,P2,A1,A2>::base*
NewPermanentTessCallback( T1* obj, R (T2::*member)(P1,P2,A1,A2) , typename Identity<P1>::type p1, typename Identity<P2>::type p2) {
  return new _TessMemberResultCallback_2_2<false,R,T1,P1,P2,A1,A2>(obj, member, p1, p2);
}


template <bool del, class R, class P1, class P2, class A1, class A2>
class _TessFunctionResultCallback_2_2 : public TessResultCallback2<R,A1,A2> {
 public:
  typedef TessResultCallback2<R,A1,A2> base;
  typedef R (*FunctionSignature)(P1,P2,A1,A2);

 private:
  FunctionSignature function_;
  typename remove_reference<P1>::type p1_;
  typename remove_reference<P2>::type p2_;

 public:
  inline _TessFunctionResultCallback_2_2(FunctionSignature function, P1 p1, P2 p2)
    : function_(function), p1_(p1), p2_(p2) { }

  virtual R Run(A1 a1,A2 a2) {
    if (!del) {
      R result = (*function_)(p1_,p2_,a1,a2);
      return result;
    } else {
      R result = (*function_)(p1_,p2_,a1,a2);
      //  zero out the pointer to ensure segfault if used again
      function_ = __null;
      delete this;
      return result;
    }
  }
};

template <bool del, class P1, class P2, class A1, class A2>
class _TessFunctionResultCallback_2_2<del, void, P1, P2, A1, A2> : public TessCallback2<A1,A2> {
 public:
  typedef TessCallback2<A1,A2> base;
  typedef void (*FunctionSignature)(P1,P2,A1,A2);

 private:
  FunctionSignature function_;
  typename remove_reference<P1>::type p1_;
  typename remove_reference<P2>::type p2_;

 public:
  inline _TessFunctionResultCallback_2_2(FunctionSignature function, P1 p1, P2 p2)
    : function_(function), p1_(p1), p2_(p2) { }

  virtual void Run(A1 a1,A2 a2) {
    if (!del) {
      (*function_)(p1_,p2_,a1,a2);
    } else {
      (*function_)(p1_,p2_,a1,a2);
      //  zero out the pointer to ensure segfault if used again
      function_ = __null;
      delete this;
    }
  }
};

template <class R, class P1, class P2, class A1, class A2>
inline typename _TessFunctionResultCallback_2_2<true,R,P1,P2,A1,A2>::base*
NewTessCallback(R (*function)(P1,P2,A1,A2), typename Identity<P1>::type p1, typename Identity<P2>::type p2) {
  return new _TessFunctionResultCallback_2_2<true,R,P1,P2,A1,A2>(function, p1, p2);
}

template <class R, class P1, class P2, class A1, class A2>
inline typename _TessFunctionResultCallback_2_2<false,R,P1,P2,A1,A2>::base*
NewPermanentTessCallback(R (*function)(P1,P2,A1,A2), typename Identity<P1>::type p1, typename Identity<P2>::type p2) {
  return new _TessFunctionResultCallback_2_2<false,R,P1,P2,A1,A2>(function, p1, p2);
}

template <bool del, class R, class T, class P1, class P2, class P3, class A1, class A2>
class _ConstTessMemberResultCallback_3_2 : public TessResultCallback2<R,A1,A2> {
 public:
  typedef TessResultCallback2<R,A1,A2> base;
  typedef R (T::*MemberSignature)(P1,P2,P3,A1,A2) const;

 private:
  const T* object_;
  MemberSignature member_;
  typename remove_reference<P1>::type p1_;
  typename remove_reference<P2>::type p2_;
  typename remove_reference<P3>::type p3_;

 public:
  inline _ConstTessMemberResultCallback_3_2(const T* object, MemberSignature member, P1 p1, P2 p2, P3 p3)
    : object_(object),
      member_(member), p1_(p1), p2_(p2), p3_(p3) { }

  virtual R Run(A1 a1,A2 a2) {
    if (!del) {
      R result = (object_->*member_)(p1_,p2_,p3_,a1,a2);
      return result;
    } else {
      R result = (object_->*member_)(p1_,p2_,p3_,a1,a2);
      //  zero out the pointer to ensure segfault if used again
      member_ = __null;
      delete this;
      return result;
    }
  }
};

template <bool del, class T, class P1, class P2, class P3, class A1, class A2>
class _ConstTessMemberResultCallback_3_2<del, void, T, P1, P2, P3, A1, A2> : public TessCallback2<A1,A2> {
 public:
  typedef TessCallback2<A1,A2> base;
  typedef void (T::*MemberSignature)(P1,P2,P3,A1,A2) const;

 private:
  const T* object_;
  MemberSignature member_;
  typename remove_reference<P1>::type p1_;
  typename remove_reference<P2>::type p2_;
  typename remove_reference<P3>::type p3_;

 public:
  inline _ConstTessMemberResultCallback_3_2(const T* object, MemberSignature member, P1 p1, P2 p2, P3 p3)
    : object_(object),
      member_(member), p1_(p1), p2_(p2), p3_(p3) { }

  virtual void Run(A1 a1,A2 a2) {
    if (!del) {
      (object_->*member_)(p1_,p2_,p3_,a1,a2);
    } else {
      (object_->*member_)(p1_,p2_,p3_,a1,a2);
      //  zero out the pointer to ensure segfault if used again
      member_ = __null;
      delete this;
    }
  }
};


template <class T1, class T2, class R, class P1, class P2, class P3, class A1, class A2>
inline typename _ConstTessMemberResultCallback_3_2<true,R,T1,P1,P2,P3,A1,A2>::base*
NewTessCallback(const T1* obj, R (T2::*member)(P1,P2,P3,A1,A2) const, typename Identity<P1>::type p1, typename Identity<P2>::type p2, typename Identity<P3>::type p3) {
  return new _ConstTessMemberResultCallback_3_2<true,R,T1,P1,P2,P3,A1,A2>(obj, member, p1, p2, p3);
}



template <class T1, class T2, class R, class P1, class P2, class P3, class A1, class A2>
inline typename _ConstTessMemberResultCallback_3_2<false,R,T1,P1,P2,P3,A1,A2>::base*
NewPermanentTessCallback(const T1* obj, R (T2::*member)(P1,P2,P3,A1,A2) const, typename Identity<P1>::type p1, typename Identity<P2>::type p2, typename Identity<P3>::type p3) {
  return new _ConstTessMemberResultCallback_3_2<false,R,T1,P1,P2,P3,A1,A2>(obj, member, p1, p2, p3);
}


template <bool del, class R, class T, class P1, class P2, class P3, class A1, class A2>
class _TessMemberResultCallback_3_2 : public TessResultCallback2<R,A1,A2> {
 public:
  typedef TessResultCallback2<R,A1,A2> base;
  typedef R (T::*MemberSignature)(P1,P2,P3,A1,A2) ;

 private:
   T* object_;
  MemberSignature member_;
  typename remove_reference<P1>::type p1_;
  typename remove_reference<P2>::type p2_;
  typename remove_reference<P3>::type p3_;

 public:
  inline _TessMemberResultCallback_3_2( T* object, MemberSignature member, P1 p1, P2 p2, P3 p3)
    : object_(object),
      member_(member), p1_(p1), p2_(p2), p3_(p3) { }

  virtual R Run(A1 a1,A2 a2) {
    if (!del) {
      R result = (object_->*member_)(p1_,p2_,p3_,a1,a2);
      return result;
    } else {
      R result = (object_->*member_)(p1_,p2_,p3_,a1,a2);
      //  zero out the pointer to ensure segfault if used again
      member_ = __null;
      delete this;
      return result;
    }
  }
};

template <bool del, class T, class P1, class P2, class P3, class A1, class A2>
class _TessMemberResultCallback_3_2<del, void, T, P1, P2, P3, A1, A2> : public TessCallback2<A1,A2> {
 public:
  typedef TessCallback2<A1,A2> base;
  typedef void (T::*MemberSignature)(P1,P2,P3,A1,A2) ;

 private:
   T* object_;
  MemberSignature member_;
  typename remove_reference<P1>::type p1_;
  typename remove_reference<P2>::type p2_;
  typename remove_reference<P3>::type p3_;

 public:
  inline _TessMemberResultCallback_3_2( T* object, MemberSignature member, P1 p1, P2 p2, P3 p3)
    : object_(object),
      member_(member), p1_(p1), p2_(p2), p3_(p3) { }

  virtual void Run(A1 a1,A2 a2) {
    if (!del) {
      (object_->*member_)(p1_,p2_,p3_,a1,a2);
    } else {
      (object_->*member_)(p1_,p2_,p3_,a1,a2);
      //  zero out the pointer to ensure segfault if used again
      member_ = __null;
      delete this;
    }
  }
};


template <class T1, class T2, class R, class P1, class P2, class P3, class A1, class A2>
inline typename _TessMemberResultCallback_3_2<true,R,T1,P1,P2,P3,A1,A2>::base*
NewTessCallback( T1* obj, R (T2::*member)(P1,P2,P3,A1,A2) , typename Identity<P1>::type p1, typename Identity<P2>::type p2, typename Identity<P3>::type p3) {
  return new _TessMemberResultCallback_3_2<true,R,T1,P1,P2,P3,A1,A2>(obj, member, p1, p2, p3);
}



template <class T1, class T2, class R, class P1, class P2, class P3, class A1, class A2>
inline typename _TessMemberResultCallback_3_2<false,R,T1,P1,P2,P3,A1,A2>::base*
NewPermanentTessCallback( T1* obj, R (T2::*member)(P1,P2,P3,A1,A2) , typename Identity<P1>::type p1, typename Identity<P2>::type p2, typename Identity<P3>::type p3) {
  return new _TessMemberResultCallback_3_2<false,R,T1,P1,P2,P3,A1,A2>(obj, member, p1, p2, p3);
}


template <bool del, class R, class P1, class P2, class P3, class A1, class A2>
class _TessFunctionResultCallback_3_2 : public TessResultCallback2<R,A1,A2> {
 public:
  typedef TessResultCallback2<R,A1,A2> base;
  typedef R (*FunctionSignature)(P1,P2,P3,A1,A2);

 private:
  FunctionSignature function_;
  typename remove_reference<P1>::type p1_;
  typename remove_reference<P2>::type p2_;
  typename remove_reference<P3>::type p3_;

 public:
  inline _TessFunctionResultCallback_3_2(FunctionSignature function, P1 p1, P2 p2, P3 p3)
    : function_(function), p1_(p1), p2_(p2), p3_(p3) { }

  virtual R Run(A1 a1,A2 a2) {
    if (!del) {
      R result = (*function_)(p1_,p2_,p3_,a1,a2);
      return result;
    } else {
      R result = (*function_)(p1_,p2_,p3_,a1,a2);
      //  zero out the pointer to ensure segfault if used again
      function_ = __null;
      delete this;
      return result;
    }
  }
};

template <bool del, class P1, class P2, class P3, class A1, class A2>
class _TessFunctionResultCallback_3_2<del, void, P1, P2, P3, A1, A2> : public TessCallback2<A1,A2> {
 public:
  typedef TessCallback2<A1,A2> base;
  typedef void (*FunctionSignature)(P1,P2,P3,A1,A2);

 private:
  FunctionSignature function_;
  typename remove_reference<P1>::type p1_;
  typename remove_reference<P2>::type p2_;
  typename remove_reference<P3>::type p3_;

 public:
  inline _TessFunctionResultCallback_3_2(FunctionSignature function, P1 p1, P2 p2, P3 p3)
    : function_(function), p1_(p1), p2_(p2), p3_(p3) { }

  virtual void Run(A1 a1,A2 a2) {
    if (!del) {
      (*function_)(p1_,p2_,p3_,a1,a2);
    } else {
      (*function_)(p1_,p2_,p3_,a1,a2);
      //  zero out the pointer to ensure segfault if used again
      function_ = __null;
      delete this;
    }
  }
};

template <class R, class P1, class P2, class P3, class A1, class A2>
inline typename _TessFunctionResultCallback_3_2<true,R,P1,P2,P3,A1,A2>::base*
NewTessCallback(R (*function)(P1,P2,P3,A1,A2), typename Identity<P1>::type p1, typename Identity<P2>::type p2, typename Identity<P3>::type p3) {
  return new _TessFunctionResultCallback_3_2<true,R,P1,P2,P3,A1,A2>(function, p1, p2, p3);
}

template <class R, class P1, class P2, class P3, class A1, class A2>
inline typename _TessFunctionResultCallback_3_2<false,R,P1,P2,P3,A1,A2>::base*
NewPermanentTessCallback(R (*function)(P1,P2,P3,A1,A2), typename Identity<P1>::type p1, typename Identity<P2>::type p2, typename Identity<P3>::type p3) {
  return new _TessFunctionResultCallback_3_2<false,R,P1,P2,P3,A1,A2>(function, p1, p2, p3);
}

template <bool del, class R, class T, class P1, class P2, class P3, class P4, class A1, class A2>
class _ConstTessMemberResultCallback_4_2 : public TessResultCallback2<R,A1,A2> {
 public:
  typedef TessResultCallback2<R,A1,A2> base;
  typedef R (T::*MemberSignature)(P1,P2,P3,P4,A1,A2) const;

 private:
  const T* object_;
  MemberSignature member_;
  typename remove_reference<P1>::type p1_;
  typename remove_reference<P2>::type p2_;
  typename remove_reference<P3>::type p3_;
  typename remove_reference<P4>::type p4_;

 public:
  inline _ConstTessMemberResultCallback_4_2(const T* object, MemberSignature member, P1 p1, P2 p2, P3 p3, P4 p4)
    : object_(object),
      member_(member), p1_(p1), p2_(p2), p3_(p3), p4_(p4) { }

  virtual R Run(A1 a1,A2 a2) {
    if (!del) {
      R result = (object_->*member_)(p1_,p2_,p3_,p4_,a1,a2);
      return result;
    } else {
      R result = (object_->*member_)(p1_,p2_,p3_,p4_,a1,a2);
      //  zero out the pointer to ensure segfault if used again
      member_ = __null;
      delete this;
      return result;
    }
  }
};

template <bool del, class T, class P1, class P2, class P3, class P4, class A1, class A2>
class _ConstTessMemberResultCallback_4_2<del, void, T, P1, P2, P3, P4, A1, A2> : public TessCallback2<A1,A2> {
 public:
  typedef TessCallback2<A1,A2> base;
  typedef void (T::*MemberSignature)(P1,P2,P3,P4,A1,A2) const;

 private:
  const T* object_;
  MemberSignature member_;
  typename remove_reference<P1>::type p1_;
  typename remove_reference<P2>::type p2_;
  typename remove_reference<P3>::type p3_;
  typename remove_reference<P4>::type p4_;

 public:
  inline _ConstTessMemberResultCallback_4_2(const T* object, MemberSignature member, P1 p1, P2 p2, P3 p3, P4 p4)
    : object_(object),
      member_(member), p1_(p1), p2_(p2), p3_(p3), p4_(p4) { }

  virtual void Run(A1 a1,A2 a2) {
    if (!del) {
      (object_->*member_)(p1_,p2_,p3_,p4_,a1,a2);
    } else {
      (object_->*member_)(p1_,p2_,p3_,p4_,a1,a2);
      //  zero out the pointer to ensure segfault if used again
      member_ = __null;
      delete this;
    }
  }
};


template <class T1, class T2, class R, class P1, class P2, class P3, class P4, class A1, class A2>
inline typename _ConstTessMemberResultCallback_4_2<true,R,T1,P1,P2,P3,P4,A1,A2>::base*
NewTessCallback(const T1* obj, R (T2::*member)(P1,P2,P3,P4,A1,A2) const, typename Identity<P1>::type p1, typename Identity<P2>::type p2, typename Identity<P3>::type p3, typename Identity<P4>::type p4) {
  return new _ConstTessMemberResultCallback_4_2<true,R,T1,P1,P2,P3,P4,A1,A2>(obj, member, p1, p2, p3, p4);
}



template <class T1, class T2, class R, class P1, class P2, class P3, class P4, class A1, class A2>
inline typename _ConstTessMemberResultCallback_4_2<false,R,T1,P1,P2,P3,P4,A1,A2>::base*
NewPermanentTessCallback(const T1* obj, R (T2::*member)(P1,P2,P3,P4,A1,A2) const, typename Identity<P1>::type p1, typename Identity<P2>::type p2, typename Identity<P3>::type p3, typename Identity<P4>::type p4) {
  return new _ConstTessMemberResultCallback_4_2<false,R,T1,P1,P2,P3,P4,A1,A2>(obj, member, p1, p2, p3, p4);
}


template <bool del, class R, class T, class P1, class P2, class P3, class P4, class A1, class A2>
class _TessMemberResultCallback_4_2 : public TessResultCallback2<R,A1,A2> {
 public:
  typedef TessResultCallback2<R,A1,A2> base;
  typedef R (T::*MemberSignature)(P1,P2,P3,P4,A1,A2) ;

 private:
   T* object_;
  MemberSignature member_;
  typename remove_reference<P1>::type p1_;
  typename remove_reference<P2>::type p2_;
  typename remove_reference<P3>::type p3_;
  typename remove_reference<P4>::type p4_;

 public:
  inline _TessMemberResultCallback_4_2( T* object, MemberSignature member, P1 p1, P2 p2, P3 p3, P4 p4)
    : object_(object),
      member_(member), p1_(p1), p2_(p2), p3_(p3), p4_(p4) { }

  virtual R Run(A1 a1,A2 a2) {
    if (!del) {
      R result = (object_->*member_)(p1_,p2_,p3_,p4_,a1,a2);
      return result;
    } else {
      R result = (object_->*member_)(p1_,p2_,p3_,p4_,a1,a2);
      //  zero out the pointer to ensure segfault if used again
      member_ = __null;
      delete this;
      return result;
    }
  }
};

template <bool del, class T, class P1, class P2, class P3, class P4, class A1, class A2>
class _TessMemberResultCallback_4_2<del, void, T, P1, P2, P3, P4, A1, A2> : public TessCallback2<A1,A2> {
 public:
  typedef TessCallback2<A1,A2> base;
  typedef void (T::*MemberSignature)(P1,P2,P3,P4,A1,A2) ;

 private:
   T* object_;
  MemberSignature member_;
  typename remove_reference<P1>::type p1_;
  typename remove_reference<P2>::type p2_;
  typename remove_reference<P3>::type p3_;
  typename remove_reference<P4>::type p4_;

 public:
  inline _TessMemberResultCallback_4_2( T* object, MemberSignature member, P1 p1, P2 p2, P3 p3, P4 p4)
    : object_(object),
      member_(member), p1_(p1), p2_(p2), p3_(p3), p4_(p4) { }

  virtual void Run(A1 a1,A2 a2) {
    if (!del) {
      (object_->*member_)(p1_,p2_,p3_,p4_,a1,a2);
    } else {
      (object_->*member_)(p1_,p2_,p3_,p4_,a1,a2);
      //  zero out the pointer to ensure segfault if used again
      member_ = __null;
      delete this;
    }
  }
};


template <class T1, class T2, class R, class P1, class P2, class P3, class P4, class A1, class A2>
inline typename _TessMemberResultCallback_4_2<true,R,T1,P1,P2,P3,P4,A1,A2>::base*
NewTessCallback( T1* obj, R (T2::*member)(P1,P2,P3,P4,A1,A2) , typename Identity<P1>::type p1, typename Identity<P2>::type p2, typename Identity<P3>::type p3, typename Identity<P4>::type p4) {
  return new _TessMemberResultCallback_4_2<true,R,T1,P1,P2,P3,P4,A1,A2>(obj, member, p1, p2, p3, p4);
}



template <class T1, class T2, class R, class P1, class P2, class P3, class P4, class A1, class A2>
inline typename _TessMemberResultCallback_4_2<false,R,T1,P1,P2,P3,P4,A1,A2>::base*
NewPermanentTessCallback( T1* obj, R (T2::*member)(P1,P2,P3,P4,A1,A2) , typename Identity<P1>::type p1, typename Identity<P2>::type p2, typename Identity<P3>::type p3, typename Identity<P4>::type p4) {
  return new _TessMemberResultCallback_4_2<false,R,T1,P1,P2,P3,P4,A1,A2>(obj, member, p1, p2, p3, p4);
}


template <bool del, class R, class P1, class P2, class P3, class P4, class A1, class A2>
class _TessFunctionResultCallback_4_2 : public TessResultCallback2<R,A1,A2> {
 public:
  typedef TessResultCallback2<R,A1,A2> base;
  typedef R (*FunctionSignature)(P1,P2,P3,P4,A1,A2);

 private:
  FunctionSignature function_;
  typename remove_reference<P1>::type p1_;
  typename remove_reference<P2>::type p2_;
  typename remove_reference<P3>::type p3_;
  typename remove_reference<P4>::type p4_;

 public:
  inline _TessFunctionResultCallback_4_2(FunctionSignature function, P1 p1, P2 p2, P3 p3, P4 p4)
    : function_(function), p1_(p1), p2_(p2), p3_(p3), p4_(p4) { }

  virtual R Run(A1 a1,A2 a2) {
    if (!del) {
      R result = (*function_)(p1_,p2_,p3_,p4_,a1,a2);
      return result;
    } else {
      R result = (*function_)(p1_,p2_,p3_,p4_,a1,a2);
      //  zero out the pointer to ensure segfault if used again
      function_ = __null;
      delete this;
      return result;
    }
  }
};

template <bool del, class P1, class P2, class P3, class P4, class A1, class A2>
class _TessFunctionResultCallback_4_2<del, void, P1, P2, P3, P4, A1, A2> : public TessCallback2<A1,A2> {
 public:
  typedef TessCallback2<A1,A2> base;
  typedef void (*FunctionSignature)(P1,P2,P3,P4,A1,A2);

 private:
  FunctionSignature function_;
  typename remove_reference<P1>::type p1_;
  typename remove_reference<P2>::type p2_;
  typename remove_reference<P3>::type p3_;
  typename remove_reference<P4>::type p4_;

 public:
  inline _TessFunctionResultCallback_4_2(FunctionSignature function, P1 p1, P2 p2, P3 p3, P4 p4)
    : function_(function), p1_(p1), p2_(p2), p3_(p3), p4_(p4) { }

  virtual void Run(A1 a1,A2 a2) {
    if (!del) {
      (*function_)(p1_,p2_,p3_,p4_,a1,a2);
    } else {
      (*function_)(p1_,p2_,p3_,p4_,a1,a2);
      //  zero out the pointer to ensure segfault if used again
      function_ = __null;
      delete this;
    }
  }
};

template <class R, class P1, class P2, class P3, class P4, class A1, class A2>
inline typename _TessFunctionResultCallback_4_2<true,R,P1,P2,P3,P4,A1,A2>::base*
NewTessCallback(R (*function)(P1,P2,P3,P4,A1,A2), typename Identity<P1>::type p1, typename Identity<P2>::type p2, typename Identity<P3>::type p3, typename Identity<P4>::type p4) {
  return new _TessFunctionResultCallback_4_2<true,R,P1,P2,P3,P4,A1,A2>(function, p1, p2, p3, p4);
}

template <class R, class P1, class P2, class P3, class P4, class A1, class A2>
inline typename _TessFunctionResultCallback_4_2<false,R,P1,P2,P3,P4,A1,A2>::base*
NewPermanentTessCallback(R (*function)(P1,P2,P3,P4,A1,A2), typename Identity<P1>::type p1, typename Identity<P2>::type p2, typename Identity<P3>::type p3, typename Identity<P4>::type p4) {
  return new _TessFunctionResultCallback_4_2<false,R,P1,P2,P3,P4,A1,A2>(function, p1, p2, p3, p4);
}

template <bool del, class R, class T, class P1, class P2, class P3, class P4, class P5, class A1, class A2>
class _ConstTessMemberResultCallback_5_2 : public TessResultCallback2<R,A1,A2> {
 public:
  typedef TessResultCallback2<R,A1,A2> base;
  typedef R (T::*MemberSignature)(P1,P2,P3,P4,P5,A1,A2) const;

 private:
  const T* object_;
  MemberSignature member_;
  typename remove_reference<P1>::type p1_;
  typename remove_reference<P2>::type p2_;
  typename remove_reference<P3>::type p3_;
  typename remove_reference<P4>::type p4_;
  typename remove_reference<P5>::type p5_;

 public:
  inline _ConstTessMemberResultCallback_5_2(const T* object, MemberSignature member, P1 p1, P2 p2, P3 p3, P4 p4, P5 p5)
    : object_(object),
      member_(member), p1_(p1), p2_(p2), p3_(p3), p4_(p4), p5_(p5) { }

  virtual R Run(A1 a1,A2 a2) {
    if (!del) {
      R result = (object_->*member_)(p1_,p2_,p3_,p4_,p5_,a1,a2);
      return result;
    } else {
      R result = (object_->*member_)(p1_,p2_,p3_,p4_,p5_,a1,a2);
      //  zero out the pointer to ensure segfault if used again
      member_ = __null;
      delete this;
      return result;
    }
  }
};

template <bool del, class T, class P1, class P2, class P3, class P4, class P5, class A1, class A2>
class _ConstTessMemberResultCallback_5_2<del, void, T, P1, P2, P3, P4, P5, A1, A2> : public TessCallback2<A1,A2> {
 public:
  typedef TessCallback2<A1,A2> base;
  typedef void (T::*MemberSignature)(P1,P2,P3,P4,P5,A1,A2) const;

 private:
  const T* object_;
  MemberSignature member_;
  typename remove_reference<P1>::type p1_;
  typename remove_reference<P2>::type p2_;
  typename remove_reference<P3>::type p3_;
  typename remove_reference<P4>::type p4_;
  typename remove_reference<P5>::type p5_;

 public:
  inline _ConstTessMemberResultCallback_5_2(const T* object, MemberSignature member, P1 p1, P2 p2, P3 p3, P4 p4, P5 p5)
    : object_(object),
      member_(member), p1_(p1), p2_(p2), p3_(p3), p4_(p4), p5_(p5) { }

  virtual void Run(A1 a1,A2 a2) {
    if (!del) {
      (object_->*member_)(p1_,p2_,p3_,p4_,p5_,a1,a2);
    } else {
      (object_->*member_)(p1_,p2_,p3_,p4_,p5_,a1,a2);
      //  zero out the pointer to ensure segfault if used again
      member_ = __null;
      delete this;
    }
  }
};


template <class T1, class T2, class R, class P1, class P2, class P3, class P4, class P5, class A1, class A2>
inline typename _ConstTessMemberResultCallback_5_2<true,R,T1,P1,P2,P3,P4,P5,A1,A2>::base*
NewTessCallback(const T1* obj, R (T2::*member)(P1,P2,P3,P4,P5,A1,A2) const, typename Identity<P1>::type p1, typename Identity<P2>::type p2, typename Identity<P3>::type p3, typename Identity<P4>::type p4, typename Identity<P5>::type p5) {
  return new _ConstTessMemberResultCallback_5_2<true,R,T1,P1,P2,P3,P4,P5,A1,A2>(obj, member, p1, p2, p3, p4, p5);
}



template <class T1, class T2, class R, class P1, class P2, class P3, class P4, class P5, class A1, class A2>
inline typename _ConstTessMemberResultCallback_5_2<false,R,T1,P1,P2,P3,P4,P5,A1,A2>::base*
NewPermanentTessCallback(const T1* obj, R (T2::*member)(P1,P2,P3,P4,P5,A1,A2) const, typename Identity<P1>::type p1, typename Identity<P2>::type p2, typename Identity<P3>::type p3, typename Identity<P4>::type p4, typename Identity<P5>::type p5) {
  return new _ConstTessMemberResultCallback_5_2<false,R,T1,P1,P2,P3,P4,P5,A1,A2>(obj, member, p1, p2, p3, p4, p5);
}


template <bool del, class R, class T, class P1, class P2, class P3, class P4, class P5, class A1, class A2>
class _TessMemberResultCallback_5_2 : public TessResultCallback2<R,A1,A2> {
 public:
  typedef TessResultCallback2<R,A1,A2> base;
  typedef R (T::*MemberSignature)(P1,P2,P3,P4,P5,A1,A2) ;

 private:
   T* object_;
  MemberSignature member_;
  typename remove_reference<P1>::type p1_;
  typename remove_reference<P2>::type p2_;
  typename remove_reference<P3>::type p3_;
  typename remove_reference<P4>::type p4_;
  typename remove_reference<P5>::type p5_;

 public:
  inline _TessMemberResultCallback_5_2( T* object, MemberSignature member, P1 p1, P2 p2, P3 p3, P4 p4, P5 p5)
    : object_(object),
      member_(member), p1_(p1), p2_(p2), p3_(p3), p4_(p4), p5_(p5) { }

  virtual R Run(A1 a1,A2 a2) {
    if (!del) {
      R result = (object_->*member_)(p1_,p2_,p3_,p4_,p5_,a1,a2);
      return result;
    } else {
      R result = (object_->*member_)(p1_,p2_,p3_,p4_,p5_,a1,a2);
      //  zero out the pointer to ensure segfault if used again
      member_ = __null;
      delete this;
      return result;
    }
  }
};

template <bool del, class T, class P1, class P2, class P3, class P4, class P5, class A1, class A2>
class _TessMemberResultCallback_5_2<del, void, T, P1, P2, P3, P4, P5, A1, A2> : public TessCallback2<A1,A2> {
 public:
  typedef TessCallback2<A1,A2> base;
  typedef void (T::*MemberSignature)(P1,P2,P3,P4,P5,A1,A2) ;

 private:
   T* object_;
  MemberSignature member_;
  typename remove_reference<P1>::type p1_;
  typename remove_reference<P2>::type p2_;
  typename remove_reference<P3>::type p3_;
  typename remove_reference<P4>::type p4_;
  typename remove_reference<P5>::type p5_;

 public:
  inline _TessMemberResultCallback_5_2( T* object, MemberSignature member, P1 p1, P2 p2, P3 p3, P4 p4, P5 p5)
    : object_(object),
      member_(member), p1_(p1), p2_(p2), p3_(p3), p4_(p4), p5_(p5) { }

  virtual void Run(A1 a1,A2 a2) {
    if (!del) {
      (object_->*member_)(p1_,p2_,p3_,p4_,p5_,a1,a2);
    } else {
      (object_->*member_)(p1_,p2_,p3_,p4_,p5_,a1,a2);
      //  zero out the pointer to ensure segfault if used again
      member_ = __null;
      delete this;
    }
  }
};


template <class T1, class T2, class R, class P1, class P2, class P3, class P4, class P5, class A1, class A2>
inline typename _TessMemberResultCallback_5_2<true,R,T1,P1,P2,P3,P4,P5,A1,A2>::base*
NewTessCallback( T1* obj, R (T2::*member)(P1,P2,P3,P4,P5,A1,A2) , typename Identity<P1>::type p1, typename Identity<P2>::type p2, typename Identity<P3>::type p3, typename Identity<P4>::type p4, typename Identity<P5>::type p5) {
  return new _TessMemberResultCallback_5_2<true,R,T1,P1,P2,P3,P4,P5,A1,A2>(obj, member, p1, p2, p3, p4, p5);
}



template <class T1, class T2, class R, class P1, class P2, class P3, class P4, class P5, class A1, class A2>
inline typename _TessMemberResultCallback_5_2<false,R,T1,P1,P2,P3,P4,P5,A1,A2>::base*
NewPermanentTessCallback( T1* obj, R (T2::*member)(P1,P2,P3,P4,P5,A1,A2) , typename Identity<P1>::type p1, typename Identity<P2>::type p2, typename Identity<P3>::type p3, typename Identity<P4>::type p4, typename Identity<P5>::type p5) {
  return new _TessMemberResultCallback_5_2<false,R,T1,P1,P2,P3,P4,P5,A1,A2>(obj, member, p1, p2, p3, p4, p5);
}


template <bool del, class R, class P1, class P2, class P3, class P4, class P5, class A1, class A2>
class _TessFunctionResultCallback_5_2 : public TessResultCallback2<R,A1,A2> {
 public:
  typedef TessResultCallback2<R,A1,A2> base;
  typedef R (*FunctionSignature)(P1,P2,P3,P4,P5,A1,A2);

 private:
  FunctionSignature function_;
  typename remove_reference<P1>::type p1_;
  typename remove_reference<P2>::type p2_;
  typename remove_reference<P3>::type p3_;
  typename remove_reference<P4>::type p4_;
  typename remove_reference<P5>::type p5_;

 public:
  inline _TessFunctionResultCallback_5_2(FunctionSignature function, P1 p1, P2 p2, P3 p3, P4 p4, P5 p5)
    : function_(function), p1_(p1), p2_(p2), p3_(p3), p4_(p4), p5_(p5) { }

  virtual R Run(A1 a1,A2 a2) {
    if (!del) {
      R result = (*function_)(p1_,p2_,p3_,p4_,p5_,a1,a2);
      return result;
    } else {
      R result = (*function_)(p1_,p2_,p3_,p4_,p5_,a1,a2);
      //  zero out the pointer to ensure segfault if used again
      function_ = __null;
      delete this;
      return result;
    }
  }
};

template <bool del, class P1, class P2, class P3, class P4, class P5, class A1, class A2>
class _TessFunctionResultCallback_5_2<del, void, P1, P2, P3, P4, P5, A1, A2> : public TessCallback2<A1,A2> {
 public:
  typedef TessCallback2<A1,A2> base;
  typedef void (*FunctionSignature)(P1,P2,P3,P4,P5,A1,A2);

 private:
  FunctionSignature function_;
  typename remove_reference<P1>::type p1_;
  typename remove_reference<P2>::type p2_;
  typename remove_reference<P3>::type p3_;
  typename remove_reference<P4>::type p4_;
  typename remove_reference<P5>::type p5_;

 public:
  inline _TessFunctionResultCallback_5_2(FunctionSignature function, P1 p1, P2 p2, P3 p3, P4 p4, P5 p5)
    : function_(function), p1_(p1), p2_(p2), p3_(p3), p4_(p4), p5_(p5) { }

  virtual void Run(A1 a1,A2 a2) {
    if (!del) {
      (*function_)(p1_,p2_,p3_,p4_,p5_,a1,a2);
    } else {
      (*function_)(p1_,p2_,p3_,p4_,p5_,a1,a2);
      //  zero out the pointer to ensure segfault if used again
      function_ = __null;
      delete this;
    }
  }
};

template <class R, class P1, class P2, class P3, class P4, class P5, class A1, class A2>
inline typename _TessFunctionResultCallback_5_2<true,R,P1,P2,P3,P4,P5,A1,A2>::base*
NewTessCallback(R (*function)(P1,P2,P3,P4,P5,A1,A2), typename Identity<P1>::type p1, typename Identity<P2>::type p2, typename Identity<P3>::type p3, typename Identity<P4>::type p4, typename Identity<P5>::type p5) {
  return new _TessFunctionResultCallback_5_2<true,R,P1,P2,P3,P4,P5,A1,A2>(function, p1, p2, p3, p4, p5);
}

template <class R, class P1, class P2, class P3, class P4, class P5, class A1, class A2>
inline typename _TessFunctionResultCallback_5_2<false,R,P1,P2,P3,P4,P5,A1,A2>::base*
NewPermanentTessCallback(R (*function)(P1,P2,P3,P4,P5,A1,A2), typename Identity<P1>::type p1, typename Identity<P2>::type p2, typename Identity<P3>::type p3, typename Identity<P4>::type p4, typename Identity<P5>::type p5) {
  return new _TessFunctionResultCallback_5_2<false,R,P1,P2,P3,P4,P5,A1,A2>(function, p1, p2, p3, p4, p5);
}

template <bool del, class R, class T, class P1, class P2, class P3, class P4, class P5, class P6, class A1, class A2>
class _ConstTessMemberResultCallback_6_2 : public TessResultCallback2<R,A1,A2> {
 public:
  typedef TessResultCallback2<R,A1,A2> base;
  typedef R (T::*MemberSignature)(P1,P2,P3,P4,P5,P6,A1,A2) const;

 private:
  const T* object_;
  MemberSignature member_;
  typename remove_reference<P1>::type p1_;
  typename remove_reference<P2>::type p2_;
  typename remove_reference<P3>::type p3_;
  typename remove_reference<P4>::type p4_;
  typename remove_reference<P5>::type p5_;
  typename remove_reference<P6>::type p6_;

 public:
  inline _ConstTessMemberResultCallback_6_2(const T* object, MemberSignature member, P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6)
    : object_(object),
      member_(member), p1_(p1), p2_(p2), p3_(p3), p4_(p4), p5_(p5), p6_(p6) { }

  virtual R Run(A1 a1,A2 a2) {
    if (!del) {
      R result = (object_->*member_)(p1_,p2_,p3_,p4_,p5_,p6_,a1,a2);
      return result;
    } else {
      R result = (object_->*member_)(p1_,p2_,p3_,p4_,p5_,p6_,a1,a2);
      //  zero out the pointer to ensure segfault if used again
      member_ = __null;
      delete this;
      return result;
    }
  }
};

template <bool del, class T, class P1, class P2, class P3, class P4, class P5, class P6, class A1, class A2>
class _ConstTessMemberResultCallback_6_2<del, void, T, P1, P2, P3, P4, P5, P6, A1, A2> : public TessCallback2<A1,A2> {
 public:
  typedef TessCallback2<A1,A2> base;
  typedef void (T::*MemberSignature)(P1,P2,P3,P4,P5,P6,A1,A2) const;

 private:
  const T* object_;
  MemberSignature member_;
  typename remove_reference<P1>::type p1_;
  typename remove_reference<P2>::type p2_;
  typename remove_reference<P3>::type p3_;
  typename remove_reference<P4>::type p4_;
  typename remove_reference<P5>::type p5_;
  typename remove_reference<P6>::type p6_;

 public:
  inline _ConstTessMemberResultCallback_6_2(const T* object, MemberSignature member, P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6)
    : object_(object),
      member_(member), p1_(p1), p2_(p2), p3_(p3), p4_(p4), p5_(p5), p6_(p6) { }

  virtual void Run(A1 a1,A2 a2) {
    if (!del) {
      (object_->*member_)(p1_,p2_,p3_,p4_,p5_,p6_,a1,a2);
    } else {
      (object_->*member_)(p1_,p2_,p3_,p4_,p5_,p6_,a1,a2);
      //  zero out the pointer to ensure segfault if used again
      member_ = __null;
      delete this;
    }
  }
};


template <class T1, class T2, class R, class P1, class P2, class P3, class P4, class P5, class P6, class A1, class A2>
inline typename _ConstTessMemberResultCallback_6_2<true,R,T1,P1,P2,P3,P4,P5,P6,A1,A2>::base*
NewTessCallback(const T1* obj, R (T2::*member)(P1,P2,P3,P4,P5,P6,A1,A2) const, typename Identity<P1>::type p1, typename Identity<P2>::type p2, typename Identity<P3>::type p3, typename Identity<P4>::type p4, typename Identity<P5>::type p5, typename Identity<P6>::type p6) {
  return new _ConstTessMemberResultCallback_6_2<true,R,T1,P1,P2,P3,P4,P5,P6,A1,A2>(obj, member, p1, p2, p3, p4, p5, p6);
}



template <class T1, class T2, class R, class P1, class P2, class P3, class P4, class P5, class P6, class A1, class A2>
inline typename _ConstTessMemberResultCallback_6_2<false,R,T1,P1,P2,P3,P4,P5,P6,A1,A2>::base*
NewPermanentTessCallback(const T1* obj, R (T2::*member)(P1,P2,P3,P4,P5,P6,A1,A2) const, typename Identity<P1>::type p1, typename Identity<P2>::type p2, typename Identity<P3>::type p3, typename Identity<P4>::type p4, typename Identity<P5>::type p5, typename Identity<P6>::type p6) {
  return new _ConstTessMemberResultCallback_6_2<false,R,T1,P1,P2,P3,P4,P5,P6,A1,A2>(obj, member, p1, p2, p3, p4, p5, p6);
}


template <bool del, class R, class T, class P1, class P2, class P3, class P4, class P5, class P6, class A1, class A2>
class _TessMemberResultCallback_6_2 : public TessResultCallback2<R,A1,A2> {
 public:
  typedef TessResultCallback2<R,A1,A2> base;
  typedef R (T::*MemberSignature)(P1,P2,P3,P4,P5,P6,A1,A2) ;

 private:
   T* object_;
  MemberSignature member_;
  typename remove_reference<P1>::type p1_;
  typename remove_reference<P2>::type p2_;
  typename remove_reference<P3>::type p3_;
  typename remove_reference<P4>::type p4_;
  typename remove_reference<P5>::type p5_;
  typename remove_reference<P6>::type p6_;

 public:
  inline _TessMemberResultCallback_6_2( T* object, MemberSignature member, P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6)
    : object_(object),
      member_(member), p1_(p1), p2_(p2), p3_(p3), p4_(p4), p5_(p5), p6_(p6) { }

  virtual R Run(A1 a1,A2 a2) {
    if (!del) {
      R result = (object_->*member_)(p1_,p2_,p3_,p4_,p5_,p6_,a1,a2);
      return result;
    } else {
      R result = (object_->*member_)(p1_,p2_,p3_,p4_,p5_,p6_,a1,a2);
      //  zero out the pointer to ensure segfault if used again
      member_ = __null;
      delete this;
      return result;
    }
  }
};

template <bool del, class T, class P1, class P2, class P3, class P4, class P5, class P6, class A1, class A2>
class _TessMemberResultCallback_6_2<del, void, T, P1, P2, P3, P4, P5, P6, A1, A2> : public TessCallback2<A1,A2> {
 public:
  typedef TessCallback2<A1,A2> base;
  typedef void (T::*MemberSignature)(P1,P2,P3,P4,P5,P6,A1,A2) ;

 private:
   T* object_;
  MemberSignature member_;
  typename remove_reference<P1>::type p1_;
  typename remove_reference<P2>::type p2_;
  typename remove_reference<P3>::type p3_;
  typename remove_reference<P4>::type p4_;
  typename remove_reference<P5>::type p5_;
  typename remove_reference<P6>::type p6_;

 public:
  inline _TessMemberResultCallback_6_2( T* object, MemberSignature member, P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6)
    : object_(object),
      member_(member), p1_(p1), p2_(p2), p3_(p3), p4_(p4), p5_(p5), p6_(p6) { }

  virtual void Run(A1 a1,A2 a2) {
    if (!del) {
      (object_->*member_)(p1_,p2_,p3_,p4_,p5_,p6_,a1,a2);
    } else {
      (object_->*member_)(p1_,p2_,p3_,p4_,p5_,p6_,a1,a2);
      //  zero out the pointer to ensure segfault if used again
      member_ = __null;
      delete this;
    }
  }
};


template <class T1, class T2, class R, class P1, class P2, class P3, class P4, class P5, class P6, class A1, class A2>
inline typename _TessMemberResultCallback_6_2<true,R,T1,P1,P2,P3,P4,P5,P6,A1,A2>::base*
NewTessCallback( T1* obj, R (T2::*member)(P1,P2,P3,P4,P5,P6,A1,A2) , typename Identity<P1>::type p1, typename Identity<P2>::type p2, typename Identity<P3>::type p3, typename Identity<P4>::type p4, typename Identity<P5>::type p5, typename Identity<P6>::type p6) {
  return new _TessMemberResultCallback_6_2<true,R,T1,P1,P2,P3,P4,P5,P6,A1,A2>(obj, member, p1, p2, p3, p4, p5, p6);
}



template <class T1, class T2, class R, class P1, class P2, class P3, class P4, class P5, class P6, class A1, class A2>
inline typename _TessMemberResultCallback_6_2<false,R,T1,P1,P2,P3,P4,P5,P6,A1,A2>::base*
NewPermanentTessCallback( T1* obj, R (T2::*member)(P1,P2,P3,P4,P5,P6,A1,A2) , typename Identity<P1>::type p1, typename Identity<P2>::type p2, typename Identity<P3>::type p3, typename Identity<P4>::type p4, typename Identity<P5>::type p5, typename Identity<P6>::type p6) {
  return new _TessMemberResultCallback_6_2<false,R,T1,P1,P2,P3,P4,P5,P6,A1,A2>(obj, member, p1, p2, p3, p4, p5, p6);
}


template <bool del, class R, class P1, class P2, class P3, class P4, class P5, class P6, class A1, class A2>
class _TessFunctionResultCallback_6_2 : public TessResultCallback2<R,A1,A2> {
 public:
  typedef TessResultCallback2<R,A1,A2> base;
  typedef R (*FunctionSignature)(P1,P2,P3,P4,P5,P6,A1,A2);

 private:
  FunctionSignature function_;
  typename remove_reference<P1>::type p1_;
  typename remove_reference<P2>::type p2_;
  typename remove_reference<P3>::type p3_;
  typename remove_reference<P4>::type p4_;
  typename remove_reference<P5>::type p5_;
  typename remove_reference<P6>::type p6_;

 public:
  inline _TessFunctionResultCallback_6_2(FunctionSignature function, P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6)
    : function_(function), p1_(p1), p2_(p2), p3_(p3), p4_(p4), p5_(p5), p6_(p6) { }

  virtual R Run(A1 a1,A2 a2) {
    if (!del) {
      R result = (*function_)(p1_,p2_,p3_,p4_,p5_,p6_,a1,a2);
      return result;
    } else {
      R result = (*function_)(p1_,p2_,p3_,p4_,p5_,p6_,a1,a2);
      //  zero out the pointer to ensure segfault if used again
      function_ = __null;
      delete this;
      return result;
    }
  }
};

template <bool del, class P1, class P2, class P3, class P4, class P5, class P6, class A1, class A2>
class _TessFunctionResultCallback_6_2<del, void, P1, P2, P3, P4, P5, P6, A1, A2> : public TessCallback2<A1,A2> {
 public:
  typedef TessCallback2<A1,A2> base;
  typedef void (*FunctionSignature)(P1,P2,P3,P4,P5,P6,A1,A2);

 private:
  FunctionSignature function_;
  typename remove_reference<P1>::type p1_;
  typename remove_reference<P2>::type p2_;
  typename remove_reference<P3>::type p3_;
  typename remove_reference<P4>::type p4_;
  typename remove_reference<P5>::type p5_;
  typename remove_reference<P6>::type p6_;

 public:
  inline _TessFunctionResultCallback_6_2(FunctionSignature function, P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6)
    : function_(function), p1_(p1), p2_(p2), p3_(p3), p4_(p4), p5_(p5), p6_(p6) { }

  virtual void Run(A1 a1,A2 a2) {
    if (!del) {
      (*function_)(p1_,p2_,p3_,p4_,p5_,p6_,a1,a2);
    } else {
      (*function_)(p1_,p2_,p3_,p4_,p5_,p6_,a1,a2);
      //  zero out the pointer to ensure segfault if used again
      function_ = __null;
      delete this;
    }
  }
};

template <class R, class P1, class P2, class P3, class P4, class P5, class P6, class A1, class A2>
inline typename _TessFunctionResultCallback_6_2<true,R,P1,P2,P3,P4,P5,P6,A1,A2>::base*
NewTessCallback(R (*function)(P1,P2,P3,P4,P5,P6,A1,A2), typename Identity<P1>::type p1, typename Identity<P2>::type p2, typename Identity<P3>::type p3, typename Identity<P4>::type p4, typename Identity<P5>::type p5, typename Identity<P6>::type p6) {
  return new _TessFunctionResultCallback_6_2<true,R,P1,P2,P3,P4,P5,P6,A1,A2>(function, p1, p2, p3, p4, p5, p6);
}

template <class R, class P1, class P2, class P3, class P4, class P5, class P6, class A1, class A2>
inline typename _TessFunctionResultCallback_6_2<false,R,P1,P2,P3,P4,P5,P6,A1,A2>::base*
NewPermanentTessCallback(R (*function)(P1,P2,P3,P4,P5,P6,A1,A2), typename Identity<P1>::type p1, typename Identity<P2>::type p2, typename Identity<P3>::type p3, typename Identity<P4>::type p4, typename Identity<P5>::type p5, typename Identity<P6>::type p6) {
  return new _TessFunctionResultCallback_6_2<false,R,P1,P2,P3,P4,P5,P6,A1,A2>(function, p1, p2, p3, p4, p5, p6);
}

template <bool del, class R, class T, class A1, class A2, class A3>
class _ConstTessMemberResultCallback_0_3 : public TessResultCallback3<R,A1,A2,A3> {
 public:
  typedef TessResultCallback3<R,A1,A2,A3> base;
  typedef R (T::*MemberSignature)(A1,A2,A3) const;

 private:
  const T* object_;
  MemberSignature member_;

 public:
  inline _ConstTessMemberResultCallback_0_3(
     const T* object, MemberSignature member)
    : object_(object),
      member_(member) {
  }

  virtual R Run(A1 a1,A2 a2,A3 a3) {
    if (!del) {
      R result = (object_->*member_)(a1,a2,a3);
      return result;
    } else {
      R result = (object_->*member_)(a1,a2,a3);
      //  zero out the pointer to ensure segfault if used again
      member_ = __null;
      delete this;
      return result;
    }
  }
};

template <bool del, class T, class A1, class A2, class A3>
class _ConstTessMemberResultCallback_0_3<del, void, T, A1, A2, A3>
  : public TessCallback3<A1,A2,A3> {
 public:
  typedef TessCallback3<A1,A2,A3> base;
  typedef void (T::*MemberSignature)(A1,A2,A3) const;

 private:
  const T* object_;
  MemberSignature member_;

 public:
  inline _ConstTessMemberResultCallback_0_3(
      const T* object, MemberSignature member)
    : object_(object),
      member_(member) {
  }

  virtual void Run(A1 a1,A2 a2,A3 a3) {
    if (!del) {
      (object_->*member_)(a1,a2,a3);
    } else {
      (object_->*member_)(a1,a2,a3);
      //  zero out the pointer to ensure segfault if used again
      member_ = __null;
      delete this;
    }
  }
};


template <class T1, class T2, class R, class A1, class A2, class A3>
inline typename _ConstTessMemberResultCallback_0_3<true,R,T1,A1,A2,A3>::base*
NewTessCallback(
    const T1* obj, R (T2::*member)(A1,A2,A3) const) {
  return new _ConstTessMemberResultCallback_0_3<true,R,T1,A1,A2,A3>(
      obj, member);
}



template <class T1, class T2, class R, class A1, class A2, class A3>
inline typename _ConstTessMemberResultCallback_0_3<false,R,T1,A1,A2,A3>::base*
NewPermanentTessCallback(
    const T1* obj, R (T2::*member)(A1,A2,A3) const) {
  return new _ConstTessMemberResultCallback_0_3<false,R,T1,A1,A2,A3>(
      obj, member);
}


template <bool del, class R, class T, class A1, class A2, class A3>
class _TessMemberResultCallback_0_3 : public TessResultCallback3<R,A1,A2,A3> {
 public:
  typedef TessResultCallback3<R,A1,A2,A3> base;
  typedef R (T::*MemberSignature)(A1,A2,A3) ;

 private:
   T* object_;
  MemberSignature member_;

 public:
  inline _TessMemberResultCallback_0_3(
      T* object, MemberSignature member)
    : object_(object),
      member_(member) {
  }

  virtual R Run(A1 a1,A2 a2,A3 a3) {
    if (!del) {
      R result = (object_->*member_)(a1,a2,a3);
      return result;
    } else {
      R result = (object_->*member_)(a1,a2,a3);
      //  zero out the pointer to ensure segfault if used again
      member_ = __null;
      delete this;
      return result;
    }
  }
};

template <bool del, class T, class A1, class A2, class A3>
class _TessMemberResultCallback_0_3<del, void, T, A1, A2, A3>
  : public TessCallback3<A1,A2,A3> {
 public:
  typedef TessCallback3<A1,A2,A3> base;
  typedef void (T::*MemberSignature)(A1,A2,A3) ;

 private:
   T* object_;
  MemberSignature member_;

 public:
  inline _TessMemberResultCallback_0_3(
       T* object, MemberSignature member)
    : object_(object),
      member_(member) {
  }

  virtual void Run(A1 a1,A2 a2,A3 a3) {
    if (!del) {
      (object_->*member_)(a1,a2,a3);
    } else {
      (object_->*member_)(a1,a2,a3);
      //  zero out the pointer to ensure segfault if used again
      member_ = __null;
      delete this;
    }
  }
};


template <class T1, class T2, class R, class A1, class A2, class A3>
inline typename _TessMemberResultCallback_0_3<true,R,T1,A1,A2,A3>::base*
NewTessCallback(
     T1* obj, R (T2::*member)(A1,A2,A3) ) {
  return new _TessMemberResultCallback_0_3<true,R,T1,A1,A2,A3>(
      obj, member);
}



template <class T1, class T2, class R, class A1, class A2, class A3>
inline typename _TessMemberResultCallback_0_3<false,R,T1,A1,A2,A3>::base*
NewPermanentTessCallback(
     T1* obj, R (T2::*member)(A1,A2,A3) ) {
  return new _TessMemberResultCallback_0_3<false,R,T1,A1,A2,A3>(
      obj, member);
}


template <bool del, class R, class A1, class A2, class A3>
class _TessFunctionResultCallback_0_3 : public TessResultCallback3<R,A1,A2,A3> {
 public:
  typedef TessResultCallback3<R,A1,A2,A3> base;
  typedef R (*FunctionSignature)(A1,A2,A3);

 private:
  FunctionSignature function_;

 public:
  inline _TessFunctionResultCallback_0_3(
      FunctionSignature function)
    : function_(function) {
  }

  virtual R Run(A1 a1,A2 a2,A3 a3) {
    if (!del) {
      R result = (*function_)(a1,a2,a3);
      return result;
    } else {
      R result = (*function_)(a1,a2,a3);
      //  zero out the pointer to ensure segfault if used again
      function_ = __null;
      delete this;
      return result;
    }
  }
};

template <bool del, class A1, class A2, class A3>
class _TessFunctionResultCallback_0_3<del, void, A1, A2, A3>
  : public TessCallback3<A1,A2,A3> {
 public:
  typedef TessCallback3<A1,A2,A3> base;
  typedef void (*FunctionSignature)(A1,A2,A3);

 private:
  FunctionSignature function_;

 public:
  inline _TessFunctionResultCallback_0_3(
      FunctionSignature function)
    : function_(function) {
  }

  virtual void Run(A1 a1,A2 a2,A3 a3) {
    if (!del) {
      (*function_)(a1,a2,a3);
    } else {
      (*function_)(a1,a2,a3);
      //  zero out the pointer to ensure segfault if used again
      function_ = __null;
      delete this;
    }
  }
};

template <class R, class A1, class A2, class A3>
inline typename _TessFunctionResultCallback_0_3<true,R,A1,A2,A3>::base*
NewTessCallback(R (*function)(A1,A2,A3)) {
  return new _TessFunctionResultCallback_0_3<true,R,A1,A2,A3>(function);
}

template <class R, class A1, class A2, class A3>
inline typename _TessFunctionResultCallback_0_3<false,R,A1,A2,A3>::base*
NewPermanentTessCallback(R (*function)(A1,A2,A3)) {
  return new _TessFunctionResultCallback_0_3<false,R,A1,A2,A3>(function);
}

template <bool del, class R, class T, class P1, class A1, class A2, class A3>
class _ConstTessMemberResultCallback_1_3
  : public TessResultCallback3<R,A1,A2,A3> {
 public:
  typedef TessResultCallback3<R,A1,A2,A3> base;
  typedef R (T::*MemberSignature)(P1,A1,A2,A3) const;

 private:
   T* object_;
  MemberSignature member_;
  typename remove_reference<P1>::type p1_;

 public:
  inline _ConstTessMemberResultCallback_1_3(T* object,
                                            MemberSignature member, P1 p1)
    : object_(object), member_(member), p1_(p1) { }

  virtual R Run(A1 a1, A2 a2, A3 a3) {
    if (!del) {
      R result = (object_->*member_)(p1_,a1,a2,a3);
      return result;
    } else {
      R result = (object_->*member_)(p1_,a1,a2,a3);
      //  zero out the pointer to ensure segfault if used again
      member_ = __null;
      delete this;
      return result;
    }
  }
};

template <bool del, class T, class P1, class A1, class A2, class A3>
class _ConstTessMemberResultCallback_1_3<del, void, T, P1, A1, A2, A3>
  : public TessCallback3<A1,A2,A3> {
 public:
  typedef TessCallback3<A1,A2,A3> base;
  typedef void (T::*MemberSignature)(P1,A1,A2,A3) const;

 private:
   T* object_;
  MemberSignature member_;
  typename remove_reference<P1>::type p1_;

 public:
  inline _ConstTessMemberResultCallback_1_3(T* object,
                                            MemberSignature member, P1 p1)
    : object_(object), member_(member), p1_(p1) { }

  virtual void Run(A1 a1, A2 a2, A3 a3) {
    if (!del) {
      (object_->*member_)(p1_,a1,a2,a3);
    } else {
      (object_->*member_)(p1_,a1,a2,a3);
      //  zero out the pointer to ensure segfault if used again
      member_ = __null;
      delete this;
    }
  }
};


template <class T1, class T2, class R, class P1, class A1, class A2, class A3>
inline typename _ConstTessMemberResultCallback_1_3<true,R,T1,P1,A1,A2,A3>::base*
NewTessCallback( T1* obj, R (T2::*member)(P1,A1,A2,A3) , typename Identity<P1>::type p1) {
  return new _ConstTessMemberResultCallback_1_3<true,R,T1,P1,A1,A2,A3>(obj, member, p1);
}



template <class T1, class T2, class R, class P1, class A1, class A2, class A3>
inline typename _ConstTessMemberResultCallback_1_3<false,R,T1,P1,A1,A2,A3>::base*
NewPermanentTessCallback( T1* obj, R (T2::*member)(P1,A1,A2,A3) , typename Identity<P1>::type p1) {
  return new _ConstTessMemberResultCallback_1_3<false,R,T1,P1,A1,A2,A3>(obj, member, p1);
}


template <bool del, class R, class T, class P1, class A1, class A2, class A3>
class _TessMemberResultCallback_1_3 : public TessResultCallback3<R,A1,A2,A3> {
 public:
  typedef TessResultCallback3<R,A1,A2,A3> base;
  typedef R (T::*MemberSignature)(P1,A1,A2,A3) ;

 private:
   T* object_;
  MemberSignature member_;
  typename remove_reference<P1>::type p1_;

 public:
  inline _TessMemberResultCallback_1_3(T* object,
                                        MemberSignature member, P1 p1)
    : object_(object), member_(member), p1_(p1) { }

  virtual R Run(A1 a1, A2 a2, A3 a3) {
    if (!del) {
      R result = (object_->*member_)(p1_,a1,a2,a3);
      return result;
    } else {
      R result = (object_->*member_)(p1_,a1,a2,a3);
      //  zero out the pointer to ensure segfault if used again
      member_ = __null;
      delete this;
      return result;
    }
  }
};

template <bool del, class T, class P1, class A1, class A2, class A3>
class _TessMemberResultCallback_1_3<del, void, T, P1, A1, A2, A3>
  : public TessCallback3<A1,A2,A3> {
 public:
  typedef TessCallback3<A1,A2,A3> base;
  typedef void (T::*MemberSignature)(P1,A1,A2,A3) ;

 private:
   T* object_;
  MemberSignature member_;
  typename remove_reference<P1>::type p1_;

 public:
  inline _TessMemberResultCallback_1_3(T* object,
                                        MemberSignature member, P1 p1)
    : object_(object), member_(member), p1_(p1) { }

  virtual void Run(A1 a1, A2 a2, A3 a3) {
    if (!del) {
      (object_->*member_)(p1_,a1,a2,a3);
    } else {
      (object_->*member_)(p1_,a1,a2,a3);
      //  zero out the pointer to ensure segfault if used again
      member_ = __null;
      delete this;
    }
  }
};


template <class T1, class T2, class R, class P1, class A1, class A2, class A3>
inline typename _TessMemberResultCallback_1_3<true,R,T1,P1,A1,A2,A3>::base*
NewTessCallback( T1* obj, R (T2::*member)(P1,A1,A2,A3) , typename Identity<P1>::type p1) {
  return new _TessMemberResultCallback_1_3<true,R,T1,P1,A1,A2,A3>(obj, member, p1);
}



template <class T1, class T2, class R, class P1, class A1, class A2, class A3>
inline typename _TessMemberResultCallback_1_3<false,R,T1,P1,A1,A2,A3>::base*
NewPermanentTessCallback( T1* obj, R (T2::*member)(P1,A1,A2,A3) , typename Identity<P1>::type p1) {
  return new _TessMemberResultCallback_1_3<false,R,T1,P1,A1,A2,A3>(obj, member, p1);
}


template <bool del, class R, class P1, class A1, class A2, class A3>
class _TessFunctionResultCallback_1_3 : public TessCallback3<A1,A2,A3> {
 public:
  typedef TessCallback3<A1,A2,A3> base;
  typedef R (*FunctionSignature)(P1,A1,A2,A3);

 private:
  FunctionSignature function_;
  typename remove_reference<P1>::type p1_;

 public:
  inline _TessFunctionResultCallback_1_3(FunctionSignature function, P1 p1)
    : function_(function), p1_(p1) { }

  virtual R Run(A1 a1, A2 a2, A3 a3) {
    if (!del) {
      R result = (*function_)(p1_,a1,a2,a3);
      return result;
    } else {
      R result = (*function_)(p1_,a1,a2,a3);
      //  zero out the pointer to ensure segfault if used again
      function_ = __null;
      delete this;
      return result;
    }
  }
};

template <bool del, class P1, class A1, class A2, class A3>
class _TessFunctionResultCallback_1_3<del, void, P1, A1, A2, A3>
  : public TessCallback3<A1,A2,A3> {
 public:
  typedef TessCallback3<A1,A2,A3> base;
  typedef void (*FunctionSignature)(P1,A1,A2,A3);

 private:
  FunctionSignature function_;
  typename remove_reference<P1>::type p1_;

 public:
  inline _TessFunctionResultCallback_1_3(FunctionSignature function, P1 p1)
    : function_(function), p1_(p1) { }

  virtual void Run(A1 a1, A2 a2, A3 a3) {
    if (!del) {
      (*function_)(p1_,a1,a2,a3);
    } else {
      (*function_)(p1_,a1,a2,a3);
      //  zero out the pointer to ensure segfault if used again
      function_ = __null;
      delete this;
    }
  }
};

template <class R, class P1, class A1, class A2, class A3>
inline typename _TessFunctionResultCallback_1_3<true,R,P1,A1,A2,A3>::base*
NewTessCallback(R (*function)(P1,A1,A2,A3), typename Identity<P1>::type p1) {
  return new _TessFunctionResultCallback_1_3<true,R,P1,A1,A2,A3>(function, p1);
}

template <class R, class P1, class A1, class A2, class A3>
inline typename _TessFunctionResultCallback_1_3<false,R,P1,A1,A2,A3>::base*
NewPermanentTessCallback(R (*function)(P1,A1,A2,A3), typename Identity<P1>::type p1) {
  return new _TessFunctionResultCallback_1_3<false,R,P1,A1,A2,A3>(function, p1);
}

template <bool del, class R, class T, class P1, class P2, class A1, class A2, class A3>
class _ConstTessMemberResultCallback_2_3 : public TessResultCallback3<R,A1,A2,A3> {
 public:
  typedef TessResultCallback3<R,A1,A2,A3> base;
  typedef R (T::*MemberSignature)(P1,P2,A1,A2,A3) const;

 private:
  const T* object_;
  MemberSignature member_;
  typename remove_reference<P1>::type p1_;
  typename remove_reference<P2>::type p2_;

 public:
  inline _ConstTessMemberResultCallback_2_3(const T* object, MemberSignature member, P1 p1, P2 p2)
    : object_(object),
      member_(member), p1_(p1), p2_(p2) { }

  virtual R Run(A1 a1,A2 a2,A3 a3) {
    if (!del) {
      R result = (object_->*member_)(p1_,p2_,a1,a2,a3);
      return result;
    } else {
      R result = (object_->*member_)(p1_,p2_,a1,a2,a3);
      //  zero out the pointer to ensure segfault if used again
      member_ = __null;
      delete this;
      return result;
    }
  }
};

template <bool del, class T, class P1, class P2, class A1, class A2, class A3>
class _ConstTessMemberResultCallback_2_3<del, void, T, P1, P2, A1, A2, A3> : public TessCallback3<A1,A2,A3> {
 public:
  typedef TessCallback3<A1,A2,A3> base;
  typedef void (T::*MemberSignature)(P1,P2,A1,A2,A3) const;

 private:
  const T* object_;
  MemberSignature member_;
  typename remove_reference<P1>::type p1_;
  typename remove_reference<P2>::type p2_;

 public:
  inline _ConstTessMemberResultCallback_2_3(const T* object, MemberSignature member, P1 p1, P2 p2)
    : object_(object),
      member_(member), p1_(p1), p2_(p2) { }

  virtual void Run(A1 a1,A2 a2,A3 a3) {
    if (!del) {
      (object_->*member_)(p1_,p2_,a1,a2,a3);
    } else {
      (object_->*member_)(p1_,p2_,a1,a2,a3);
      //  zero out the pointer to ensure segfault if used again
      member_ = __null;
      delete this;
    }
  }
};


template <class T1, class T2, class R, class P1, class P2, class A1, class A2, class A3>
inline typename _ConstTessMemberResultCallback_2_3<true,R,T1,P1,P2,A1,A2,A3>::base*
NewTessCallback(const T1* obj, R (T2::*member)(P1,P2,A1,A2,A3) const, typename Identity<P1>::type p1, typename Identity<P2>::type p2) {
  return new _ConstTessMemberResultCallback_2_3<true,R,T1,P1,P2,A1,A2,A3>(obj, member, p1, p2);
}



template <class T1, class T2, class R, class P1, class P2, class A1, class A2, class A3>
inline typename _ConstTessMemberResultCallback_2_3<false,R,T1,P1,P2,A1,A2,A3>::base*
NewPermanentTessCallback(const T1* obj, R (T2::*member)(P1,P2,A1,A2,A3) const, typename Identity<P1>::type p1, typename Identity<P2>::type p2) {
  return new _ConstTessMemberResultCallback_2_3<false,R,T1,P1,P2,A1,A2,A3>(obj, member, p1, p2);
}


template <bool del, class R, class T, class P1, class P2, class A1, class A2, class A3>
class _TessMemberResultCallback_2_3 : public TessResultCallback3<R,A1,A2,A3> {
 public:
  typedef TessResultCallback3<R,A1,A2,A3> base;
  typedef R (T::*MemberSignature)(P1,P2,A1,A2,A3) ;

 private:
   T* object_;
  MemberSignature member_;
  typename remove_reference<P1>::type p1_;
  typename remove_reference<P2>::type p2_;

 public:
  inline _TessMemberResultCallback_2_3( T* object, MemberSignature member, P1 p1, P2 p2)
    : object_(object),
      member_(member), p1_(p1), p2_(p2) { }


  virtual R Run(A1 a1,A2 a2,A3 a3) {
    if (!del) {
      R result = (object_->*member_)(p1_,p2_,a1,a2,a3);
      return result;
    } else {
      R result = (object_->*member_)(p1_,p2_,a1,a2,a3);
      //  zero out the pointer to ensure segfault if used again
      member_ = __null;
      delete this;
      return result;
    }
  }
};

template <bool del, class T, class P1, class P2, class A1, class A2, class A3>
class _TessMemberResultCallback_2_3<del, void, T, P1, P2, A1, A2, A3> : public TessCallback3<A1,A2,A3> {
 public:
  typedef TessCallback3<A1,A2,A3> base;
  typedef void (T::*MemberSignature)(P1,P2,A1,A2,A3) ;

 private:
   T* object_;
  MemberSignature member_;
  typename remove_reference<P1>::type p1_;
  typename remove_reference<P2>::type p2_;

 public:
  inline _TessMemberResultCallback_2_3( T* object, MemberSignature member, P1 p1, P2 p2)
    : object_(object),
      member_(member), p1_(p1), p2_(p2) { }

  virtual void Run(A1 a1,A2 a2,A3 a3) {
    if (!del) {
      (object_->*member_)(p1_,p2_,a1,a2,a3);
    } else {
      (object_->*member_)(p1_,p2_,a1,a2,a3);
      //  zero out the pointer to ensure segfault if used again
      member_ = __null;
      delete this;
    }
  }
};


template <class T1, class T2, class R, class P1, class P2, class A1, class A2, class A3>
inline typename _TessMemberResultCallback_2_3<true,R,T1,P1,P2,A1,A2,A3>::base*
NewTessCallback( T1* obj, R (T2::*member)(P1,P2,A1,A2,A3) , typename Identity<P1>::type p1, typename Identity<P2>::type p2) {
  return new _TessMemberResultCallback_2_3<true,R,T1,P1,P2,A1,A2,A3>(obj, member, p1, p2);
}



template <class T1, class T2, class R, class P1, class P2, class A1, class A2, class A3>
inline typename _TessMemberResultCallback_2_3<false,R,T1,P1,P2,A1,A2,A3>::base*
NewPermanentTessCallback( T1* obj, R (T2::*member)(P1,P2,A1,A2,A3) , typename Identity<P1>::type p1, typename Identity<P2>::type p2) {
  return new _TessMemberResultCallback_2_3<false,R,T1,P1,P2,A1,A2,A3>(obj, member, p1, p2);
}


template <bool del, class R, class P1, class P2, class A1, class A2, class A3>
class _TessFunctionResultCallback_2_3 : public TessResultCallback3<R,A1,A2,A3> {
 public:
  typedef TessResultCallback3<R,A1,A2,A3> base;
  typedef R (*FunctionSignature)(P1,P2,A1,A2,A3);

 private:
  FunctionSignature function_;
  typename remove_reference<P1>::type p1_;
  typename remove_reference<P2>::type p2_;

 public:
  inline _TessFunctionResultCallback_2_3(FunctionSignature function, P1 p1, P2 p2)
    : function_(function), p1_(p1), p2_(p2) { }

  virtual R Run(A1 a1,A2 a2,A3 a3) {
    if (!del) {
      R result = (*function_)(p1_,p2_,a1,a2,a3);
      return result;
    } else {
      R result = (*function_)(p1_,p2_,a1,a2,a3);
      //  zero out the pointer to ensure segfault if used again
      function_ = __null;
      delete this;
      return result;
    }
  }
};

template <bool del, class P1, class P2, class A1, class A2, class A3>
class _TessFunctionResultCallback_2_3<del, void, P1, P2, A1, A2, A3> : public TessCallback3<A1,A2,A3> {
 public:
  typedef TessCallback3<A1,A2,A3> base;
  typedef void (*FunctionSignature)(P1,P2,A1,A2,A3);

 private:
  FunctionSignature function_;
  typename remove_reference<P1>::type p1_;
  typename remove_reference<P2>::type p2_;

 public:
  inline _TessFunctionResultCallback_2_3(FunctionSignature function, P1 p1, P2 p2)
    : function_(function), p1_(p1), p2_(p2) { }

  virtual void Run(A1 a1,A2 a2,A3 a3) {
    if (!del) {
      (*function_)(p1_,p2_,a1,a2,a3);
    } else {
      (*function_)(p1_,p2_,a1,a2,a3);
      //  zero out the pointer to ensure segfault if used again
      function_ = __null;
      delete this;
    }
  }
};

template <class R, class P1, class P2, class A1, class A2, class A3>
inline typename _TessFunctionResultCallback_2_3<true,R,P1,P2,A1,A2,A3>::base*
NewTessCallback(R (*function)(P1,P2,A1,A2,A3), typename Identity<P1>::type p1, typename Identity<P2>::type p2) {
  return new _TessFunctionResultCallback_2_3<true,R,P1,P2,A1,A2,A3>(function, p1, p2);
}

template <class R, class P1, class P2, class A1, class A2, class A3>
inline typename _TessFunctionResultCallback_2_3<false,R,P1,P2,A1,A2,A3>::base*
NewPermanentTessCallback(R (*function)(P1,P2,A1,A2,A3), typename Identity<P1>::type p1, typename Identity<P2>::type p2) {
  return new _TessFunctionResultCallback_2_3<false,R,P1,P2,A1,A2,A3>(function, p1, p2);
}

template <bool del, class R, class T, class P1, class P2, class P3, class A1, class A2, class A3>
class _ConstTessMemberResultCallback_3_3 : public TessResultCallback3<R,A1,A2,A3> {
 public:
  typedef TessResultCallback3<R,A1,A2,A3> base;
  typedef R (T::*MemberSignature)(P1,P2,P3,A1,A2,A3) const;

 private:
  const T* object_;
  MemberSignature member_;
  typename remove_reference<P1>::type p1_;
  typename remove_reference<P2>::type p2_;
  typename remove_reference<P3>::type p3_;

 public:
  inline _ConstTessMemberResultCallback_3_3(const T* object, MemberSignature member, P1 p1, P2 p2, P3 p3)
    : object_(object),
      member_(member), p1_(p1), p2_(p2), p3_(p3) { }

  virtual R Run(A1 a1,A2 a2,A3 a3) {
    if (!del) {
      R result = (object_->*member_)(p1_,p2_,p3_,a1,a2,a3);
      return result;
    } else {
      R result = (object_->*member_)(p1_,p2_,p3_,a1,a2,a3);
      //  zero out the pointer to ensure segfault if used again
      member_ = __null;
      delete this;
      return result;
    }
  }
};

template <bool del, class T, class P1, class P2, class P3, class A1, class A2, class A3>
class _ConstTessMemberResultCallback_3_3<del, void, T, P1, P2, P3, A1, A2, A3> : public TessCallback3<A1,A2,A3> {
 public:
  typedef TessCallback3<A1,A2,A3> base;
  typedef void (T::*MemberSignature)(P1,P2,P3,A1,A2,A3) const;

 private:
  const T* object_;
  MemberSignature member_;
  typename remove_reference<P1>::type p1_;
  typename remove_reference<P2>::type p2_;
  typename remove_reference<P3>::type p3_;

 public:
  inline _ConstTessMemberResultCallback_3_3(const T* object, MemberSignature member, P1 p1, P2 p2, P3 p3)
    : object_(object),
      member_(member), p1_(p1), p2_(p2), p3_(p3) { }

  virtual void Run(A1 a1,A2 a2,A3 a3) {
    if (!del) {
      (object_->*member_)(p1_,p2_,p3_,a1,a2,a3);
    } else {
      (object_->*member_)(p1_,p2_,p3_,a1,a2,a3);
      //  zero out the pointer to ensure segfault if used again
      member_ = __null;
      delete this;
    }
  }
};


template <class T1, class T2, class R, class P1, class P2, class P3, class A1, class A2, class A3>
inline typename _ConstTessMemberResultCallback_3_3<true,R,T1,P1,P2,P3,A1,A2,A3>::base*
NewTessCallback(const T1* obj, R (T2::*member)(P1,P2,P3,A1,A2,A3) const, typename Identity<P1>::type p1, typename Identity<P2>::type p2, typename Identity<P3>::type p3) {
  return new _ConstTessMemberResultCallback_3_3<true,R,T1,P1,P2,P3,A1,A2,A3>(obj, member, p1, p2, p3);
}



template <class T1, class T2, class R, class P1, class P2, class P3, class A1, class A2, class A3>
inline typename _ConstTessMemberResultCallback_3_3<false,R,T1,P1,P2,P3,A1,A2,A3>::base*
NewPermanentTessCallback(const T1* obj, R (T2::*member)(P1,P2,P3,A1,A2,A3) const, typename Identity<P1>::type p1, typename Identity<P2>::type p2, typename Identity<P3>::type p3) {
  return new _ConstTessMemberResultCallback_3_3<false,R,T1,P1,P2,P3,A1,A2,A3>(obj, member, p1, p2, p3);
}


template <bool del, class R, class T, class P1, class P2, class P3, class A1, class A2, class A3>
class _TessMemberResultCallback_3_3 : public TessResultCallback3<R,A1,A2,A3> {
 public:
  typedef TessResultCallback3<R,A1,A2,A3> base;
  typedef R (T::*MemberSignature)(P1,P2,P3,A1,A2,A3) ;

 private:
   T* object_;
  MemberSignature member_;
  typename remove_reference<P1>::type p1_;
  typename remove_reference<P2>::type p2_;
  typename remove_reference<P3>::type p3_;

 public:
  inline _TessMemberResultCallback_3_3( T* object, MemberSignature member, P1 p1, P2 p2, P3 p3)
    : object_(object),
      member_(member), p1_(p1), p2_(p2), p3_(p3) { }

  virtual R Run(A1 a1,A2 a2,A3 a3) {
    if (!del) {
      R result = (object_->*member_)(p1_,p2_,p3_,a1,a2,a3);
      return result;
    } else {
      R result = (object_->*member_)(p1_,p2_,p3_,a1,a2,a3);
      //  zero out the pointer to ensure segfault if used again
      member_ = __null;
      delete this;
      return result;
    }
  }
};

template <bool del, class T, class P1, class P2, class P3, class A1, class A2, class A3>
class _TessMemberResultCallback_3_3<del, void, T, P1, P2, P3, A1, A2, A3> : public TessCallback3<A1,A2,A3> {
 public:
  typedef TessCallback3<A1,A2,A3> base;
  typedef void (T::*MemberSignature)(P1,P2,P3,A1,A2,A3) ;

 private:
   T* object_;
  MemberSignature member_;
  typename remove_reference<P1>::type p1_;
  typename remove_reference<P2>::type p2_;
  typename remove_reference<P3>::type p3_;

 public:
  inline _TessMemberResultCallback_3_3( T* object, MemberSignature member, P1 p1, P2 p2, P3 p3)
    : object_(object),
      member_(member), p1_(p1), p2_(p2), p3_(p3) { }

  virtual void Run(A1 a1,A2 a2,A3 a3) {
    if (!del) {
      (object_->*member_)(p1_,p2_,p3_,a1,a2,a3);
    } else {
      (object_->*member_)(p1_,p2_,p3_,a1,a2,a3);
      //  zero out the pointer to ensure segfault if used again
      member_ = __null;
      delete this;
    }
  }
};


template <class T1, class T2, class R, class P1, class P2, class P3, class A1, class A2, class A3>
inline typename _TessMemberResultCallback_3_3<true,R,T1,P1,P2,P3,A1,A2,A3>::base*
NewTessCallback( T1* obj, R (T2::*member)(P1,P2,P3,A1,A2,A3) , typename Identity<P1>::type p1, typename Identity<P2>::type p2, typename Identity<P3>::type p3) {
  return new _TessMemberResultCallback_3_3<true,R,T1,P1,P2,P3,A1,A2,A3>(obj, member, p1, p2, p3);
}



template <class T1, class T2, class R, class P1, class P2, class P3, class A1, class A2, class A3>
inline typename _TessMemberResultCallback_3_3<false,R,T1,P1,P2,P3,A1,A2,A3>::base*
NewPermanentTessCallback( T1* obj, R (T2::*member)(P1,P2,P3,A1,A2,A3) , typename Identity<P1>::type p1, typename Identity<P2>::type p2, typename Identity<P3>::type p3) {
  return new _TessMemberResultCallback_3_3<false,R,T1,P1,P2,P3,A1,A2,A3>(obj, member, p1, p2, p3);
}


template <bool del, class R, class P1, class P2, class P3, class A1, class A2, class A3>
class _TessFunctionResultCallback_3_3 : public TessResultCallback3<R,A1,A2,A3> {
 public:
  typedef TessResultCallback3<R,A1,A2,A3> base;
  typedef R (*FunctionSignature)(P1,P2,P3,A1,A2,A3);

 private:
  FunctionSignature function_;
  typename remove_reference<P1>::type p1_;
  typename remove_reference<P2>::type p2_;
  typename remove_reference<P3>::type p3_;

 public:
  inline _TessFunctionResultCallback_3_3(FunctionSignature function, P1 p1, P2 p2, P3 p3)
    : function_(function), p1_(p1), p2_(p2), p3_(p3) { }

  virtual R Run(A1 a1,A2 a2,A3 a3) {
    if (!del) {
      R result = (*function_)(p1_,p2_,p3_,a1,a2,a3);
      return result;
    } else {
      R result = (*function_)(p1_,p2_,p3_,a1,a2,a3);
      //  zero out the pointer to ensure segfault if used again
      function_ = __null;
      delete this;
      return result;
    }
  }
};

template <bool del, class P1, class P2, class P3, class A1, class A2, class A3>
class _TessFunctionResultCallback_3_3<del, void, P1, P2, P3, A1, A2, A3> : public TessCallback3<A1,A2,A3> {
 public:
  typedef TessCallback3<A1,A2,A3> base;
  typedef void (*FunctionSignature)(P1,P2,P3,A1,A2,A3);

 private:
  FunctionSignature function_;
  typename remove_reference<P1>::type p1_;
  typename remove_reference<P2>::type p2_;
  typename remove_reference<P3>::type p3_;

 public:
  inline _TessFunctionResultCallback_3_3(FunctionSignature function, P1 p1, P2 p2, P3 p3)
    : function_(function), p1_(p1), p2_(p2), p3_(p3) { }

  virtual void Run(A1 a1,A2 a2,A3 a3) {
    if (!del) {
      (*function_)(p1_,p2_,p3_,a1,a2,a3);
    } else {
      (*function_)(p1_,p2_,p3_,a1,a2,a3);
      //  zero out the pointer to ensure segfault if used again
      function_ = __null;
      delete this;
    }
  }
};

template <class R, class P1, class P2, class P3, class A1, class A2, class A3>
inline typename _TessFunctionResultCallback_3_3<true,R,P1,P2,P3,A1,A2,A3>::base*
NewTessCallback(R (*function)(P1,P2,P3,A1,A2,A3), typename Identity<P1>::type p1, typename Identity<P2>::type p2, typename Identity<P3>::type p3) {
  return new _TessFunctionResultCallback_3_3<true,R,P1,P2,P3,A1,A2,A3>(function, p1, p2, p3);
}

template <class R, class P1, class P2, class P3, class A1, class A2, class A3>
inline typename _TessFunctionResultCallback_3_3<false,R,P1,P2,P3,A1,A2,A3>::base*
NewPermanentTessCallback(R (*function)(P1,P2,P3,A1,A2,A3), typename Identity<P1>::type p1, typename Identity<P2>::type p2, typename Identity<P3>::type p3) {
  return new _TessFunctionResultCallback_3_3<false,R,P1,P2,P3,A1,A2,A3>(function, p1, p2, p3);
}

template <bool del, class R, class T, class P1, class P2, class P3, class P4, class A1, class A2, class A3>
class _ConstTessMemberResultCallback_4_3 : public TessResultCallback3<R,A1,A2,A3> {
 public:
  typedef TessResultCallback3<R,A1,A2,A3> base;
  typedef R (T::*MemberSignature)(P1,P2,P3,P4,A1,A2,A3) const;

 private:
  const T* object_;
  MemberSignature member_;
  typename remove_reference<P1>::type p1_;
  typename remove_reference<P2>::type p2_;
  typename remove_reference<P3>::type p3_;
  typename remove_reference<P4>::type p4_;

 public:
  inline _ConstTessMemberResultCallback_4_3(const T* object, MemberSignature member, P1 p1, P2 p2, P3 p3, P4 p4)
    : object_(object),
      member_(member), p1_(p1), p2_(p2), p3_(p3), p4_(p4) { }

  virtual R Run(A1 a1,A2 a2,A3 a3) {
    if (!del) {
      R result = (object_->*member_)(p1_,p2_,p3_,p4_,a1,a2,a3);
      return result;
    } else {
      R result = (object_->*member_)(p1_,p2_,p3_,p4_,a1,a2,a3);
      //  zero out the pointer to ensure segfault if used again
      member_ = __null;
      delete this;
      return result;
    }
  }
};

template <bool del, class T, class P1, class P2, class P3, class P4, class A1, class A2, class A3>
class _ConstTessMemberResultCallback_4_3<del, void, T, P1, P2, P3, P4, A1, A2, A3> : public TessCallback3<A1,A2,A3> {
 public:
  typedef TessCallback3<A1,A2,A3> base;
  typedef void (T::*MemberSignature)(P1,P2,P3,P4,A1,A2,A3) const;

 private:
  const T* object_;
  MemberSignature member_;
  typename remove_reference<P1>::type p1_;
  typename remove_reference<P2>::type p2_;
  typename remove_reference<P3>::type p3_;
  typename remove_reference<P4>::type p4_;

 public:
  inline _ConstTessMemberResultCallback_4_3(const T* object, MemberSignature member, P1 p1, P2 p2, P3 p3, P4 p4)
    : object_(object),
      member_(member), p1_(p1), p2_(p2), p3_(p3), p4_(p4) { }

  virtual void Run(A1 a1,A2 a2,A3 a3) {
    if (!del) {
      (object_->*member_)(p1_,p2_,p3_,p4_,a1,a2,a3);
    } else {
      (object_->*member_)(p1_,p2_,p3_,p4_,a1,a2,a3);
      //  zero out the pointer to ensure segfault if used again
      member_ = __null;
      delete this;
    }
  }
};


template <class T1, class T2, class R, class P1, class P2, class P3, class P4, class A1, class A2, class A3>
inline typename _ConstTessMemberResultCallback_4_3<true,R,T1,P1,P2,P3,P4,A1,A2,A3>::base*
NewTessCallback(const T1* obj, R (T2::*member)(P1,P2,P3,P4,A1,A2,A3) const, typename Identity<P1>::type p1, typename Identity<P2>::type p2, typename Identity<P3>::type p3, typename Identity<P4>::type p4) {
  return new _ConstTessMemberResultCallback_4_3<true,R,T1,P1,P2,P3,P4,A1,A2,A3>(obj, member, p1, p2, p3, p4);
}



template <class T1, class T2, class R, class P1, class P2, class P3, class P4, class A1, class A2, class A3>
inline typename _ConstTessMemberResultCallback_4_3<false,R,T1,P1,P2,P3,P4,A1,A2,A3>::base*
NewPermanentTessCallback(const T1* obj, R (T2::*member)(P1,P2,P3,P4,A1,A2,A3) const, typename Identity<P1>::type p1, typename Identity<P2>::type p2, typename Identity<P3>::type p3, typename Identity<P4>::type p4) {
  return new _ConstTessMemberResultCallback_4_3<false,R,T1,P1,P2,P3,P4,A1,A2,A3>(obj, member, p1, p2, p3, p4);
}


template <bool del, class R, class T, class P1, class P2, class P3, class P4, class A1, class A2, class A3>
class _TessMemberResultCallback_4_3 : public TessResultCallback3<R,A1,A2,A3> {
 public:
  typedef TessResultCallback3<R,A1,A2,A3> base;
  typedef R (T::*MemberSignature)(P1,P2,P3,P4,A1,A2,A3) ;

 private:
   T* object_;
  MemberSignature member_;
  typename remove_reference<P1>::type p1_;
  typename remove_reference<P2>::type p2_;
  typename remove_reference<P3>::type p3_;
  typename remove_reference<P4>::type p4_;

 public:
  inline _TessMemberResultCallback_4_3( T* object, MemberSignature member, P1 p1, P2 p2, P3 p3, P4 p4)
    : object_(object),
      member_(member), p1_(p1), p2_(p2), p3_(p3), p4_(p4) { }

  virtual R Run(A1 a1,A2 a2,A3 a3) {
    if (!del) {
      R result = (object_->*member_)(p1_,p2_,p3_,p4_,a1,a2,a3);
      return result;
    } else {
      R result = (object_->*member_)(p1_,p2_,p3_,p4_,a1,a2,a3);
      //  zero out the pointer to ensure segfault if used again
      member_ = __null;
      delete this;
      return result;
    }
  }
};

template <bool del, class T, class P1, class P2, class P3, class P4, class A1, class A2, class A3>
class _TessMemberResultCallback_4_3<del, void, T, P1, P2, P3, P4, A1, A2, A3> : public TessCallback3<A1,A2,A3> {
 public:
  typedef TessCallback3<A1,A2,A3> base;
  typedef void (T::*MemberSignature)(P1,P2,P3,P4,A1,A2,A3) ;

 private:
   T* object_;
  MemberSignature member_;
  typename remove_reference<P1>::type p1_;
  typename remove_reference<P2>::type p2_;
  typename remove_reference<P3>::type p3_;
  typename remove_reference<P4>::type p4_;

 public:
  inline _TessMemberResultCallback_4_3( T* object, MemberSignature member, P1 p1, P2 p2, P3 p3, P4 p4)
    : object_(object),
      member_(member), p1_(p1), p2_(p2), p3_(p3), p4_(p4) { }

  virtual void Run(A1 a1,A2 a2,A3 a3) {
    if (!del) {
      (object_->*member_)(p1_,p2_,p3_,p4_,a1,a2,a3);
    } else {
      (object_->*member_)(p1_,p2_,p3_,p4_,a1,a2,a3);
      //  zero out the pointer to ensure segfault if used again
      member_ = __null;
      delete this;
    }
  }
};


template <class T1, class T2, class R, class P1, class P2, class P3, class P4, class A1, class A2, class A3>
inline typename _TessMemberResultCallback_4_3<true,R,T1,P1,P2,P3,P4,A1,A2,A3>::base*
NewTessCallback( T1* obj, R (T2::*member)(P1,P2,P3,P4,A1,A2,A3) , typename Identity<P1>::type p1, typename Identity<P2>::type p2, typename Identity<P3>::type p3, typename Identity<P4>::type p4) {
  return new _TessMemberResultCallback_4_3<true,R,T1,P1,P2,P3,P4,A1,A2,A3>(obj, member, p1, p2, p3, p4);
}



template <class T1, class T2, class R, class P1, class P2, class P3, class P4, class A1, class A2, class A3>
inline typename _TessMemberResultCallback_4_3<false,R,T1,P1,P2,P3,P4,A1,A2,A3>::base*
NewPermanentTessCallback( T1* obj, R (T2::*member)(P1,P2,P3,P4,A1,A2,A3) , typename Identity<P1>::type p1, typename Identity<P2>::type p2, typename Identity<P3>::type p3, typename Identity<P4>::type p4) {
  return new _TessMemberResultCallback_4_3<false,R,T1,P1,P2,P3,P4,A1,A2,A3>(obj, member, p1, p2, p3, p4);
}


template <bool del, class R, class P1, class P2, class P3, class P4, class A1, class A2, class A3>
class _TessFunctionResultCallback_4_3 : public TessResultCallback3<R,A1,A2,A3> {
 public:
  typedef TessResultCallback3<R,A1,A2,A3> base;
  typedef R (*FunctionSignature)(P1,P2,P3,P4,A1,A2,A3);

 private:
  FunctionSignature function_;
  typename remove_reference<P1>::type p1_;
  typename remove_reference<P2>::type p2_;
  typename remove_reference<P3>::type p3_;
  typename remove_reference<P4>::type p4_;

 public:
  inline _TessFunctionResultCallback_4_3(FunctionSignature function, P1 p1, P2 p2, P3 p3, P4 p4)
    : function_(function), p1_(p1), p2_(p2), p3_(p3), p4_(p4) { }

  virtual R Run(A1 a1,A2 a2,A3 a3) {
    if (!del) {
      R result = (*function_)(p1_,p2_,p3_,p4_,a1,a2,a3);
      return result;
    } else {
      R result = (*function_)(p1_,p2_,p3_,p4_,a1,a2,a3);
      //  zero out the pointer to ensure segfault if used again
      function_ = __null;
      delete this;
      return result;
    }
  }
};

template <bool del, class P1, class P2, class P3, class P4, class A1, class A2, class A3>
class _TessFunctionResultCallback_4_3<del, void, P1, P2, P3, P4, A1, A2, A3> : public TessCallback3<A1,A2,A3> {
 public:
  typedef TessCallback3<A1,A2,A3> base;
  typedef void (*FunctionSignature)(P1,P2,P3,P4,A1,A2,A3);

 private:
  FunctionSignature function_;
  typename remove_reference<P1>::type p1_;
  typename remove_reference<P2>::type p2_;
  typename remove_reference<P3>::type p3_;
  typename remove_reference<P4>::type p4_;

 public:
  inline _TessFunctionResultCallback_4_3(FunctionSignature function, P1 p1, P2 p2, P3 p3, P4 p4)
    : function_(function), p1_(p1), p2_(p2), p3_(p3), p4_(p4) { }

  virtual void Run(A1 a1,A2 a2,A3 a3) {
    if (!del) {
      (*function_)(p1_,p2_,p3_,p4_,a1,a2,a3);
    } else {
      (*function_)(p1_,p2_,p3_,p4_,a1,a2,a3);
      //  zero out the pointer to ensure segfault if used again
      function_ = __null;
      delete this;
    }
  }
};

template <class R, class P1, class P2, class P3, class P4, class A1, class A2, class A3>
inline typename _TessFunctionResultCallback_4_3<true,R,P1,P2,P3,P4,A1,A2,A3>::base*
NewTessCallback(R (*function)(P1,P2,P3,P4,A1,A2,A3), typename Identity<P1>::type p1, typename Identity<P2>::type p2, typename Identity<P3>::type p3, typename Identity<P4>::type p4) {
  return new _TessFunctionResultCallback_4_3<true,R,P1,P2,P3,P4,A1,A2,A3>(function, p1, p2, p3, p4);
}

template <class R, class P1, class P2, class P3, class P4, class A1, class A2, class A3>
inline typename _TessFunctionResultCallback_4_3<false,R,P1,P2,P3,P4,A1,A2,A3>::base*
NewPermanentTessCallback(R (*function)(P1,P2,P3,P4,A1,A2,A3), typename Identity<P1>::type p1, typename Identity<P2>::type p2, typename Identity<P3>::type p3, typename Identity<P4>::type p4) {
  return new _TessFunctionResultCallback_4_3<false,R,P1,P2,P3,P4,A1,A2,A3>(function, p1, p2, p3, p4);
}

template <bool del, class R, class T, class P1, class P2, class P3, class P4, class P5, class A1, class A2, class A3>
class _ConstTessMemberResultCallback_5_3 : public TessResultCallback3<R,A1,A2,A3> {
 public:
  typedef TessResultCallback3<R,A1,A2,A3> base;
  typedef R (T::*MemberSignature)(P1,P2,P3,P4,P5,A1,A2,A3) const;

 private:
  const T* object_;
  MemberSignature member_;
  typename remove_reference<P1>::type p1_;
  typename remove_reference<P2>::type p2_;
  typename remove_reference<P3>::type p3_;
  typename remove_reference<P4>::type p4_;
  typename remove_reference<P5>::type p5_;

 public:
  inline _ConstTessMemberResultCallback_5_3(const T* object, MemberSignature member, P1 p1, P2 p2, P3 p3, P4 p4, P5 p5)
    : object_(object),
      member_(member), p1_(p1), p2_(p2), p3_(p3), p4_(p4), p5_(p5) { }

  virtual R Run(A1 a1,A2 a2,A3 a3) {
    if (!del) {
      R result = (object_->*member_)(p1_,p2_,p3_,p4_,p5_,a1,a2,a3);
      return result;
    } else {
      R result = (object_->*member_)(p1_,p2_,p3_,p4_,p5_,a1,a2,a3);
      //  zero out the pointer to ensure segfault if used again
      member_ = __null;
      delete this;
      return result;
    }
  }
};

template <bool del, class T, class P1, class P2, class P3, class P4, class P5, class A1, class A2, class A3>
class _ConstTessMemberResultCallback_5_3<del, void, T, P1, P2, P3, P4, P5, A1, A2, A3> : public TessCallback3<A1,A2,A3> {
 public:
  typedef TessCallback3<A1,A2,A3> base;
  typedef void (T::*MemberSignature)(P1,P2,P3,P4,P5,A1,A2,A3) const;

 private:
  const T* object_;
  MemberSignature member_;
  typename remove_reference<P1>::type p1_;
  typename remove_reference<P2>::type p2_;
  typename remove_reference<P3>::type p3_;
  typename remove_reference<P4>::type p4_;
  typename remove_reference<P5>::type p5_;

 public:
  inline _ConstTessMemberResultCallback_5_3(const T* object, MemberSignature member, P1 p1, P2 p2, P3 p3, P4 p4, P5 p5)
    : object_(object),
      member_(member), p1_(p1), p2_(p2), p3_(p3), p4_(p4), p5_(p5) { }

  virtual void Run(A1 a1,A2 a2,A3 a3) {
    if (!del) {
      (object_->*member_)(p1_,p2_,p3_,p4_,p5_,a1,a2,a3);
    } else {
      (object_->*member_)(p1_,p2_,p3_,p4_,p5_,a1,a2,a3);
      //  zero out the pointer to ensure segfault if used again
      member_ = __null;
      delete this;
    }
  }
};


template <class T1, class T2, class R, class P1, class P2, class P3, class P4, class P5, class A1, class A2, class A3>
inline typename _ConstTessMemberResultCallback_5_3<true,R,T1,P1,P2,P3,P4,P5,A1,A2,A3>::base*
NewTessCallback(const T1* obj, R (T2::*member)(P1,P2,P3,P4,P5,A1,A2,A3) const, typename Identity<P1>::type p1, typename Identity<P2>::type p2, typename Identity<P3>::type p3, typename Identity<P4>::type p4, typename Identity<P5>::type p5) {
  return new _ConstTessMemberResultCallback_5_3<true,R,T1,P1,P2,P3,P4,P5,A1,A2,A3>(obj, member, p1, p2, p3, p4, p5);
}



template <class T1, class T2, class R, class P1, class P2, class P3, class P4, class P5, class A1, class A2, class A3>
inline typename _ConstTessMemberResultCallback_5_3<false,R,T1,P1,P2,P3,P4,P5,A1,A2,A3>::base*
NewPermanentTessCallback(const T1* obj, R (T2::*member)(P1,P2,P3,P4,P5,A1,A2,A3) const, typename Identity<P1>::type p1, typename Identity<P2>::type p2, typename Identity<P3>::type p3, typename Identity<P4>::type p4, typename Identity<P5>::type p5) {
  return new _ConstTessMemberResultCallback_5_3<false,R,T1,P1,P2,P3,P4,P5,A1,A2,A3>(obj, member, p1, p2, p3, p4, p5);
}


template <bool del, class R, class T, class P1, class P2, class P3, class P4, class P5, class A1, class A2, class A3>
class _TessMemberResultCallback_5_3 : public TessResultCallback3<R,A1,A2,A3> {
 public:
  typedef TessResultCallback3<R,A1,A2,A3> base;
  typedef R (T::*MemberSignature)(P1,P2,P3,P4,P5,A1,A2,A3) ;

 private:
   T* object_;
  MemberSignature member_;
  typename remove_reference<P1>::type p1_;
  typename remove_reference<P2>::type p2_;
  typename remove_reference<P3>::type p3_;
  typename remove_reference<P4>::type p4_;
  typename remove_reference<P5>::type p5_;

 public:
  inline _TessMemberResultCallback_5_3( T* object, MemberSignature member, P1 p1, P2 p2, P3 p3, P4 p4, P5 p5)
    : object_(object),
      member_(member), p1_(p1), p2_(p2), p3_(p3), p4_(p4), p5_(p5) { }

  virtual R Run(A1 a1,A2 a2,A3 a3) {
    if (!del) {
      R result = (object_->*member_)(p1_,p2_,p3_,p4_,p5_,a1,a2,a3);
      return result;
    } else {
      R result = (object_->*member_)(p1_,p2_,p3_,p4_,p5_,a1,a2,a3);
      //  zero out the pointer to ensure segfault if used again
      member_ = __null;
      delete this;
      return result;
    }
  }
};

template <bool del, class T, class P1, class P2, class P3, class P4, class P5, class A1, class A2, class A3>
class _TessMemberResultCallback_5_3<del, void, T, P1, P2, P3, P4, P5, A1, A2, A3> : public TessCallback3<A1,A2,A3> {
 public:
  typedef TessCallback3<A1,A2,A3> base;
  typedef void (T::*MemberSignature)(P1,P2,P3,P4,P5,A1,A2,A3) ;

 private:
   T* object_;
  MemberSignature member_;
  typename remove_reference<P1>::type p1_;
  typename remove_reference<P2>::type p2_;
  typename remove_reference<P3>::type p3_;
  typename remove_reference<P4>::type p4_;
  typename remove_reference<P5>::type p5_;

 public:
  inline _TessMemberResultCallback_5_3( T* object, MemberSignature member, P1 p1, P2 p2, P3 p3, P4 p4, P5 p5)
    : object_(object),
      member_(member), p1_(p1), p2_(p2), p3_(p3), p4_(p4), p5_(p5) { }

  virtual void Run(A1 a1,A2 a2,A3 a3) {
    if (!del) {
      (object_->*member_)(p1_,p2_,p3_,p4_,p5_,a1,a2,a3);
    } else {
      (object_->*member_)(p1_,p2_,p3_,p4_,p5_,a1,a2,a3);
      //  zero out the pointer to ensure segfault if used again
      member_ = __null;
      delete this;
    }
  }
};


template <class T1, class T2, class R, class P1, class P2, class P3, class P4, class P5, class A1, class A2, class A3>
inline typename _TessMemberResultCallback_5_3<true,R,T1,P1,P2,P3,P4,P5,A1,A2,A3>::base*
NewTessCallback( T1* obj, R (T2::*member)(P1,P2,P3,P4,P5,A1,A2,A3) , typename Identity<P1>::type p1, typename Identity<P2>::type p2, typename Identity<P3>::type p3, typename Identity<P4>::type p4, typename Identity<P5>::type p5) {
  return new _TessMemberResultCallback_5_3<true,R,T1,P1,P2,P3,P4,P5,A1,A2,A3>(obj, member, p1, p2, p3, p4, p5);
}



template <class T1, class T2, class R, class P1, class P2, class P3, class P4, class P5, class A1, class A2, class A3>
inline typename _TessMemberResultCallback_5_3<false,R,T1,P1,P2,P3,P4,P5,A1,A2,A3>::base*
NewPermanentTessCallback( T1* obj, R (T2::*member)(P1,P2,P3,P4,P5,A1,A2,A3) , typename Identity<P1>::type p1, typename Identity<P2>::type p2, typename Identity<P3>::type p3, typename Identity<P4>::type p4, typename Identity<P5>::type p5) {
  return new _TessMemberResultCallback_5_3<false,R,T1,P1,P2,P3,P4,P5,A1,A2,A3>(obj, member, p1, p2, p3, p4, p5);
}


template <bool del, class R, class P1, class P2, class P3, class P4, class P5, class A1, class A2, class A3>
class _TessFunctionResultCallback_5_3 : public TessResultCallback3<R,A1,A2,A3> {
 public:
  typedef TessResultCallback3<R,A1,A2,A3> base;
  typedef R (*FunctionSignature)(P1,P2,P3,P4,P5,A1,A2,A3);

 private:
  FunctionSignature function_;
  typename remove_reference<P1>::type p1_;
  typename remove_reference<P2>::type p2_;
  typename remove_reference<P3>::type p3_;
  typename remove_reference<P4>::type p4_;
  typename remove_reference<P5>::type p5_;

 public:
  inline _TessFunctionResultCallback_5_3(FunctionSignature function, P1 p1, P2 p2, P3 p3, P4 p4, P5 p5)
    : function_(function), p1_(p1), p2_(p2), p3_(p3), p4_(p4), p5_(p5) { }

  virtual R Run(A1 a1,A2 a2,A3 a3) {
    if (!del) {
      R result = (*function_)(p1_,p2_,p3_,p4_,p5_,a1,a2,a3);
      return result;
    } else {
      R result = (*function_)(p1_,p2_,p3_,p4_,p5_,a1,a2,a3);
      //  zero out the pointer to ensure segfault if used again
      function_ = __null;
      delete this;
      return result;
    }
  }
};

template <bool del, class P1, class P2, class P3, class P4, class P5, class A1, class A2, class A3>
class _TessFunctionResultCallback_5_3<del, void, P1, P2, P3, P4, P5, A1, A2, A3> : public TessCallback3<A1,A2,A3> {
 public:
  typedef TessCallback3<A1,A2,A3> base;
  typedef void (*FunctionSignature)(P1,P2,P3,P4,P5,A1,A2,A3);

 private:
  FunctionSignature function_;
  typename remove_reference<P1>::type p1_;
  typename remove_reference<P2>::type p2_;
  typename remove_reference<P3>::type p3_;
  typename remove_reference<P4>::type p4_;
  typename remove_reference<P5>::type p5_;

 public:
  inline _TessFunctionResultCallback_5_3(FunctionSignature function, P1 p1, P2 p2, P3 p3, P4 p4, P5 p5)
    : function_(function), p1_(p1), p2_(p2), p3_(p3), p4_(p4), p5_(p5) { }

  virtual void Run(A1 a1,A2 a2,A3 a3) {
    if (!del) {
      (*function_)(p1_,p2_,p3_,p4_,p5_,a1,a2,a3);
    } else {
      (*function_)(p1_,p2_,p3_,p4_,p5_,a1,a2,a3);
      //  zero out the pointer to ensure segfault if used again
      function_ = __null;
      delete this;
    }
  }
};

template <class R, class P1, class P2, class P3, class P4, class P5, class A1, class A2, class A3>
inline typename _TessFunctionResultCallback_5_3<true,R,P1,P2,P3,P4,P5,A1,A2,A3>::base*
NewTessCallback(R (*function)(P1,P2,P3,P4,P5,A1,A2,A3), typename Identity<P1>::type p1, typename Identity<P2>::type p2, typename Identity<P3>::type p3, typename Identity<P4>::type p4, typename Identity<P5>::type p5) {
  return new _TessFunctionResultCallback_5_3<true,R,P1,P2,P3,P4,P5,A1,A2,A3>(function, p1, p2, p3, p4, p5);
}

template <class R, class P1, class P2, class P3, class P4, class P5, class A1, class A2, class A3>
inline typename _TessFunctionResultCallback_5_3<false,R,P1,P2,P3,P4,P5,A1,A2,A3>::base*
NewPermanentTessCallback(R (*function)(P1,P2,P3,P4,P5,A1,A2,A3), typename Identity<P1>::type p1, typename Identity<P2>::type p2, typename Identity<P3>::type p3, typename Identity<P4>::type p4, typename Identity<P5>::type p5) {
  return new _TessFunctionResultCallback_5_3<false,R,P1,P2,P3,P4,P5,A1,A2,A3>(function, p1, p2, p3, p4, p5);
}

template <bool del, class R, class T, class P1, class P2, class P3, class P4, class P5, class P6, class A1, class A2, class A3>
class _ConstTessMemberResultCallback_6_3 : public TessResultCallback3<R,A1,A2,A3> {
 public:
  typedef TessResultCallback3<R,A1,A2,A3> base;
  typedef R (T::*MemberSignature)(P1,P2,P3,P4,P5,P6,A1,A2,A3) const;

 private:
  const T* object_;
  MemberSignature member_;
  typename remove_reference<P1>::type p1_;
  typename remove_reference<P2>::type p2_;
  typename remove_reference<P3>::type p3_;
  typename remove_reference<P4>::type p4_;
  typename remove_reference<P5>::type p5_;
  typename remove_reference<P6>::type p6_;

 public:
  inline _ConstTessMemberResultCallback_6_3(const T* object, MemberSignature member, P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6)
    : object_(object),
      member_(member), p1_(p1), p2_(p2), p3_(p3), p4_(p4), p5_(p5), p6_(p6) { }

  virtual R Run(A1 a1,A2 a2,A3 a3) {
    if (!del) {
      R result = (object_->*member_)(p1_,p2_,p3_,p4_,p5_,p6_,a1,a2,a3);
      return result;
    } else {
      R result = (object_->*member_)(p1_,p2_,p3_,p4_,p5_,p6_,a1,a2,a3);
      //  zero out the pointer to ensure segfault if used again
      member_ = __null;
      delete this;
      return result;
    }
  }
};

template <bool del, class T, class P1, class P2, class P3, class P4, class P5, class P6, class A1, class A2, class A3>
class _ConstTessMemberResultCallback_6_3<del, void, T, P1, P2, P3, P4, P5, P6, A1, A2, A3> : public TessCallback3<A1,A2,A3> {
 public:
  typedef TessCallback3<A1,A2,A3> base;
  typedef void (T::*MemberSignature)(P1,P2,P3,P4,P5,P6,A1,A2,A3) const;

 private:
  const T* object_;
  MemberSignature member_;
  typename remove_reference<P1>::type p1_;
  typename remove_reference<P2>::type p2_;
  typename remove_reference<P3>::type p3_;
  typename remove_reference<P4>::type p4_;
  typename remove_reference<P5>::type p5_;
  typename remove_reference<P6>::type p6_;

 public:
  inline _ConstTessMemberResultCallback_6_3(const T* object, MemberSignature member, P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6)
    : object_(object),
      member_(member), p1_(p1), p2_(p2), p3_(p3), p4_(p4), p5_(p5), p6_(p6) { }

  virtual void Run(A1 a1,A2 a2,A3 a3) {
    if (!del) {
      (object_->*member_)(p1_,p2_,p3_,p4_,p5_,p6_,a1,a2,a3);
    } else {
      (object_->*member_)(p1_,p2_,p3_,p4_,p5_,p6_,a1,a2,a3);
      //  zero out the pointer to ensure segfault if used again
      member_ = __null;
      delete this;
    }
  }
};


template <class T1, class T2, class R, class P1, class P2, class P3, class P4, class P5, class P6, class A1, class A2, class A3>
inline typename _ConstTessMemberResultCallback_6_3<true,R,T1,P1,P2,P3,P4,P5,P6,A1,A2,A3>::base*
NewTessCallback(const T1* obj, R (T2::*member)(P1,P2,P3,P4,P5,P6,A1,A2,A3) const, typename Identity<P1>::type p1, typename Identity<P2>::type p2, typename Identity<P3>::type p3, typename Identity<P4>::type p4, typename Identity<P5>::type p5, typename Identity<P6>::type p6) {
  return new _ConstTessMemberResultCallback_6_3<true,R,T1,P1,P2,P3,P4,P5,P6,A1,A2,A3>(obj, member, p1, p2, p3, p4, p5, p6);
}



template <class T1, class T2, class R, class P1, class P2, class P3, class P4, class P5, class P6, class A1, class A2, class A3>
inline typename _ConstTessMemberResultCallback_6_3<false,R,T1,P1,P2,P3,P4,P5,P6,A1,A2,A3>::base*
NewPermanentTessCallback(const T1* obj, R (T2::*member)(P1,P2,P3,P4,P5,P6,A1,A2,A3) const, typename Identity<P1>::type p1, typename Identity<P2>::type p2, typename Identity<P3>::type p3, typename Identity<P4>::type p4, typename Identity<P5>::type p5, typename Identity<P6>::type p6) {
  return new _ConstTessMemberResultCallback_6_3<false,R,T1,P1,P2,P3,P4,P5,P6,A1,A2,A3>(obj, member, p1, p2, p3, p4, p5, p6);
}


template <bool del, class R, class T, class P1, class P2, class P3, class P4, class P5, class P6, class A1, class A2, class A3>
class _TessMemberResultCallback_6_3 : public TessResultCallback3<R,A1,A2,A3> {
 public:
  typedef TessResultCallback3<R,A1,A2,A3> base;
  typedef R (T::*MemberSignature)(P1,P2,P3,P4,P5,P6,A1,A2,A3) ;

 private:
   T* object_;
  MemberSignature member_;
  typename remove_reference<P1>::type p1_;
  typename remove_reference<P2>::type p2_;
  typename remove_reference<P3>::type p3_;
  typename remove_reference<P4>::type p4_;
  typename remove_reference<P5>::type p5_;
  typename remove_reference<P6>::type p6_;

 public:
  inline _TessMemberResultCallback_6_3( T* object, MemberSignature member, P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6)
    : object_(object),
      member_(member), p1_(p1), p2_(p2), p3_(p3), p4_(p4), p5_(p5), p6_(p6) { }

  virtual R Run(A1 a1,A2 a2,A3 a3) {
    if (!del) {
      R result = (object_->*member_)(p1_,p2_,p3_,p4_,p5_,p6_,a1,a2,a3);
      return result;
    } else {
      R result = (object_->*member_)(p1_,p2_,p3_,p4_,p5_,p6_,a1,a2,a3);
      //  zero out the pointer to ensure segfault if used again
      member_ = __null;
      delete this;
      return result;
    }
  }
};

template <bool del, class T, class P1, class P2, class P3, class P4, class P5, class P6, class A1, class A2, class A3>
class _TessMemberResultCallback_6_3<del, void, T, P1, P2, P3, P4, P5, P6, A1, A2, A3> : public TessCallback3<A1,A2,A3> {
 public:
  typedef TessCallback3<A1,A2,A3> base;
  typedef void (T::*MemberSignature)(P1,P2,P3,P4,P5,P6,A1,A2,A3) ;

 private:
   T* object_;
  MemberSignature member_;
  typename remove_reference<P1>::type p1_;
  typename remove_reference<P2>::type p2_;
  typename remove_reference<P3>::type p3_;
  typename remove_reference<P4>::type p4_;
  typename remove_reference<P5>::type p5_;
  typename remove_reference<P6>::type p6_;

 public:
  inline _TessMemberResultCallback_6_3( T* object, MemberSignature member, P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6)
    : object_(object),
      member_(member), p1_(p1), p2_(p2), p3_(p3), p4_(p4), p5_(p5), p6_(p6) { }

  virtual void Run(A1 a1,A2 a2,A3 a3) {
    if (!del) {
      (object_->*member_)(p1_,p2_,p3_,p4_,p5_,p6_,a1,a2,a3);
    } else {
      (object_->*member_)(p1_,p2_,p3_,p4_,p5_,p6_,a1,a2,a3);
      //  zero out the pointer to ensure segfault if used again
      member_ = __null;
      delete this;
    }
  }
};


template <class T1, class T2, class R, class P1, class P2, class P3, class P4, class P5, class P6, class A1, class A2, class A3>
inline typename _TessMemberResultCallback_6_3<true,R,T1,P1,P2,P3,P4,P5,P6,A1,A2,A3>::base*
NewTessCallback( T1* obj, R (T2::*member)(P1,P2,P3,P4,P5,P6,A1,A2,A3) , typename Identity<P1>::type p1, typename Identity<P2>::type p2, typename Identity<P3>::type p3, typename Identity<P4>::type p4, typename Identity<P5>::type p5, typename Identity<P6>::type p6) {
  return new _TessMemberResultCallback_6_3<true,R,T1,P1,P2,P3,P4,P5,P6,A1,A2,A3>(obj, member, p1, p2, p3, p4, p5, p6);
}



template <class T1, class T2, class R, class P1, class P2, class P3, class P4, class P5, class P6, class A1, class A2, class A3>
inline typename _TessMemberResultCallback_6_3<false,R,T1,P1,P2,P3,P4,P5,P6,A1,A2,A3>::base*
NewPermanentTessCallback( T1* obj, R (T2::*member)(P1,P2,P3,P4,P5,P6,A1,A2,A3) , typename Identity<P1>::type p1, typename Identity<P2>::type p2, typename Identity<P3>::type p3, typename Identity<P4>::type p4, typename Identity<P5>::type p5, typename Identity<P6>::type p6) {
  return new _TessMemberResultCallback_6_3<false,R,T1,P1,P2,P3,P4,P5,P6,A1,A2,A3>(obj, member, p1, p2, p3, p4, p5, p6);
}


template <bool del, class R, class P1, class P2, class P3, class P4, class P5, class P6, class A1, class A2, class A3>
class _TessFunctionResultCallback_6_3 : public TessResultCallback3<R,A1,A2,A3> {
 public:
  typedef TessResultCallback3<R,A1,A2,A3> base;
  typedef R (*FunctionSignature)(P1,P2,P3,P4,P5,P6,A1,A2,A3);

 private:
  FunctionSignature function_;
  typename remove_reference<P1>::type p1_;
  typename remove_reference<P2>::type p2_;
  typename remove_reference<P3>::type p3_;
  typename remove_reference<P4>::type p4_;
  typename remove_reference<P5>::type p5_;
  typename remove_reference<P6>::type p6_;

 public:
  inline _TessFunctionResultCallback_6_3(FunctionSignature function, P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6)
    : function_(function), p1_(p1), p2_(p2), p3_(p3), p4_(p4), p5_(p5), p6_(p6) { }

  virtual R Run(A1 a1,A2 a2,A3 a3) {
    if (!del) {
      R result = (*function_)(p1_,p2_,p3_,p4_,p5_,p6_,a1,a2,a3);
      return result;
    } else {
      R result = (*function_)(p1_,p2_,p3_,p4_,p5_,p6_,a1,a2,a3);
      //  zero out the pointer to ensure segfault if used again
      function_ = __null;
      delete this;
      return result;
    }
  }
};

template <bool del, class P1, class P2, class P3, class P4, class P5, class P6, class A1, class A2, class A3>
class _TessFunctionResultCallback_6_3<del, void, P1, P2, P3, P4, P5, P6, A1, A2, A3> : public TessCallback3<A1,A2,A3> {
 public:
  typedef TessCallback3<A1,A2,A3> base;
  typedef void (*FunctionSignature)(P1,P2,P3,P4,P5,P6,A1,A2,A3);

 private:
  FunctionSignature function_;
  typename remove_reference<P1>::type p1_;
  typename remove_reference<P2>::type p2_;
  typename remove_reference<P3>::type p3_;
  typename remove_reference<P4>::type p4_;
  typename remove_reference<P5>::type p5_;
  typename remove_reference<P6>::type p6_;

 public:
  inline _TessFunctionResultCallback_6_3(FunctionSignature function, P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6)
    : function_(function), p1_(p1), p2_(p2), p3_(p3), p4_(p4), p5_(p5), p6_(p6) { }

  virtual void Run(A1 a1,A2 a2,A3 a3) {
    if (!del) {
      (*function_)(p1_,p2_,p3_,p4_,p5_,p6_,a1,a2,a3);
    } else {
      (*function_)(p1_,p2_,p3_,p4_,p5_,p6_,a1,a2,a3);
      //  zero out the pointer to ensure segfault if used again
      function_ = __null;
      delete this;
    }
  }
};

template <class R, class P1, class P2, class P3, class P4, class P5, class P6, class A1, class A2, class A3>
inline typename _TessFunctionResultCallback_6_3<true,R,P1,P2,P3,P4,P5,P6,A1,A2,A3>::base*
NewTessCallback(R (*function)(P1,P2,P3,P4,P5,P6,A1,A2,A3), typename Identity<P1>::type p1, typename Identity<P2>::type p2, typename Identity<P3>::type p3, typename Identity<P4>::type p4, typename Identity<P5>::type p5, typename Identity<P6>::type p6) {
  return new _TessFunctionResultCallback_6_3<true,R,P1,P2,P3,P4,P5,P6,A1,A2,A3>(function, p1, p2, p3, p4, p5, p6);
}

template <class R, class P1, class P2, class P3, class P4, class P5, class P6, class A1, class A2, class A3>
inline typename _TessFunctionResultCallback_6_3<false,R,P1,P2,P3,P4,P5,P6,A1,A2,A3>::base*
NewPermanentTessCallback(R (*function)(P1,P2,P3,P4,P5,P6,A1,A2,A3), typename Identity<P1>::type p1, typename Identity<P2>::type p2, typename Identity<P3>::type p3, typename Identity<P4>::type p4, typename Identity<P5>::type p5, typename Identity<P6>::type p6) {
  return new _TessFunctionResultCallback_6_3<false,R,P1,P2,P3,P4,P5,P6,A1,A2,A3>(function, p1, p2, p3, p4, p5, p6);
}

template <bool del, class R, class T, class A1, class A2, class A3, class A4>
class _ConstTessMemberResultCallback_0_4 : public TessResultCallback4<R,A1,A2,A3,A4> {
 public:
  typedef TessResultCallback4<R,A1,A2,A3,A4> base;
  typedef R (T::*MemberSignature)(A1,A2,A3,A4) const;

 private:
  const T* object_;
  MemberSignature member_;

 public:
  inline _ConstTessMemberResultCallback_0_4(const T* object, MemberSignature member)
    : object_(object),
      member_(member) { }

  virtual R Run(A1 a1,A2 a2,A3 a3,A4 a4) {
    if (!del) {
      R result = (object_->*member_)(a1,a2,a3,a4);
      return result;
    } else {
      R result = (object_->*member_)(a1,a2,a3,a4);
      //  zero out the pointer to ensure segfault if used again
      member_ = __null;
      delete this;
      return result;
    }
  }
};

template <bool del, class T, class A1, class A2, class A3, class A4>
class _ConstTessMemberResultCallback_0_4<del, void, T, A1, A2, A3, A4> : public TessCallback4<A1,A2,A3,A4> {
 public:
  typedef TessCallback4<A1,A2,A3,A4> base;
  typedef void (T::*MemberSignature)(A1,A2,A3,A4) const;

 private:
  const T* object_;
  MemberSignature member_;

 public:
  inline _ConstTessMemberResultCallback_0_4(const T* object, MemberSignature member)
    : object_(object),
      member_(member) { }

  virtual void Run(A1 a1,A2 a2,A3 a3,A4 a4) {
    if (!del) {
      (object_->*member_)(a1,a2,a3,a4);
    } else {
      (object_->*member_)(a1,a2,a3,a4);
      //  zero out the pointer to ensure segfault if used again
      member_ = __null;
      delete this;
    }
  }
};


template <class T1, class T2, class R, class A1, class A2, class A3, class A4>
inline typename _ConstTessMemberResultCallback_0_4<true,R,T1,A1,A2,A3,A4>::base*
NewTessCallback(const T1* obj, R (T2::*member)(A1,A2,A3,A4) const) {
  return new _ConstTessMemberResultCallback_0_4<true,R,T1,A1,A2,A3,A4>(obj, member);
}



template <class T1, class T2, class R, class A1, class A2, class A3, class A4>
inline typename _ConstTessMemberResultCallback_0_4<false,R,T1,A1,A2,A3,A4>::base*
NewPermanentTessCallback(const T1* obj, R (T2::*member)(A1,A2,A3,A4) const) {
  return new _ConstTessMemberResultCallback_0_4<false,R,T1,A1,A2,A3,A4>(obj, member);
}


template <bool del, class R, class T, class A1, class A2, class A3, class A4>
class _TessMemberResultCallback_0_4 : public TessResultCallback4<R,A1,A2,A3,A4> {
 public:
  typedef TessResultCallback4<R,A1,A2,A3,A4> base;
  typedef R (T::*MemberSignature)(A1,A2,A3,A4) ;

 private:
   T* object_;
  MemberSignature member_;

 public:
  inline _TessMemberResultCallback_0_4( T* object, MemberSignature member)
    : object_(object),
      member_(member) { }

  virtual R Run(A1 a1,A2 a2,A3 a3,A4 a4) {
    if (!del) {
      R result = (object_->*member_)(a1,a2,a3,a4);
      return result;
    } else {
      R result = (object_->*member_)(a1,a2,a3,a4);
     //  zero out the pointer to ensure segfault if used again
      member_ = __null;
      delete this;
      return result;
    }
  }
};

template <bool del, class T, class A1, class A2, class A3, class A4>
class _TessMemberResultCallback_0_4<del, void, T, A1, A2, A3, A4> : public TessCallback4<A1,A2,A3,A4> {
 public:
  typedef TessCallback4<A1,A2,A3,A4> base;
  typedef void (T::*MemberSignature)(A1,A2,A3,A4) ;

 private:
   T* object_;
  MemberSignature member_;

 public:
  inline _TessMemberResultCallback_0_4( T* object, MemberSignature member)
    : object_(object),
      member_(member) { }

  virtual void Run(A1 a1,A2 a2,A3 a3,A4 a4) {
    if (!del) {
      (object_->*member_)(a1,a2,a3,a4);
    } else {
      (object_->*member_)(a1,a2,a3,a4);
      //  zero out the pointer to ensure segfault if used again
      member_ = __null;
      delete this;
    }
  }
};


template <class T1, class T2, class R, class A1, class A2, class A3, class A4>
inline typename _TessMemberResultCallback_0_4<true,R,T1,A1,A2,A3,A4>::base*
NewTessCallback( T1* obj, R (T2::*member)(A1,A2,A3,A4) ) {
  return new _TessMemberResultCallback_0_4<true,R,T1,A1,A2,A3,A4>(obj, member);
}



template <class T1, class T2, class R, class A1, class A2, class A3, class A4>
inline typename _TessMemberResultCallback_0_4<false,R,T1,A1,A2,A3,A4>::base*
NewPermanentTessCallback( T1* obj, R (T2::*member)(A1,A2,A3,A4) ) {
  return new _TessMemberResultCallback_0_4<false,R,T1,A1,A2,A3,A4>(obj, member);
}


template <bool del, class R, class A1, class A2, class A3, class A4>
class _TessFunctionResultCallback_0_4 : public TessResultCallback4<R,A1,A2,A3,A4> {
 public:
  typedef TessResultCallback4<R,A1,A2,A3,A4> base;
  typedef R (*FunctionSignature)(A1,A2,A3,A4);

 private:
  FunctionSignature function_;

 public:
  inline _TessFunctionResultCallback_0_4(FunctionSignature function)
    : function_(function) { }

  virtual R Run(A1 a1,A2 a2,A3 a3,A4 a4) {
    if (!del) {
      R result = (*function_)(a1,a2,a3,a4);
      return result;
    } else {
      R result = (*function_)(a1,a2,a3,a4);
      //  zero out the pointer to ensure segfault if used again
      function_ = __null;
      delete this;
      return result;
    }
  }
};

template <bool del, class A1, class A2, class A3, class A4>
class _TessFunctionResultCallback_0_4<del, void, A1, A2, A3, A4> : public TessCallback4<A1,A2,A3,A4> {
 public:
  typedef TessCallback4<A1,A2,A3,A4> base;
  typedef void (*FunctionSignature)(A1,A2,A3,A4);

 private:
  FunctionSignature function_;

 public:
  inline _TessFunctionResultCallback_0_4(FunctionSignature function)
    : function_(function) { }

  virtual void Run(A1 a1,A2 a2,A3 a3,A4 a4) {
    if (!del) {
      (*function_)(a1,a2,a3,a4);
    } else {
      (*function_)(a1,a2,a3,a4);
      //  zero out the pointer to ensure segfault if used again
      function_ = __null;
      delete this;
    }
  }
};

template <class R, class A1, class A2, class A3, class A4>
inline typename _TessFunctionResultCallback_0_4<true,R,A1,A2,A3,A4>::base*
NewTessCallback(R (*function)(A1,A2,A3,A4)) {
  return new _TessFunctionResultCallback_0_4<true,R,A1,A2,A3,A4>(function);
}

template <class R, class A1, class A2, class A3, class A4>
inline typename _TessFunctionResultCallback_0_4<false,R,A1,A2,A3,A4>::base*
NewPermanentTessCallback(R (*function)(A1,A2,A3,A4)) {
  return new _TessFunctionResultCallback_0_4<false,R,A1,A2,A3,A4>(function);
}

template <bool del, class R, class T, class P1, class A1, class A2, class A3, class A4>
class _ConstTessMemberResultCallback_1_4 : public TessResultCallback4<R,A1,A2,A3,A4> {
 public:
  typedef TessResultCallback4<R,A1,A2,A3,A4> base;
  typedef R (T::*MemberSignature)(P1,A1,A2,A3,A4) const;

 private:
  const T* object_;
  MemberSignature member_;
  typename remove_reference<P1>::type p1_;

 public:
  inline _ConstTessMemberResultCallback_1_4(const T* object, MemberSignature member, P1 p1)
    : object_(object),
      member_(member), p1_(p1) { }

  virtual R Run(A1 a1,A2 a2,A3 a3,A4 a4) {
    if (!del) {
      R result = (object_->*member_)(p1_,a1,a2,a3,a4);
      return result;
    } else {
      R result = (object_->*member_)(p1_,a1,a2,a3,a4);
      //  zero out the pointer to ensure segfault if used again
      member_ = __null;
      delete this;
      return result;
    }
  }
};

template <bool del, class T, class P1, class A1, class A2, class A3, class A4>
class _ConstTessMemberResultCallback_1_4<del, void, T, P1, A1, A2, A3, A4> : public TessCallback4<A1,A2,A3,A4> {
 public:
  typedef TessCallback4<A1,A2,A3,A4> base;
  typedef void (T::*MemberSignature)(P1,A1,A2,A3,A4) const;

 private:
  const T* object_;
  MemberSignature member_;
  typename remove_reference<P1>::type p1_;

 public:
  inline _ConstTessMemberResultCallback_1_4(const T* object, MemberSignature member, P1 p1)
    : object_(object),
      member_(member), p1_(p1) { }

  virtual void Run(A1 a1,A2 a2,A3 a3,A4 a4) {
    if (!del) {
      (object_->*member_)(p1_,a1,a2,a3,a4);
    } else {
      (object_->*member_)(p1_,a1,a2,a3,a4);
      //  zero out the pointer to ensure segfault if used again
      member_ = __null;
      delete this;
    }
  }
};


template <class T1, class T2, class R, class P1, class A1, class A2, class A3, class A4>
inline typename _ConstTessMemberResultCallback_1_4<true,R,T1,P1,A1,A2,A3,A4>::base*
NewTessCallback(const T1* obj, R (T2::*member)(P1,A1,A2,A3,A4) const, typename Identity<P1>::type p1) {
  return new _ConstTessMemberResultCallback_1_4<true,R,T1,P1,A1,A2,A3,A4>(obj, member, p1);
}



template <class T1, class T2, class R, class P1, class A1, class A2, class A3, class A4>
inline typename _ConstTessMemberResultCallback_1_4<false,R,T1,P1,A1,A2,A3,A4>::base*
NewPermanentTessCallback(const T1* obj, R (T2::*member)(P1,A1,A2,A3,A4) const, typename Identity<P1>::type p1) {
  return new _ConstTessMemberResultCallback_1_4<false,R,T1,P1,A1,A2,A3,A4>(obj, member, p1);
}


template <bool del, class R, class T, class P1, class A1, class A2, class A3, class A4>
class _TessMemberResultCallback_1_4 : public TessResultCallback4<R,A1,A2,A3,A4> {
 public:
  typedef TessResultCallback4<R,A1,A2,A3,A4> base;
  typedef R (T::*MemberSignature)(P1,A1,A2,A3,A4) ;

 private:
   T* object_;
  MemberSignature member_;
  typename remove_reference<P1>::type p1_;

 public:
  inline _TessMemberResultCallback_1_4( T* object, MemberSignature member, P1 p1)
    : object_(object),
      member_(member), p1_(p1) { }

  virtual R Run(A1 a1,A2 a2,A3 a3,A4 a4) {
    if (!del) {
      R result = (object_->*member_)(p1_,a1,a2,a3,a4);
      return result;
    } else {
      R result = (object_->*member_)(p1_,a1,a2,a3,a4);
      //  zero out the pointer to ensure segfault if used again
      member_ = __null;
      delete this;
      return result;
    }
  }
};

template <bool del, class T, class P1, class A1, class A2, class A3, class A4>
class _TessMemberResultCallback_1_4<del, void, T, P1, A1, A2, A3, A4> : public TessCallback4<A1,A2,A3,A4> {
 public:
  typedef TessCallback4<A1,A2,A3,A4> base;
  typedef void (T::*MemberSignature)(P1,A1,A2,A3,A4) ;

 private:
   T* object_;
  MemberSignature member_;
  typename remove_reference<P1>::type p1_;

 public:
  inline _TessMemberResultCallback_1_4( T* object, MemberSignature member, P1 p1)
    : object_(object),
      member_(member), p1_(p1) { }

  virtual void Run(A1 a1,A2 a2,A3 a3,A4 a4) {
    if (!del) {
      (object_->*member_)(p1_,a1,a2,a3,a4);
    } else {
      (object_->*member_)(p1_,a1,a2,a3,a4);
      //  zero out the pointer to ensure segfault if used again
      member_ = __null;
      delete this;
    }
  }
};


template <class T1, class T2, class R, class P1, class A1, class A2, class A3, class A4>
inline typename _TessMemberResultCallback_1_4<true,R,T1,P1,A1,A2,A3,A4>::base*
NewTessCallback( T1* obj, R (T2::*member)(P1,A1,A2,A3,A4) , typename Identity<P1>::type p1) {
  return new _TessMemberResultCallback_1_4<true,R,T1,P1,A1,A2,A3,A4>(obj, member, p1);
}



template <class T1, class T2, class R, class P1, class A1, class A2, class A3, class A4>
inline typename _TessMemberResultCallback_1_4<false,R,T1,P1,A1,A2,A3,A4>::base*
NewPermanentTessCallback( T1* obj, R (T2::*member)(P1,A1,A2,A3,A4) , typename Identity<P1>::type p1) {
  return new _TessMemberResultCallback_1_4<false,R,T1,P1,A1,A2,A3,A4>(obj, member, p1);
}


template <bool del, class R, class P1, class A1, class A2, class A3, class A4>
class _TessFunctionResultCallback_1_4 : public TessResultCallback4<R,A1,A2,A3,A4> {
 public:
  typedef TessResultCallback4<R,A1,A2,A3,A4> base;
  typedef R (*FunctionSignature)(P1,A1,A2,A3,A4);

 private:
  FunctionSignature function_;
  typename remove_reference<P1>::type p1_;

 public:
  inline _TessFunctionResultCallback_1_4(FunctionSignature function, P1 p1)
    : function_(function), p1_(p1) { }

  virtual R Run(A1 a1,A2 a2,A3 a3,A4 a4) {
    if (!del) {
      R result = (*function_)(p1_,a1,a2,a3,a4);
      return result;
    } else {
      R result = (*function_)(p1_,a1,a2,a3,a4);
      //  zero out the pointer to ensure segfault if used again
      function_ = __null;
      delete this;
      return result;
    }
  }
};

template <bool del, class P1, class A1, class A2, class A3, class A4>
class _TessFunctionResultCallback_1_4<del, void, P1, A1, A2, A3, A4> : public TessCallback4<A1,A2,A3,A4> {
 public:
  typedef TessCallback4<A1,A2,A3,A4> base;
  typedef void (*FunctionSignature)(P1,A1,A2,A3,A4);

 private:
  FunctionSignature function_;
  typename remove_reference<P1>::type p1_;

 public:
  inline _TessFunctionResultCallback_1_4(FunctionSignature function, P1 p1)
    : function_(function), p1_(p1) { }

  virtual void Run(A1 a1,A2 a2,A3 a3,A4 a4) {
    if (!del) {
      (*function_)(p1_,a1,a2,a3,a4);
    } else {
      (*function_)(p1_,a1,a2,a3,a4);
      //  zero out the pointer to ensure segfault if used again
      function_ = __null;
      delete this;
    }
  }
};

template <class R, class P1, class A1, class A2, class A3, class A4>
inline typename _TessFunctionResultCallback_1_4<true,R,P1,A1,A2,A3,A4>::base*
NewTessCallback(R (*function)(P1,A1,A2,A3,A4), typename Identity<P1>::type p1) {
  return new _TessFunctionResultCallback_1_4<true,R,P1,A1,A2,A3,A4>(function, p1);
}

template <class R, class P1, class A1, class A2, class A3, class A4>
inline typename _TessFunctionResultCallback_1_4<false,R,P1,A1,A2,A3,A4>::base*
NewPermanentTessCallback(R (*function)(P1,A1,A2,A3,A4), typename Identity<P1>::type p1) {
  return new _TessFunctionResultCallback_1_4<false,R,P1,A1,A2,A3,A4>(function, p1);
}

template <bool del, class R, class T, class P1, class P2, class A1, class A2, class A3, class A4>
class _ConstTessMemberResultCallback_2_4 : public TessResultCallback4<R,A1,A2,A3,A4> {
 public:
  typedef TessResultCallback4<R,A1,A2,A3,A4> base;
  typedef R (T::*MemberSignature)(P1,P2,A1,A2,A3,A4) const;

 private:
  const T* object_;
  MemberSignature member_;
  typename remove_reference<P1>::type p1_;
  typename remove_reference<P2>::type p2_;

 public:
  inline _ConstTessMemberResultCallback_2_4(const T* object, MemberSignature member, P1 p1, P2 p2)
    : object_(object),
      member_(member), p1_(p1), p2_(p2) { }

  virtual R Run(A1 a1,A2 a2,A3 a3,A4 a4) {
    if (!del) {
      R result = (object_->*member_)(p1_,p2_,a1,a2,a3,a4);
      return result;
    } else {
      R result = (object_->*member_)(p1_,p2_,a1,a2,a3,a4);
      //  zero out the pointer to ensure segfault if used again
      member_ = __null;
      delete this;
      return result;
    }
  }
};

template <bool del, class T, class P1, class P2, class A1, class A2, class A3, class A4>
class _ConstTessMemberResultCallback_2_4<del, void, T, P1, P2, A1, A2, A3, A4> : public TessCallback4<A1,A2,A3,A4> {
 public:
  typedef TessCallback4<A1,A2,A3,A4> base;
  typedef void (T::*MemberSignature)(P1,P2,A1,A2,A3,A4) const;

 private:
  const T* object_;
  MemberSignature member_;
  typename remove_reference<P1>::type p1_;
  typename remove_reference<P2>::type p2_;

 public:
  inline _ConstTessMemberResultCallback_2_4(const T* object, MemberSignature member, P1 p1, P2 p2)
    : object_(object),
      member_(member), p1_(p1), p2_(p2) { }

  virtual void Run(A1 a1,A2 a2,A3 a3,A4 a4) {
    if (!del) {
      (object_->*member_)(p1_,p2_,a1,a2,a3,a4);
    } else {
      (object_->*member_)(p1_,p2_,a1,a2,a3,a4);
      //  zero out the pointer to ensure segfault if used again
      member_ = __null;
      delete this;
    }
  }
};


template <class T1, class T2, class R, class P1, class P2, class A1, class A2, class A3, class A4>
inline typename _ConstTessMemberResultCallback_2_4<true,R,T1,P1,P2,A1,A2,A3,A4>::base*
NewTessCallback(const T1* obj, R (T2::*member)(P1,P2,A1,A2,A3,A4) const, typename Identity<P1>::type p1, typename Identity<P2>::type p2) {
  return new _ConstTessMemberResultCallback_2_4<true,R,T1,P1,P2,A1,A2,A3,A4>(obj, member, p1, p2);
}



template <class T1, class T2, class R, class P1, class P2, class A1, class A2, class A3, class A4>
inline typename _ConstTessMemberResultCallback_2_4<false,R,T1,P1,P2,A1,A2,A3,A4>::base*
NewPermanentTessCallback(const T1* obj, R (T2::*member)(P1,P2,A1,A2,A3,A4) const, typename Identity<P1>::type p1, typename Identity<P2>::type p2) {
  return new _ConstTessMemberResultCallback_2_4<false,R,T1,P1,P2,A1,A2,A3,A4>(obj, member, p1, p2);
}


template <bool del, class R, class T, class P1, class P2, class A1, class A2, class A3, class A4>
class _TessMemberResultCallback_2_4 : public TessResultCallback4<R,A1,A2,A3,A4> {
 public:
  typedef TessResultCallback4<R,A1,A2,A3,A4> base;
  typedef R (T::*MemberSignature)(P1,P2,A1,A2,A3,A4) ;

 private:
   T* object_;
  MemberSignature member_;
  typename remove_reference<P1>::type p1_;
  typename remove_reference<P2>::type p2_;

 public:
  inline _TessMemberResultCallback_2_4( T* object, MemberSignature member, P1 p1, P2 p2)
    : object_(object),
      member_(member), p1_(p1), p2_(p2) { }

  virtual R Run(A1 a1,A2 a2,A3 a3,A4 a4) {
    if (!del) {
      R result = (object_->*member_)(p1_,p2_,a1,a2,a3,a4);
      return result;
    } else {
      R result = (object_->*member_)(p1_,p2_,a1,a2,a3,a4);
      //  zero out the pointer to ensure segfault if used again
      member_ = __null;
      delete this;
      return result;
    }
  }
};

template <bool del, class T, class P1, class P2, class A1, class A2, class A3, class A4>
class _TessMemberResultCallback_2_4<del, void, T, P1, P2, A1, A2, A3, A4> : public TessCallback4<A1,A2,A3,A4> {
 public:
  typedef TessCallback4<A1,A2,A3,A4> base;
  typedef void (T::*MemberSignature)(P1,P2,A1,A2,A3,A4) ;

 private:
   T* object_;
  MemberSignature member_;
  typename remove_reference<P1>::type p1_;
  typename remove_reference<P2>::type p2_;

 public:
  inline _TessMemberResultCallback_2_4( T* object, MemberSignature member, P1 p1, P2 p2)
    : object_(object),
      member_(member), p1_(p1), p2_(p2) { }

  virtual void Run(A1 a1,A2 a2,A3 a3,A4 a4) {
    if (!del) {
      (object_->*member_)(p1_,p2_,a1,a2,a3,a4);
    } else {
      (object_->*member_)(p1_,p2_,a1,a2,a3,a4);
      //  zero out the pointer to ensure segfault if used again
      member_ = __null;
      delete this;
    }
  }
};


template <class T1, class T2, class R, class P1, class P2, class A1, class A2, class A3, class A4>
inline typename _TessMemberResultCallback_2_4<true,R,T1,P1,P2,A1,A2,A3,A4>::base*
NewTessCallback( T1* obj, R (T2::*member)(P1,P2,A1,A2,A3,A4) , typename Identity<P1>::type p1, typename Identity<P2>::type p2) {
  return new _TessMemberResultCallback_2_4<true,R,T1,P1,P2,A1,A2,A3,A4>(obj, member, p1, p2);
}



template <class T1, class T2, class R, class P1, class P2, class A1, class A2, class A3, class A4>
inline typename _TessMemberResultCallback_2_4<false,R,T1,P1,P2,A1,A2,A3,A4>::base*
NewPermanentTessCallback( T1* obj, R (T2::*member)(P1,P2,A1,A2,A3,A4) , typename Identity<P1>::type p1, typename Identity<P2>::type p2) {
  return new _TessMemberResultCallback_2_4<false,R,T1,P1,P2,A1,A2,A3,A4>(obj, member, p1, p2);
}


template <bool del, class R, class P1, class P2, class A1, class A2, class A3, class A4>
class _TessFunctionResultCallback_2_4 : public TessResultCallback4<R,A1,A2,A3,A4> {
 public:
  typedef TessResultCallback4<R,A1,A2,A3,A4> base;
  typedef R (*FunctionSignature)(P1,P2,A1,A2,A3,A4);

 private:
  FunctionSignature function_;
  typename remove_reference<P1>::type p1_;
  typename remove_reference<P2>::type p2_;

 public:
  inline _TessFunctionResultCallback_2_4(FunctionSignature function, P1 p1, P2 p2)
    : function_(function), p1_(p1), p2_(p2) { }

  virtual R Run(A1 a1,A2 a2,A3 a3,A4 a4) {
    if (!del) {
      R result = (*function_)(p1_,p2_,a1,a2,a3,a4);
      return result;
    } else {
      R result = (*function_)(p1_,p2_,a1,a2,a3,a4);
      //  zero out the pointer to ensure segfault if used again
      function_ = __null;
      delete this;
      return result;
    }
  }
};

template <bool del, class P1, class P2, class A1, class A2, class A3, class A4>
class _TessFunctionResultCallback_2_4<del, void, P1, P2, A1, A2, A3, A4> : public TessCallback4<A1,A2,A3,A4> {
 public:
  typedef TessCallback4<A1,A2,A3,A4> base;
  typedef void (*FunctionSignature)(P1,P2,A1,A2,A3,A4);

 private:
  FunctionSignature function_;
  typename remove_reference<P1>::type p1_;
  typename remove_reference<P2>::type p2_;

 public:
  inline _TessFunctionResultCallback_2_4(FunctionSignature function, P1 p1, P2 p2)
    : function_(function), p1_(p1), p2_(p2) { }

  virtual void Run(A1 a1,A2 a2,A3 a3,A4 a4) {
    if (!del) {
      (*function_)(p1_,p2_,a1,a2,a3,a4);
    } else {
      (*function_)(p1_,p2_,a1,a2,a3,a4);
      //  zero out the pointer to ensure segfault if used again
      function_ = __null;
      delete this;
    }
  }
};

template <class R, class P1, class P2, class A1, class A2, class A3, class A4>
inline typename _TessFunctionResultCallback_2_4<true,R,P1,P2,A1,A2,A3,A4>::base*
NewTessCallback(R (*function)(P1,P2,A1,A2,A3,A4), typename Identity<P1>::type p1, typename Identity<P2>::type p2) {
  return new _TessFunctionResultCallback_2_4<true,R,P1,P2,A1,A2,A3,A4>(function, p1, p2);
}

template <class R, class P1, class P2, class A1, class A2, class A3, class A4>
inline typename _TessFunctionResultCallback_2_4<false,R,P1,P2,A1,A2,A3,A4>::base*
NewPermanentTessCallback(R (*function)(P1,P2,A1,A2,A3,A4), typename Identity<P1>::type p1, typename Identity<P2>::type p2) {
  return new _TessFunctionResultCallback_2_4<false,R,P1,P2,A1,A2,A3,A4>(function, p1, p2);
}

template <bool del, class R, class T, class P1, class P2, class P3, class A1, class A2, class A3, class A4>
class _ConstTessMemberResultCallback_3_4 : public TessResultCallback4<R,A1,A2,A3,A4> {
 public:
  typedef TessResultCallback4<R,A1,A2,A3,A4> base;
  typedef R (T::*MemberSignature)(P1,P2,P3,A1,A2,A3,A4) const;

 private:
  const T* object_;
  MemberSignature member_;
  typename remove_reference<P1>::type p1_;
  typename remove_reference<P2>::type p2_;
  typename remove_reference<P3>::type p3_;

 public:
  inline _ConstTessMemberResultCallback_3_4(const T* object, MemberSignature member, P1 p1, P2 p2, P3 p3)
    : object_(object),
      member_(member), p1_(p1), p2_(p2), p3_(p3) { }

  virtual R Run(A1 a1,A2 a2,A3 a3,A4 a4) {
    if (!del) {
      R result = (object_->*member_)(p1_,p2_,p3_,a1,a2,a3,a4);
      return result;
    } else {
      R result = (object_->*member_)(p1_,p2_,p3_,a1,a2,a3,a4);
      //  zero out the pointer to ensure segfault if used again
      member_ = __null;
      delete this;
      return result;
    }
  }
};

template <bool del, class T, class P1, class P2, class P3, class A1, class A2, class A3, class A4>
class _ConstTessMemberResultCallback_3_4<del, void, T, P1, P2, P3, A1, A2, A3, A4> : public TessCallback4<A1,A2,A3,A4> {
 public:
  typedef TessCallback4<A1,A2,A3,A4> base;
  typedef void (T::*MemberSignature)(P1,P2,P3,A1,A2,A3,A4) const;

 private:
  const T* object_;
  MemberSignature member_;
  typename remove_reference<P1>::type p1_;
  typename remove_reference<P2>::type p2_;
  typename remove_reference<P3>::type p3_;

 public:
  inline _ConstTessMemberResultCallback_3_4(const T* object, MemberSignature member, P1 p1, P2 p2, P3 p3)
    : object_(object),
      member_(member), p1_(p1), p2_(p2), p3_(p3) { }

  virtual void Run(A1 a1,A2 a2,A3 a3,A4 a4) {
    if (!del) {
      (object_->*member_)(p1_,p2_,p3_,a1,a2,a3,a4);
    } else {
      (object_->*member_)(p1_,p2_,p3_,a1,a2,a3,a4);
      //  zero out the pointer to ensure segfault if used again
      member_ = __null;
      delete this;
    }
  }
};


template <class T1, class T2, class R, class P1, class P2, class P3, class A1, class A2, class A3, class A4>
inline typename _ConstTessMemberResultCallback_3_4<true,R,T1,P1,P2,P3,A1,A2,A3,A4>::base*
NewTessCallback(const T1* obj, R (T2::*member)(P1,P2,P3,A1,A2,A3,A4) const, typename Identity<P1>::type p1, typename Identity<P2>::type p2, typename Identity<P3>::type p3) {
  return new _ConstTessMemberResultCallback_3_4<true,R,T1,P1,P2,P3,A1,A2,A3,A4>(obj, member, p1, p2, p3);
}



template <class T1, class T2, class R, class P1, class P2, class P3, class A1, class A2, class A3, class A4>
inline typename _ConstTessMemberResultCallback_3_4<false,R,T1,P1,P2,P3,A1,A2,A3,A4>::base*
NewPermanentTessCallback(const T1* obj, R (T2::*member)(P1,P2,P3,A1,A2,A3,A4) const, typename Identity<P1>::type p1, typename Identity<P2>::type p2, typename Identity<P3>::type p3) {
  return new _ConstTessMemberResultCallback_3_4<false,R,T1,P1,P2,P3,A1,A2,A3,A4>(obj, member, p1, p2, p3);
}


template <bool del, class R, class T, class P1, class P2, class P3, class A1, class A2, class A3, class A4>
class _TessMemberResultCallback_3_4 : public TessResultCallback4<R,A1,A2,A3,A4> {
 public:
  typedef TessResultCallback4<R,A1,A2,A3,A4> base;
  typedef R (T::*MemberSignature)(P1,P2,P3,A1,A2,A3,A4) ;

 private:
   T* object_;
  MemberSignature member_;
  typename remove_reference<P1>::type p1_;
  typename remove_reference<P2>::type p2_;
  typename remove_reference<P3>::type p3_;

 public:
  inline _TessMemberResultCallback_3_4( T* object, MemberSignature member, P1 p1, P2 p2, P3 p3)
    : object_(object),
      member_(member), p1_(p1), p2_(p2), p3_(p3) { }

  virtual R Run(A1 a1,A2 a2,A3 a3,A4 a4) {
    if (!del) {
      R result = (object_->*member_)(p1_,p2_,p3_,a1,a2,a3,a4);
      return result;
    } else {
      R result = (object_->*member_)(p1_,p2_,p3_,a1,a2,a3,a4);
      //  zero out the pointer to ensure segfault if used again
      member_ = __null;
      delete this;
      return result;
    }
  }
};

template <bool del, class T, class P1, class P2, class P3, class A1, class A2, class A3, class A4>
class _TessMemberResultCallback_3_4<del, void, T, P1, P2, P3, A1, A2, A3, A4> : public TessCallback4<A1,A2,A3,A4> {
 public:
  typedef TessCallback4<A1,A2,A3,A4> base;
  typedef void (T::*MemberSignature)(P1,P2,P3,A1,A2,A3,A4) ;

 private:
   T* object_;
  MemberSignature member_;
  typename remove_reference<P1>::type p1_;
  typename remove_reference<P2>::type p2_;
  typename remove_reference<P3>::type p3_;

 public:
  inline _TessMemberResultCallback_3_4( T* object, MemberSignature member, P1 p1, P2 p2, P3 p3)
    : object_(object),
      member_(member), p1_(p1), p2_(p2), p3_(p3) { }

  virtual void Run(A1 a1,A2 a2,A3 a3,A4 a4) {
    if (!del) {
      (object_->*member_)(p1_,p2_,p3_,a1,a2,a3,a4);
    } else {
      (object_->*member_)(p1_,p2_,p3_,a1,a2,a3,a4);
      //  zero out the pointer to ensure segfault if used again
      member_ = __null;
      delete this;
    }
  }
};


template <class T1, class T2, class R, class P1, class P2, class P3, class A1, class A2, class A3, class A4>
inline typename _TessMemberResultCallback_3_4<true,R,T1,P1,P2,P3,A1,A2,A3,A4>::base*
NewTessCallback( T1* obj, R (T2::*member)(P1,P2,P3,A1,A2,A3,A4) , typename Identity<P1>::type p1, typename Identity<P2>::type p2, typename Identity<P3>::type p3) {
  return new _TessMemberResultCallback_3_4<true,R,T1,P1,P2,P3,A1,A2,A3,A4>(obj, member, p1, p2, p3);
}



template <class T1, class T2, class R, class P1, class P2, class P3, class A1, class A2, class A3, class A4>
inline typename _TessMemberResultCallback_3_4<false,R,T1,P1,P2,P3,A1,A2,A3,A4>::base*
NewPermanentTessCallback( T1* obj, R (T2::*member)(P1,P2,P3,A1,A2,A3,A4) , typename Identity<P1>::type p1, typename Identity<P2>::type p2, typename Identity<P3>::type p3) {
  return new _TessMemberResultCallback_3_4<false,R,T1,P1,P2,P3,A1,A2,A3,A4>(obj, member, p1, p2, p3);
}


template <bool del, class R, class P1, class P2, class P3, class A1, class A2, class A3, class A4>
class _TessFunctionResultCallback_3_4 : public TessResultCallback4<R,A1,A2,A3,A4> {
 public:
  typedef TessResultCallback4<R,A1,A2,A3,A4> base;
  typedef R (*FunctionSignature)(P1,P2,P3,A1,A2,A3,A4);

 private:
  FunctionSignature function_;
  typename remove_reference<P1>::type p1_;
  typename remove_reference<P2>::type p2_;
  typename remove_reference<P3>::type p3_;

 public:
  inline _TessFunctionResultCallback_3_4(FunctionSignature function, P1 p1, P2 p2, P3 p3)
    : function_(function), p1_(p1), p2_(p2), p3_(p3) { }

  virtual R Run(A1 a1,A2 a2,A3 a3,A4 a4) {
    if (!del) {
      R result = (*function_)(p1_,p2_,p3_,a1,a2,a3,a4);
      return result;
    } else {
      R result = (*function_)(p1_,p2_,p3_,a1,a2,a3,a4);
      //  zero out the pointer to ensure segfault if used again
      function_ = __null;
      delete this;
      return result;
    }
  }
};

template <bool del, class P1, class P2, class P3, class A1, class A2, class A3, class A4>
class _TessFunctionResultCallback_3_4<del, void, P1, P2, P3, A1, A2, A3, A4> : public TessCallback4<A1,A2,A3,A4> {
 public:
  typedef TessCallback4<A1,A2,A3,A4> base;
  typedef void (*FunctionSignature)(P1,P2,P3,A1,A2,A3,A4);

 private:
  FunctionSignature function_;
  typename remove_reference<P1>::type p1_;
  typename remove_reference<P2>::type p2_;
  typename remove_reference<P3>::type p3_;

 public:
  inline _TessFunctionResultCallback_3_4(FunctionSignature function, P1 p1, P2 p2, P3 p3)
    : function_(function), p1_(p1), p2_(p2), p3_(p3) { }

  virtual void Run(A1 a1,A2 a2,A3 a3,A4 a4) {
    if (!del) {
      (*function_)(p1_,p2_,p3_,a1,a2,a3,a4);
    } else {
      (*function_)(p1_,p2_,p3_,a1,a2,a3,a4);
      //  zero out the pointer to ensure segfault if used again
      function_ = __null;
      delete this;
    }
  }
};

template <class R, class P1, class P2, class P3, class A1, class A2, class A3, class A4>
inline typename _TessFunctionResultCallback_3_4<true,R,P1,P2,P3,A1,A2,A3,A4>::base*
NewTessCallback(R (*function)(P1,P2,P3,A1,A2,A3,A4), typename Identity<P1>::type p1, typename Identity<P2>::type p2, typename Identity<P3>::type p3) {
  return new _TessFunctionResultCallback_3_4<true,R,P1,P2,P3,A1,A2,A3,A4>(function, p1, p2, p3);
}

template <class R, class P1, class P2, class P3, class A1, class A2, class A3, class A4>
inline typename _TessFunctionResultCallback_3_4<false,R,P1,P2,P3,A1,A2,A3,A4>::base*
NewPermanentTessCallback(R (*function)(P1,P2,P3,A1,A2,A3,A4), typename Identity<P1>::type p1, typename Identity<P2>::type p2, typename Identity<P3>::type p3) {
  return new _TessFunctionResultCallback_3_4<false,R,P1,P2,P3,A1,A2,A3,A4>(function, p1, p2, p3);
}

template <bool del, class R, class T, class P1, class P2, class P3, class P4, class A1, class A2, class A3, class A4>
class _ConstTessMemberResultCallback_4_4 : public TessResultCallback4<R,A1,A2,A3,A4> {
 public:
  typedef TessResultCallback4<R,A1,A2,A3,A4> base;
  typedef R (T::*MemberSignature)(P1,P2,P3,P4,A1,A2,A3,A4) const;

 private:
  const T* object_;
  MemberSignature member_;
  typename remove_reference<P1>::type p1_;
  typename remove_reference<P2>::type p2_;
  typename remove_reference<P3>::type p3_;
  typename remove_reference<P4>::type p4_;

 public:
  inline _ConstTessMemberResultCallback_4_4(const T* object, MemberSignature member, P1 p1, P2 p2, P3 p3, P4 p4)
    : object_(object),
      member_(member), p1_(p1), p2_(p2), p3_(p3), p4_(p4) { }

  virtual R Run(A1 a1,A2 a2,A3 a3,A4 a4) {
    if (!del) {
      R result = (object_->*member_)(p1_,p2_,p3_,p4_,a1,a2,a3,a4);
      return result;
    } else {
      R result = (object_->*member_)(p1_,p2_,p3_,p4_,a1,a2,a3,a4);
      //  zero out the pointer to ensure segfault if used again
      member_ = __null;
      delete this;
      return result;
    }
  }
};

template <bool del, class T, class P1, class P2, class P3, class P4, class A1, class A2, class A3, class A4>
class _ConstTessMemberResultCallback_4_4<del, void, T, P1, P2, P3, P4, A1, A2, A3, A4> : public TessCallback4<A1,A2,A3,A4> {
 public:
  typedef TessCallback4<A1,A2,A3,A4> base;
  typedef void (T::*MemberSignature)(P1,P2,P3,P4,A1,A2,A3,A4) const;

 private:
  const T* object_;
  MemberSignature member_;
  typename remove_reference<P1>::type p1_;
  typename remove_reference<P2>::type p2_;
  typename remove_reference<P3>::type p3_;
  typename remove_reference<P4>::type p4_;

 public:
  inline _ConstTessMemberResultCallback_4_4(const T* object, MemberSignature member, P1 p1, P2 p2, P3 p3, P4 p4)
    : object_(object),
      member_(member), p1_(p1), p2_(p2), p3_(p3), p4_(p4) { }

  virtual void Run(A1 a1,A2 a2,A3 a3,A4 a4) {
    if (!del) {
      (object_->*member_)(p1_,p2_,p3_,p4_,a1,a2,a3,a4);
    } else {
      (object_->*member_)(p1_,p2_,p3_,p4_,a1,a2,a3,a4);
      //  zero out the pointer to ensure segfault if used again
      member_ = __null;
      delete this;
    }
  }
};


template <class T1, class T2, class R, class P1, class P2, class P3, class P4, class A1, class A2, class A3, class A4>
inline typename _ConstTessMemberResultCallback_4_4<true,R,T1,P1,P2,P3,P4,A1,A2,A3,A4>::base*
NewTessCallback(const T1* obj, R (T2::*member)(P1,P2,P3,P4,A1,A2,A3,A4) const, typename Identity<P1>::type p1, typename Identity<P2>::type p2, typename Identity<P3>::type p3, typename Identity<P4>::type p4) {
  return new _ConstTessMemberResultCallback_4_4<true,R,T1,P1,P2,P3,P4,A1,A2,A3,A4>(obj, member, p1, p2, p3, p4);
}



template <class T1, class T2, class R, class P1, class P2, class P3, class P4, class A1, class A2, class A3, class A4>
inline typename _ConstTessMemberResultCallback_4_4<false,R,T1,P1,P2,P3,P4,A1,A2,A3,A4>::base*
NewPermanentTessCallback(const T1* obj, R (T2::*member)(P1,P2,P3,P4,A1,A2,A3,A4) const, typename Identity<P1>::type p1, typename Identity<P2>::type p2, typename Identity<P3>::type p3, typename Identity<P4>::type p4) {
  return new _ConstTessMemberResultCallback_4_4<false,R,T1,P1,P2,P3,P4,A1,A2,A3,A4>(obj, member, p1, p2, p3, p4);
}


template <bool del, class R, class T, class P1, class P2, class P3, class P4, class A1, class A2, class A3, class A4>
class _TessMemberResultCallback_4_4 : public TessResultCallback4<R,A1,A2,A3,A4> {
 public:
  typedef TessResultCallback4<R,A1,A2,A3,A4> base;
  typedef R (T::*MemberSignature)(P1,P2,P3,P4,A1,A2,A3,A4) ;

 private:
   T* object_;
  MemberSignature member_;
  typename remove_reference<P1>::type p1_;
  typename remove_reference<P2>::type p2_;
  typename remove_reference<P3>::type p3_;
  typename remove_reference<P4>::type p4_;

 public:
  inline _TessMemberResultCallback_4_4( T* object, MemberSignature member, P1 p1, P2 p2, P3 p3, P4 p4)
    : object_(object),
      member_(member), p1_(p1), p2_(p2), p3_(p3), p4_(p4) { }

  virtual R Run(A1 a1,A2 a2,A3 a3,A4 a4) {
    if (!del) {
      R result = (object_->*member_)(p1_,p2_,p3_,p4_,a1,a2,a3,a4);
      return result;
    } else {
      R result = (object_->*member_)(p1_,p2_,p3_,p4_,a1,a2,a3,a4);
      //  zero out the pointer to ensure segfault if used again
      member_ = __null;
      delete this;
      return result;
    }
  }
};

template <bool del, class T, class P1, class P2, class P3, class P4, class A1, class A2, class A3, class A4>
class _TessMemberResultCallback_4_4<del, void, T, P1, P2, P3, P4, A1, A2, A3, A4> : public TessCallback4<A1,A2,A3,A4> {
 public:
  typedef TessCallback4<A1,A2,A3,A4> base;
  typedef void (T::*MemberSignature)(P1,P2,P3,P4,A1,A2,A3,A4) ;

 private:
   T* object_;
  MemberSignature member_;
  typename remove_reference<P1>::type p1_;
  typename remove_reference<P2>::type p2_;
  typename remove_reference<P3>::type p3_;
  typename remove_reference<P4>::type p4_;

 public:
  inline _TessMemberResultCallback_4_4( T* object, MemberSignature member, P1 p1, P2 p2, P3 p3, P4 p4)
    : object_(object),
      member_(member), p1_(p1), p2_(p2), p3_(p3), p4_(p4) { }

  virtual void Run(A1 a1,A2 a2,A3 a3,A4 a4) {
    if (!del) {
      (object_->*member_)(p1_,p2_,p3_,p4_,a1,a2,a3,a4);
    } else {
      (object_->*member_)(p1_,p2_,p3_,p4_,a1,a2,a3,a4);
      //  zero out the pointer to ensure segfault if used again
      member_ = __null;
      delete this;
    }
  }
};


template <class T1, class T2, class R, class P1, class P2, class P3, class P4, class A1, class A2, class A3, class A4>
inline typename _TessMemberResultCallback_4_4<true,R,T1,P1,P2,P3,P4,A1,A2,A3,A4>::base*
NewTessCallback( T1* obj, R (T2::*member)(P1,P2,P3,P4,A1,A2,A3,A4) , typename Identity<P1>::type p1, typename Identity<P2>::type p2, typename Identity<P3>::type p3, typename Identity<P4>::type p4) {
  return new _TessMemberResultCallback_4_4<true,R,T1,P1,P2,P3,P4,A1,A2,A3,A4>(obj, member, p1, p2, p3, p4);
}



template <class T1, class T2, class R, class P1, class P2, class P3, class P4, class A1, class A2, class A3, class A4>
inline typename _TessMemberResultCallback_4_4<false,R,T1,P1,P2,P3,P4,A1,A2,A3,A4>::base*
NewPermanentTessCallback( T1* obj, R (T2::*member)(P1,P2,P3,P4,A1,A2,A3,A4) , typename Identity<P1>::type p1, typename Identity<P2>::type p2, typename Identity<P3>::type p3, typename Identity<P4>::type p4) {
  return new _TessMemberResultCallback_4_4<false,R,T1,P1,P2,P3,P4,A1,A2,A3,A4>(obj, member, p1, p2, p3, p4);
}


template <bool del, class R, class P1, class P2, class P3, class P4, class A1, class A2, class A3, class A4>
class _TessFunctionResultCallback_4_4 : public TessResultCallback4<R,A1,A2,A3,A4> {
 public:
  typedef TessResultCallback4<R,A1,A2,A3,A4> base;
  typedef R (*FunctionSignature)(P1,P2,P3,P4,A1,A2,A3,A4);

 private:
  FunctionSignature function_;
  typename remove_reference<P1>::type p1_;
  typename remove_reference<P2>::type p2_;
  typename remove_reference<P3>::type p3_;
  typename remove_reference<P4>::type p4_;

 public:
  inline _TessFunctionResultCallback_4_4(FunctionSignature function, P1 p1, P2 p2, P3 p3, P4 p4)
    : function_(function), p1_(p1), p2_(p2), p3_(p3), p4_(p4) { }

  virtual R Run(A1 a1,A2 a2,A3 a3,A4 a4) {
    if (!del) {
      R result = (*function_)(p1_,p2_,p3_,p4_,a1,a2,a3,a4);
      return result;
    } else {
      R result = (*function_)(p1_,p2_,p3_,p4_,a1,a2,a3,a4);
      //  zero out the pointer to ensure segfault if used again
      function_ = __null;
      delete this;
      return result;
    }
  }
};

template <bool del, class P1, class P2, class P3, class P4, class A1, class A2, class A3, class A4>
class _TessFunctionResultCallback_4_4<del, void, P1, P2, P3, P4, A1, A2, A3, A4> : public TessCallback4<A1,A2,A3,A4> {
 public:
  typedef TessCallback4<A1,A2,A3,A4> base;
  typedef void (*FunctionSignature)(P1,P2,P3,P4,A1,A2,A3,A4);

 private:
  FunctionSignature function_;
  typename remove_reference<P1>::type p1_;
  typename remove_reference<P2>::type p2_;
  typename remove_reference<P3>::type p3_;
  typename remove_reference<P4>::type p4_;

 public:
  inline _TessFunctionResultCallback_4_4(FunctionSignature function, P1 p1, P2 p2, P3 p3, P4 p4)
    : function_(function), p1_(p1), p2_(p2), p3_(p3), p4_(p4) { }

  virtual void Run(A1 a1,A2 a2,A3 a3,A4 a4) {
    if (!del) {
      (*function_)(p1_,p2_,p3_,p4_,a1,a2,a3,a4);
    } else {
      (*function_)(p1_,p2_,p3_,p4_,a1,a2,a3,a4);
      //  zero out the pointer to ensure segfault if used again
      function_ = __null;
      delete this;
    }
  }
};

template <class R, class P1, class P2, class P3, class P4, class A1, class A2, class A3, class A4>
inline typename _TessFunctionResultCallback_4_4<true,R,P1,P2,P3,P4,A1,A2,A3,A4>::base*
NewTessCallback(R (*function)(P1,P2,P3,P4,A1,A2,A3,A4), typename Identity<P1>::type p1, typename Identity<P2>::type p2, typename Identity<P3>::type p3, typename Identity<P4>::type p4) {
  return new _TessFunctionResultCallback_4_4<true,R,P1,P2,P3,P4,A1,A2,A3,A4>(function, p1, p2, p3, p4);
}

template <class R, class P1, class P2, class P3, class P4, class A1, class A2, class A3, class A4>
inline typename _TessFunctionResultCallback_4_4<false,R,P1,P2,P3,P4,A1,A2,A3,A4>::base*
NewPermanentTessCallback(R (*function)(P1,P2,P3,P4,A1,A2,A3,A4), typename Identity<P1>::type p1, typename Identity<P2>::type p2, typename Identity<P3>::type p3, typename Identity<P4>::type p4) {
  return new _TessFunctionResultCallback_4_4<false,R,P1,P2,P3,P4,A1,A2,A3,A4>(function, p1, p2, p3, p4);
}

template <bool del, class R, class T, class P1, class P2, class P3, class P4, class P5, class A1, class A2, class A3, class A4>
class _ConstTessMemberResultCallback_5_4 : public TessResultCallback4<R,A1,A2,A3,A4> {
 public:
  typedef TessResultCallback4<R,A1,A2,A3,A4> base;
  typedef R (T::*MemberSignature)(P1,P2,P3,P4,P5,A1,A2,A3,A4) const;

 private:
  const T* object_;
  MemberSignature member_;
  typename remove_reference<P1>::type p1_;
  typename remove_reference<P2>::type p2_;
  typename remove_reference<P3>::type p3_;
  typename remove_reference<P4>::type p4_;
  typename remove_reference<P5>::type p5_;

 public:
  inline _ConstTessMemberResultCallback_5_4(const T* object, MemberSignature member, P1 p1, P2 p2, P3 p3, P4 p4, P5 p5)
    : object_(object),
      member_(member), p1_(p1), p2_(p2), p3_(p3), p4_(p4), p5_(p5) { }

  virtual R Run(A1 a1,A2 a2,A3 a3,A4 a4) {
    if (!del) {
      R result = (object_->*member_)(p1_,p2_,p3_,p4_,p5_,a1,a2,a3,a4);
      return result;
    } else {
      R result = (object_->*member_)(p1_,p2_,p3_,p4_,p5_,a1,a2,a3,a4);
      //  zero out the pointer to ensure segfault if used again
      member_ = __null;
      delete this;
      return result;
    }
  }
};

template <bool del, class T, class P1, class P2, class P3, class P4, class P5, class A1, class A2, class A3, class A4>
class _ConstTessMemberResultCallback_5_4<del, void, T, P1, P2, P3, P4, P5, A1, A2, A3, A4> : public TessCallback4<A1,A2,A3,A4> {
 public:
  typedef TessCallback4<A1,A2,A3,A4> base;
  typedef void (T::*MemberSignature)(P1,P2,P3,P4,P5,A1,A2,A3,A4) const;

 private:
  const T* object_;
  MemberSignature member_;
  typename remove_reference<P1>::type p1_;
  typename remove_reference<P2>::type p2_;
  typename remove_reference<P3>::type p3_;
  typename remove_reference<P4>::type p4_;
  typename remove_reference<P5>::type p5_;

 public:
  inline _ConstTessMemberResultCallback_5_4(const T* object, MemberSignature member, P1 p1, P2 p2, P3 p3, P4 p4, P5 p5)
    : object_(object),
      member_(member), p1_(p1), p2_(p2), p3_(p3), p4_(p4), p5_(p5) { }

  virtual void Run(A1 a1,A2 a2,A3 a3,A4 a4) {
    if (!del) {
      (object_->*member_)(p1_,p2_,p3_,p4_,p5_,a1,a2,a3,a4);
    } else {
      (object_->*member_)(p1_,p2_,p3_,p4_,p5_,a1,a2,a3,a4);
      //  zero out the pointer to ensure segfault if used again
      member_ = __null;
      delete this;
    }
  }
};


template <class T1, class T2, class R, class P1, class P2, class P3, class P4, class P5, class A1, class A2, class A3, class A4>
inline typename _ConstTessMemberResultCallback_5_4<true,R,T1,P1,P2,P3,P4,P5,A1,A2,A3,A4>::base*
NewTessCallback(const T1* obj, R (T2::*member)(P1,P2,P3,P4,P5,A1,A2,A3,A4) const, typename Identity<P1>::type p1, typename Identity<P2>::type p2, typename Identity<P3>::type p3, typename Identity<P4>::type p4, typename Identity<P5>::type p5) {
  return new _ConstTessMemberResultCallback_5_4<true,R,T1,P1,P2,P3,P4,P5,A1,A2,A3,A4>(obj, member, p1, p2, p3, p4, p5);
}



template <class T1, class T2, class R, class P1, class P2, class P3, class P4, class P5, class A1, class A2, class A3, class A4>
inline typename _ConstTessMemberResultCallback_5_4<false,R,T1,P1,P2,P3,P4,P5,A1,A2,A3,A4>::base*
NewPermanentTessCallback(const T1* obj, R (T2::*member)(P1,P2,P3,P4,P5,A1,A2,A3,A4) const, typename Identity<P1>::type p1, typename Identity<P2>::type p2, typename Identity<P3>::type p3, typename Identity<P4>::type p4, typename Identity<P5>::type p5) {
  return new _ConstTessMemberResultCallback_5_4<false,R,T1,P1,P2,P3,P4,P5,A1,A2,A3,A4>(obj, member, p1, p2, p3, p4, p5);
}


template <bool del, class R, class T, class P1, class P2, class P3, class P4, class P5, class A1, class A2, class A3, class A4>
class _TessMemberResultCallback_5_4 : public TessResultCallback4<R,A1,A2,A3,A4> {
 public:
  typedef TessResultCallback4<R,A1,A2,A3,A4> base;
  typedef R (T::*MemberSignature)(P1,P2,P3,P4,P5,A1,A2,A3,A4) ;

 private:
   T* object_;
  MemberSignature member_;
  typename remove_reference<P1>::type p1_;
  typename remove_reference<P2>::type p2_;
  typename remove_reference<P3>::type p3_;
  typename remove_reference<P4>::type p4_;
  typename remove_reference<P5>::type p5_;

 public:
  inline _TessMemberResultCallback_5_4( T* object, MemberSignature member, P1 p1, P2 p2, P3 p3, P4 p4, P5 p5)
    : object_(object),
      member_(member), p1_(p1), p2_(p2), p3_(p3), p4_(p4), p5_(p5) { }

  virtual R Run(A1 a1,A2 a2,A3 a3,A4 a4) {
    if (!del) {
      R result = (object_->*member_)(p1_,p2_,p3_,p4_,p5_,a1,a2,a3,a4);
      return result;
    } else {
      R result = (object_->*member_)(p1_,p2_,p3_,p4_,p5_,a1,a2,a3,a4);
      //  zero out the pointer to ensure segfault if used again
      member_ = __null;
      delete this;
      return result;
    }
  }
};

template <bool del, class T, class P1, class P2, class P3, class P4, class P5, class A1, class A2, class A3, class A4>
class _TessMemberResultCallback_5_4<del, void, T, P1, P2, P3, P4, P5, A1, A2, A3, A4> : public TessCallback4<A1,A2,A3,A4> {
 public:
  typedef TessCallback4<A1,A2,A3,A4> base;
  typedef void (T::*MemberSignature)(P1,P2,P3,P4,P5,A1,A2,A3,A4) ;

 private:
   T* object_;
  MemberSignature member_;
  typename remove_reference<P1>::type p1_;
  typename remove_reference<P2>::type p2_;
  typename remove_reference<P3>::type p3_;
  typename remove_reference<P4>::type p4_;
  typename remove_reference<P5>::type p5_;

 public:
  inline _TessMemberResultCallback_5_4( T* object, MemberSignature member, P1 p1, P2 p2, P3 p3, P4 p4, P5 p5)
    : object_(object),
      member_(member), p1_(p1), p2_(p2), p3_(p3), p4_(p4), p5_(p5) { }

  virtual void Run(A1 a1,A2 a2,A3 a3,A4 a4) {
    if (!del) {
      (object_->*member_)(p1_,p2_,p3_,p4_,p5_,a1,a2,a3,a4);
    } else {
      (object_->*member_)(p1_,p2_,p3_,p4_,p5_,a1,a2,a3,a4);
      //  zero out the pointer to ensure segfault if used again
      member_ = __null;
      delete this;
    }
  }
};


template <class T1, class T2, class R, class P1, class P2, class P3, class P4, class P5, class A1, class A2, class A3, class A4>
inline typename _TessMemberResultCallback_5_4<true,R,T1,P1,P2,P3,P4,P5,A1,A2,A3,A4>::base*
NewTessCallback( T1* obj, R (T2::*member)(P1,P2,P3,P4,P5,A1,A2,A3,A4) , typename Identity<P1>::type p1, typename Identity<P2>::type p2, typename Identity<P3>::type p3, typename Identity<P4>::type p4, typename Identity<P5>::type p5) {
  return new _TessMemberResultCallback_5_4<true,R,T1,P1,P2,P3,P4,P5,A1,A2,A3,A4>(obj, member, p1, p2, p3, p4, p5);
}



template <class T1, class T2, class R, class P1, class P2, class P3, class P4, class P5, class A1, class A2, class A3, class A4>
inline typename _TessMemberResultCallback_5_4<false,R,T1,P1,P2,P3,P4,P5,A1,A2,A3,A4>::base*
NewPermanentTessCallback( T1* obj, R (T2::*member)(P1,P2,P3,P4,P5,A1,A2,A3,A4) , typename Identity<P1>::type p1, typename Identity<P2>::type p2, typename Identity<P3>::type p3, typename Identity<P4>::type p4, typename Identity<P5>::type p5) {
  return new _TessMemberResultCallback_5_4<false,R,T1,P1,P2,P3,P4,P5,A1,A2,A3,A4>(obj, member, p1, p2, p3, p4, p5);
}


template <bool del, class R, class P1, class P2, class P3, class P4, class P5, class A1, class A2, class A3, class A4>
class _TessFunctionResultCallback_5_4 : public TessResultCallback4<R,A1,A2,A3,A4> {
 public:
  typedef TessResultCallback4<R,A1,A2,A3,A4> base;
  typedef R (*FunctionSignature)(P1,P2,P3,P4,P5,A1,A2,A3,A4);

 private:
  FunctionSignature function_;
  typename remove_reference<P1>::type p1_;
  typename remove_reference<P2>::type p2_;
  typename remove_reference<P3>::type p3_;
  typename remove_reference<P4>::type p4_;
  typename remove_reference<P5>::type p5_;

 public:
  inline _TessFunctionResultCallback_5_4(FunctionSignature function, P1 p1, P2 p2, P3 p3, P4 p4, P5 p5)
    : function_(function), p1_(p1), p2_(p2), p3_(p3), p4_(p4), p5_(p5) { }

  virtual R Run(A1 a1,A2 a2,A3 a3,A4 a4) {
    if (!del) {
      R result = (*function_)(p1_,p2_,p3_,p4_,p5_,a1,a2,a3,a4);
      return result;
    } else {
      R result = (*function_)(p1_,p2_,p3_,p4_,p5_,a1,a2,a3,a4);
      //  zero out the pointer to ensure segfault if used again
      function_ = __null;
      delete this;
      return result;
    }
  }
};

template <bool del, class P1, class P2, class P3, class P4, class P5, class A1, class A2, class A3, class A4>
class _TessFunctionResultCallback_5_4<del, void, P1, P2, P3, P4, P5, A1, A2, A3, A4> : public TessCallback4<A1,A2,A3,A4> {
 public:
  typedef TessCallback4<A1,A2,A3,A4> base;
  typedef void (*FunctionSignature)(P1,P2,P3,P4,P5,A1,A2,A3,A4);

 private:
  FunctionSignature function_;
  typename remove_reference<P1>::type p1_;
  typename remove_reference<P2>::type p2_;
  typename remove_reference<P3>::type p3_;
  typename remove_reference<P4>::type p4_;
  typename remove_reference<P5>::type p5_;

 public:
  inline _TessFunctionResultCallback_5_4(FunctionSignature function, P1 p1, P2 p2, P3 p3, P4 p4, P5 p5)
    : function_(function), p1_(p1), p2_(p2), p3_(p3), p4_(p4), p5_(p5) { }

  virtual void Run(A1 a1,A2 a2,A3 a3,A4 a4) {
    if (!del) {
      (*function_)(p1_,p2_,p3_,p4_,p5_,a1,a2,a3,a4);
    } else {
      (*function_)(p1_,p2_,p3_,p4_,p5_,a1,a2,a3,a4);
      //  zero out the pointer to ensure segfault if used again
      function_ = __null;
      delete this;
    }
  }
};

template <class R, class P1, class P2, class P3, class P4, class P5, class A1, class A2, class A3, class A4>
inline typename _TessFunctionResultCallback_5_4<true,R,P1,P2,P3,P4,P5,A1,A2,A3,A4>::base*
NewTessCallback(R (*function)(P1,P2,P3,P4,P5,A1,A2,A3,A4), typename Identity<P1>::type p1, typename Identity<P2>::type p2, typename Identity<P3>::type p3, typename Identity<P4>::type p4, typename Identity<P5>::type p5) {
  return new _TessFunctionResultCallback_5_4<true,R,P1,P2,P3,P4,P5,A1,A2,A3,A4>(function, p1, p2, p3, p4, p5);
}

template <class R, class P1, class P2, class P3, class P4, class P5, class A1, class A2, class A3, class A4>
inline typename _TessFunctionResultCallback_5_4<false,R,P1,P2,P3,P4,P5,A1,A2,A3,A4>::base*
NewPermanentTessCallback(R (*function)(P1,P2,P3,P4,P5,A1,A2,A3,A4), typename Identity<P1>::type p1, typename Identity<P2>::type p2, typename Identity<P3>::type p3, typename Identity<P4>::type p4, typename Identity<P5>::type p5) {
  return new _TessFunctionResultCallback_5_4<false,R,P1,P2,P3,P4,P5,A1,A2,A3,A4>(function, p1, p2, p3, p4, p5);
}

template <bool del, class R, class T, class P1, class P2, class P3, class P4, class P5, class P6, class A1, class A2, class A3, class A4>
class _ConstTessMemberResultCallback_6_4 : public TessResultCallback4<R,A1,A2,A3,A4> {
 public:
  typedef TessResultCallback4<R,A1,A2,A3,A4> base;
  typedef R (T::*MemberSignature)(P1,P2,P3,P4,P5,P6,A1,A2,A3,A4) const;

 private:
  const T* object_;
  MemberSignature member_;
  typename remove_reference<P1>::type p1_;
  typename remove_reference<P2>::type p2_;
  typename remove_reference<P3>::type p3_;
  typename remove_reference<P4>::type p4_;
  typename remove_reference<P5>::type p5_;
  typename remove_reference<P6>::type p6_;

 public:
  inline _ConstTessMemberResultCallback_6_4(const T* object, MemberSignature member, P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6)
    : object_(object),
      member_(member), p1_(p1), p2_(p2), p3_(p3), p4_(p4), p5_(p5), p6_(p6) { }

  virtual R Run(A1 a1,A2 a2,A3 a3,A4 a4) {
    if (!del) {
      R result = (object_->*member_)(p1_,p2_,p3_,p4_,p5_,p6_,a1,a2,a3,a4);
      return result;
    } else {
      R result = (object_->*member_)(p1_,p2_,p3_,p4_,p5_,p6_,a1,a2,a3,a4);
      //  zero out the pointer to ensure segfault if used again
      member_ = __null;
      delete this;
      return result;
    }
  }
};

template <bool del, class T, class P1, class P2, class P3, class P4, class P5, class P6, class A1, class A2, class A3, class A4>
class _ConstTessMemberResultCallback_6_4<del, void, T, P1, P2, P3, P4, P5, P6, A1, A2, A3, A4> : public TessCallback4<A1,A2,A3,A4> {
 public:
  typedef TessCallback4<A1,A2,A3,A4> base;
  typedef void (T::*MemberSignature)(P1,P2,P3,P4,P5,P6,A1,A2,A3,A4) const;

 private:
  const T* object_;
  MemberSignature member_;
  typename remove_reference<P1>::type p1_;
  typename remove_reference<P2>::type p2_;
  typename remove_reference<P3>::type p3_;
  typename remove_reference<P4>::type p4_;
  typename remove_reference<P5>::type p5_;
  typename remove_reference<P6>::type p6_;

 public:
  inline _ConstTessMemberResultCallback_6_4(const T* object, MemberSignature member, P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6)
    : object_(object),
      member_(member), p1_(p1), p2_(p2), p3_(p3), p4_(p4), p5_(p5), p6_(p6) { }

  virtual void Run(A1 a1,A2 a2,A3 a3,A4 a4) {
    if (!del) {
      (object_->*member_)(p1_,p2_,p3_,p4_,p5_,p6_,a1,a2,a3,a4);
    } else {
      (object_->*member_)(p1_,p2_,p3_,p4_,p5_,p6_,a1,a2,a3,a4);
      //  zero out the pointer to ensure segfault if used again
      member_ = __null;
      delete this;
    }
  }
};


template <class T1, class T2, class R, class P1, class P2, class P3, class P4, class P5, class P6, class A1, class A2, class A3, class A4>
inline typename _ConstTessMemberResultCallback_6_4<true,R,T1,P1,P2,P3,P4,P5,P6,A1,A2,A3,A4>::base*
NewTessCallback(const T1* obj, R (T2::*member)(P1,P2,P3,P4,P5,P6,A1,A2,A3,A4) const, typename Identity<P1>::type p1, typename Identity<P2>::type p2, typename Identity<P3>::type p3, typename Identity<P4>::type p4, typename Identity<P5>::type p5, typename Identity<P6>::type p6) {
  return new _ConstTessMemberResultCallback_6_4<true,R,T1,P1,P2,P3,P4,P5,P6,A1,A2,A3,A4>(obj, member, p1, p2, p3, p4, p5, p6);
}



template <class T1, class T2, class R, class P1, class P2, class P3, class P4, class P5, class P6, class A1, class A2, class A3, class A4>
inline typename _ConstTessMemberResultCallback_6_4<false,R,T1,P1,P2,P3,P4,P5,P6,A1,A2,A3,A4>::base*
NewPermanentTessCallback(const T1* obj, R (T2::*member)(P1,P2,P3,P4,P5,P6,A1,A2,A3,A4) const, typename Identity<P1>::type p1, typename Identity<P2>::type p2, typename Identity<P3>::type p3, typename Identity<P4>::type p4, typename Identity<P5>::type p5, typename Identity<P6>::type p6) {
  return new _ConstTessMemberResultCallback_6_4<false,R,T1,P1,P2,P3,P4,P5,P6,A1,A2,A3,A4>(obj, member, p1, p2, p3, p4, p5, p6);
}


template <bool del, class R, class T, class P1, class P2, class P3, class P4, class P5, class P6, class A1, class A2, class A3, class A4>
class _TessMemberResultCallback_6_4 : public TessResultCallback4<R,A1,A2,A3,A4> {
 public:
  typedef TessResultCallback4<R,A1,A2,A3,A4> base;
  typedef R (T::*MemberSignature)(P1,P2,P3,P4,P5,P6,A1,A2,A3,A4) ;

 private:
   T* object_;
  MemberSignature member_;
  typename remove_reference<P1>::type p1_;
  typename remove_reference<P2>::type p2_;
  typename remove_reference<P3>::type p3_;
  typename remove_reference<P4>::type p4_;
  typename remove_reference<P5>::type p5_;
  typename remove_reference<P6>::type p6_;

 public:
  inline _TessMemberResultCallback_6_4( T* object, MemberSignature member, P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6)
    : object_(object),
      member_(member), p1_(p1), p2_(p2), p3_(p3), p4_(p4), p5_(p5), p6_(p6) { }

  virtual R Run(A1 a1,A2 a2,A3 a3,A4 a4) {
    if (!del) {
      R result = (object_->*member_)(p1_,p2_,p3_,p4_,p5_,p6_,a1,a2,a3,a4);
      return result;
    } else {
      R result = (object_->*member_)(p1_,p2_,p3_,p4_,p5_,p6_,a1,a2,a3,a4);
      //  zero out the pointer to ensure segfault if used again
      member_ = __null;
      delete this;
      return result;
    }
  }
};

template <bool del, class T, class P1, class P2, class P3, class P4, class P5, class P6, class A1, class A2, class A3, class A4>
class _TessMemberResultCallback_6_4<del, void, T, P1, P2, P3, P4, P5, P6, A1, A2, A3, A4> : public TessCallback4<A1,A2,A3,A4> {
 public:
  typedef TessCallback4<A1,A2,A3,A4> base;
  typedef void (T::*MemberSignature)(P1,P2,P3,P4,P5,P6,A1,A2,A3,A4) ;

 private:
   T* object_;
  MemberSignature member_;
  typename remove_reference<P1>::type p1_;
  typename remove_reference<P2>::type p2_;
  typename remove_reference<P3>::type p3_;
  typename remove_reference<P4>::type p4_;
  typename remove_reference<P5>::type p5_;
  typename remove_reference<P6>::type p6_;

 public:
  inline _TessMemberResultCallback_6_4( T* object, MemberSignature member, P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6)
    : object_(object),
      member_(member), p1_(p1), p2_(p2), p3_(p3), p4_(p4), p5_(p5), p6_(p6) { }

  virtual void Run(A1 a1,A2 a2,A3 a3,A4 a4) {
    if (!del) {
      (object_->*member_)(p1_,p2_,p3_,p4_,p5_,p6_,a1,a2,a3,a4);
    } else {
      (object_->*member_)(p1_,p2_,p3_,p4_,p5_,p6_,a1,a2,a3,a4);
      //  zero out the pointer to ensure segfault if used again
      member_ = __null;
      delete this;
    }
  }
};


template <class T1, class T2, class R, class P1, class P2, class P3, class P4, class P5, class P6, class A1, class A2, class A3, class A4>
inline typename _TessMemberResultCallback_6_4<true,R,T1,P1,P2,P3,P4,P5,P6,A1,A2,A3,A4>::base*
NewTessCallback( T1* obj, R (T2::*member)(P1,P2,P3,P4,P5,P6,A1,A2,A3,A4) , typename Identity<P1>::type p1, typename Identity<P2>::type p2, typename Identity<P3>::type p3, typename Identity<P4>::type p4, typename Identity<P5>::type p5, typename Identity<P6>::type p6) {
  return new _TessMemberResultCallback_6_4<true,R,T1,P1,P2,P3,P4,P5,P6,A1,A2,A3,A4>(obj, member, p1, p2, p3, p4, p5, p6);
}



template <class T1, class T2, class R, class P1, class P2, class P3, class P4, class P5, class P6, class A1, class A2, class A3, class A4>
inline typename _TessMemberResultCallback_6_4<false,R,T1,P1,P2,P3,P4,P5,P6,A1,A2,A3,A4>::base*
NewPermanentTessCallback( T1* obj, R (T2::*member)(P1,P2,P3,P4,P5,P6,A1,A2,A3,A4) , typename Identity<P1>::type p1, typename Identity<P2>::type p2, typename Identity<P3>::type p3, typename Identity<P4>::type p4, typename Identity<P5>::type p5, typename Identity<P6>::type p6) {
  return new _TessMemberResultCallback_6_4<false,R,T1,P1,P2,P3,P4,P5,P6,A1,A2,A3,A4>(obj, member, p1, p2, p3, p4, p5, p6);
}


template <bool del, class R, class P1, class P2, class P3, class P4, class P5, class P6, class A1, class A2, class A3, class A4>
class _TessFunctionResultCallback_6_4 : public TessResultCallback4<R,A1,A2,A3,A4> {
 public:
  typedef TessResultCallback4<R,A1,A2,A3,A4> base;
  typedef R (*FunctionSignature)(P1,P2,P3,P4,P5,P6,A1,A2,A3,A4);

 private:
  FunctionSignature function_;
  typename remove_reference<P1>::type p1_;
  typename remove_reference<P2>::type p2_;
  typename remove_reference<P3>::type p3_;
  typename remove_reference<P4>::type p4_;
  typename remove_reference<P5>::type p5_;
  typename remove_reference<P6>::type p6_;

 public:
  inline _TessFunctionResultCallback_6_4(FunctionSignature function, P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6)
    : function_(function), p1_(p1), p2_(p2), p3_(p3), p4_(p4), p5_(p5), p6_(p6) { }

  virtual R Run(A1 a1,A2 a2,A3 a3,A4 a4) {
    if (!del) {
      R result = (*function_)(p1_,p2_,p3_,p4_,p5_,p6_,a1,a2,a3,a4);
      return result;
    } else {
      R result = (*function_)(p1_,p2_,p3_,p4_,p5_,p6_,a1,a2,a3,a4);
      //  zero out the pointer to ensure segfault if used again
      function_ = __null;
      delete this;
      return result;
    }
  }
};

template <bool del, class P1, class P2, class P3, class P4, class P5, class P6, class A1, class A2, class A3, class A4>
class _TessFunctionResultCallback_6_4<del, void, P1, P2, P3, P4, P5, P6, A1, A2, A3, A4> : public TessCallback4<A1,A2,A3,A4> {
 public:
  typedef TessCallback4<A1,A2,A3,A4> base;
  typedef void (*FunctionSignature)(P1,P2,P3,P4,P5,P6,A1,A2,A3,A4);

 private:
  FunctionSignature function_;
  typename remove_reference<P1>::type p1_;
  typename remove_reference<P2>::type p2_;
  typename remove_reference<P3>::type p3_;
  typename remove_reference<P4>::type p4_;
  typename remove_reference<P5>::type p5_;
  typename remove_reference<P6>::type p6_;

 public:
  inline _TessFunctionResultCallback_6_4(FunctionSignature function, P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6)
    : function_(function), p1_(p1), p2_(p2), p3_(p3), p4_(p4), p5_(p5), p6_(p6) { }

  virtual void Run(A1 a1,A2 a2,A3 a3,A4 a4) {
    if (!del) {
      (*function_)(p1_,p2_,p3_,p4_,p5_,p6_,a1,a2,a3,a4);
    } else {
      (*function_)(p1_,p2_,p3_,p4_,p5_,p6_,a1,a2,a3,a4);
      //  zero out the pointer to ensure segfault if used again
      function_ = __null;
      delete this;
    }
  }
};

template <class R, class P1, class P2, class P3, class P4, class P5, class P6, class A1, class A2, class A3, class A4>
inline typename _TessFunctionResultCallback_6_4<true,R,P1,P2,P3,P4,P5,P6,A1,A2,A3,A4>::base*
NewTessCallback(R (*function)(P1,P2,P3,P4,P5,P6,A1,A2,A3,A4), typename Identity<P1>::type p1, typename Identity<P2>::type p2, typename Identity<P3>::type p3, typename Identity<P4>::type p4, typename Identity<P5>::type p5, typename Identity<P6>::type p6) {
  return new _TessFunctionResultCallback_6_4<true,R,P1,P2,P3,P4,P5,P6,A1,A2,A3,A4>(function, p1, p2, p3, p4, p5, p6);
}

template <class R, class P1, class P2, class P3, class P4, class P5, class P6, class A1, class A2, class A3, class A4>
inline typename _TessFunctionResultCallback_6_4<false,R,P1,P2,P3,P4,P5,P6,A1,A2,A3,A4>::base*
NewPermanentTessCallback(R (*function)(P1,P2,P3,P4,P5,P6,A1,A2,A3,A4), typename Identity<P1>::type p1, typename Identity<P2>::type p2, typename Identity<P3>::type p3, typename Identity<P4>::type p4, typename Identity<P5>::type p5, typename Identity<P6>::type p6) {
  return new _TessFunctionResultCallback_6_4<false,R,P1,P2,P3,P4,P5,P6,A1,A2,A3,A4>(function, p1, p2, p3, p4, p5, p6);
}

template <class A1,class A2,class A3,class A4,class A5>
class TessCallback5 {
 public:
  virtual ~TessCallback5() { }
  virtual void Run(A1,A2,A3,A4,A5) = 0;
};

template <class R, class A1,class A2,class A3,class A4,class A5>
class TessResultCallback5 {
 public:
  virtual ~TessResultCallback5() { }
  virtual R Run(A1,A2,A3,A4,A5) = 0;
};

template <bool del, class R, class T, class A1, class A2, class A3, class A4, class A5>
class _ConstTessMemberResultCallback_0_5 : public TessResultCallback5<R,A1,A2,A3,A4,A5> {
 public:
  typedef TessResultCallback5<R,A1,A2,A3,A4,A5> base;
  typedef R (T::*MemberSignature)(A1,A2,A3,A4,A5) const;

 private:
  const T* object_;
  MemberSignature member_;

 public:
  inline _ConstTessMemberResultCallback_0_5(const T* object, MemberSignature member)
    : object_(object),
      member_(member) { }

  virtual R Run(A1 a1,A2 a2,A3 a3,A4 a4,A5 a5) {
    if (!del) {
      R result = (object_->*member_)(a1,a2,a3,a4,a5);
      return result;
    } else {
      R result = (object_->*member_)(a1,a2,a3,a4,a5);
      //  zero out the pointer to ensure segfault if used again
      member_ = __null;
      delete this;
      return result;
    }
  }
};

template <bool del, class T, class A1, class A2, class A3, class A4, class A5>
class _ConstTessMemberResultCallback_0_5<del, void, T, A1, A2, A3, A4, A5> : public TessCallback5<A1,A2,A3,A4,A5> {
 public:
  typedef TessCallback5<A1,A2,A3,A4,A5> base;
  typedef void (T::*MemberSignature)(A1,A2,A3,A4,A5) const;

 private:
  const T* object_;
  MemberSignature member_;

 public:
  inline _ConstTessMemberResultCallback_0_5(const T* object, MemberSignature member)
    : object_(object),
      member_(member) { }

  virtual void Run(A1 a1,A2 a2,A3 a3,A4 a4,A5 a5) {
    if (!del) {
      (object_->*member_)(a1,a2,a3,a4,a5);
    } else {
      (object_->*member_)(a1,a2,a3,a4,a5);
      //  zero out the pointer to ensure segfault if used again
      member_ = __null;
      delete this;
    }
  }
};


template <class T1, class T2, class R, class A1, class A2, class A3, class A4, class A5>
inline typename _ConstTessMemberResultCallback_0_5<true,R,T1,A1,A2,A3,A4,A5>::base*
NewTessCallback(const T1* obj, R (T2::*member)(A1,A2,A3,A4,A5) const) {
  return new _ConstTessMemberResultCallback_0_5<true,R,T1,A1,A2,A3,A4,A5>(obj, member);
}



template <class T1, class T2, class R, class A1, class A2, class A3, class A4, class A5>
inline typename _ConstTessMemberResultCallback_0_5<false,R,T1,A1,A2,A3,A4,A5>::base*
NewPermanentTessCallback(const T1* obj, R (T2::*member)(A1,A2,A3,A4,A5) const) {
  return new _ConstTessMemberResultCallback_0_5<false,R,T1,A1,A2,A3,A4,A5>(obj, member);
}


template <bool del, class R, class T, class A1, class A2, class A3, class A4, class A5>
class _TessMemberResultCallback_0_5 : public TessResultCallback5<R,A1,A2,A3,A4,A5> {
 public:
  typedef TessResultCallback5<R,A1,A2,A3,A4,A5> base;
  typedef R (T::*MemberSignature)(A1,A2,A3,A4,A5) ;

 private:
   T* object_;
  MemberSignature member_;

 public:
  inline _TessMemberResultCallback_0_5( T* object, MemberSignature member)
    : object_(object),
      member_(member) { }

  virtual R Run(A1 a1,A2 a2,A3 a3,A4 a4,A5 a5) {
    if (!del) {
      R result = (object_->*member_)(a1,a2,a3,a4,a5);
      return result;
    } else {
      R result = (object_->*member_)(a1,a2,a3,a4,a5);
      //  zero out the pointer to ensure segfault if used again
      member_ = __null;
      delete this;
      return result;
    }
  }
};

template <bool del, class T, class A1, class A2, class A3, class A4, class A5>
class _TessMemberResultCallback_0_5<del, void, T, A1, A2, A3, A4, A5> : public TessCallback5<A1,A2,A3,A4,A5> {
 public:
  typedef TessCallback5<A1,A2,A3,A4,A5> base;
  typedef void (T::*MemberSignature)(A1,A2,A3,A4,A5) ;

 private:
   T* object_;
  MemberSignature member_;

 public:
  inline _TessMemberResultCallback_0_5( T* object, MemberSignature member)
    : object_(object),
      member_(member) { }

  virtual void Run(A1 a1,A2 a2,A3 a3,A4 a4,A5 a5) {
    if (!del) {
      (object_->*member_)(a1,a2,a3,a4,a5);
    } else {
      (object_->*member_)(a1,a2,a3,a4,a5);
      //  zero out the pointer to ensure segfault if used again
      member_ = __null;
      delete this;
    }
  }
};


template <class T1, class T2, class R, class A1, class A2, class A3, class A4, class A5>
inline typename _TessMemberResultCallback_0_5<true,R,T1,A1,A2,A3,A4,A5>::base*
NewTessCallback( T1* obj, R (T2::*member)(A1,A2,A3,A4,A5) ) {
  return new _TessMemberResultCallback_0_5<true,R,T1,A1,A2,A3,A4,A5>(obj, member);
}



template <class T1, class T2, class R, class A1, class A2, class A3, class A4, class A5>
inline typename _TessMemberResultCallback_0_5<false,R,T1,A1,A2,A3,A4,A5>::base*
NewPermanentTessCallback( T1* obj, R (T2::*member)(A1,A2,A3,A4,A5) ) {
  return new _TessMemberResultCallback_0_5<false,R,T1,A1,A2,A3,A4,A5>(obj, member);
}


template <bool del, class R, class A1, class A2, class A3, class A4, class A5>
class _TessFunctionResultCallback_0_5 : public TessResultCallback5<R,A1,A2,A3,A4,A5> {
 public:
  typedef TessResultCallback5<R,A1,A2,A3,A4,A5> base;
  typedef R (*FunctionSignature)(A1,A2,A3,A4,A5);

 private:
  FunctionSignature function_;

 public:
  inline _TessFunctionResultCallback_0_5(FunctionSignature function)
    : function_(function) { }

  virtual R Run(A1 a1,A2 a2,A3 a3,A4 a4,A5 a5) {
    if (!del) {
      R result = (*function_)(a1,a2,a3,a4,a5);
      return result;
    } else {
      R result = (*function_)(a1,a2,a3,a4,a5);
      //  zero out the pointer to ensure segfault if used again
      function_ = __null;
      delete this;
      return result;
    }
  }
};

template <bool del, class A1, class A2, class A3, class A4, class A5>
class _TessFunctionResultCallback_0_5<del, void, A1, A2, A3, A4, A5> : public TessCallback5<A1,A2,A3,A4,A5> {
 public:
  typedef TessCallback5<A1,A2,A3,A4,A5> base;
  typedef void (*FunctionSignature)(A1,A2,A3,A4,A5);

 private:
  FunctionSignature function_;

 public:
  inline _TessFunctionResultCallback_0_5(FunctionSignature function)
    : function_(function) { }

  virtual void Run(A1 a1,A2 a2,A3 a3,A4 a4,A5 a5) {
    if (!del) {
      (*function_)(a1,a2,a3,a4,a5);
    } else {
      (*function_)(a1,a2,a3,a4,a5);
      //  zero out the pointer to ensure segfault if used again
      function_ = __null;
      delete this;
    }
  }
};

template <class R, class A1, class A2, class A3, class A4, class A5>
inline typename _TessFunctionResultCallback_0_5<true,R,A1,A2,A3,A4,A5>::base*
NewTessCallback(R (*function)(A1,A2,A3,A4,A5)) {
  return new _TessFunctionResultCallback_0_5<true,R,A1,A2,A3,A4,A5>(function);
}

template <class R, class A1, class A2, class A3, class A4, class A5>
inline typename _TessFunctionResultCallback_0_5<false,R,A1,A2,A3,A4,A5>::base*
NewPermanentTessCallback(R (*function)(A1,A2,A3,A4,A5)) {
  return new _TessFunctionResultCallback_0_5<false,R,A1,A2,A3,A4,A5>(function);
}

template <bool del, class R, class T, class P1, class A1, class A2, class A3, class A4, class A5>
class _ConstTessMemberResultCallback_1_5 : public TessResultCallback5<R,A1,A2,A3,A4,A5> {
 public:
  typedef TessResultCallback5<R,A1,A2,A3,A4,A5> base;
  typedef R (T::*MemberSignature)(P1,A1,A2,A3,A4,A5) const;

 private:
  const T* object_;
  MemberSignature member_;
  typename remove_reference<P1>::type p1_;

 public:
  inline _ConstTessMemberResultCallback_1_5(const T* object, MemberSignature member, P1 p1)
    : object_(object),
      member_(member), p1_(p1) { }

  virtual R Run(A1 a1,A2 a2,A3 a3,A4 a4,A5 a5) {
    if (!del) {
      R result = (object_->*member_)(p1_,a1,a2,a3,a4,a5);
      return result;
    } else {
      R result = (object_->*member_)(p1_,a1,a2,a3,a4,a5);
      //  zero out the pointer to ensure segfault if used again
      member_ = __null;
      delete this;
      return result;
    }
  }
};

template <bool del, class T, class P1, class A1, class A2, class A3, class A4, class A5>
class _ConstTessMemberResultCallback_1_5<del, void, T, P1, A1, A2, A3, A4, A5> : public TessCallback5<A1,A2,A3,A4,A5> {
 public:
  typedef TessCallback5<A1,A2,A3,A4,A5> base;
  typedef void (T::*MemberSignature)(P1,A1,A2,A3,A4,A5) const;

 private:
  const T* object_;
  MemberSignature member_;
  typename remove_reference<P1>::type p1_;

 public:
  inline _ConstTessMemberResultCallback_1_5(const T* object, MemberSignature member, P1 p1)
    : object_(object),
      member_(member), p1_(p1) { }

  virtual void Run(A1 a1,A2 a2,A3 a3,A4 a4,A5 a5) {
    if (!del) {
      (object_->*member_)(p1_,a1,a2,a3,a4,a5);
    } else {
      (object_->*member_)(p1_,a1,a2,a3,a4,a5);
      //  zero out the pointer to ensure segfault if used again
      member_ = __null;
      delete this;
    }
  }
};


template <class T1, class T2, class R, class P1, class A1, class A2, class A3, class A4, class A5>
inline typename _ConstTessMemberResultCallback_1_5<true,R,T1,P1,A1,A2,A3,A4,A5>::base*
NewTessCallback(const T1* obj, R (T2::*member)(P1,A1,A2,A3,A4,A5) const, typename Identity<P1>::type p1) {
  return new _ConstTessMemberResultCallback_1_5<true,R,T1,P1,A1,A2,A3,A4,A5>(obj, member, p1);
}



template <class T1, class T2, class R, class P1, class A1, class A2, class A3, class A4, class A5>
inline typename _ConstTessMemberResultCallback_1_5<false,R,T1,P1,A1,A2,A3,A4,A5>::base*
NewPermanentTessCallback(const T1* obj, R (T2::*member)(P1,A1,A2,A3,A4,A5) const, typename Identity<P1>::type p1) {
  return new _ConstTessMemberResultCallback_1_5<false,R,T1,P1,A1,A2,A3,A4,A5>(obj, member, p1);
}


template <bool del, class R, class T, class P1, class A1, class A2, class A3, class A4, class A5>
class _TessMemberResultCallback_1_5 : public TessResultCallback5<R,A1,A2,A3,A4,A5> {
 public:
  typedef TessResultCallback5<R,A1,A2,A3,A4,A5> base;
  typedef R (T::*MemberSignature)(P1,A1,A2,A3,A4,A5) ;

 private:
   T* object_;
  MemberSignature member_;
  typename remove_reference<P1>::type p1_;

 public:
  inline _TessMemberResultCallback_1_5( T* object, MemberSignature member, P1 p1)
    : object_(object),
      member_(member), p1_(p1) { }

  virtual R Run(A1 a1,A2 a2,A3 a3,A4 a4,A5 a5) {
    if (!del) {
      R result = (object_->*member_)(p1_,a1,a2,a3,a4,a5);
      return result;
    } else {
      R result = (object_->*member_)(p1_,a1,a2,a3,a4,a5);
      //  zero out the pointer to ensure segfault if used again
      member_ = __null;
      delete this;
      return result;
    }
  }
};

template <bool del, class T, class P1, class A1, class A2, class A3, class A4, class A5>
class _TessMemberResultCallback_1_5<del, void, T, P1, A1, A2, A3, A4, A5> : public TessCallback5<A1,A2,A3,A4,A5> {
 public:
  typedef TessCallback5<A1,A2,A3,A4,A5> base;
  typedef void (T::*MemberSignature)(P1,A1,A2,A3,A4,A5) ;

 private:
   T* object_;
  MemberSignature member_;
  typename remove_reference<P1>::type p1_;

 public:
  inline _TessMemberResultCallback_1_5( T* object, MemberSignature member, P1 p1)
    : object_(object),
      member_(member), p1_(p1) { }

  virtual void Run(A1 a1,A2 a2,A3 a3,A4 a4,A5 a5) {
    if (!del) {
      (object_->*member_)(p1_,a1,a2,a3,a4,a5);
    } else {
      (object_->*member_)(p1_,a1,a2,a3,a4,a5);
      //  zero out the pointer to ensure segfault if used again
      member_ = __null;
      delete this;
    }
  }
};


template <class T1, class T2, class R, class P1, class A1, class A2, class A3, class A4, class A5>
inline typename _TessMemberResultCallback_1_5<true,R,T1,P1,A1,A2,A3,A4,A5>::base*
NewTessCallback( T1* obj, R (T2::*member)(P1,A1,A2,A3,A4,A5) , typename Identity<P1>::type p1) {
  return new _TessMemberResultCallback_1_5<true,R,T1,P1,A1,A2,A3,A4,A5>(obj, member, p1);
}



template <class T1, class T2, class R, class P1, class A1, class A2, class A3, class A4, class A5>
inline typename _TessMemberResultCallback_1_5<false,R,T1,P1,A1,A2,A3,A4,A5>::base*
NewPermanentTessCallback( T1* obj, R (T2::*member)(P1,A1,A2,A3,A4,A5) , typename Identity<P1>::type p1) {
  return new _TessMemberResultCallback_1_5<false,R,T1,P1,A1,A2,A3,A4,A5>(obj, member, p1);
}


template <bool del, class R, class P1, class A1, class A2, class A3, class A4, class A5>
class _TessFunctionResultCallback_1_5 : public TessResultCallback5<R,A1,A2,A3,A4,A5> {
 public:
  typedef TessResultCallback5<R,A1,A2,A3,A4,A5> base;
  typedef R (*FunctionSignature)(P1,A1,A2,A3,A4,A5);

 private:
  FunctionSignature function_;
  typename remove_reference<P1>::type p1_;

 public:
  inline _TessFunctionResultCallback_1_5(FunctionSignature function, P1 p1)
    : function_(function), p1_(p1) { }

  virtual R Run(A1 a1,A2 a2,A3 a3,A4 a4,A5 a5) {
    if (!del) {
      R result = (*function_)(p1_,a1,a2,a3,a4,a5);
      return result;
    } else {
      R result = (*function_)(p1_,a1,a2,a3,a4,a5);
      //  zero out the pointer to ensure segfault if used again
      function_ = __null;
      delete this;
      return result;
    }
  }
};

template <bool del, class P1, class A1, class A2, class A3, class A4, class A5>
class _TessFunctionResultCallback_1_5<del, void, P1, A1, A2, A3, A4, A5> : public TessCallback5<A1,A2,A3,A4,A5> {
 public:
  typedef TessCallback5<A1,A2,A3,A4,A5> base;
  typedef void (*FunctionSignature)(P1,A1,A2,A3,A4,A5);

 private:
  FunctionSignature function_;
  typename remove_reference<P1>::type p1_;

 public:
  inline _TessFunctionResultCallback_1_5(FunctionSignature function, P1 p1)
    : function_(function), p1_(p1) { }

  virtual void Run(A1 a1,A2 a2,A3 a3,A4 a4,A5 a5) {
    if (!del) {
      (*function_)(p1_,a1,a2,a3,a4,a5);
    } else {
      (*function_)(p1_,a1,a2,a3,a4,a5);
      //  zero out the pointer to ensure segfault if used again
      function_ = __null;
      delete this;
    }
  }
};

template <class R, class P1, class A1, class A2, class A3, class A4, class A5>
inline typename _TessFunctionResultCallback_1_5<true,R,P1,A1,A2,A3,A4,A5>::base*
NewTessCallback(R (*function)(P1,A1,A2,A3,A4,A5), typename Identity<P1>::type p1) {
  return new _TessFunctionResultCallback_1_5<true,R,P1,A1,A2,A3,A4,A5>(function, p1);
}

template <class R, class P1, class A1, class A2, class A3, class A4, class A5>
inline typename _TessFunctionResultCallback_1_5<false,R,P1,A1,A2,A3,A4,A5>::base*
NewPermanentTessCallback(R (*function)(P1,A1,A2,A3,A4,A5), typename Identity<P1>::type p1) {
  return new _TessFunctionResultCallback_1_5<false,R,P1,A1,A2,A3,A4,A5>(function, p1);
}

template <bool del, class R, class T, class P1, class P2, class A1, class A2, class A3, class A4, class A5>
class _ConstTessMemberResultCallback_2_5 : public TessResultCallback5<R,A1,A2,A3,A4,A5> {
 public:
  typedef TessResultCallback5<R,A1,A2,A3,A4,A5> base;
  typedef R (T::*MemberSignature)(P1,P2,A1,A2,A3,A4,A5) const;

 private:
  const T* object_;
  MemberSignature member_;
  typename remove_reference<P1>::type p1_;
  typename remove_reference<P2>::type p2_;

 public:
  inline _ConstTessMemberResultCallback_2_5(const T* object, MemberSignature member, P1 p1, P2 p2)
    : object_(object),
      member_(member), p1_(p1), p2_(p2) { }

  virtual R Run(A1 a1,A2 a2,A3 a3,A4 a4,A5 a5) {
    if (!del) {
      R result = (object_->*member_)(p1_,p2_,a1,a2,a3,a4,a5);
      return result;
    } else {
      R result = (object_->*member_)(p1_,p2_,a1,a2,a3,a4,a5);
      //  zero out the pointer to ensure segfault if used again
      member_ = __null;
      delete this;
      return result;
    }
  }
};

template <bool del, class T, class P1, class P2, class A1, class A2, class A3, class A4, class A5>
class _ConstTessMemberResultCallback_2_5<del, void, T, P1, P2, A1, A2, A3, A4, A5> : public TessCallback5<A1,A2,A3,A4,A5> {
 public:
  typedef TessCallback5<A1,A2,A3,A4,A5> base;
  typedef void (T::*MemberSignature)(P1,P2,A1,A2,A3,A4,A5) const;

 private:
  const T* object_;
  MemberSignature member_;
  typename remove_reference<P1>::type p1_;
  typename remove_reference<P2>::type p2_;

 public:
  inline _ConstTessMemberResultCallback_2_5(const T* object, MemberSignature member, P1 p1, P2 p2)
    : object_(object),
      member_(member), p1_(p1), p2_(p2) { }

  virtual void Run(A1 a1,A2 a2,A3 a3,A4 a4,A5 a5) {
    if (!del) {
      (object_->*member_)(p1_,p2_,a1,a2,a3,a4,a5);
    } else {
      (object_->*member_)(p1_,p2_,a1,a2,a3,a4,a5);
      //  zero out the pointer to ensure segfault if used again
      member_ = __null;
      delete this;
    }
  }
};


template <class T1, class T2, class R, class P1, class P2, class A1, class A2, class A3, class A4, class A5>
inline typename _ConstTessMemberResultCallback_2_5<true,R,T1,P1,P2,A1,A2,A3,A4,A5>::base*
NewTessCallback(const T1* obj, R (T2::*member)(P1,P2,A1,A2,A3,A4,A5) const, typename Identity<P1>::type p1, typename Identity<P2>::type p2) {
  return new _ConstTessMemberResultCallback_2_5<true,R,T1,P1,P2,A1,A2,A3,A4,A5>(obj, member, p1, p2);
}



template <class T1, class T2, class R, class P1, class P2, class A1, class A2, class A3, class A4, class A5>
inline typename _ConstTessMemberResultCallback_2_5<false,R,T1,P1,P2,A1,A2,A3,A4,A5>::base*
NewPermanentTessCallback(const T1* obj, R (T2::*member)(P1,P2,A1,A2,A3,A4,A5) const, typename Identity<P1>::type p1, typename Identity<P2>::type p2) {
  return new _ConstTessMemberResultCallback_2_5<false,R,T1,P1,P2,A1,A2,A3,A4,A5>(obj, member, p1, p2);
}


template <bool del, class R, class T, class P1, class P2, class A1, class A2, class A3, class A4, class A5>
class _TessMemberResultCallback_2_5 : public TessResultCallback5<R,A1,A2,A3,A4,A5> {
 public:
  typedef TessResultCallback5<R,A1,A2,A3,A4,A5> base;
  typedef R (T::*MemberSignature)(P1,P2,A1,A2,A3,A4,A5) ;

 private:
   T* object_;
  MemberSignature member_;
  typename remove_reference<P1>::type p1_;
  typename remove_reference<P2>::type p2_;

 public:
  inline _TessMemberResultCallback_2_5( T* object, MemberSignature member, P1 p1, P2 p2)
    : object_(object),
      member_(member), p1_(p1), p2_(p2) { }

  virtual R Run(A1 a1,A2 a2,A3 a3,A4 a4,A5 a5) {
    if (!del) {
      R result = (object_->*member_)(p1_,p2_,a1,a2,a3,a4,a5);
      return result;
    } else {
      R result = (object_->*member_)(p1_,p2_,a1,a2,a3,a4,a5);
      //  zero out the pointer to ensure segfault if used again
      member_ = __null;
      delete this;
      return result;
    }
  }
};

template <bool del, class T, class P1, class P2, class A1, class A2, class A3, class A4, class A5>
class _TessMemberResultCallback_2_5<del, void, T, P1, P2, A1, A2, A3, A4, A5> : public TessCallback5<A1,A2,A3,A4,A5> {
 public:
  typedef TessCallback5<A1,A2,A3,A4,A5> base;
  typedef void (T::*MemberSignature)(P1,P2,A1,A2,A3,A4,A5) ;

 private:
   T* object_;
  MemberSignature member_;
  typename remove_reference<P1>::type p1_;
  typename remove_reference<P2>::type p2_;

 public:
  inline _TessMemberResultCallback_2_5( T* object, MemberSignature member, P1 p1, P2 p2)
    : object_(object),
      member_(member), p1_(p1), p2_(p2) { }

  virtual void Run(A1 a1,A2 a2,A3 a3,A4 a4,A5 a5) {
    if (!del) {
      (object_->*member_)(p1_,p2_,a1,a2,a3,a4,a5);
    } else {
      (object_->*member_)(p1_,p2_,a1,a2,a3,a4,a5);
      //  zero out the pointer to ensure segfault if used again
      member_ = __null;
      delete this;
    }
  }
};


template <class T1, class T2, class R, class P1, class P2, class A1, class A2, class A3, class A4, class A5>
inline typename _TessMemberResultCallback_2_5<true,R,T1,P1,P2,A1,A2,A3,A4,A5>::base*
NewTessCallback( T1* obj, R (T2::*member)(P1,P2,A1,A2,A3,A4,A5) , typename Identity<P1>::type p1, typename Identity<P2>::type p2) {
  return new _TessMemberResultCallback_2_5<true,R,T1,P1,P2,A1,A2,A3,A4,A5>(obj, member, p1, p2);
}



template <class T1, class T2, class R, class P1, class P2, class A1, class A2, class A3, class A4, class A5>
inline typename _TessMemberResultCallback_2_5<false,R,T1,P1,P2,A1,A2,A3,A4,A5>::base*
NewPermanentTessCallback( T1* obj, R (T2::*member)(P1,P2,A1,A2,A3,A4,A5) , typename Identity<P1>::type p1, typename Identity<P2>::type p2) {
  return new _TessMemberResultCallback_2_5<false,R,T1,P1,P2,A1,A2,A3,A4,A5>(obj, member, p1, p2);
}


template <bool del, class R, class P1, class P2, class A1, class A2, class A3, class A4, class A5>
class _TessFunctionResultCallback_2_5 : public TessResultCallback5<R,A1,A2,A3,A4,A5> {
 public:
  typedef TessResultCallback5<R,A1,A2,A3,A4,A5> base;
  typedef R (*FunctionSignature)(P1,P2,A1,A2,A3,A4,A5);

 private:
  FunctionSignature function_;
  typename remove_reference<P1>::type p1_;
  typename remove_reference<P2>::type p2_;

 public:
  inline _TessFunctionResultCallback_2_5(FunctionSignature function, P1 p1, P2 p2)
    : function_(function), p1_(p1), p2_(p2) { }

  virtual R Run(A1 a1,A2 a2,A3 a3,A4 a4,A5 a5) {
    if (!del) {
      R result = (*function_)(p1_,p2_,a1,a2,a3,a4,a5);
      return result;
    } else {
      R result = (*function_)(p1_,p2_,a1,a2,a3,a4,a5);
      //  zero out the pointer to ensure segfault if used again
      function_ = __null;
      delete this;
      return result;
    }
  }
};

template <bool del, class P1, class P2, class A1, class A2, class A3, class A4, class A5>
class _TessFunctionResultCallback_2_5<del, void, P1, P2, A1, A2, A3, A4, A5> : public TessCallback5<A1,A2,A3,A4,A5> {
 public:
  typedef TessCallback5<A1,A2,A3,A4,A5> base;
  typedef void (*FunctionSignature)(P1,P2,A1,A2,A3,A4,A5);

 private:
  FunctionSignature function_;
  typename remove_reference<P1>::type p1_;
  typename remove_reference<P2>::type p2_;

 public:
  inline _TessFunctionResultCallback_2_5(FunctionSignature function, P1 p1, P2 p2)
    : function_(function), p1_(p1), p2_(p2) { }

  virtual void Run(A1 a1,A2 a2,A3 a3,A4 a4,A5 a5) {
    if (!del) {
      (*function_)(p1_,p2_,a1,a2,a3,a4,a5);
    } else {
      (*function_)(p1_,p2_,a1,a2,a3,a4,a5);
      //  zero out the pointer to ensure segfault if used again
      function_ = __null;
      delete this;
    }
  }
};

template <class R, class P1, class P2, class A1, class A2, class A3, class A4, class A5>
inline typename _TessFunctionResultCallback_2_5<true,R,P1,P2,A1,A2,A3,A4,A5>::base*
NewTessCallback(R (*function)(P1,P2,A1,A2,A3,A4,A5), typename Identity<P1>::type p1, typename Identity<P2>::type p2) {
  return new _TessFunctionResultCallback_2_5<true,R,P1,P2,A1,A2,A3,A4,A5>(function, p1, p2);
}

template <class R, class P1, class P2, class A1, class A2, class A3, class A4, class A5>
inline typename _TessFunctionResultCallback_2_5<false,R,P1,P2,A1,A2,A3,A4,A5>::base*
NewPermanentTessCallback(R (*function)(P1,P2,A1,A2,A3,A4,A5), typename Identity<P1>::type p1, typename Identity<P2>::type p2) {
  return new _TessFunctionResultCallback_2_5<false,R,P1,P2,A1,A2,A3,A4,A5>(function, p1, p2);
}

template <bool del, class R, class T, class P1, class P2, class P3, class A1, class A2, class A3, class A4, class A5>
class _ConstTessMemberResultCallback_3_5 : public TessResultCallback5<R,A1,A2,A3,A4,A5> {
 public:
  typedef TessResultCallback5<R,A1,A2,A3,A4,A5> base;
  typedef R (T::*MemberSignature)(P1,P2,P3,A1,A2,A3,A4,A5) const;

 private:
  const T* object_;
  MemberSignature member_;
  typename remove_reference<P1>::type p1_;
  typename remove_reference<P2>::type p2_;
  typename remove_reference<P3>::type p3_;

 public:
  inline _ConstTessMemberResultCallback_3_5(const T* object, MemberSignature member, P1 p1, P2 p2, P3 p3)
    : object_(object),
      member_(member), p1_(p1), p2_(p2), p3_(p3) { }

  virtual R Run(A1 a1,A2 a2,A3 a3,A4 a4,A5 a5) {
    if (!del) {
      R result = (object_->*member_)(p1_,p2_,p3_,a1,a2,a3,a4,a5);
      return result;
    } else {
      R result = (object_->*member_)(p1_,p2_,p3_,a1,a2,a3,a4,a5);
      //  zero out the pointer to ensure segfault if used again
      member_ = __null;
      delete this;
      return result;
    }
  }
};

template <bool del, class T, class P1, class P2, class P3, class A1, class A2, class A3, class A4, class A5>
class _ConstTessMemberResultCallback_3_5<del, void, T, P1, P2, P3, A1, A2, A3, A4, A5> : public TessCallback5<A1,A2,A3,A4,A5> {
 public:
  typedef TessCallback5<A1,A2,A3,A4,A5> base;
  typedef void (T::*MemberSignature)(P1,P2,P3,A1,A2,A3,A4,A5) const;

 private:
  const T* object_;
  MemberSignature member_;
  typename remove_reference<P1>::type p1_;
  typename remove_reference<P2>::type p2_;
  typename remove_reference<P3>::type p3_;

 public:
  inline _ConstTessMemberResultCallback_3_5(const T* object, MemberSignature member, P1 p1, P2 p2, P3 p3)
    : object_(object),
      member_(member), p1_(p1), p2_(p2), p3_(p3) { }

  virtual void Run(A1 a1,A2 a2,A3 a3,A4 a4,A5 a5) {
    if (!del) {
      (object_->*member_)(p1_,p2_,p3_,a1,a2,a3,a4,a5);
    } else {
      (object_->*member_)(p1_,p2_,p3_,a1,a2,a3,a4,a5);
      //  zero out the pointer to ensure segfault if used again
      member_ = __null;
      delete this;
    }
  }
};


template <class T1, class T2, class R, class P1, class P2, class P3, class A1, class A2, class A3, class A4, class A5>
inline typename _ConstTessMemberResultCallback_3_5<true,R,T1,P1,P2,P3,A1,A2,A3,A4,A5>::base*
NewTessCallback(const T1* obj, R (T2::*member)(P1,P2,P3,A1,A2,A3,A4,A5) const, typename Identity<P1>::type p1, typename Identity<P2>::type p2, typename Identity<P3>::type p3) {
  return new _ConstTessMemberResultCallback_3_5<true,R,T1,P1,P2,P3,A1,A2,A3,A4,A5>(obj, member, p1, p2, p3);
}



template <class T1, class T2, class R, class P1, class P2, class P3, class A1, class A2, class A3, class A4, class A5>
inline typename _ConstTessMemberResultCallback_3_5<false,R,T1,P1,P2,P3,A1,A2,A3,A4,A5>::base*
NewPermanentTessCallback(const T1* obj, R (T2::*member)(P1,P2,P3,A1,A2,A3,A4,A5) const, typename Identity<P1>::type p1, typename Identity<P2>::type p2, typename Identity<P3>::type p3) {
  return new _ConstTessMemberResultCallback_3_5<false,R,T1,P1,P2,P3,A1,A2,A3,A4,A5>(obj, member, p1, p2, p3);
}


template <bool del, class R, class T, class P1, class P2, class P3, class A1, class A2, class A3, class A4, class A5>
class _TessMemberResultCallback_3_5 : public TessResultCallback5<R,A1,A2,A3,A4,A5> {
 public:
  typedef TessResultCallback5<R,A1,A2,A3,A4,A5> base;
  typedef R (T::*MemberSignature)(P1,P2,P3,A1,A2,A3,A4,A5) ;

 private:
   T* object_;
  MemberSignature member_;
  typename remove_reference<P1>::type p1_;
  typename remove_reference<P2>::type p2_;
  typename remove_reference<P3>::type p3_;

 public:
  inline _TessMemberResultCallback_3_5( T* object, MemberSignature member, P1 p1, P2 p2, P3 p3)
    : object_(object),
      member_(member), p1_(p1), p2_(p2), p3_(p3) { }

  virtual R Run(A1 a1,A2 a2,A3 a3,A4 a4,A5 a5) {
    if (!del) {
      R result = (object_->*member_)(p1_,p2_,p3_,a1,a2,a3,a4,a5);
      return result;
    } else {
      R result = (object_->*member_)(p1_,p2_,p3_,a1,a2,a3,a4,a5);
      //  zero out the pointer to ensure segfault if used again
      member_ = __null;
      delete this;
      return result;
    }
  }
};

template <bool del, class T, class P1, class P2, class P3, class A1, class A2, class A3, class A4, class A5>
class _TessMemberResultCallback_3_5<del, void, T, P1, P2, P3, A1, A2, A3, A4, A5> : public TessCallback5<A1,A2,A3,A4,A5> {
 public:
  typedef TessCallback5<A1,A2,A3,A4,A5> base;
  typedef void (T::*MemberSignature)(P1,P2,P3,A1,A2,A3,A4,A5) ;

 private:
   T* object_;
  MemberSignature member_;
  typename remove_reference<P1>::type p1_;
  typename remove_reference<P2>::type p2_;
  typename remove_reference<P3>::type p3_;

 public:
  inline _TessMemberResultCallback_3_5( T* object, MemberSignature member, P1 p1, P2 p2, P3 p3)
    : object_(object),
      member_(member), p1_(p1), p2_(p2), p3_(p3) { }

  virtual void Run(A1 a1,A2 a2,A3 a3,A4 a4,A5 a5) {
    if (!del) {
      (object_->*member_)(p1_,p2_,p3_,a1,a2,a3,a4,a5);
    } else {
      (object_->*member_)(p1_,p2_,p3_,a1,a2,a3,a4,a5);
      //  zero out the pointer to ensure segfault if used again
      member_ = __null;
      delete this;
    }
  }
};


template <class T1, class T2, class R, class P1, class P2, class P3, class A1, class A2, class A3, class A4, class A5>
inline typename _TessMemberResultCallback_3_5<true,R,T1,P1,P2,P3,A1,A2,A3,A4,A5>::base*
NewTessCallback( T1* obj, R (T2::*member)(P1,P2,P3,A1,A2,A3,A4,A5) , typename Identity<P1>::type p1, typename Identity<P2>::type p2, typename Identity<P3>::type p3) {
  return new _TessMemberResultCallback_3_5<true,R,T1,P1,P2,P3,A1,A2,A3,A4,A5>(obj, member, p1, p2, p3);
}



template <class T1, class T2, class R, class P1, class P2, class P3, class A1, class A2, class A3, class A4, class A5>
inline typename _TessMemberResultCallback_3_5<false,R,T1,P1,P2,P3,A1,A2,A3,A4,A5>::base*
NewPermanentTessCallback( T1* obj, R (T2::*member)(P1,P2,P3,A1,A2,A3,A4,A5) , typename Identity<P1>::type p1, typename Identity<P2>::type p2, typename Identity<P3>::type p3) {
  return new _TessMemberResultCallback_3_5<false,R,T1,P1,P2,P3,A1,A2,A3,A4,A5>(obj, member, p1, p2, p3);
}


template <bool del, class R, class P1, class P2, class P3, class A1, class A2, class A3, class A4, class A5>
class _TessFunctionResultCallback_3_5 : public TessResultCallback5<R,A1,A2,A3,A4,A5> {
 public:
  typedef TessResultCallback5<R,A1,A2,A3,A4,A5> base;
  typedef R (*FunctionSignature)(P1,P2,P3,A1,A2,A3,A4,A5);

 private:
  FunctionSignature function_;
  typename remove_reference<P1>::type p1_;
  typename remove_reference<P2>::type p2_;
  typename remove_reference<P3>::type p3_;

 public:
  inline _TessFunctionResultCallback_3_5(FunctionSignature function, P1 p1, P2 p2, P3 p3)
    : function_(function), p1_(p1), p2_(p2), p3_(p3) { }

  virtual R Run(A1 a1,A2 a2,A3 a3,A4 a4,A5 a5) {
    if (!del) {
      R result = (*function_)(p1_,p2_,p3_,a1,a2,a3,a4,a5);
      return result;
    } else {
      R result = (*function_)(p1_,p2_,p3_,a1,a2,a3,a4,a5);
      //  zero out the pointer to ensure segfault if used again
      function_ = __null;
      delete this;
      return result;
    }
  }
};

template <bool del, class P1, class P2, class P3, class A1, class A2, class A3, class A4, class A5>
class _TessFunctionResultCallback_3_5<del, void, P1, P2, P3, A1, A2, A3, A4, A5> : public TessCallback5<A1,A2,A3,A4,A5> {
 public:
  typedef TessCallback5<A1,A2,A3,A4,A5> base;
  typedef void (*FunctionSignature)(P1,P2,P3,A1,A2,A3,A4,A5);

 private:
  FunctionSignature function_;
  typename remove_reference<P1>::type p1_;
  typename remove_reference<P2>::type p2_;
  typename remove_reference<P3>::type p3_;

 public:
  inline _TessFunctionResultCallback_3_5(FunctionSignature function, P1 p1, P2 p2, P3 p3)
    : function_(function), p1_(p1), p2_(p2), p3_(p3) { }

  virtual void Run(A1 a1,A2 a2,A3 a3,A4 a4,A5 a5) {
    if (!del) {
      (*function_)(p1_,p2_,p3_,a1,a2,a3,a4,a5);
    } else {
      (*function_)(p1_,p2_,p3_,a1,a2,a3,a4,a5);
      //  zero out the pointer to ensure segfault if used again
      function_ = __null;
      delete this;
    }
  }
};

template <class R, class P1, class P2, class P3, class A1, class A2, class A3, class A4, class A5>
inline typename _TessFunctionResultCallback_3_5<true,R,P1,P2,P3,A1,A2,A3,A4,A5>::base*
NewTessCallback(R (*function)(P1,P2,P3,A1,A2,A3,A4,A5), typename Identity<P1>::type p1, typename Identity<P2>::type p2, typename Identity<P3>::type p3) {
  return new _TessFunctionResultCallback_3_5<true,R,P1,P2,P3,A1,A2,A3,A4,A5>(function, p1, p2, p3);
}

template <class R, class P1, class P2, class P3, class A1, class A2, class A3, class A4, class A5>
inline typename _TessFunctionResultCallback_3_5<false,R,P1,P2,P3,A1,A2,A3,A4,A5>::base*
NewPermanentTessCallback(R (*function)(P1,P2,P3,A1,A2,A3,A4,A5), typename Identity<P1>::type p1, typename Identity<P2>::type p2, typename Identity<P3>::type p3) {
  return new _TessFunctionResultCallback_3_5<false,R,P1,P2,P3,A1,A2,A3,A4,A5>(function, p1, p2, p3);
}

template <bool del, class R, class T, class P1, class P2, class P3, class P4, class A1, class A2, class A3, class A4, class A5>
class _ConstTessMemberResultCallback_4_5 : public TessResultCallback5<R,A1,A2,A3,A4,A5> {
 public:
  typedef TessResultCallback5<R,A1,A2,A3,A4,A5> base;
  typedef R (T::*MemberSignature)(P1,P2,P3,P4,A1,A2,A3,A4,A5) const;

 private:
  const T* object_;
  MemberSignature member_;
  typename remove_reference<P1>::type p1_;
  typename remove_reference<P2>::type p2_;
  typename remove_reference<P3>::type p3_;
  typename remove_reference<P4>::type p4_;

 public:
  inline _ConstTessMemberResultCallback_4_5(const T* object, MemberSignature member, P1 p1, P2 p2, P3 p3, P4 p4)
    : object_(object),
      member_(member), p1_(p1), p2_(p2), p3_(p3), p4_(p4) { }

  virtual R Run(A1 a1,A2 a2,A3 a3,A4 a4,A5 a5) {
    if (!del) {
      R result = (object_->*member_)(p1_,p2_,p3_,p4_,a1,a2,a3,a4,a5);
      return result;
    } else {
      R result = (object_->*member_)(p1_,p2_,p3_,p4_,a1,a2,a3,a4,a5);
      //  zero out the pointer to ensure segfault if used again
      member_ = __null;
      delete this;
      return result;
    }
  }
};

template <bool del, class T, class P1, class P2, class P3, class P4, class A1, class A2, class A3, class A4, class A5>
class _ConstTessMemberResultCallback_4_5<del, void, T, P1, P2, P3, P4, A1, A2, A3, A4, A5> : public TessCallback5<A1,A2,A3,A4,A5> {
 public:
  typedef TessCallback5<A1,A2,A3,A4,A5> base;
  typedef void (T::*MemberSignature)(P1,P2,P3,P4,A1,A2,A3,A4,A5) const;

 private:
  const T* object_;
  MemberSignature member_;
  typename remove_reference<P1>::type p1_;
  typename remove_reference<P2>::type p2_;
  typename remove_reference<P3>::type p3_;
  typename remove_reference<P4>::type p4_;

 public:
  inline _ConstTessMemberResultCallback_4_5(const T* object, MemberSignature member, P1 p1, P2 p2, P3 p3, P4 p4)
    : object_(object),
      member_(member), p1_(p1), p2_(p2), p3_(p3), p4_(p4) { }

  virtual void Run(A1 a1,A2 a2,A3 a3,A4 a4,A5 a5) {
    if (!del) {
      (object_->*member_)(p1_,p2_,p3_,p4_,a1,a2,a3,a4,a5);
    } else {
      (object_->*member_)(p1_,p2_,p3_,p4_,a1,a2,a3,a4,a5);
      //  zero out the pointer to ensure segfault if used again
      member_ = __null;
      delete this;
    }
  }
};


template <class T1, class T2, class R, class P1, class P2, class P3, class P4, class A1, class A2, class A3, class A4, class A5>
inline typename _ConstTessMemberResultCallback_4_5<true,R,T1,P1,P2,P3,P4,A1,A2,A3,A4,A5>::base*
NewTessCallback(const T1* obj, R (T2::*member)(P1,P2,P3,P4,A1,A2,A3,A4,A5) const, typename Identity<P1>::type p1, typename Identity<P2>::type p2, typename Identity<P3>::type p3, typename Identity<P4>::type p4) {
  return new _ConstTessMemberResultCallback_4_5<true,R,T1,P1,P2,P3,P4,A1,A2,A3,A4,A5>(obj, member, p1, p2, p3, p4);
}



template <class T1, class T2, class R, class P1, class P2, class P3, class P4, class A1, class A2, class A3, class A4, class A5>
inline typename _ConstTessMemberResultCallback_4_5<false,R,T1,P1,P2,P3,P4,A1,A2,A3,A4,A5>::base*
NewPermanentTessCallback(const T1* obj, R (T2::*member)(P1,P2,P3,P4,A1,A2,A3,A4,A5) const, typename Identity<P1>::type p1, typename Identity<P2>::type p2, typename Identity<P3>::type p3, typename Identity<P4>::type p4) {
  return new _ConstTessMemberResultCallback_4_5<false,R,T1,P1,P2,P3,P4,A1,A2,A3,A4,A5>(obj, member, p1, p2, p3, p4);
}


template <bool del, class R, class T, class P1, class P2, class P3, class P4, class A1, class A2, class A3, class A4, class A5>
class _TessMemberResultCallback_4_5 : public TessResultCallback5<R,A1,A2,A3,A4,A5> {
 public:
  typedef TessResultCallback5<R,A1,A2,A3,A4,A5> base;
  typedef R (T::*MemberSignature)(P1,P2,P3,P4,A1,A2,A3,A4,A5) ;

 private:
   T* object_;
  MemberSignature member_;
  typename remove_reference<P1>::type p1_;
  typename remove_reference<P2>::type p2_;
  typename remove_reference<P3>::type p3_;
  typename remove_reference<P4>::type p4_;

 public:
  inline _TessMemberResultCallback_4_5( T* object, MemberSignature member, P1 p1, P2 p2, P3 p3, P4 p4)
    : object_(object),
      member_(member), p1_(p1), p2_(p2), p3_(p3), p4_(p4) { }

  virtual R Run(A1 a1,A2 a2,A3 a3,A4 a4,A5 a5) {
    if (!del) {
      R result = (object_->*member_)(p1_,p2_,p3_,p4_,a1,a2,a3,a4,a5);
      return result;
    } else {
      R result = (object_->*member_)(p1_,p2_,p3_,p4_,a1,a2,a3,a4,a5);
      //  zero out the pointer to ensure segfault if used again
      member_ = __null;
      delete this;
      return result;
    }
  }
};

template <bool del, class T, class P1, class P2, class P3, class P4, class A1, class A2, class A3, class A4, class A5>
class _TessMemberResultCallback_4_5<del, void, T, P1, P2, P3, P4, A1, A2, A3, A4, A5> : public TessCallback5<A1,A2,A3,A4,A5> {
 public:
  typedef TessCallback5<A1,A2,A3,A4,A5> base;
  typedef void (T::*MemberSignature)(P1,P2,P3,P4,A1,A2,A3,A4,A5) ;

 private:
   T* object_;
  MemberSignature member_;
  typename remove_reference<P1>::type p1_;
  typename remove_reference<P2>::type p2_;
  typename remove_reference<P3>::type p3_;
  typename remove_reference<P4>::type p4_;

 public:
  inline _TessMemberResultCallback_4_5( T* object, MemberSignature member, P1 p1, P2 p2, P3 p3, P4 p4)
    : object_(object),
      member_(member), p1_(p1), p2_(p2), p3_(p3), p4_(p4) { }

  virtual void Run(A1 a1,A2 a2,A3 a3,A4 a4,A5 a5) {
    if (!del) {
      (object_->*member_)(p1_,p2_,p3_,p4_,a1,a2,a3,a4,a5);
    } else {
      (object_->*member_)(p1_,p2_,p3_,p4_,a1,a2,a3,a4,a5);
      //  zero out the pointer to ensure segfault if used again
      member_ = __null;
      delete this;
    }
  }
};


template <class T1, class T2, class R, class P1, class P2, class P3, class P4, class A1, class A2, class A3, class A4, class A5>
inline typename _TessMemberResultCallback_4_5<true,R,T1,P1,P2,P3,P4,A1,A2,A3,A4,A5>::base*
NewTessCallback( T1* obj, R (T2::*member)(P1,P2,P3,P4,A1,A2,A3,A4,A5) , typename Identity<P1>::type p1, typename Identity<P2>::type p2, typename Identity<P3>::type p3, typename Identity<P4>::type p4) {
  return new _TessMemberResultCallback_4_5<true,R,T1,P1,P2,P3,P4,A1,A2,A3,A4,A5>(obj, member, p1, p2, p3, p4);
}



template <class T1, class T2, class R, class P1, class P2, class P3, class P4, class A1, class A2, class A3, class A4, class A5>
inline typename _TessMemberResultCallback_4_5<false,R,T1,P1,P2,P3,P4,A1,A2,A3,A4,A5>::base*
NewPermanentTessCallback( T1* obj, R (T2::*member)(P1,P2,P3,P4,A1,A2,A3,A4,A5) , typename Identity<P1>::type p1, typename Identity<P2>::type p2, typename Identity<P3>::type p3, typename Identity<P4>::type p4) {
  return new _TessMemberResultCallback_4_5<false,R,T1,P1,P2,P3,P4,A1,A2,A3,A4,A5>(obj, member, p1, p2, p3, p4);
}


template <bool del, class R, class P1, class P2, class P3, class P4, class A1, class A2, class A3, class A4, class A5>
class _TessFunctionResultCallback_4_5 : public TessResultCallback5<R,A1,A2,A3,A4,A5> {
 public:
  typedef TessResultCallback5<R,A1,A2,A3,A4,A5> base;
  typedef R (*FunctionSignature)(P1,P2,P3,P4,A1,A2,A3,A4,A5);

 private:
  FunctionSignature function_;
  typename remove_reference<P1>::type p1_;
  typename remove_reference<P2>::type p2_;
  typename remove_reference<P3>::type p3_;
  typename remove_reference<P4>::type p4_;

 public:
  inline _TessFunctionResultCallback_4_5(FunctionSignature function, P1 p1, P2 p2, P3 p3, P4 p4)
    : function_(function), p1_(p1), p2_(p2), p3_(p3), p4_(p4) { }

  virtual R Run(A1 a1,A2 a2,A3 a3,A4 a4,A5 a5) {
    if (!del) {
      R result = (*function_)(p1_,p2_,p3_,p4_,a1,a2,a3,a4,a5);
      return result;
    } else {
      R result = (*function_)(p1_,p2_,p3_,p4_,a1,a2,a3,a4,a5);
      //  zero out the pointer to ensure segfault if used again
      function_ = __null;
      delete this;
      return result;
    }
  }
};

template <bool del, class P1, class P2, class P3, class P4, class A1, class A2, class A3, class A4, class A5>
class _TessFunctionResultCallback_4_5<del, void, P1, P2, P3, P4, A1, A2, A3, A4, A5> : public TessCallback5<A1,A2,A3,A4,A5> {
 public:
  typedef TessCallback5<A1,A2,A3,A4,A5> base;
  typedef void (*FunctionSignature)(P1,P2,P3,P4,A1,A2,A3,A4,A5);

 private:
  FunctionSignature function_;
  typename remove_reference<P1>::type p1_;
  typename remove_reference<P2>::type p2_;
  typename remove_reference<P3>::type p3_;
  typename remove_reference<P4>::type p4_;

 public:
  inline _TessFunctionResultCallback_4_5(FunctionSignature function, P1 p1, P2 p2, P3 p3, P4 p4)
    : function_(function), p1_(p1), p2_(p2), p3_(p3), p4_(p4) { }

  virtual void Run(A1 a1,A2 a2,A3 a3,A4 a4,A5 a5) {
    if (!del) {
      (*function_)(p1_,p2_,p3_,p4_,a1,a2,a3,a4,a5);
    } else {
      (*function_)(p1_,p2_,p3_,p4_,a1,a2,a3,a4,a5);
      //  zero out the pointer to ensure segfault if used again
      function_ = __null;
      delete this;
    }
  }
};

template <class R, class P1, class P2, class P3, class P4, class A1, class A2, class A3, class A4, class A5>
inline typename _TessFunctionResultCallback_4_5<true,R,P1,P2,P3,P4,A1,A2,A3,A4,A5>::base*
NewTessCallback(R (*function)(P1,P2,P3,P4,A1,A2,A3,A4,A5), typename Identity<P1>::type p1, typename Identity<P2>::type p2, typename Identity<P3>::type p3, typename Identity<P4>::type p4) {
  return new _TessFunctionResultCallback_4_5<true,R,P1,P2,P3,P4,A1,A2,A3,A4,A5>(function, p1, p2, p3, p4);
}

template <class R, class P1, class P2, class P3, class P4, class A1, class A2, class A3, class A4, class A5>
inline typename _TessFunctionResultCallback_4_5<false,R,P1,P2,P3,P4,A1,A2,A3,A4,A5>::base*
NewPermanentTessCallback(R (*function)(P1,P2,P3,P4,A1,A2,A3,A4,A5), typename Identity<P1>::type p1, typename Identity<P2>::type p2, typename Identity<P3>::type p3, typename Identity<P4>::type p4) {
  return new _TessFunctionResultCallback_4_5<false,R,P1,P2,P3,P4,A1,A2,A3,A4,A5>(function, p1, p2, p3, p4);
}

template <bool del, class R, class T, class P1, class P2, class P3, class P4, class P5, class A1, class A2, class A3, class A4, class A5>
class _ConstTessMemberResultCallback_5_5 : public TessResultCallback5<R,A1,A2,A3,A4,A5> {
 public:
  typedef TessResultCallback5<R,A1,A2,A3,A4,A5> base;
  typedef R (T::*MemberSignature)(P1,P2,P3,P4,P5,A1,A2,A3,A4,A5) const;

 private:
  const T* object_;
  MemberSignature member_;
  typename remove_reference<P1>::type p1_;
  typename remove_reference<P2>::type p2_;
  typename remove_reference<P3>::type p3_;
  typename remove_reference<P4>::type p4_;
  typename remove_reference<P5>::type p5_;

 public:
  inline _ConstTessMemberResultCallback_5_5(const T* object, MemberSignature member, P1 p1, P2 p2, P3 p3, P4 p4, P5 p5)
    : object_(object),
      member_(member), p1_(p1), p2_(p2), p3_(p3), p4_(p4), p5_(p5) { }


  virtual R Run(A1 a1,A2 a2,A3 a3,A4 a4,A5 a5) {
    if (!del) {
      R result = (object_->*member_)(p1_,p2_,p3_,p4_,p5_,a1,a2,a3,a4,a5);
      return result;
    } else {
      R result = (object_->*member_)(p1_,p2_,p3_,p4_,p5_,a1,a2,a3,a4,a5);
      //  zero out the pointer to ensure segfault if used again
      member_ = __null;
      delete this;
      return result;
    }
  }
};

template <bool del, class T, class P1, class P2, class P3, class P4, class P5, class A1, class A2, class A3, class A4, class A5>
class _ConstTessMemberResultCallback_5_5<del, void, T, P1, P2, P3, P4, P5, A1, A2, A3, A4, A5> : public TessCallback5<A1,A2,A3,A4,A5> {
 public:
  typedef TessCallback5<A1,A2,A3,A4,A5> base;
  typedef void (T::*MemberSignature)(P1,P2,P3,P4,P5,A1,A2,A3,A4,A5) const;

 private:
  const T* object_;
  MemberSignature member_;
  typename remove_reference<P1>::type p1_;
  typename remove_reference<P2>::type p2_;
  typename remove_reference<P3>::type p3_;
  typename remove_reference<P4>::type p4_;
  typename remove_reference<P5>::type p5_;

 public:
  inline _ConstTessMemberResultCallback_5_5(const T* object, MemberSignature member, P1 p1, P2 p2, P3 p3, P4 p4, P5 p5)
    : object_(object),
      member_(member), p1_(p1), p2_(p2), p3_(p3), p4_(p4), p5_(p5) { }

  virtual void Run(A1 a1,A2 a2,A3 a3,A4 a4,A5 a5) {
    if (!del) {
      (object_->*member_)(p1_,p2_,p3_,p4_,p5_,a1,a2,a3,a4,a5);
    } else {
      (object_->*member_)(p1_,p2_,p3_,p4_,p5_,a1,a2,a3,a4,a5);
      //  zero out the pointer to ensure segfault if used again
      member_ = __null;
      delete this;
    }
  }
};


template <class T1, class T2, class R, class P1, class P2, class P3, class P4, class P5, class A1, class A2, class A3, class A4, class A5>
inline typename _ConstTessMemberResultCallback_5_5<true,R,T1,P1,P2,P3,P4,P5,A1,A2,A3,A4,A5>::base*
NewTessCallback(const T1* obj, R (T2::*member)(P1,P2,P3,P4,P5,A1,A2,A3,A4,A5) const, typename Identity<P1>::type p1, typename Identity<P2>::type p2, typename Identity<P3>::type p3, typename Identity<P4>::type p4, typename Identity<P5>::type p5) {
  return new _ConstTessMemberResultCallback_5_5<true,R,T1,P1,P2,P3,P4,P5,A1,A2,A3,A4,A5>(obj, member, p1, p2, p3, p4, p5);
}



template <class T1, class T2, class R, class P1, class P2, class P3, class P4, class P5, class A1, class A2, class A3, class A4, class A5>
inline typename _ConstTessMemberResultCallback_5_5<false,R,T1,P1,P2,P3,P4,P5,A1,A2,A3,A4,A5>::base*
NewPermanentTessCallback(const T1* obj, R (T2::*member)(P1,P2,P3,P4,P5,A1,A2,A3,A4,A5) const, typename Identity<P1>::type p1, typename Identity<P2>::type p2, typename Identity<P3>::type p3, typename Identity<P4>::type p4, typename Identity<P5>::type p5) {
  return new _ConstTessMemberResultCallback_5_5<false,R,T1,P1,P2,P3,P4,P5,A1,A2,A3,A4,A5>(obj, member, p1, p2, p3, p4, p5);
}


template <bool del, class R, class T, class P1, class P2, class P3, class P4, class P5, class A1, class A2, class A3, class A4, class A5>
class _TessMemberResultCallback_5_5 : public TessResultCallback5<R,A1,A2,A3,A4,A5> {
 public:
  typedef TessResultCallback5<R,A1,A2,A3,A4,A5> base;
  typedef R (T::*MemberSignature)(P1,P2,P3,P4,P5,A1,A2,A3,A4,A5) ;

 private:
   T* object_;
  MemberSignature member_;
  typename remove_reference<P1>::type p1_;
  typename remove_reference<P2>::type p2_;
  typename remove_reference<P3>::type p3_;
  typename remove_reference<P4>::type p4_;
  typename remove_reference<P5>::type p5_;

 public:
  inline _TessMemberResultCallback_5_5( T* object, MemberSignature member, P1 p1, P2 p2, P3 p3, P4 p4, P5 p5)
    : object_(object),
      member_(member), p1_(p1), p2_(p2), p3_(p3), p4_(p4), p5_(p5) { }

  virtual R Run(A1 a1,A2 a2,A3 a3,A4 a4,A5 a5) {
    if (!del) {
      R result = (object_->*member_)(p1_,p2_,p3_,p4_,p5_,a1,a2,a3,a4,a5);
      return result;
    } else {
      R result = (object_->*member_)(p1_,p2_,p3_,p4_,p5_,a1,a2,a3,a4,a5);
      //  zero out the pointer to ensure segfault if used again
      member_ = __null;
      delete this;
      return result;
    }
  }
};

template <bool del, class T, class P1, class P2, class P3, class P4, class P5, class A1, class A2, class A3, class A4, class A5>
class _TessMemberResultCallback_5_5<del, void, T, P1, P2, P3, P4, P5, A1, A2, A3, A4, A5> : public TessCallback5<A1,A2,A3,A4,A5> {
 public:
  typedef TessCallback5<A1,A2,A3,A4,A5> base;
  typedef void (T::*MemberSignature)(P1,P2,P3,P4,P5,A1,A2,A3,A4,A5) ;

 private:
   T* object_;
  MemberSignature member_;
  typename remove_reference<P1>::type p1_;
  typename remove_reference<P2>::type p2_;
  typename remove_reference<P3>::type p3_;
  typename remove_reference<P4>::type p4_;
  typename remove_reference<P5>::type p5_;

 public:
  inline _TessMemberResultCallback_5_5( T* object, MemberSignature member, P1 p1, P2 p2, P3 p3, P4 p4, P5 p5)
    : object_(object),
      member_(member), p1_(p1), p2_(p2), p3_(p3), p4_(p4), p5_(p5) { }

  virtual void Run(A1 a1,A2 a2,A3 a3,A4 a4,A5 a5) {
    if (!del) {
      (object_->*member_)(p1_,p2_,p3_,p4_,p5_,a1,a2,a3,a4,a5);
    } else {
      (object_->*member_)(p1_,p2_,p3_,p4_,p5_,a1,a2,a3,a4,a5);
      //  zero out the pointer to ensure segfault if used again
      member_ = __null;
      delete this;
    }
  }
};


template <class T1, class T2, class R, class P1, class P2, class P3, class P4, class P5, class A1, class A2, class A3, class A4, class A5>
inline typename _TessMemberResultCallback_5_5<true,R,T1,P1,P2,P3,P4,P5,A1,A2,A3,A4,A5>::base*
NewTessCallback( T1* obj, R (T2::*member)(P1,P2,P3,P4,P5,A1,A2,A3,A4,A5) , typename Identity<P1>::type p1, typename Identity<P2>::type p2, typename Identity<P3>::type p3, typename Identity<P4>::type p4, typename Identity<P5>::type p5) {
  return new _TessMemberResultCallback_5_5<true,R,T1,P1,P2,P3,P4,P5,A1,A2,A3,A4,A5>(obj, member, p1, p2, p3, p4, p5);
}



template <class T1, class T2, class R, class P1, class P2, class P3, class P4, class P5, class A1, class A2, class A3, class A4, class A5>
inline typename _TessMemberResultCallback_5_5<false,R,T1,P1,P2,P3,P4,P5,A1,A2,A3,A4,A5>::base*
NewPermanentTessCallback( T1* obj, R (T2::*member)(P1,P2,P3,P4,P5,A1,A2,A3,A4,A5) , typename Identity<P1>::type p1, typename Identity<P2>::type p2, typename Identity<P3>::type p3, typename Identity<P4>::type p4, typename Identity<P5>::type p5) {
  return new _TessMemberResultCallback_5_5<false,R,T1,P1,P2,P3,P4,P5,A1,A2,A3,A4,A5>(obj, member, p1, p2, p3, p4, p5);
}


template <bool del, class R, class P1, class P2, class P3, class P4, class P5, class A1, class A2, class A3, class A4, class A5>
class _TessFunctionResultCallback_5_5 : public TessResultCallback5<R,A1,A2,A3,A4,A5> {
 public:
  typedef TessResultCallback5<R,A1,A2,A3,A4,A5> base;
  typedef R (*FunctionSignature)(P1,P2,P3,P4,P5,A1,A2,A3,A4,A5);

 private:
  FunctionSignature function_;
  typename remove_reference<P1>::type p1_;
  typename remove_reference<P2>::type p2_;
  typename remove_reference<P3>::type p3_;
  typename remove_reference<P4>::type p4_;
  typename remove_reference<P5>::type p5_;

 public:
  inline _TessFunctionResultCallback_5_5(FunctionSignature function, P1 p1, P2 p2, P3 p3, P4 p4, P5 p5)
    : function_(function), p1_(p1), p2_(p2), p3_(p3), p4_(p4), p5_(p5) { }

  virtual R Run(A1 a1,A2 a2,A3 a3,A4 a4,A5 a5) {
    if (!del) {
      R result = (*function_)(p1_,p2_,p3_,p4_,p5_,a1,a2,a3,a4,a5);
      return result;
    } else {
      R result = (*function_)(p1_,p2_,p3_,p4_,p5_,a1,a2,a3,a4,a5);
      //  zero out the pointer to ensure segfault if used again
      function_ = __null;
      delete this;
      return result;
    }
  }
};

template <bool del, class P1, class P2, class P3, class P4, class P5, class A1, class A2, class A3, class A4, class A5>
class _TessFunctionResultCallback_5_5<del, void, P1, P2, P3, P4, P5, A1, A2, A3, A4, A5> : public TessCallback5<A1,A2,A3,A4,A5> {
 public:
  typedef TessCallback5<A1,A2,A3,A4,A5> base;
  typedef void (*FunctionSignature)(P1,P2,P3,P4,P5,A1,A2,A3,A4,A5);

 private:
  FunctionSignature function_;
  typename remove_reference<P1>::type p1_;
  typename remove_reference<P2>::type p2_;
  typename remove_reference<P3>::type p3_;
  typename remove_reference<P4>::type p4_;
  typename remove_reference<P5>::type p5_;

 public:
  inline _TessFunctionResultCallback_5_5(FunctionSignature function, P1 p1, P2 p2, P3 p3, P4 p4, P5 p5)
    : function_(function), p1_(p1), p2_(p2), p3_(p3), p4_(p4), p5_(p5) { }

  virtual void Run(A1 a1,A2 a2,A3 a3,A4 a4,A5 a5) {
    if (!del) {
      (*function_)(p1_,p2_,p3_,p4_,p5_,a1,a2,a3,a4,a5);
    } else {
      (*function_)(p1_,p2_,p3_,p4_,p5_,a1,a2,a3,a4,a5);
      //  zero out the pointer to ensure segfault if used again
      function_ = __null;
      delete this;
    }
  }
};

template <class R, class P1, class P2, class P3, class P4, class P5, class A1, class A2, class A3, class A4, class A5>
inline typename _TessFunctionResultCallback_5_5<true,R,P1,P2,P3,P4,P5,A1,A2,A3,A4,A5>::base*
NewTessCallback(R (*function)(P1,P2,P3,P4,P5,A1,A2,A3,A4,A5), typename Identity<P1>::type p1, typename Identity<P2>::type p2, typename Identity<P3>::type p3, typename Identity<P4>::type p4, typename Identity<P5>::type p5) {
  return new _TessFunctionResultCallback_5_5<true,R,P1,P2,P3,P4,P5,A1,A2,A3,A4,A5>(function, p1, p2, p3, p4, p5);
}

template <class R, class P1, class P2, class P3, class P4, class P5, class A1, class A2, class A3, class A4, class A5>
inline typename _TessFunctionResultCallback_5_5<false,R,P1,P2,P3,P4,P5,A1,A2,A3,A4,A5>::base*
NewPermanentTessCallback(R (*function)(P1,P2,P3,P4,P5,A1,A2,A3,A4,A5), typename Identity<P1>::type p1, typename Identity<P2>::type p2, typename Identity<P3>::type p3, typename Identity<P4>::type p4, typename Identity<P5>::type p5) {
  return new _TessFunctionResultCallback_5_5<false,R,P1,P2,P3,P4,P5,A1,A2,A3,A4,A5>(function, p1, p2, p3, p4, p5);
}

template <bool del, class R, class T, class P1, class P2, class P3, class P4, class P5, class P6, class A1, class A2, class A3, class A4, class A5>
class _ConstTessMemberResultCallback_6_5 : public TessResultCallback5<R,A1,A2,A3,A4,A5> {
 public:
  typedef TessResultCallback5<R,A1,A2,A3,A4,A5> base;
  typedef R (T::*MemberSignature)(P1,P2,P3,P4,P5,P6,A1,A2,A3,A4,A5) const;

 private:
  const T* object_;
  MemberSignature member_;
  typename remove_reference<P1>::type p1_;
  typename remove_reference<P2>::type p2_;
  typename remove_reference<P3>::type p3_;
  typename remove_reference<P4>::type p4_;
  typename remove_reference<P5>::type p5_;
  typename remove_reference<P6>::type p6_;

 public:
  inline _ConstTessMemberResultCallback_6_5(const T* object, MemberSignature member, P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6)
    : object_(object),
      member_(member), p1_(p1), p2_(p2), p3_(p3), p4_(p4), p5_(p5), p6_(p6) { }

  virtual R Run(A1 a1,A2 a2,A3 a3,A4 a4,A5 a5) {
    if (!del) {
      R result = (object_->*member_)(p1_,p2_,p3_,p4_,p5_,p6_,a1,a2,a3,a4,a5);
      return result;
    } else {
      R result = (object_->*member_)(p1_,p2_,p3_,p4_,p5_,p6_,a1,a2,a3,a4,a5);
      //  zero out the pointer to ensure segfault if used again
      member_ = __null;
      delete this;
      return result;
    }
  }
};

template <bool del, class T, class P1, class P2, class P3, class P4, class P5, class P6, class A1, class A2, class A3, class A4, class A5>
class _ConstTessMemberResultCallback_6_5<del, void, T, P1, P2, P3, P4, P5, P6, A1, A2, A3, A4, A5> : public TessCallback5<A1,A2,A3,A4,A5> {
 public:
  typedef TessCallback5<A1,A2,A3,A4,A5> base;
  typedef void (T::*MemberSignature)(P1,P2,P3,P4,P5,P6,A1,A2,A3,A4,A5) const;

 private:
  const T* object_;
  MemberSignature member_;
  typename remove_reference<P1>::type p1_;
  typename remove_reference<P2>::type p2_;
  typename remove_reference<P3>::type p3_;
  typename remove_reference<P4>::type p4_;
  typename remove_reference<P5>::type p5_;
  typename remove_reference<P6>::type p6_;

 public:
  inline _ConstTessMemberResultCallback_6_5(const T* object, MemberSignature member, P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6)
    : object_(object),
      member_(member), p1_(p1), p2_(p2), p3_(p3), p4_(p4), p5_(p5), p6_(p6) { }

  virtual void Run(A1 a1,A2 a2,A3 a3,A4 a4,A5 a5) {
    if (!del) {
      (object_->*member_)(p1_,p2_,p3_,p4_,p5_,p6_,a1,a2,a3,a4,a5);
    } else {
      (object_->*member_)(p1_,p2_,p3_,p4_,p5_,p6_,a1,a2,a3,a4,a5);
      //  zero out the pointer to ensure segfault if used again
      member_ = __null;
      delete this;
    }
  }
};


template <class T1, class T2, class R, class P1, class P2, class P3, class P4, class P5, class P6, class A1, class A2, class A3, class A4, class A5>
inline typename _ConstTessMemberResultCallback_6_5<true,R,T1,P1,P2,P3,P4,P5,P6,A1,A2,A3,A4,A5>::base*
NewTessCallback(const T1* obj, R (T2::*member)(P1,P2,P3,P4,P5,P6,A1,A2,A3,A4,A5) const, typename Identity<P1>::type p1, typename Identity<P2>::type p2, typename Identity<P3>::type p3, typename Identity<P4>::type p4, typename Identity<P5>::type p5, typename Identity<P6>::type p6) {
  return new _ConstTessMemberResultCallback_6_5<true,R,T1,P1,P2,P3,P4,P5,P6,A1,A2,A3,A4,A5>(obj, member, p1, p2, p3, p4, p5, p6);
}



template <class T1, class T2, class R, class P1, class P2, class P3, class P4, class P5, class P6, class A1, class A2, class A3, class A4, class A5>
inline typename _ConstTessMemberResultCallback_6_5<false,R,T1,P1,P2,P3,P4,P5,P6,A1,A2,A3,A4,A5>::base*
NewPermanentTessCallback(const T1* obj, R (T2::*member)(P1,P2,P3,P4,P5,P6,A1,A2,A3,A4,A5) const, typename Identity<P1>::type p1, typename Identity<P2>::type p2, typename Identity<P3>::type p3, typename Identity<P4>::type p4, typename Identity<P5>::type p5, typename Identity<P6>::type p6) {
  return new _ConstTessMemberResultCallback_6_5<false,R,T1,P1,P2,P3,P4,P5,P6,A1,A2,A3,A4,A5>(obj, member, p1, p2, p3, p4, p5, p6);
}


template <bool del, class R, class T, class P1, class P2, class P3, class P4, class P5, class P6, class A1, class A2, class A3, class A4, class A5>
class _TessMemberResultCallback_6_5 : public TessResultCallback5<R,A1,A2,A3,A4,A5> {
 public:
  typedef TessResultCallback5<R,A1,A2,A3,A4,A5> base;
  typedef R (T::*MemberSignature)(P1,P2,P3,P4,P5,P6,A1,A2,A3,A4,A5) ;

 private:
   T* object_;
  MemberSignature member_;
  typename remove_reference<P1>::type p1_;
  typename remove_reference<P2>::type p2_;
  typename remove_reference<P3>::type p3_;
  typename remove_reference<P4>::type p4_;
  typename remove_reference<P5>::type p5_;
  typename remove_reference<P6>::type p6_;

 public:
  inline _TessMemberResultCallback_6_5( T* object, MemberSignature member, P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6)
    : object_(object),
      member_(member), p1_(p1), p2_(p2), p3_(p3), p4_(p4), p5_(p5), p6_(p6) { }

  virtual R Run(A1 a1,A2 a2,A3 a3,A4 a4,A5 a5) {
    if (!del) {
      R result = (object_->*member_)(p1_,p2_,p3_,p4_,p5_,p6_,a1,a2,a3,a4,a5);
      return result;
    } else {
      R result = (object_->*member_)(p1_,p2_,p3_,p4_,p5_,p6_,a1,a2,a3,a4,a5);
      //  zero out the pointer to ensure segfault if used again
      member_ = __null;
      delete this;
      return result;
    }
  }
};

template <bool del, class T, class P1, class P2, class P3, class P4, class P5, class P6, class A1, class A2, class A3, class A4, class A5>
class _TessMemberResultCallback_6_5<del, void, T, P1, P2, P3, P4, P5, P6, A1, A2, A3, A4, A5> : public TessCallback5<A1,A2,A3,A4,A5> {
 public:
  typedef TessCallback5<A1,A2,A3,A4,A5> base;
  typedef void (T::*MemberSignature)(P1,P2,P3,P4,P5,P6,A1,A2,A3,A4,A5) ;

 private:
   T* object_;
  MemberSignature member_;
  typename remove_reference<P1>::type p1_;
  typename remove_reference<P2>::type p2_;
  typename remove_reference<P3>::type p3_;
  typename remove_reference<P4>::type p4_;
  typename remove_reference<P5>::type p5_;
  typename remove_reference<P6>::type p6_;

 public:
  inline _TessMemberResultCallback_6_5( T* object, MemberSignature member, P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6)
    : object_(object),
      member_(member), p1_(p1), p2_(p2), p3_(p3), p4_(p4), p5_(p5), p6_(p6) { }

  virtual void Run(A1 a1,A2 a2,A3 a3,A4 a4,A5 a5) {
    if (!del) {
      (object_->*member_)(p1_,p2_,p3_,p4_,p5_,p6_,a1,a2,a3,a4,a5);
    } else {
      (object_->*member_)(p1_,p2_,p3_,p4_,p5_,p6_,a1,a2,a3,a4,a5);
      //  zero out the pointer to ensure segfault if used again
      member_ = __null;
      delete this;
    }
  }
};


template <class T1, class T2, class R, class P1, class P2, class P3, class P4, class P5, class P6, class A1, class A2, class A3, class A4, class A5>
inline typename _TessMemberResultCallback_6_5<true,R,T1,P1,P2,P3,P4,P5,P6,A1,A2,A3,A4,A5>::base*
NewTessCallback( T1* obj, R (T2::*member)(P1,P2,P3,P4,P5,P6,A1,A2,A3,A4,A5) , typename Identity<P1>::type p1, typename Identity<P2>::type p2, typename Identity<P3>::type p3, typename Identity<P4>::type p4, typename Identity<P5>::type p5, typename Identity<P6>::type p6) {
  return new _TessMemberResultCallback_6_5<true,R,T1,P1,P2,P3,P4,P5,P6,A1,A2,A3,A4,A5>(obj, member, p1, p2, p3, p4, p5, p6);
}



template <class T1, class T2, class R, class P1, class P2, class P3, class P4, class P5, class P6, class A1, class A2, class A3, class A4, class A5>
inline typename _TessMemberResultCallback_6_5<false,R,T1,P1,P2,P3,P4,P5,P6,A1,A2,A3,A4,A5>::base*
NewPermanentTessCallback( T1* obj, R (T2::*member)(P1,P2,P3,P4,P5,P6,A1,A2,A3,A4,A5) , typename Identity<P1>::type p1, typename Identity<P2>::type p2, typename Identity<P3>::type p3, typename Identity<P4>::type p4, typename Identity<P5>::type p5, typename Identity<P6>::type p6) {
  return new _TessMemberResultCallback_6_5<false,R,T1,P1,P2,P3,P4,P5,P6,A1,A2,A3,A4,A5>(obj, member, p1, p2, p3, p4, p5, p6);
}


template <bool del, class R, class P1, class P2, class P3, class P4, class P5, class P6, class A1, class A2, class A3, class A4, class A5>
class _TessFunctionResultCallback_6_5 : public TessResultCallback5<R,A1,A2,A3,A4,A5> {
 public:
  typedef TessResultCallback5<R,A1,A2,A3,A4,A5> base;
  typedef R (*FunctionSignature)(P1,P2,P3,P4,P5,P6,A1,A2,A3,A4,A5);

 private:
  FunctionSignature function_;
  typename remove_reference<P1>::type p1_;
  typename remove_reference<P2>::type p2_;
  typename remove_reference<P3>::type p3_;
  typename remove_reference<P4>::type p4_;
  typename remove_reference<P5>::type p5_;
  typename remove_reference<P6>::type p6_;

 public:
  inline _TessFunctionResultCallback_6_5(FunctionSignature function, P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6)
    : function_(function), p1_(p1), p2_(p2), p3_(p3), p4_(p4), p5_(p5), p6_(p6) { }

  virtual R Run(A1 a1,A2 a2,A3 a3,A4 a4,A5 a5) {
    if (!del) {
      R result = (*function_)(p1_,p2_,p3_,p4_,p5_,p6_,a1,a2,a3,a4,a5);
      return result;
    } else {
      R result = (*function_)(p1_,p2_,p3_,p4_,p5_,p6_,a1,a2,a3,a4,a5);
      //  zero out the pointer to ensure segfault if used again
      function_ = __null;
      delete this;
      return result;
    }
  }
};

template <bool del, class P1, class P2, class P3, class P4, class P5, class P6, class A1, class A2, class A3, class A4, class A5>
class _TessFunctionResultCallback_6_5<del, void, P1, P2, P3, P4, P5, P6, A1, A2, A3, A4, A5> : public TessCallback5<A1,A2,A3,A4,A5> {
 public:
  typedef TessCallback5<A1,A2,A3,A4,A5> base;
  typedef void (*FunctionSignature)(P1,P2,P3,P4,P5,P6,A1,A2,A3,A4,A5);

 private:
  FunctionSignature function_;
  typename remove_reference<P1>::type p1_;
  typename remove_reference<P2>::type p2_;
  typename remove_reference<P3>::type p3_;
  typename remove_reference<P4>::type p4_;
  typename remove_reference<P5>::type p5_;
  typename remove_reference<P6>::type p6_;

 public:
  inline _TessFunctionResultCallback_6_5(FunctionSignature function, P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6)
    : function_(function), p1_(p1), p2_(p2), p3_(p3), p4_(p4), p5_(p5), p6_(p6) { }

  virtual void Run(A1 a1,A2 a2,A3 a3,A4 a4,A5 a5) {
    if (!del) {
      (*function_)(p1_,p2_,p3_,p4_,p5_,p6_,a1,a2,a3,a4,a5);
    } else {
      (*function_)(p1_,p2_,p3_,p4_,p5_,p6_,a1,a2,a3,a4,a5);
      //  zero out the pointer to ensure segfault if used again
      function_ = __null;
      delete this;
    }
  }
};

template <class R, class P1, class P2, class P3, class P4, class P5, class P6, class A1, class A2, class A3, class A4, class A5>
inline typename _TessFunctionResultCallback_6_5<true,R,P1,P2,P3,P4,P5,P6,A1,A2,A3,A4,A5>::base*
NewTessCallback(R (*function)(P1,P2,P3,P4,P5,P6,A1,A2,A3,A4,A5), typename Identity<P1>::type p1, typename Identity<P2>::type p2, typename Identity<P3>::type p3, typename Identity<P4>::type p4, typename Identity<P5>::type p5, typename Identity<P6>::type p6) {
  return new _TessFunctionResultCallback_6_5<true,R,P1,P2,P3,P4,P5,P6,A1,A2,A3,A4,A5>(function, p1, p2, p3, p4, p5, p6);
}

template <class R, class P1, class P2, class P3, class P4, class P5, class P6, class A1, class A2, class A3, class A4, class A5>
inline typename _TessFunctionResultCallback_6_5<false,R,P1,P2,P3,P4,P5,P6,A1,A2,A3,A4,A5>::base*
NewPermanentTessCallback(R (*function)(P1,P2,P3,P4,P5,P6,A1,A2,A3,A4,A5), typename Identity<P1>::type p1, typename Identity<P2>::type p2, typename Identity<P3>::type p3, typename Identity<P4>::type p4, typename Identity<P5>::type p5, typename Identity<P6>::type p6) {
  return new _TessFunctionResultCallback_6_5<false,R,P1,P2,P3,P4,P5,P6,A1,A2,A3,A4,A5>(function, p1, p2, p3, p4, p5, p6);
}
# 37 "/Users/satavtar/github/tesseract/api/baseapi.h" 2

# 1 "/usr/local/include/tesseract/pageiterator.h" 1
///////////////////////////////////////////////////////////////////////
// File:        pageiterator.h
// Description: Iterator for tesseract page structure that avoids using
//              tesseract internal data structures.
// Author:      Ray Smith
// Created:     Fri Feb 26 11:01:06 PST 2010
//
// (C) Copyright 2010, Google Inc.
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
///////////////////////////////////////////////////////////////////////







struct BlamerBundle;
class C_BLOB_IT;
class PAGE_RES;
class PAGE_RES_IT;
class WERD;
struct Pix;
struct Pta;

namespace tesseract {

class Tesseract;

/**
 * Class to iterate over tesseract page structure, providing access to all
 * levels of the page hierarchy, without including any tesseract headers or
 * having to handle any tesseract structures.
 * WARNING! This class points to data held within the TessBaseAPI class, and
 * therefore can only be used while the TessBaseAPI class still exists and
 * has not been subjected to a call of Init, SetImage, Recognize, Clear, End
 * DetectOS, or anything else that changes the internal PAGE_RES.
 * See apitypes.h for the definition of PageIteratorLevel.
 * See also ResultIterator, derived from PageIterator, which adds in the
 * ability to access OCR output with text-specific methods.
 */

class PageIterator {
 public:
  /**
   * page_res and tesseract come directly from the BaseAPI.
   * The rectangle parameters are copied indirectly from the Thresholder,
   * via the BaseAPI. They represent the coordinates of some rectangle in an
   * original image (in top-left-origin coordinates) and therefore the top-left
   * needs to be added to any output boxes in order to specify coordinates
   * in the original image. See TessBaseAPI::SetRectangle.
   * The scale and scaled_yres are in case the Thresholder scaled the image
   * rectangle prior to thresholding. Any coordinates in tesseract's image
   * must be divided by scale before adding (rect_left, rect_top).
   * The scaled_yres indicates the effective resolution of the binary image
   * that tesseract has been given by the Thresholder.
   * After the constructor, Begin has already been called.
   */
  PageIterator(PAGE_RES* page_res, Tesseract* tesseract,
               int scale, int scaled_yres,
               int rect_left, int rect_top,
               int rect_width, int rect_height);
  virtual ~PageIterator();

  /**
   * Page/ResultIterators may be copied! This makes it possible to iterate over
   * all the objects at a lower level, while maintaining an iterator to
   * objects at a higher level. These constructors DO NOT CALL Begin, so
   * iterations will continue from the location of src.
   */
  PageIterator(const PageIterator& src);
  const PageIterator& operator=(const PageIterator& src);

  /** Are we positioned at the same location as other? */
  bool PositionedAtSameWord(const PAGE_RES_IT* other) const;

  // ============= Moving around within the page ============.

  /**
   * Moves the iterator to point to the start of the page to begin an
   * iteration.
   */
  virtual void Begin();

  /**
   * Moves the iterator to the beginning of the paragraph.
   * This class implements this functionality by moving it to the zero indexed
   * blob of the first (leftmost) word on the first row of the paragraph.
   */
  virtual void RestartParagraph();

  /**
   * Return whether this iterator points anywhere in the first textline of a
   * paragraph.
   */
  bool IsWithinFirstTextlineOfParagraph() const;

  /**
   * Moves the iterator to the beginning of the text line.
   * This class implements this functionality by moving it to the zero indexed
   * blob of the first (leftmost) word of the row.
   */
  virtual void RestartRow();

  /**
   * Moves to the start of the next object at the given level in the
   * page hierarchy, and returns false if the end of the page was reached.
   * NOTE that RIL_SYMBOL will skip non-text blocks, but all other
   * PageIteratorLevel level values will visit each non-text block once.
   * Think of non text blocks as containing a single para, with a single line,
   * with a single imaginary word.
   * Calls to Next with different levels may be freely intermixed.
   * This function iterates words in right-to-left scripts correctly, if
   * the appropriate language has been loaded into Tesseract.
   */
  virtual bool Next(PageIteratorLevel level);

  /**
   * Returns true if the iterator is at the start of an object at the given
   * level.
   *
   * For instance, suppose an iterator it is pointed to the first symbol of the
   * first word of the third line of the second paragraph of the first block in
   * a page, then:
   *   it.IsAtBeginningOf(RIL_BLOCK) = false
   *   it.IsAtBeginningOf(RIL_PARA) = false
   *   it.IsAtBeginningOf(RIL_TEXTLINE) = true
   *   it.IsAtBeginningOf(RIL_WORD) = true
   *   it.IsAtBeginningOf(RIL_SYMBOL) = true
   */
  virtual bool IsAtBeginningOf(PageIteratorLevel level) const;

  /**
   * Returns whether the iterator is positioned at the last element in a
   * given level. (e.g. the last word in a line, the last line in a block)
   *
   *     Here's some two-paragraph example
   *   text.  It starts off innocuously
   *   enough but quickly turns bizarre.
   *     The author inserts a cornucopia
   *   of words to guard against confused
   *   references.
   *
   * Now take an iterator it pointed to the start of "bizarre."
   *  it.IsAtFinalElement(RIL_PARA, RIL_SYMBOL) = false
   *  it.IsAtFinalElement(RIL_PARA, RIL_WORD) = true
   *  it.IsAtFinalElement(RIL_BLOCK, RIL_WORD) = false
   */
  virtual bool IsAtFinalElement(PageIteratorLevel level,
                                PageIteratorLevel element) const;

  /**
   * Returns whether this iterator is positioned
   *   before other:   -1
   *   equal to other:  0
   *   after other:     1
   */
  int Cmp(const PageIterator &other) const;

  // ============= Accessing data ==============.
  // Coordinate system:
  // Integer coordinates are at the cracks between the pixels.
  // The top-left corner of the top-left pixel in the image is at (0,0).
  // The bottom-right corner of the bottom-right pixel in the image is at
  // (width, height).
  // Every bounding box goes from the top-left of the top-left contained
  // pixel to the bottom-right of the bottom-right contained pixel, so
  // the bounding box of the single top-left pixel in the image is:
  // (0,0)->(1,1).
  // If an image rectangle has been set in the API, then returned coordinates
  // relate to the original (full) image, rather than the rectangle.

  /**
   * Controls what to include in a bounding box. Bounding boxes of all levels
   * between RIL_WORD and RIL_BLOCK can include or exclude potential diacritics.
   * Between layout analysis and recognition, it isn't known where all
   * diacritics belong, so this control is used to include or exclude some
   * diacritics that are above or below the main body of the word. In most cases
   * where the placement is obvious, and after recognition, it doesn't make as
   * much difference, as the diacritics will already be included in the word.
   */
  void SetBoundingBoxComponents(bool include_upper_dots,
                                bool include_lower_dots) {
    include_upper_dots_ = include_upper_dots;
    include_lower_dots_ = include_lower_dots;
  }

  /**
   * Returns the bounding rectangle of the current object at the given level.
   * See comment on coordinate system above.
   * Returns false if there is no such object at the current position.
   * The returned bounding box is guaranteed to match the size and position
   * of the image returned by GetBinaryImage, but may clip foreground pixels
   * from a grey image. The padding argument to GetImage can be used to expand
   * the image to include more foreground pixels. See GetImage below.
   */
  bool BoundingBox(PageIteratorLevel level,
                   int* left, int* top, int* right, int* bottom) const;
  bool BoundingBox(PageIteratorLevel level, const int padding,
                   int* left, int* top, int* right, int* bottom) const;
  /**
   * Returns the bounding rectangle of the object in a coordinate system of the
   * working image rectangle having its origin at (rect_left_, rect_top_) with
   * respect to the original image and is scaled by a factor scale_.
   */
  bool BoundingBoxInternal(PageIteratorLevel level,
                           int* left, int* top, int* right, int* bottom) const;

  /** Returns whether there is no object of a given level. */
  bool Empty(PageIteratorLevel level) const;

  /**
   * Returns the type of the current block. See apitypes.h for
   * PolyBlockType.
   */
  PolyBlockType BlockType() const;

  /**
   * Returns the polygon outline of the current block. The returned Pta must
   * be ptaDestroy-ed after use. Note that the returned Pta lists the vertices
   * of the polygon, and the last edge is the line segment between the last
   * point and the first point. NULL will be returned if the iterator is
   * at the end of the document or layout analysis was not used.
   */
  Pta* BlockPolygon() const;

  /**
   * Returns a binary image of the current object at the given level.
   * The position and size match the return from BoundingBoxInternal, and so
   * this could be upscaled with respect to the original input image.
   * Use pixDestroy to delete the image after use.
   */
  Pix* GetBinaryImage(PageIteratorLevel level) const;

  /**
   * Returns an image of the current object at the given level in greyscale
   * if available in the input. To guarantee a binary image use BinaryImage.
   * NOTE that in order to give the best possible image, the bounds are
   * expanded slightly over the binary connected component, by the supplied
   * padding, so the top-left position of the returned image is returned
   * in (left,top). These will most likely not match the coordinates
   * returned by BoundingBox.
   * If you do not supply an original image, you will get a binary one.
   * Use pixDestroy to delete the image after use.
   */
  Pix* GetImage(PageIteratorLevel level, int padding, Pix* original_img,
                int* left, int* top) const;

  /**
   * Returns the baseline of the current object at the given level.
   * The baseline is the line that passes through (x1, y1) and (x2, y2).
   * WARNING: with vertical text, baselines may be vertical!
   * Returns false if there is no baseline at the current position.
   */
  bool Baseline(PageIteratorLevel level,
                int* x1, int* y1, int* x2, int* y2) const;

  /**
   * Returns orientation for the block the iterator points to.
   *   orientation, writing_direction, textline_order: see publictypes.h
   *   deskew_angle: after rotating the block so the text orientation is
   *                 upright, how many radians does one have to rotate the
   *                 block anti-clockwise for it to be level?
   *                   -Pi/4 <= deskew_angle <= Pi/4
   */
  void Orientation(tesseract::Orientation *orientation,
                   tesseract::WritingDirection *writing_direction,
                   tesseract::TextlineOrder *textline_order,
                   float *deskew_angle) const;

  /**
   * Returns information about the current paragraph, if available.
   *
   *   justification -
   *     LEFT if ragged right, or fully justified and script is left-to-right.
   *     RIGHT if ragged left, or fully justified and script is right-to-left.
   *     unknown if it looks like source code or we have very few lines.
   *   is_list_item -
   *     true if we believe this is a member of an ordered or unordered list.
   *   is_crown -
   *     true if the first line of the paragraph is aligned with the other
   *     lines of the paragraph even though subsequent paragraphs have first
   *     line indents.  This typically indicates that this is the continuation
   *     of a previous paragraph or that it is the very first paragraph in
   *     the chapter.
   *   first_line_indent -
   *     For LEFT aligned paragraphs, the first text line of paragraphs of
   *     this kind are indented this many pixels from the left edge of the
   *     rest of the paragraph.
   *     for RIGHT aligned paragraphs, the first text line of paragraphs of
   *     this kind are indented this many pixels from the right edge of the
   *     rest of the paragraph.
   *     NOTE 1: This value may be negative.
   *     NOTE 2: if *is_crown == true, the first line of this paragraph is
   *             actually flush, and first_line_indent is set to the "common"
   *             first_line_indent for subsequent paragraphs in this block
   *             of text.
   */
  void ParagraphInfo(tesseract::ParagraphJustification *justification,
                     bool *is_list_item,
                     bool *is_crown,
                     int *first_line_indent) const;

  // If the current WERD_RES (it_->word()) is not NULL, sets the BlamerBundle
  // of the current word to the given pointer (takes ownership of the pointer)
  // and returns true.
  // Can only be used when iterating on the word level.
  bool SetWordBlamerBundle(BlamerBundle *blamer_bundle);

 protected:
  /**
   * Sets up the internal data for iterating the blobs of a new word, then
   * moves the iterator to the given offset.
   */
             void BeginWord(int offset);

  /** Pointer to the page_res owned by the API. */
  PAGE_RES* page_res_;
  /** Pointer to the Tesseract object owned by the API. */
  Tesseract* tesseract_;
  /**
   * The iterator to the page_res_. Owned by this ResultIterator.
   * A pointer just to avoid dragging in Tesseract includes.
   */
  PAGE_RES_IT* it_;
  /**
   * The current input WERD being iterated. If there is an output from OCR,
   * then word_ is NULL. Owned by the API
   */
  WERD* word_;
  /** The length of the current word_. */
  int word_length_;
  /** The current blob index within the word. */
  int blob_index_;
  /**
   * Iterator to the blobs within the word. If NULL, then we are iterating
   * OCR results in the box_word.
   * Owned by this ResultIterator.
   */
  C_BLOB_IT* cblob_it_;
  /** Control over what to include in bounding boxes. */
  bool include_upper_dots_;
  bool include_lower_dots_;
  /** Parameters saved from the Thresholder. Needed to rebuild coordinates.*/
  int scale_;
  int scaled_yres_;
  int rect_left_;
  int rect_top_;
  int rect_width_;
  int rect_height_;
};

} // namespace tesseract.
# 39 "/Users/satavtar/github/tesseract/api/baseapi.h" 2
# 1 "/usr/local/include/tesseract/resultiterator.h" 1
///////////////////////////////////////////////////////////////////////
// File:        resultiterator.h
// Description: Iterator for tesseract results that is capable of
//              iterating in proper reading order over Bi Directional
//              (e.g. mixed Hebrew and English) text.
// Author:      David Eger
// Created:     Fri May 27 13:58:06 PST 2011
//
// (C) Copyright 2011, Google Inc.
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
///////////////////////////////////////////////////////////////////////






# 1 "/usr/local/include/tesseract/ltrresultiterator.h" 1
///////////////////////////////////////////////////////////////////////
// File:        ltrresultiterator.h
// Description: Iterator for tesseract results in strict left-to-right
//              order that avoids using tesseract internal data structures.
// Author:      Ray Smith
// Created:     Fri Feb 26 11:01:06 PST 2010
//
// (C) Copyright 2010, Google Inc.
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
///////////////////////////////////////////////////////////////////////
# 28 "/usr/local/include/tesseract/ltrresultiterator.h"
class BLOB_CHOICE_IT;
class WERD_RES;

namespace tesseract {

class Tesseract;

// Class to iterate over tesseract results, providing access to all levels
// of the page hierarchy, without including any tesseract headers or having
// to handle any tesseract structures.
// WARNING! This class points to data held within the TessBaseAPI class, and
// therefore can only be used while the TessBaseAPI class still exists and
// has not been subjected to a call of Init, SetImage, Recognize, Clear, End
// DetectOS, or anything else that changes the internal PAGE_RES.
// See apitypes.h for the definition of PageIteratorLevel.
// See also base class PageIterator, which contains the bulk of the interface.
// LTRResultIterator adds text-specific methods for access to OCR output.

class LTRResultIterator : public PageIterator {
  friend class ChoiceIterator;
 public:
  // page_res and tesseract come directly from the BaseAPI.
  // The rectangle parameters are copied indirectly from the Thresholder,
  // via the BaseAPI. They represent the coordinates of some rectangle in an
  // original image (in top-left-origin coordinates) and therefore the top-left
  // needs to be added to any output boxes in order to specify coordinates
  // in the original image. See TessBaseAPI::SetRectangle.
  // The scale and scaled_yres are in case the Thresholder scaled the image
  // rectangle prior to thresholding. Any coordinates in tesseract's image
  // must be divided by scale before adding (rect_left, rect_top).
  // The scaled_yres indicates the effective resolution of the binary image
  // that tesseract has been given by the Thresholder.
  // After the constructor, Begin has already been called.
  LTRResultIterator(PAGE_RES* page_res, Tesseract* tesseract,
                    int scale, int scaled_yres,
                    int rect_left, int rect_top,
                    int rect_width, int rect_height);
  virtual ~LTRResultIterator();

  // LTRResultIterators may be copied! This makes it possible to iterate over
  // all the objects at a lower level, while maintaining an iterator to
  // objects at a higher level. These constructors DO NOT CALL Begin, so
  // iterations will continue from the location of src.
  // TODO: For now the copy constructor and operator= only need the base class
  // versions, but if new data members are added, don't forget to add them!

  // ============= Moving around within the page ============.

  // See PageIterator.

  // ============= Accessing data ==============.

  // Returns the null terminated UTF-8 encoded text string for the current
  // object at the given level. Use delete [] to free after use.
  char* GetUTF8Text(PageIteratorLevel level) const;

  // Set the string inserted at the end of each text line. "\n" by default.
  void SetLineSeparator(const char *new_line);

  // Set the string inserted at the end of each paragraph. "\n" by default.
  void SetParagraphSeparator(const char *new_para);

  // Returns the mean confidence of the current object at the given level.
  // The number should be interpreted as a percent probability. (0.0f-100.0f)
  float Confidence(PageIteratorLevel level) const;

  // Returns the attributes of the current row.
  void RowAttributes(float* row_height,
                     float* descenders,
                     float* ascenders) const;

  // ============= Functions that refer to words only ============.

  // Returns the font attributes of the current word. If iterating at a higher
  // level object than words, eg textlines, then this will return the
  // attributes of the first word in that textline.
  // The actual return value is a string representing a font name. It points
  // to an internal table and SHOULD NOT BE DELETED. Lifespan is the same as
  // the iterator itself, ie rendered invalid by various members of
  // TessBaseAPI, including Init, SetImage, End or deleting the TessBaseAPI.
  // Pointsize is returned in printers points (1/72 inch.)
  const char* WordFontAttributes(bool* is_bold,
                                 bool* is_italic,
                                 bool* is_underlined,
                                 bool* is_monospace,
                                 bool* is_serif,
                                 bool* is_smallcaps,
                                 int* pointsize,
                                 int* font_id) const;

  // Return the name of the language used to recognize this word.
  // On error, NULL.  Do not delete this pointer.
  const char* WordRecognitionLanguage() const;

  // Return the overall directionality of this word.
  StrongScriptDirection WordDirection() const;

  // Returns true if the current word was found in a dictionary.
  bool WordIsFromDictionary() const;

  // Returns true if the current word is numeric.
  bool WordIsNumeric() const;

  // Returns true if the word contains blamer information.
  bool HasBlamerInfo() const;

  // Returns the pointer to ParamsTrainingBundle stored in the BlamerBundle
  // of the current word.
  const void *GetParamsTrainingBundle() const;

  // Returns a pointer to the string with blamer information for this word.
  // Assumes that the word's blamer_bundle is not NULL.
  const char *GetBlamerDebug() const;

  // Returns a pointer to the string with misadaption information for this word.
  // Assumes that the word's blamer_bundle is not NULL.
  const char *GetBlamerMisadaptionDebug() const;

  // Returns true if a truth string was recorded for the current word.
  bool HasTruthString() const;

  // Returns true if the given string is equivalent to the truth string for
  // the current word.
  bool EquivalentToTruth(const char *str) const;

  // Returns a null terminated UTF-8 encoded truth string for the current word.
  // Use delete [] to free after use.
  char* WordTruthUTF8Text() const;

  // Returns a null terminated UTF-8 encoded normalized OCR string for the
  // current word. Use delete [] to free after use.
  char* WordNormedUTF8Text() const;

  // Returns a pointer to serialized choice lattice.
  // Fills lattice_size with the number of bytes in lattice data.
  const char *WordLattice(int *lattice_size) const;

  // ============= Functions that refer to symbols only ============.

  // Returns true if the current symbol is a superscript.
  // If iterating at a higher level object than symbols, eg words, then
  // this will return the attributes of the first symbol in that word.
  bool SymbolIsSuperscript() const;
  // Returns true if the current symbol is a subscript.
  // If iterating at a higher level object than symbols, eg words, then
  // this will return the attributes of the first symbol in that word.
  bool SymbolIsSubscript() const;
  // Returns true if the current symbol is a dropcap.
  // If iterating at a higher level object than symbols, eg words, then
  // this will return the attributes of the first symbol in that word.
  bool SymbolIsDropcap() const;

 protected:
  const char *line_separator_;
  const char *paragraph_separator_;
};

// Class to iterate over the classifier choices for a single RIL_SYMBOL.
class ChoiceIterator {
 public:
  // Construction is from a LTRResultIterator that points to the symbol of
  // interest. The ChoiceIterator allows a one-shot iteration over the
  // choices for this symbol and after that is is useless.
  explicit ChoiceIterator(const LTRResultIterator& result_it);
  ~ChoiceIterator();

  // Moves to the next choice for the symbol and returns false if there
  // are none left.
  bool Next();

  // ============= Accessing data ==============.

  // Returns the null terminated UTF-8 encoded text string for the current
  // choice.
  // NOTE: Unlike LTRResultIterator::GetUTF8Text, the return points to an
  // internal structure and should NOT be delete[]ed to free after use.
  const char* GetUTF8Text() const;

  // Returns the confidence of the current choice.
  // The number should be interpreted as a percent probability. (0.0f-100.0f)
  float Confidence() const;

 private:
  // Pointer to the WERD_RES object owned by the API.
  WERD_RES* word_res_;
  // Iterator over the blob choices.
  BLOB_CHOICE_IT* choice_it_;
};

} // namespace tesseract.
# 27 "/usr/local/include/tesseract/resultiterator.h" 2

template <typename T> class GenericVector;
template <typename T> class GenericVectorEqEq;
class BLOB_CHOICE_IT;
class WERD_RES;
class STRING;

namespace tesseract {

class Tesseract;

class ResultIterator : public LTRResultIterator {
 public:
  static ResultIterator *StartOfParagraph(const LTRResultIterator &resit);

  /**
   * ResultIterator is copy constructible!
   * The default copy constructor works just fine for us.
   */
  virtual ~ResultIterator() {}

  // ============= Moving around within the page ============.
  /**
   * Moves the iterator to point to the start of the page to begin
   * an iteration.
   */
  virtual void Begin();

  /**
   * Moves to the start of the next object at the given level in the
   * page hierarchy in the appropriate reading order and returns false if
   * the end of the page was reached.
   * NOTE that RIL_SYMBOL will skip non-text blocks, but all other
   * PageIteratorLevel level values will visit each non-text block once.
   * Think of non text blocks as containing a single para, with a single line,
   * with a single imaginary word.
   * Calls to Next with different levels may be freely intermixed.
   * This function iterates words in right-to-left scripts correctly, if
   * the appropriate language has been loaded into Tesseract.
   */
  virtual bool Next(PageIteratorLevel level);

  /**
   * IsAtBeginningOf() returns whether we're at the logical beginning of the
   * given level.  (as opposed to ResultIterator's left-to-right top-to-bottom
   * order).  Otherwise, this acts the same as PageIterator::IsAtBeginningOf().
   * For a full description, see pageiterator.h
   */
  virtual bool IsAtBeginningOf(PageIteratorLevel level) const;

  /**
   * Implement PageIterator's IsAtFinalElement correctly in a BiDi context.
   * For instance, IsAtFinalElement(RIL_PARA, RIL_WORD) returns whether we
   * point at the last word in a paragraph.  See PageIterator for full comment.
  */
  virtual bool IsAtFinalElement(PageIteratorLevel level,
                                PageIteratorLevel element) const;

  // ============= Accessing data ==============.

  /**
   * Returns the null terminated UTF-8 encoded text string for the current
   * object at the given level. Use delete [] to free after use.
  */
  virtual char* GetUTF8Text(PageIteratorLevel level) const;

  /**
   * Return whether the current paragraph's dominant reading direction
   * is left-to-right (as opposed to right-to-left).
  */
  bool ParagraphIsLtr() const;

  // ============= Exposed only for testing =============.

  /**
   * Yields the reading order as a sequence of indices and (optional)
   * meta-marks for a set of words (given left-to-right).
   * The meta marks are passed as negative values:
   *   kMinorRunStart  Start of minor direction text.
   *   kMinorRunEnd    End of minor direction text.
   *   kComplexWord    The next indexed word contains both left-to-right and
   *                    right-to-left characters and was treated as neutral.
   *
   * For example, suppose we have five words in a text line,
   * indexed [0,1,2,3,4] from the leftmost side of the text line.
   * The following are all believable reading_orders:
   *
   * Left-to-Right (in ltr paragraph):
   *     { 0, 1, 2, 3, 4 }
   * Left-to-Right (in rtl paragraph):
   *     { kMinorRunStart, 0, 1, 2, 3, 4, kMinorRunEnd }
   * Right-to-Left (in rtl paragraph):
   *     { 4, 3, 2, 1, 0 }
   * Left-to-Right except for an RTL phrase in words 2, 3 in an ltr paragraph:
   *     { 0, 1, kMinorRunStart, 3, 2, kMinorRunEnd, 4 }
   */
  static void CalculateTextlineOrder(
      bool paragraph_is_ltr,
      const GenericVector<StrongScriptDirection> &word_dirs,
      GenericVectorEqEq<int> *reading_order);

  static const int kMinorRunStart;
  static const int kMinorRunEnd;
  static const int kComplexWord;

 protected:
  /**
   * We presume the data associated with the given iterator will outlive us.
   * NB: This is private because it does something that is non-obvious:
   *   it resets to the beginning of the paragraph instead of staying wherever
   *   resit might have pointed.
   */
             explicit ResultIterator(const LTRResultIterator &resit);

 private:
  /**
   * Calculates the current paragraph's dominant writing direction.
   * Typically, members should use current_paragraph_ltr_ instead.
   */
  bool CurrentParagraphIsLtr() const;

  /**
   * Returns word indices as measured from resit->RestartRow() = index 0
   * for the reading order of words within a textline given an iterator
   * into the middle of the text line.
   * In addition to non-negative word indices, the following negative values
   * may be inserted:
   *   kMinorRunStart  Start of minor direction text.
   *   kMinorRunEnd    End of minor direction text.
   *   kComplexWord    The previous word contains both left-to-right and
   *                   right-to-left characters and was treated as neutral.
   */
  void CalculateTextlineOrder(bool paragraph_is_ltr,
                              const LTRResultIterator &resit,
                              GenericVectorEqEq<int> *indices) const;
  /** Same as above, but the caller's ssd gets filled in if ssd != NULL. */
  void CalculateTextlineOrder(bool paragraph_is_ltr,
                              const LTRResultIterator &resit,
                              GenericVector<StrongScriptDirection> *ssd,
                              GenericVectorEqEq<int> *indices) const;

  /**
   * What is the index of the current word in a strict left-to-right reading
   * of the row?
   */
  int LTRWordIndex() const;

  /**
   * Given an iterator pointing at a word, returns the logical reading order
   * of blob indices for the word.
   */
  void CalculateBlobOrder(GenericVector<int> *blob_indices) const;

  /** Precondition: current_paragraph_is_ltr_ is set. */
  void MoveToLogicalStartOfTextline();

  /**
   * Precondition: current_paragraph_is_ltr_ and in_minor_direction_
   * are set.
   */
  void MoveToLogicalStartOfWord();

  /** Are we pointing at the final (reading order) symbol of the word? */
  bool IsAtFinalSymbolOfWord() const;

  /** Are we pointing at the first (reading order) symbol of the word? */
  bool IsAtFirstSymbolOfWord() const;

  /**
   * Append any extra marks that should be appended to this word when printed.
   * Mostly, these are Unicode BiDi control characters.
   */
  void AppendSuffixMarks(STRING *text) const;

  /** Appends the current word in reading order to the given buffer.*/
  void AppendUTF8WordText(STRING *text) const;

  /**
   * Appends the text of the current text line, *assuming this iterator is
   * positioned at the beginning of the text line*  This function
   * updates the iterator to point to the first position past the text line.
   * Each textline is terminated in a single newline character.
   * If the textline ends a paragraph, it gets a second terminal newline.
   */
  void IterateAndAppendUTF8TextlineText(STRING *text);

  /**
   * Appends the text of the current paragraph in reading order
   * to the given buffer.
   * Each textline is terminated in a single newline character, and the
   * paragraph gets an extra newline at the end.
   */
  void AppendUTF8ParagraphText(STRING *text) const;

  /** Returns whether the bidi_debug flag is set to at least min_level. */
  bool BidiDebug(int min_level) const;

  bool current_paragraph_is_ltr_;

  /**
   * Is the currently pointed-at character at the beginning of
   * a minor-direction run?
   */
  bool at_beginning_of_minor_run_;

  /** Is the currently pointed-at character in a minor-direction sequence? */
  bool in_minor_direction_;

  /**
   * Should detected inter-word spaces be preserved, or "compressed" to a single
   * space character (default behavior).
   */
  bool preserve_interword_spaces_;
};

} // namespace tesseract.
# 40 "/Users/satavtar/github/tesseract/api/baseapi.h" 2

template <typename T> class GenericVector;
class PAGE_RES;
class PAGE_RES_IT;
class ParagraphModel;
struct BlamerBundle;
class BLOCK_LIST;
class DENORM;
class MATRIX;
class ROW;
class STRING;
class WERD;
struct Pix;
struct Box;
struct Pixa;
struct Boxa;
class ETEXT_DESC;
struct OSResults;
class TBOX;
class UNICHARSET;
class WERD_CHOICE_LIST;

struct INT_FEATURE_STRUCT;
typedef INT_FEATURE_STRUCT *INT_FEATURE;
struct TBLOB;

namespace tesseract {


class CubeRecoContext;

class Dawg;
class Dict;
class EquationDetect;
class PageIterator;
class LTRResultIterator;
class ResultIterator;
class MutableIterator;
class TessResultRenderer;
class Tesseract;
class Trie;
class Wordrec;

typedef int (Dict::*DictFunc)(void* void_dawg_args,
                              UNICHAR_ID unichar_id, bool word_end) const;
typedef double (Dict::*ProbabilityInContextFunc)(const char* lang,
                                                 const char* context,
                                                 int context_bytes,
                                                 const char* character,
                                                 int character_bytes);
typedef float (Dict::*ParamsModelClassifyFunc)(
    const char *lang, void *path);
typedef void (Wordrec::*FillLatticeFunc)(const MATRIX &ratings,
                                         const WERD_CHOICE_LIST &best_choices,
                                         const UNICHARSET &unicharset,
                                         BlamerBundle *blamer_bundle);
typedef TessCallback4<const UNICHARSET &, int, PageIterator *, Pix *>
    TruthCallback;

/**
 * Base class for all tesseract APIs.
 * Specific classes can add ability to work on different inputs or produce
 * different outputs.
 * This class is mostly an interface layer on top of the Tesseract instance
 * class to hide the data types so that users of this class don't have to
 * include any other Tesseract headers.
 */
class TessBaseAPI {
 public:
  TessBaseAPI();
  virtual ~TessBaseAPI();

  /**
   * Returns the version identifier as a static string. Do not delete.
   */
  static const char* Version();

  /**
   * If compiled with OpenCL AND an available OpenCL
   * device is deemed faster than serial code, then
   * "device" is populated with the cl_device_id
   * and returns sizeof(cl_device_id)
   * otherwise *device=NULL and returns 0.
   */
  static size_t getOpenCLDevice(void **device);

  /**
   * Writes the thresholded image to stderr as a PBM file on receipt of a
   * SIGSEGV, SIGFPE, or SIGBUS signal. (Linux/Unix only).
   */
  static void CatchSignals();

  /**
   * Set the name of the input file. Needed for training and
   * reading a UNLV zone file, and for searchable PDF output.
   */
  void SetInputName(const char* name);
  /**
   * These functions are required for searchable PDF output.
   * We need our hands on the input file so that we can include
   * it in the PDF without transcoding. If that is not possible,
   * we need the original image. Finally, resolution metadata
   * is stored in the PDF so we need that as well.
   */
  const char* GetInputName();
  void SetInputImage(Pix *pix);
  Pix* GetInputImage();
  int GetSourceYResolution();
  const char* GetDatapath();

  /** Set the name of the bonus output files. Needed only for debugging. */
  void SetOutputName(const char* name);

  /**
   * Set the value of an internal "parameter."
   * Supply the name of the parameter and the value as a string, just as
   * you would in a config file.
   * Returns false if the name lookup failed.
   * Eg SetVariable("tessedit_char_blacklist", "xyz"); to ignore x, y and z.
   * Or SetVariable("classify_bln_numeric_mode", "1"); to set numeric-only mode.
   * SetVariable may be used before Init, but settings will revert to
   * defaults on End().
   *
   * Note: Must be called after Init(). Only works for non-init variables
   * (init variables should be passed to Init()).
   */
  bool SetVariable(const char* name, const char* value);
  bool SetDebugVariable(const char* name, const char* value);

  /**
   * Returns true if the parameter was found among Tesseract parameters.
   * Fills in value with the value of the parameter.
   */
  bool GetIntVariable(const char *name, int *value) const;
  bool GetBoolVariable(const char *name, bool *value) const;
  bool GetDoubleVariable(const char *name, double *value) const;

  /**
   * Returns the pointer to the string that represents the value of the
   * parameter if it was found among Tesseract parameters.
   */
  const char *GetStringVariable(const char *name) const;

  /**
   * Print Tesseract parameters to the given file.
   */
  void PrintVariables(FILE *fp) const;

  /**
   * Get value of named variable as a string, if it exists.
   */
  bool GetVariableAsString(const char *name, STRING *val);

  /**
   * Instances are now mostly thread-safe and totally independent,
   * but some global parameters remain. Basically it is safe to use multiple
   * TessBaseAPIs in different threads in parallel, UNLESS:
   * you use SetVariable on some of the Params in classify and textord.
   * If you do, then the effect will be to change it for all your instances.
   *
   * Start tesseract. Returns zero on success and -1 on failure.
   * NOTE that the only members that may be called before Init are those
   * listed above here in the class definition.
   *
   * The datapath must be the name of the parent directory of tessdata and
   * must end in / . Any name after the last / will be stripped.
   * The language is (usually) an ISO 639-3 string or NULL will default to eng.
   * It is entirely safe (and eventually will be efficient too) to call
   * Init multiple times on the same instance to change language, or just
   * to reset the classifier.
   * The language may be a string of the form [~]<lang>[+[~]<lang>]* indicating
   * that multiple languages are to be loaded. Eg hin+eng will load Hindi and
   * English. Languages may specify internally that they want to be loaded
   * with one or more other languages, so the ~ sign is available to override
   * that. Eg if hin were set to load eng by default, then hin+~eng would force
   * loading only hin. The number of loaded languages is limited only by
   * memory, with the caveat that loading additional languages will impact
   * both speed and accuracy, as there is more work to do to decide on the
   * applicable language, and there is more chance of hallucinating incorrect
   * words.
   * WARNING: On changing languages, all Tesseract parameters are reset
   * back to their default values. (Which may vary between languages.)
   * If you have a rare need to set a Variable that controls
   * initialization for a second call to Init you should explicitly
   * call End() and then use SetVariable before Init. This is only a very
   * rare use case, since there are very few uses that require any parameters
   * to be set before Init.
   *
   * If set_only_non_debug_params is true, only params that do not contain
   * "debug" in the name will be set.
   */
  int Init(const char* datapath, const char* language, OcrEngineMode mode,
           char **configs, int configs_size,
           const GenericVector<STRING> *vars_vec,
           const GenericVector<STRING> *vars_values,
           bool set_only_non_debug_params);
  int Init(const char* datapath, const char* language, OcrEngineMode oem) {
    return Init(datapath, language, oem, __null, 0, __null, __null, false);
  }
  int Init(const char* datapath, const char* language) {
    return Init(datapath, language, OEM_DEFAULT, __null, 0, __null, __null, false);
  }

  /**
   * Returns the languages string used in the last valid initialization.
   * If the last initialization specified "deu+hin" then that will be
   * returned. If hin loaded eng automatically as well, then that will
   * not be included in this list. To find the languages actually
   * loaded use GetLoadedLanguagesAsVector.
   * The returned string should NOT be deleted.
   */
  const char* GetInitLanguagesAsString() const;

  /**
   * Returns the loaded languages in the vector of STRINGs.
   * Includes all languages loaded by the last Init, including those loaded
   * as dependencies of other loaded languages.
   */
  void GetLoadedLanguagesAsVector(GenericVector<STRING>* langs) const;

  /**
   * Returns the available languages in the vector of STRINGs.
   */
  void GetAvailableLanguagesAsVector(GenericVector<STRING>* langs) const;

  /**
   * Init only the lang model component of Tesseract. The only functions
   * that work after this init are SetVariable and IsValidWord.
   * WARNING: temporary! This function will be removed from here and placed
   * in a separate API at some future time.
   */
  int InitLangMod(const char* datapath, const char* language);

  /**
   * Init only for page layout analysis. Use only for calls to SetImage and
   * AnalysePage. Calls that attempt recognition will generate an error.
   */
  void InitForAnalysePage();

  /**
   * Read a "config" file containing a set of param, value pairs.
   * Searches the standard places: tessdata/configs, tessdata/tessconfigs
   * and also accepts a relative or absolute path name.
   * Note: only non-init params will be set (init params are set by Init()).
   */
  void ReadConfigFile(const char* filename);
  /** Same as above, but only set debug params from the given config file. */
  void ReadDebugConfigFile(const char* filename);

  /**
   * Set the current page segmentation mode. Defaults to PSM_SINGLE_BLOCK.
   * The mode is stored as an IntParam so it can also be modified by
   * ReadConfigFile or SetVariable("tessedit_pageseg_mode", mode as string).
   */
  void SetPageSegMode(PageSegMode mode);

  /** Return the current page segmentation mode. */
  PageSegMode GetPageSegMode() const;

  /**
   * Recognize a rectangle from an image and return the result as a string.
   * May be called many times for a single Init.
   * Currently has no error checking.
   * Greyscale of 8 and color of 24 or 32 bits per pixel may be given.
   * Palette color images will not work properly and must be converted to
   * 24 bit.
   * Binary images of 1 bit per pixel may also be given but they must be
   * byte packed with the MSB of the first byte being the first pixel, and a
   * 1 represents WHITE. For binary images set bytes_per_pixel=0.
   * The recognized text is returned as a char* which is coded
   * as UTF8 and must be freed with the delete [] operator.
   *
   * Note that TesseractRect is the simplified convenience interface.
   * For advanced uses, use SetImage, (optionally) SetRectangle, Recognize,
   * and one or more of the Get*Text functions below.
   */
  char* TesseractRect(const unsigned char* imagedata,
                      int bytes_per_pixel, int bytes_per_line,
                      int left, int top, int width, int height);

  /**
   * Call between pages or documents etc to free up memory and forget
   * adaptive data.
   */
  void ClearAdaptiveClassifier();

  /**
   * @defgroup AdvancedAPI Advanced API
   * The following methods break TesseractRect into pieces, so you can
   * get hold of the thresholded image, get the text in different formats,
   * get bounding boxes, confidences etc.
   */
   /* @{ */

  /**
   * Provide an image for Tesseract to recognize. Format is as
   * TesseractRect above. Does not copy the image buffer, or take
   * ownership. The source image may be destroyed after Recognize is called,
   * either explicitly or implicitly via one of the Get*Text functions.
   * SetImage clears all recognition results, and sets the rectangle to the
   * full image, so it may be followed immediately by a GetUTF8Text, and it
   * will automatically perform recognition.
   */
  void SetImage(const unsigned char* imagedata, int width, int height,
                int bytes_per_pixel, int bytes_per_line);

  /**
   * Provide an image for Tesseract to recognize. As with SetImage above,
   * Tesseract doesn't take a copy or ownership or pixDestroy the image, so
   * it must persist until after Recognize.
   * Pix vs raw, which to use?
   * Use Pix where possible. A future version of Tesseract may choose to use Pix
   * as its internal representation and discard IMAGE altogether.
   * Because of that, an implementation that sources and targets Pix may end up
   * with less copies than an implementation that does not.
   */
  void SetImage(Pix* pix);

  /**
   * Set the resolution of the source image in pixels per inch so font size
   * information can be calculated in results.  Call this after SetImage().
   */
  void SetSourceResolution(int ppi);

  /**
   * Restrict recognition to a sub-rectangle of the image. Call after SetImage.
   * Each SetRectangle clears the recogntion results so multiple rectangles
   * can be recognized with the same image.
   */
  void SetRectangle(int left, int top, int width, int height);

  /**
   * In extreme cases only, usually with a subclass of Thresholder, it
   * is possible to provide a different Thresholder. The Thresholder may
   * be preloaded with an image, settings etc, or they may be set after.
   * Note that Tesseract takes ownership of the Thresholder and will
   * delete it when it it is replaced or the API is destructed.
   */
  void SetThresholder(ImageThresholder* thresholder) {
    if (thresholder_ != __null)
      delete thresholder_;
    thresholder_ = thresholder;
    ClearResults();
  }

  /**
   * Get a copy of the internal thresholded image from Tesseract.
   * Caller takes ownership of the Pix and must pixDestroy it.
   * May be called any time after SetImage, or after TesseractRect.
   */
  Pix* GetThresholdedImage();

  /**
   * Get the result of page layout analysis as a leptonica-style
   * Boxa, Pixa pair, in reading order.
   * Can be called before or after Recognize.
   */
  Boxa* GetRegions(Pixa** pixa);

  /**
   * Get the textlines as a leptonica-style
   * Boxa, Pixa pair, in reading order.
   * Can be called before or after Recognize.
   * If raw_image is true, then extract from the original image instead of the
   * thresholded image and pad by raw_padding pixels.
   * If blockids is not NULL, the block-id of each line is also returned as an
   * array of one element per line. delete [] after use.
   * If paraids is not NULL, the paragraph-id of each line within its block is
   * also returned as an array of one element per line. delete [] after use.
   */
  Boxa* GetTextlines(const bool raw_image, const int raw_padding,
                     Pixa** pixa, int** blockids, int** paraids);
  /*
     Helper method to extract from the thresholded image. (most common usage)
  */
  Boxa* GetTextlines(Pixa** pixa, int** blockids) {
    return GetTextlines(false, 0, pixa, blockids, __null);
  }

  /**
   * Get textlines and strips of image regions as a leptonica-style Boxa, Pixa
   * pair, in reading order. Enables downstream handling of non-rectangular
   * regions.
   * Can be called before or after Recognize.
   * If blockids is not NULL, the block-id of each line is also returned as an
   * array of one element per line. delete [] after use.
   */
  Boxa* GetStrips(Pixa** pixa, int** blockids);

  /**
   * Get the words as a leptonica-style
   * Boxa, Pixa pair, in reading order.
   * Can be called before or after Recognize.
   */
  Boxa* GetWords(Pixa** pixa);

  /**
   * Gets the individual connected (text) components (created
   * after pages segmentation step, but before recognition)
   * as a leptonica-style Boxa, Pixa pair, in reading order.
   * Can be called before or after Recognize.
   * Note: the caller is responsible for calling boxaDestroy()
   * on the returned Boxa array and pixaDestroy() on cc array.
   */
  Boxa* GetConnectedComponents(Pixa** cc);

  /**
   * Get the given level kind of components (block, textline, word etc.) as a
   * leptonica-style Boxa, Pixa pair, in reading order.
   * Can be called before or after Recognize.
   * If blockids is not NULL, the block-id of each component is also returned
   * as an array of one element per component. delete [] after use.
   * If blockids is not NULL, the paragraph-id of each component with its block
   * is also returned as an array of one element per component. delete [] after
   * use.
   * If raw_image is true, then portions of the original image are extracted
   * instead of the thresholded image and padded with raw_padding.
   * If text_only is true, then only text components are returned.
   */
  Boxa* GetComponentImages(const PageIteratorLevel level,
                           const bool text_only, const bool raw_image,
                           const int raw_padding,
                           Pixa** pixa, int** blockids, int** paraids);
  // Helper function to get binary images with no padding (most common usage).
  Boxa* GetComponentImages(const PageIteratorLevel level,
                           const bool text_only,
                           Pixa** pixa, int** blockids) {
    return GetComponentImages(level, text_only, false, 0, pixa, blockids, __null);
  }

  /**
   * Returns the scale factor of the thresholded image that would be returned by
   * GetThresholdedImage() and the various GetX() methods that call
   * GetComponentImages().
   * Returns 0 if no thresholder has been set.
   */
  int GetThresholdedImageScaleFactor() const;

  /**
   * Dump the internal binary image to a PGM file.
   * @deprecated Use GetThresholdedImage and write the image using pixWrite
   * instead if possible.
   */
  void DumpPGM(const char* filename);

  /**
   * Runs page layout analysis in the mode set by SetPageSegMode.
   * May optionally be called prior to Recognize to get access to just
   * the page layout results. Returns an iterator to the results.
   * If merge_similar_words is true, words are combined where suitable for use
   * with a line recognizer. Use if you want to use AnalyseLayout to find the
   * textlines, and then want to process textline fragments with an external
   * line recognizer.
   * Returns NULL on error or an empty page.
   * The returned iterator must be deleted after use.
   * WARNING! This class points to data held within the TessBaseAPI class, and
   * therefore can only be used while the TessBaseAPI class still exists and
   * has not been subjected to a call of Init, SetImage, Recognize, Clear, End
   * DetectOS, or anything else that changes the internal PAGE_RES.
   */
  PageIterator* AnalyseLayout();
  PageIterator* AnalyseLayout(bool merge_similar_words);

  /**
   * Recognize the image from SetAndThresholdImage, generating Tesseract
   * internal structures. Returns 0 on success.
   * Optional. The Get*Text functions below will call Recognize if needed.
   * After Recognize, the output is kept internally until the next SetImage.
   */
  int Recognize(ETEXT_DESC* monitor);

  /**
   * Methods to retrieve information after SetAndThresholdImage(),
   * Recognize() or TesseractRect(). (Recognize is called implicitly if needed.)
   */

  /** Variant on Recognize used for testing chopper. */
  int RecognizeForChopTest(ETEXT_DESC* monitor);

  /**
   * Turns images into symbolic text.
   *
   * filename can point to a single image, a multi-page TIFF,
   * or a plain text list of image filenames.
   *
   * retry_config is useful for debugging. If not NULL, you can fall
   * back to an alternate configuration if a page fails for some
   * reason.
   *
   * timeout_millisec terminates processing if any single page
   * takes too long. Set to 0 for unlimited time.
   *
   * renderer is responible for creating the output. For example,
   * use the TessTextRenderer if you want plaintext output, or
   * the TessPDFRender to produce searchable PDF.
   *
   * If tessedit_page_number is non-negative, will only process that
   * single page. Works for multi-page tiff file, or filelist.
   *
   * Returns true if successful, false on error.
   */
  bool ProcessPages(const char* filename, const char* retry_config,
                    int timeout_millisec, TessResultRenderer* renderer);
  // Does the real work of ProcessPages.
  bool ProcessPagesInternal(const char* filename, const char* retry_config,
                            int timeout_millisec, TessResultRenderer* renderer);

  /**
   * Turn a single image into symbolic text.
   *
   * The pix is the image processed. filename and page_index are
   * metadata used by side-effect processes, such as reading a box
   * file or formatting as hOCR.
   *
   * See ProcessPages for desciptions of other parameters.
   */
  bool ProcessPage(Pix* pix, int page_index, const char* filename,
                   const char* retry_config, int timeout_millisec,
                   TessResultRenderer* renderer);

  /**
   * Get a reading-order iterator to the results of LayoutAnalysis and/or
   * Recognize. The returned iterator must be deleted after use.
   * WARNING! This class points to data held within the TessBaseAPI class, and
   * therefore can only be used while the TessBaseAPI class still exists and
   * has not been subjected to a call of Init, SetImage, Recognize, Clear, End
   * DetectOS, or anything else that changes the internal PAGE_RES.
   */
  ResultIterator* GetIterator();

  /**
   * Get a mutable iterator to the results of LayoutAnalysis and/or Recognize.
   * The returned iterator must be deleted after use.
   * WARNING! This class points to data held within the TessBaseAPI class, and
   * therefore can only be used while the TessBaseAPI class still exists and
   * has not been subjected to a call of Init, SetImage, Recognize, Clear, End
   * DetectOS, or anything else that changes the internal PAGE_RES.
   */
  MutableIterator* GetMutableIterator();

  /**
   * The recognized text is returned as a char* which is coded
   * as UTF8 and must be freed with the delete [] operator.
   */
  char* GetUTF8Text();

  /**
   * Make a HTML-formatted string with hOCR markup from the internal
   * data structures.
   * page_number is 0-based but will appear in the output as 1-based.
   * monitor can be used to
   * 	cancel the recognition
   * 	receive progress callbacks
   */
  char* GetHOCRText(struct ETEXT_DESC* monitor, int page_number);

  /**
   * Make a HTML-formatted string with hOCR markup from the internal
   * data structures.
   * page_number is 0-based but will appear in the output as 1-based.
   */
  char* GetHOCRText(int page_number);

  /**
   * Make a TSV-formatted string from the internal data structures.
   * page_number is 0-based but will appear in the output as 1-based.
   */
  char* GetTSVText(int page_number);

  /**
   * The recognized text is returned as a char* which is coded in the same
   * format as a box file used in training. Returned string must be freed with
   * the delete [] operator.
   * Constructs coordinates in the original image - not just the rectangle.
   * page_number is a 0-based page index that will appear in the box file.
   */
  char* GetBoxText(int page_number);

  /**
   * The recognized text is returned as a char* which is coded
   * as UNLV format Latin-1 with specific reject and suspect codes
   * and must be freed with the delete [] operator.
   */
  char* GetUNLVText();

  /**
   * The recognized text is returned as a char* which is coded
   * as UTF8 and must be freed with the delete [] operator.
   * page_number is a 0-based page index that will appear in the osd file.
   */
  char* GetOsdText(int page_number);

  /** Returns the (average) confidence value between 0 and 100. */
  int MeanTextConf();
  /**
   * Returns all word confidences (between 0 and 100) in an array, terminated
   * by -1.  The calling function must delete [] after use.
   * The number of confidences should correspond to the number of space-
   * delimited words in GetUTF8Text.
   */
  int* AllWordConfidences();

  /**
   * Applies the given word to the adaptive classifier if possible.
   * The word must be SPACE-DELIMITED UTF-8 - l i k e t h i s , so it can
   * tell the boundaries of the graphemes.
   * Assumes that SetImage/SetRectangle have been used to set the image
   * to the given word. The mode arg should be PSM_SINGLE_WORD or
   * PSM_CIRCLE_WORD, as that will be used to control layout analysis.
   * The currently set PageSegMode is preserved.
   * Returns false if adaption was not possible for some reason.
   */
  bool AdaptToWordStr(PageSegMode mode, const char* wordstr);

  /**
   * Free up recognition results and any stored image data, without actually
   * freeing any recognition data that would be time-consuming to reload.
   * Afterwards, you must call SetImage or TesseractRect before doing
   * any Recognize or Get* operation.
   */
  void Clear();

  /**
   * Close down tesseract and free up all memory. End() is equivalent to
   * destructing and reconstructing your TessBaseAPI.
   * Once End() has been used, none of the other API functions may be used
   * other than Init and anything declared above it in the class definition.
   */
  void End();

  /**
   * Clear any library-level memory caches.
   * There are a variety of expensive-to-load constant data structures (mostly
   * language dictionaries) that are cached globally -- surviving the Init()
   * and End() of individual TessBaseAPI's.  This function allows the clearing
   * of these caches.
   **/
  static void ClearPersistentCache();

  /**
   * Check whether a word is valid according to Tesseract's language model
   * @return 0 if the word is invalid, non-zero if valid.
   * @warning temporary! This function will be removed from here and placed
   * in a separate API at some future time.
   */
  int IsValidWord(const char *word);
  // Returns true if utf8_character is defined in the UniCharset.
  bool IsValidCharacter(const char *utf8_character);


  bool GetTextDirection(int* out_offset, float* out_slope);

  /** Sets Dict::letter_is_okay_ function to point to the given function. */
  void SetDictFunc(DictFunc f);

  /** Sets Dict::probability_in_context_ function to point to the given
   * function.
   */
  void SetProbabilityInContextFunc(ProbabilityInContextFunc f);

  /** Sets Wordrec::fill_lattice_ function to point to the given function. */
  void SetFillLatticeFunc(FillLatticeFunc f);

  /**
   * Estimates the Orientation And Script of the image.
   * @return true if the image was processed successfully.
   */
  bool DetectOS(OSResults*);

  /** This method returns the features associated with the input image. */
  void GetFeaturesForBlob(TBLOB* blob, INT_FEATURE_STRUCT* int_features,
                          int* num_features, int* feature_outline_index);

  /**
   * This method returns the row to which a box of specified dimensions would
   * belong. If no good match is found, it returns NULL.
   */
  static ROW* FindRowForBox(BLOCK_LIST* blocks, int left, int top,
                            int right, int bottom);

  /**
   * Method to run adaptive classifier on a blob.
   * It returns at max num_max_matches results.
   */
  void RunAdaptiveClassifier(TBLOB* blob,
                             int num_max_matches,
                             int* unichar_ids,
                             float* ratings,
                             int* num_matches_returned);

  /** This method returns the string form of the specified unichar. */
  const char* GetUnichar(int unichar_id);

  /** Return the pointer to the i-th dawg loaded into tesseract_ object. */
  const Dawg *GetDawg(int i) const;

  /** Return the number of dawgs loaded into tesseract_ object. */
  int NumDawgs() const;

  /** Returns a ROW object created from the input row specification. */
  static ROW *MakeTessOCRRow(float baseline, float xheight,
                             float descender, float ascender);

  /** Returns a TBLOB corresponding to the entire input image. */
  static TBLOB *MakeTBLOB(Pix *pix);

  /**
   * This method baseline normalizes a TBLOB in-place. The input row is used
   * for normalization. The denorm is an optional parameter in which the
   * normalization-antidote is returned.
   */
  static void NormalizeTBLOB(TBLOB *tblob, ROW *row, bool numeric_mode);

  Tesseract* tesseract() const {
    return tesseract_;
  }

  OcrEngineMode oem() const {
    return last_oem_requested_;
  }

  void InitTruthCallback(TruthCallback *cb) { truth_cb_ = cb; }


  /** Return a pointer to underlying CubeRecoContext object if present. */
  CubeRecoContext *GetCubeRecoContext() const;


  void set_min_orientation_margin(double margin);

  /**
   * Return text orientation of each block as determined by an earlier run
   * of layout analysis.
   */
  void GetBlockTextOrientations(int** block_orientation,
                                bool** vertical_writing);

  /** Find lines from the image making the BLOCK_LIST. */
  BLOCK_LIST* FindLinesCreateBlockList();

  /**
   * Delete a block list.
   * This is to keep BLOCK_LIST pointer opaque
   * and let go of including the other headers.
   */
  static void DeleteBlockList(BLOCK_LIST* block_list);
 /* @} */

 protected:

  /** Common code for setting the image. Returns true if Init has been called. */
             bool InternalSetImage();

  /**
   * Run the thresholder to make the thresholded image. If pix is not NULL,
   * the source is thresholded to pix instead of the internal IMAGE.
   */
             virtual void Threshold(Pix** pix);

  /**
   * Find lines from the image making the BLOCK_LIST.
   * @return 0 on success.
   */
             int FindLines();

  /** Delete the pageres and block list ready for a new page. */
  void ClearResults();

  /**
   * Return an LTR Result Iterator -- used only for training, as we really want
   * to ignore all BiDi smarts at that point.
   * delete once you're done with it.
   */
             LTRResultIterator* GetLTRIterator();

  /**
   * Return the length of the output text string, as UTF8, assuming
   * one newline per line and one per block, with a terminator,
   * and assuming a single character reject marker for each rejected character.
   * Also return the number of recognized blobs in blob_count.
   */
             int TextLength(int* blob_count);

  /** @defgroup ocropusAddOns ocropus add-ons */
  /* @{ */

  /**
   * Adapt to recognize the current image as the given character.
   * The image must be preloaded and be just an image of a single character.
   */
             void AdaptToCharacter(const char *unichar_repr,
                                   int length,
                                   float baseline,
                                   float xheight,
                                   float descender,
                                   float ascender);

  /** Recognize text doing one pass only, using settings for a given pass. */
             PAGE_RES* RecognitionPass1(BLOCK_LIST* block_list);
             PAGE_RES* RecognitionPass2(BLOCK_LIST* block_list,
                                        PAGE_RES* pass1_result);

  //// paragraphs.cpp ////////////////////////////////////////////////////
             void DetectParagraphs(bool after_text_recognition);

  /**
   * Extract the OCR results, costs (penalty points for uncertainty),
   * and the bounding boxes of the characters.
   */
             static int TesseractExtractResult(char** text,
                                    int** lengths,
                                    float** costs,
                                    int** x0,
                                    int** y0,
                                    int** x1,
                                    int** y1,
                                    PAGE_RES* page_res);

             const PAGE_RES* GetPageRes() const {
    return page_res_;
  };
  /* @} */


 protected:
  Tesseract* tesseract_; ///< The underlying data object.
  Tesseract* osd_tesseract_; ///< For orientation & script detection.
  EquationDetect* equ_detect_; ///<The equation detector.
  ImageThresholder* thresholder_; ///< Image thresholding module.
  GenericVector<ParagraphModel *>* paragraph_models_;
  BLOCK_LIST* block_list_; ///< The page layout.
  PAGE_RES* page_res_; ///< The page-level data.
  STRING* input_file_; ///< Name used by training code.
  Pix* input_image_; ///< Image used for searchable PDF
  STRING* output_file_; ///< Name used by debug code.
  STRING* datapath_; ///< Current location of tessdata.
  STRING* language_; ///< Last initialized language.
  OcrEngineMode last_oem_requested_; ///< Last ocr language mode requested.
  bool recognition_done_; ///< page_res_ contains recognition data.
  TruthCallback *truth_cb_; /// fxn for setting truth_* in WERD_RES

  /**
   * @defgroup ThresholderParams Thresholder Parameters
   * Parameters saved from the Thresholder. Needed to rebuild coordinates.
   */
  /* @{ */
  int rect_left_;
  int rect_top_;
  int rect_width_;
  int rect_height_;
  int image_width_;
  int image_height_;
  /* @} */

 private:
  // A list of image filenames gets special consideration
  bool ProcessPagesFileList(FILE *fp,
                            STRING *buf,
                            const char* retry_config, int timeout_millisec,
                            TessResultRenderer* renderer,
                            int tessedit_page_number);
  // TIFF supports multipage so gets special consideration
  bool ProcessPagesMultipageTiff(const unsigned char *data,
                                 size_t size,
                                 const char* filename,
                                 const char* retry_config,
                                 int timeout_millisec,
                                 TessResultRenderer* renderer,
                                 int tessedit_page_number);
}; // class TessBaseAPI.

/** Escape a char string - remove &<>"' with HTML codes. */
STRING HOcrEscape(const char* text);
} // namespace tesseract.
# 11 "tessapi-quality.cpp" 2

void getCompImage(const char* filename, int page){

    Pix* image;
    struct timeval start, end;
    int cpu, status;
    double delta;
    Pixa** pixa;
    int** blockids;
    /*
     * Read total number of pages in multiTiff input files into npages variable

     int npages;
     FILE *fp, *fo;
     fp = fopen(filename, "rb");
     if (fp == NULL) {
     printf("Image file cannot be opened!\n");
     exit(-1);
     }
     tiffGetCount(fp, &npages);
     fclose(fp);
    // ok, total n. of pages in npages variable

    //fo = fopen("output.txt", "a+t");
    */
    printf("Running line by line example..\n\n\n");
    image = pixReadTiff(filename, page);

    // set number of threads to use
    int num_threads = 4;
    omp_set_num_threads(num_threads);

    gettimeofday(&start, __null);
#pragma omp parallel
 {
        tesseract::TessBaseAPI *papi = new tesseract::TessBaseAPI();
        // Initialize tesseract-ocr with English, without specifying tessdata path
        if (papi->Init(__null, "eng")) {
            fprintf(__stdoutp, "Could not initialize tesseract.\n");
            exit(1);
        }

        papi->SetImage(image);
        Boxa* boxes = papi->GetComponentImages(tesseract::RIL_TEXTLINE, true, pixa, blockids);
        //  printf("Found %d textline image components.\n", boxes->n);
#pragma omp for schedule(dynamic, 1)
 for (int i = 0; i < boxes->n; i++) {
            BOX* box = boxaGetBox(boxes, i, L_CLONE);

            papi->SetRectangle(box->x, box->y, box->w, box->h);
            char* ocrResult = papi->GetUTF8Text();
            int my_thread = omp_get_thread_num();
            //int conf = papi->MeanTextConf();
            fprintf(__stdoutp, "Thread %d, Page %d: Box[%d], text: %s",
                         my_thread, page, i, ocrResult);
        }
        // Destroy used object and release memory
        papi->End();
    }

    gettimeofday(&end, __null);
    delta = ((end.tv_sec - start.tv_sec) * 1000000u +
            end.tv_usec - start.tv_usec) / 1.e6;
    fprintf(__stdoutp, "elapsed time: %f\n\n", delta);

    pixDestroy(&image);
}


int main(int argc, char *argv[])
{

    if (argc != 3){
        printf("Type the (tiff) file name to OCRize\n"
                "Then the page in the file to OCRize (first page=0, second=1 etc..)\n\n");
        exit(-1);
    }

    int page = atoi(argv[2]);

    getCompImage(argv[1], page);

    return 0;
}
